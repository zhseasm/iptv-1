#!/bin/bash
# FFmpeg / nginx / openresty / xray / v2ray / cloudflare partner,workers / ibm cf / armbian / proxmox Wrapper Script By MTimer
# Copyright (C) 2019-2021
# Released under GPL Version 3 License

set -euo pipefail

sh_ver="1.80.6"
sh_debug=0
export LANGUAGE=
export LC_ALL=
export LANG=en_US.UTF-8
SH_LINK="https://woniuzfb.github.io/iptv/iptv.sh"
SH_LINK_BACKUP="http://tv.epub.fun/iptv.sh"
SH_FILE="/usr/local/bin/tv"
i18n_FILE="/usr/local/bin/tv-i18n"
OR_FILE="/usr/local/bin/or"
NX_FILE="/usr/local/bin/nx"
XC_FILE="/usr/local/bin/cx"
ARM_FILE="/usr/local/bin/arm"
PVE_FILE="/usr/local/bin/pve"
IPTV_ROOT="/usr/local/iptv"
JQ_FILE="$IPTV_ROOT/jq"
CHANNELS_FILE="$IPTV_ROOT/channels.json"
LOCK_FILE="$IPTV_ROOT/lock"
MONITOR_LOG="$IPTV_ROOT/monitor.log"
LOGROTATE_CONFIG="$IPTV_ROOT/logrotate"
CRON_FILE="$IPTV_ROOT/cron"
XTREAM_CODES="$IPTV_ROOT/xtream_codes"
XTREAM_CODES_EXAM="$IPTV_ROOT/xtream_codes_exam"
NODE_ROOT="$IPTV_ROOT/node"
IP_DENY="$IPTV_ROOT/ip.deny"
IP_LOG="$IPTV_ROOT/ip.log"
FFMPEG_LOG_ROOT="$IPTV_ROOT/ffmpeg"
# create your own mirror: tv ffmpeg
FFMPEG_MIRROR_LINK="http://pngquant.com/ffmpeg"
V2_FILE="/usr/local/bin/v2"
V2_LINK="https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh"
V2_LINK_BACKUP="$FFMPEG_MIRROR_LINK/v2ray_install-release.sh"
V2CTL_FILE="/usr/local/bin/v2ctl"
V2_CONFIG="/usr/local/etc/v2ray/config.json"
X_FILE="/usr/local/bin/x"
FFMPEG_MIRROR_ROOT="$IPTV_ROOT/ffmpeg"
LIVE_ROOT="$IPTV_ROOT/live"
SERVICES_FILE="$IPTV_ROOT/services.json"
VIP_FILE="$IPTV_ROOT/vip.json"
VIP_CHANNELS_LINK="$FFMPEG_MIRROR_LINK/vip_channels.json"
VIP_CHANNELS_FILE="$IPTV_ROOT/vip_channels.json"
VIP_ROOT="$IPTV_ROOT/vip"
VIP_USERS_ROOT="$VIP_ROOT/users"
C_ROOT="$IPTV_ROOT/c"
MD5SUM_FILE="$C_ROOT/md5sum"
MD5SUM_LINK="https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/md5sum.c"
MD5SUM_LINK_BACKUP="$FFMPEG_MIRROR_LINK/md5sum.c"
CREATOR_FILE="$IPTV_ROOT/HLS-Stream-Creator.sh"
CF_FILE="/usr/local/bin/cf"
CF_CONFIG="$HOME/cloudflare.json"
CF_WORKERS_ROOT="$HOME/workers"
CF_WORKERS_FILE="$CF_WORKERS_ROOT/cloudflare_workers.py"
CF_WORKERS_LINK="https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/cloudflare_workers.py"
CF_WORKERS_LINK_BACKUP="$FFMPEG_MIRROR_LINK/cloudflare_workers.py"
STREAM_PROXY_LINK="https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/stream_proxy.js"
STREAM_PROXY_LINK_BACKUP="$FFMPEG_MIRROR_LINK/stream_proxy.js"
XTREAM_CODES_PROXY_LINK="https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/xtream_codes_proxy.js"
XTREAM_CODES_PROXY_LINK_BACKUP="$FFMPEG_MIRROR_LINK/xtream_codes_proxy.js"
IBM_FILE="/usr/local/bin/ibm"
IBM_APPS_ROOT="$HOME/ibm_apps"
IBM_CONFIG="$HOME/ibm.json"
DEFAULT_DEMOS="http://tv.epub.fun/default.json"
DEFAULT_CHANNELS_LINK="http://tv.epub.fun/channels.json"
XTREAM_CODES_LINK="http://tv.epub.fun/xtream_codes"
USER_AGENT_BROWSER="Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36"
USER_AGENT_TV="Mozilla/5.0 (QtEmbedded; U; Linux; C)"
green="\033[32m"
red="\033[31m"
blue="\033[34m"
normal="\033[0m"
dim_underlined="\033[37;4;2m"
indent_6="\r\033[6C"
indent_20="\r\033[20C"

Println()
{
    if [ -z "${monitor:-}" ] 
    then
        printf '%b' "\n$1\n"
    fi
}

ReleaseCheck()
{
    [ -n "${release:-}" ] && return 0

    release_files=( /etc/issue /etc/os-release /proc/version )
    release=""

    for release_file in "${release_files[@]}"
    do
        if [ ! -s "$release_file" ] 
        then
            continue
        fi

        if grep -Eqi "Red Hat|redhat|CentOS|Fedora|Amazon" < "$release_file" 
        then
            release="rpm"
            break
        elif grep -Eqi "Ubuntu" < "$release_file" 
        then
            release="ubu"
            break
        elif grep -Eqi "Debian" < "$release_file" 
        then
            release="deb"
            break
        fi
    done

    if [ -z "$release" ] 
    then
        Println "${red}[ERROR]${normal} not support yet...\n"
        exit 1
    fi

    if [ "$(uname -m | grep -c 64)" -gt 0 ]
    then
        release_bit=64
    else
        release_bit=32
    fi
}

DebFixSources()
{
    if [ "${deb_fix:-1}" -eq 1 ] 
    then
        if [ -f /etc/apt/sources.list.d/sources-aliyun-0.list ] 
        then
            deb_list=$(< /etc/apt/sources.list.d/sources-aliyun-0.list)
            rm -f /etc/apt/sources.list.d/sources-aliyun-0.list
            rm -rf /var/lib/apt/lists/*
        else
            deb_list=$(< /etc/apt/sources.list)
        fi

        if grep -q "jessie" <<< "$deb_list"
        then
            printf '%s' "
deb http://archive.debian.org/debian/ jessie main
deb-src http://archive.debian.org/debian/ jessie main

deb http://security.debian.org jessie/updates main
deb-src http://security.debian.org jessie/updates main
" > "/etc/apt/sources.list"
            apt-get clean >/dev/null 2>&1
        elif grep -q "wheezy" <<< "$deb_list" 
        then
            printf '%s' "
deb http://archive.debian.org/debian/ wheezy main
deb-src http://archive.debian.org/debian/ wheezy main

deb http://security.debian.org wheezy/updates main
deb-src http://security.debian.org wheezy/updates main
" > "/etc/apt/sources.list"
            apt-get clean >/dev/null 2>&1
        fi

        deb_fix=0
    fi
}

AptUpdate()
{
    if [ "${apt_updated:-0}" -eq 0 ] 
    then
        apt-get -y update >/dev/null
        apt_updated=1
    fi
}

DepInstall()
{
    dependency=$1

    [[ -x $(command -v $dependency) ]] && return 0

    ReleaseCheck

    if [ "$dependency" == "gettext" ] || [ "$dependency" == "wget" ]
    then
        Println "${green}[INFO]${normal} Installing $dependency, it takes awhile..."

        if [ "$release" == "rpm" ] 
        then
            if [[ -x $(command -v getenforce) ]] && [ "$(getenforce)" != "Disabled" ]
            then
                setenforce permissive
                sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
            fi
            if yum -y install $dependency >/dev/null 2>&1
            then
                Println "${green}[INFO]${normal} $dependency installation succeed..."
            else
                Println "${green}[ERROR]${normal} $dependency installation failed...\n"
                exit 1
            fi
        else
            [ "$release" == "deb" ] && DebFixSources
            AptUpdate
            if apt-get -y install $dependency >/dev/null 2>&1
            then
                Println "${green}[INFO]${normal} $dependency installation succeed..."
            else
                Println "${green}[ERROR]${normal} $dependency installation failed...\n"
                exit 1
            fi
        fi

        return 0
    fi

    Println "`eval_gettext \"\\\$info 安装 \\\$dependency, 请稍等...\"`"

    if [ "$release" == "rpm" ] 
    then
        if [[ -x $(command -v getenforce) ]] && [ "$(getenforce)" != "Disabled" ]
        then
            setenforce permissive
            sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
        fi
        if yum -y install $dependency >/dev/null 2>&1
        then
            Println "`eval_gettext \"\\\$info \\\$dependency 安装成功\"`"
        else
            Println "`eval_gettext \"\\\$error \\\$dependency 安装失败\"`\n"
            exit 1
        fi
    else
        [ "$release" == "deb" ] && DebFixSources
        AptUpdate
        if apt-get -y install $1 >/dev/null 2>&1
        then
            Println "`eval_gettext \"\\\$info \\\$dependency 安装成功\"`"
        else
            Println "`eval_gettext \"\\\$error \\\$dependency 安装失败\"`\n"
            exit 1
        fi
    fi
}

i18nInstall()
{
    local sh_locale=${1:-zh_CN}

    Println "$info You can always use command ${green}tv c <en|ru|de|zh_CN...>${normal} to change/update language!"
    Println "Downloading ${green}$sh_locale${normal} language file...\n"

    DepInstall wget

    if [ "$sh_locale" == "zh_CN" ] 
    then
        echo -e "sh_locale=$sh_locale\nexport LANG=zh_CN.UTF-8\nlocale_fix=0" > "$i18n_FILE"
        Println "`eval_gettext \"\\\${green}成功!\\\${normal}\"`\n"
        return 0
    fi

    trap '
        rm -f "$TEXTDOMAINDIR/$sh_locale/LC_MESSAGES/iptv.mo"
    ' EXIT

    if wget --timeout=15 --tries=3 --no-check-certificate $FFMPEG_MIRROR_LINK/locale/po/iptv.sh-$sh_locale.mo -qO $TEXTDOMAINDIR/$sh_locale/LC_MESSAGES/iptv.mo
    then
        trap - EXIT
        echo -e "sh_locale=$sh_locale\nexport LANG=en_US.UTF-8\nlocale_fix=0" > "$i18n_FILE"
        Println "`eval_gettext \"\\\${green}成功!\\\${normal}\"`\n"
    else
        Println "`eval_gettext \"\\\${red}失败! 请稍后再试!\\\${normal}\"`\n"
        exit 1
    fi
}

i18nGetMsg()
{
    case ${1:-} in
        "") 
            i18n_yes=$(gettext "是")
            i18n_no=$(gettext "否")
            i18n_cancel=$(gettext "取消")
            i18n_canceled=$(gettext "已取消")
            i18n_default_cancel=$(gettext "(默认: 取消): ")
            i18n_input_correct_no=$(gettext "请输入正确的序号")
            i18n_input_correct_number=$(gettext "请输入正确的数字")
            info="${green}`gettext \"[信息]\"`${normal}"
            error="${red}`gettext \"[错误]\"`${normal}"
            tip="${green}`gettext \"[注意]\"`${normal}"
            yn_options=( "$i18n_yes" "$i18n_no" )
            ny_options=( "$i18n_no" "$i18n_yes" )
        ;;
        list_channels) 
            i18n_video_shift=${i18n_video_shift:-$(gettext "画面延迟")}
            i18n_audio_shift=${i18n_audio_shift:-$(gettext "声音延迟")}
            i18n_seconds=${i18n_seconds:-$(gettext "秒")}
            i18n_not_set=${i18n_not_set:-$(gettext "不设置")}
            i18n_const_no=${i18n_const_no:-$(gettext " 固定码率:否")}
            i18n_const_yes=${i18n_const_yes:-$(gettext " 固定码率:是")}
            i18n_resolution=${i18n_resolution:-$(gettext "分辨率")}
            i18n_bitrates=${i18n_bitrates:-$(gettext "比特率")}
            i18n_original=${i18n_original:-$(gettext "原画")}
            i18n_proxy=${i18n_proxy:-$(gettext "代理")}
            i18n_enabled=${i18n_enabled:-$(gettext "开启")}
            i18n_disabled=${i18n_disabled:-$(gettext "关闭")}
            i18n_pid=${i18n_pid:-$(gettext "进程ID")}
            i18n_status=${i18n_status:-$(gettext "状态")}
            i18n_channel_name=${i18n_channel_name:-$(gettext "频道名称")}
            i18n_codec=${i18n_codec:-$(gettext "编码")}
            i18n_video_audio_shift=${i18n_video_audio_shift:-$(gettext "延迟")}
            i18n_video_quality=${i18n_video_quality:-$(gettext "视频质量")}
            i18n_stream_link=${i18n_stream_link:-$(gettext "源")}
            i18n_playlist_file=${i18n_playlist_file:-$(gettext "m3u8路径")}
            i18n_flv_push_link=${i18n_flv_push_link:-$(gettext "推流地址")}
            i18n_flv_pull_link=${i18n_flv_pull_link:-$(gettext "拉流地址")}
        ;;
        get_channel)
            i18n_channel_try_again=${i18n_channel_try_again:-$(gettext "频道发生变化, 请重试 !")}
            i18n_video_shift=${i18n_video_shift:-$(gettext "画面延迟")}
            i18n_audio_shift=${i18n_audio_shift:-$(gettext "声音延迟")}
            i18n_seconds=${i18n_seconds:-$(gettext "秒")}
            i18n_not_set=${i18n_not_set:-$(gettext "不设置")}
            i18n_const_no=${i18n_const_no:-$(gettext " 固定码率:否")}
            i18n_const_yes=${i18n_const_yes:-$(gettext " 固定码率:是")}
            i18n_resolution=${i18n_resolution:-$(gettext "分辨率")}
            i18n_bitrates=${i18n_bitrates:-$(gettext "比特率")}
            i18n_original=${i18n_original:-$(gettext "原画")}
            i18n_enabled=${i18n_enabled:-$(gettext "开启")}
            i18n_disabled=${i18n_disabled:-$(gettext "关闭")}
            i18n_sync_not_set=${i18n_sync_not_set:-$(gettext "请先设置 sync")}
            i18n_sync_not_enabled=${i18n_sync_not_enabled:-$(gettext "请先开启 sync")}
        ;;
        list_channel)
            i18n_playlist_name=${i18n_playlist_name:-$(gettext "m3u8名称")}
            i18n_playlist_link=${i18n_playlist_link:-$(gettext "m3u8链接")}
            i18n_seg_dir_name=${i18n_seg_dir_name:-$(gettext "分片子目录")}
            i18n_seg_name=${i18n_seg_name:-$(gettext "分片名称")}
            i18n_seg_length=${i18n_seg_length:-$(gettext "分片时长")}
            i18n_seg_count=${i18n_seg_count:-$(gettext "分片数")}
            i18n_encrypt=${i18n_encrypt:-$(gettext "加密")}
            i18n_keyinfo_name=${i18n_keyinfo_name:-$(gettext "keyinfo名称")}
            i18n_key_name=${i18n_key_name:-$(gettext "key名称")}
            i18n_live=${i18n_live:-$(gettext "直播")}
            i18n_xtream_codes_proxy=${i18n_xtream_codes_proxy:-$(gettext "xtream codes 代理")}
            i18n_user_agent=${i18n_user_agent:-$(gettext "user agent")}
            i18n_headers=${i18n_headers:-$(gettext "headers")}
            i18n_cookies=${i18n_cookies:-$(gettext "cookies")}
            i18n_video_codec=${i18n_video_codec:-$(gettext "视频编码")}
            i18n_audio_codec=${i18n_audio_codec:-$(gettext "音频编码")}
            i18n_delay=${i18n_delay:-$(gettext "延迟")}
            i18n_input_flags=${i18n_input_flags:-$(gettext "输入参数")}
            i18n_output_flags=${i18n_output_flags:-$(gettext "输出参数")}
            i18n_none=${i18n_none:-$(gettext "无")}
        ;;
        *) 
        ;;
    esac
}

LocaleFix()
{
    ReleaseCheck

    Println "${green}[INFO]${normal} Installing language (locale) support, it takes awhile..."

    if [ "$release" == "rpm" ] 
    then
        if [[ -x $(command -v getenforce) ]] && [ "$(getenforce)" != "Disabled" ]
        then
            setenforce permissive
            sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
        fi
        yum -y install glibc-common glibc-locale-source glibc-all-langpacks glibc-langpack-en glibc-langpacks-zh langpacks-zh_CN >/dev/null 2>&1 || true
    else
        [ "$release" == "deb" ] && DebFixSources
        AptUpdate
        if [[ ! -x $(command -v locale-gen) ]] 
        then
            if ! apt-get -y install locales >/dev/null 2>&1
            then
                Println "${red}[ERROR]${normal} locales installation failed\n" && exit 1
            fi
        fi
        if [ -s /etc/locale.gen ] 
        then
            sed -i "s/# $1.UTF-8 UTF-8/$1.UTF-8 UTF-8/" /etc/locale.gen
        fi
        locale-gen $1.UTF-8 >/dev/null
    fi

    if ! grep -q "$1" < <(locale -a 2> /dev/null) 
    then
        Println "${red}[ERROR]${normal} locales installation failed\n" && exit 1
    fi
}

# eval_gettext MSGID
# looks up the translation of MSGID and substitutes shell variables in the
# result.
eval_gettext () {
  gettext "$1" | (export PATH `envsubst --variables "$1"`; envsubst "$1")
}

TEXTDOMAIN=iptv
TEXTDOMAINDIR=/usr/share/locale

export TEXTDOMAIN TEXTDOMAINDIR

DepInstall gettext

[ $EUID -ne 0 ] && Println "`eval_gettext \"\\\${red}[ERROR]\\\${normal} MUST BE ROOT, TRY\\\${green} sudo su \\\${normal}\"`\n" && exit 1

if [ -s "$i18n_FILE" ] 
then
    # shellcheck source=/dev/null
    . "$i18n_FILE"
fi

if [ -z "${sh_locale:-}" ] 
then
    sh_locale="zh_CN"

    if [ "${locale_fix:-1}" -eq 1 ] && ! grep -q 'zh_CN' < <(locale -a 2> /dev/null) 
    then
        LocaleFix zh_CN
    fi

    echo -e "sh_locale=$sh_locale\nexport LANG=zh_CN.UTF-8\nlocale_fix=0" > "$i18n_FILE"
elif [ "$sh_locale" == "zh_CN" ] 
then
    if [ "${locale_fix:-1}" -eq 1 ] 
    then
        if ! grep -q 'zh_CN' < <(locale -a 2> /dev/null) 
        then
            LocaleFix zh_CN
        fi
        echo -e "sh_locale=$sh_locale\nexport LANG=zh_CN.UTF-8\nlocale_fix=0" > "$i18n_FILE"
    fi
else
    if [ "${locale_fix:-1}" -eq 1 ] && [ "$sh_locale" == "en" ] && ! grep -q 'en_US' < <(locale -a 2> /dev/null) 
    then
        LocaleFix en_US
        echo -e "sh_locale=$sh_locale\nexport LANG=en_US.UTF-8\nlocale_fix=0" > "$i18n_FILE"
    fi

    if [ ! -s "$TEXTDOMAINDIR/$sh_locale/LC_MESSAGES/iptv.mo" ] 
    then
        i18nInstall "$sh_locale"
    fi
fi

i18nGetMsg

DepsCheck()
{
    ReleaseCheck

    DepInstall tput

    Spinner "`gettext \"检查依赖, 耗时可能会很长\"`" DepsInstall
}

DepsInstall()
{
    if [ "$release" == "rpm" ] 
    then
        if [[ -x $(command -v getenforce) ]] && [ "$(getenforce)" != "Disabled" ]
        then
            setenforce permissive
            sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
        fi
        depends=(wget unzip vim curl crond logrotate patch)
        for depend in "${depends[@]}"
        do
            if [[ ! -x $(command -v "$depend") ]] 
            then
                if yum -y install "$depend" >/dev/null 2>&1
                then
                    Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
                else
                    Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
                fi
            fi
        done
        if [[ ! -x $(command -v dig) ]] 
        then
            depend=dig
            if yum -y install bind-utils >/dev/null 2>&1
            then
                Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
            else
                Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
            fi
        fi
        if [[ ! -x $(command -v hexdump) ]] 
        then
            depend=hexdump
            if yum -y install util-linux >/dev/null 2>&1
            then
                Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
            else
                Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
            fi
        fi
        if [[ ! -x $(command -v ss) ]] 
        then
            depend=ss
            if yum -y install iproute >/dev/null 2>&1
            then
                Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
            else
                Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
            fi
        fi
    else
        [ "$release" == "deb" ] && DebFixSources
        AptUpdate
        depends=(wget unzip vim curl cron ufw python3 logrotate patch)
        for depend in "${depends[@]}"
        do
            if [[ ! -x $(command -v "$depend") ]] 
            then
                if apt-get -y install "$depend" >/dev/null 2>&1
                then
                    Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
                else
                    Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
                fi
            fi
        done
        if [[ ! -x $(command -v dig) ]] 
        then
            depend=dig
            if apt-get -y install dnsutils >/dev/null 2>&1
            then
                Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
            else
                Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
            fi
        fi
        if [[ ! -x $(command -v hexdump) ]] 
        then
            depend=hexdump
            if apt-get -y install bsdmainutils >/dev/null 2>&1
            then
                Println "`eval_gettext \"\\\$info 依赖 \\\$depend 安装成功\"`"
            else
                Println "`eval_gettext \"\\\$error 依赖 \\\$depend 安装失败\"`\n" && exit 1
            fi
        fi
    fi
}

# based on https://raw.githubusercontent.com/tanhauhau/Inquirer.sh/master/dist/inquirer.sh
inquirer()
{
    if [[ ! -x $(command -v tput) ]] 
    then
        DepsCheck
    fi
    local arrow checked unchecked red green blue cyan bold normal dim
    arrow=$(echo -e '\xe2\x9d\xaf')
    checked=$(echo -e '\xe2\x97\x89')
    unchecked=$(echo -e '\xe2\x97\xaf')
    red=$(tput setaf 1)
    green=$(tput setaf 2)
    blue=$(tput setaf 4)
    cyan=$(tput setaf 6)
    bold=$(tput bold)
    normal=$(tput sgr0)
    dim=$'\e[2m'

    inquirer:print() {
        echo "$1"
        tput el
    }

    inquirer:join() {
        local IFS=$'\n'
        local var=("$1"[@])
        local _join_list=("${!var}")
        local first=true
        for item in "${_join_list[@]}"
        do
            if [ "$first" = true ]
            then
                printf "%s" "$item"
                first=false
            else
                printf "${2-, }%s" "$item"
            fi
        done
    }

    inquirer:gen_env_from_options() {
        local IFS=$'\n'
        local var=("$1"[@])
        local _indices=("${!var}")
        var=("$2"[@])
        local _env_names=("${!var}")
        local _checkbox_selected

        for i in $(inquirer:gen_index ${#_env_names[@]})
        do
            _checkbox_selected[i]=false
        done

        for i in "${_indices[@]}"
        do
            _checkbox_selected[i]=true
        done

        for i in $(inquirer:gen_index ${#_env_names[@]})
        do
            printf "%s=%s\n" "${_env_names[i]}" "${_checkbox_selected[i]}"
        done
    }

    inquirer:on_default() {
        true;
    }

    inquirer:on_keypress() {
        local OLD_IFS=$IFS
        local key
        local on_up=${1:-inquirer:on_default}
        local on_down=${2:-inquirer:on_default}
        local on_space=${3:-inquirer:on_default}
        local on_enter=${4:-inquirer:on_default}
        local on_left=${5:-inquirer:on_default}
        local on_right=${6:-inquirer:on_default}
        local on_ascii=${7:-inquirer:on_default}
        local on_backspace=${8:-inquirer:on_default}
        local on_not_ascii=${9:-inquirer:on_default}
        _break_keypress=false
        while IFS="" read -rsn1 key
        do
            case "$key" in
                $'\x1b')
                    read -rsn1 key
                    if [[ $key == "[" ]]
                    then
                        read -rsn1 key
                        case "$key" in
                        'A') $on_up;;
                        'B') $on_down;;
                        'D') $on_left;;
                        'C') $on_right;;
                        esac
                    fi
                ;;
                $'\x20') $on_space;;
                $'\x7f') $on_backspace $key;;
                '') $on_enter $key;;
                *[$'\x80'-$'\xFF']*) $on_not_ascii $key;;
                # [^ -~]
                *) $on_ascii $key;;
            esac
            if [ "$_break_keypress" = true ]
            then
                break
            fi
        done
        IFS=$OLD_IFS
    }

    inquirer:gen_index() {
        local k=$1
        local l=0
        for((l=0;l<k;l++));
        do
            echo $l
        done
    }

    inquirer:cleanup() {
        # Reset character attributes, make cursor visible, and restore
        # previous screen contents (if possible).
        tput sgr0
        tput cnorm
        stty echo
    }

    inquirer:control_c() {
        inquirer:cleanup
        exit $?
    }

    inquirer:select_indices() {
        local var=("$1"[@])
        local _select_list
        read -r -a _select_list <<< "${!var}"
        var=("$2"[@])
        local _select_indices
        read -r -a _select_indices <<< "${!var}"
        local _select_var_name=$3
        declare -a new_array
        for i in $(inquirer:gen_index ${#_select_indices[@]})
        do
            new_array+=("${_select_list[${_select_indices[i]}]}")
        done
        read -r -a ${_select_var_name?} <<< "${new_array[@]}"
        unset new_array
    }

    inquirer:on_checkbox_input_up() {
        inquirer:remove_checkbox_instructions
        tput cub "$(tput cols)"

        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            printf '%s' " ${green}${checked}${normal} ${_checkbox_list[$_current_index]} ${normal}"
        else
            printf '%s' " ${unchecked} ${_checkbox_list[$_current_index]} ${normal}"
        fi
        tput el

        if [ $_current_index = 0 ]
        then
            _current_index=$((${#_checkbox_list[@]}-1))
            tput cud $((${#_checkbox_list[@]}-1))
            tput cub "$(tput cols)"
        else
            _current_index=$((_current_index-1))

            tput cuu1
            tput cub "$(tput cols)"
            tput el
        fi

        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            printf '%s' "${cyan}${arrow}${green}${checked}${normal} ${_checkbox_list[$_current_index]} ${normal}"
        else
            printf '%s' "${cyan}${arrow}${normal}${unchecked} ${_checkbox_list[$_current_index]} ${normal}"
        fi
    }

    inquirer:on_checkbox_input_down() {
        inquirer:remove_checkbox_instructions
        tput cub "$(tput cols)"

        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            printf '%s' " ${green}${checked}${normal} ${_checkbox_list[$_current_index]} ${normal}"
        else
            printf '%s' " ${unchecked} ${_checkbox_list[$_current_index]} ${normal}"
        fi

        tput el

        if [ $_current_index = $((${#_checkbox_list[@]}-1)) ]
        then
            _current_index=0
            tput cuu $((${#_checkbox_list[@]}-1))
            tput cub "$(tput cols)"
        else
            _current_index=$((_current_index+1))
            tput cud1
            tput cub "$(tput cols)"
            tput el
        fi

        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            printf '%s' "${cyan}${arrow}${green}${checked}${normal} ${_checkbox_list[$_current_index]} ${normal}"
        else
            printf '%s' "${cyan}${arrow}${normal}${unchecked} ${_checkbox_list[$_current_index]} ${normal}"
        fi
    }

    inquirer:on_checkbox_input_enter() {
        local OLD_IFS=$IFS
        _checkbox_selected_indices=()
        _checkbox_selected_options=()
        IFS=$'\n'

        for i in $(inquirer:gen_index ${#_checkbox_list[@]})
        do
            if [ "${_checkbox_selected[i]}" = true ]
            then
                _checkbox_selected_indices+=("$i")
                _checkbox_selected_options+=("${_checkbox_list[i]}")
            fi
        done

        tput cud $((${#_checkbox_list[@]}-_current_index))
        tput cub "$(tput cols)"

        for i in $(seq $((${#_checkbox_list[@]}+1)))
        do
            tput el1
            tput el
            tput cuu1
        done
        tput cub "$(tput cols)"

        tput cuf $((prompt_width+3))
        printf '%s' "${cyan}$(inquirer:join _checkbox_selected_options)${normal}"
        tput el

        tput cud1
        tput cub "$(tput cols)"
        tput el

        _break_keypress=true
        IFS=$OLD_IFS
    }

    inquirer:on_checkbox_input_space() {
        inquirer:remove_checkbox_instructions
        tput cub "$(tput cols)"
        tput el
        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            _checkbox_selected[$_current_index]=false
        else
            _checkbox_selected[$_current_index]=true
        fi

        if [ "${_checkbox_selected[$_current_index]}" = true ]
        then
            printf '%s' "${cyan}${arrow}${green}${checked}${normal} ${_checkbox_list[$_current_index]} ${normal}"
        else
            printf '%s' "${cyan}${arrow}${normal}${unchecked} ${_checkbox_list[$_current_index]} ${normal}"
        fi
    }

    inquirer:remove_checkbox_instructions() {
        if [ "$_first_keystroke" = true ]
        then
            tput cuu $((_current_index+1))
            tput cub "$(tput cols)"
            tput cuf $((prompt_width+3))
            tput el
            tput cud $((_current_index+1))
            _first_keystroke=false
        fi
    }

    inquirer:on_checkbox_input_ascii() {
        local key=$1
        case $key in
            "w" ) inquirer:on_checkbox_input_up;;
            "s" ) inquirer:on_checkbox_input_down;;
        esac
    }

    inquirer:_checkbox_input() {
        local i j var=("$2"[@])
        _checkbox_list=("${!var}")
        _current_index=0
        _first_keystroke=true

        trap inquirer:control_c SIGINT EXIT

        stty -echo
        tput civis

        inquirer:print "${green}?${normal} ${bold}${prompt}${normal} ${dim}`gettext \"(按 <space> 选择, <enter> 确认)\"`${normal}"

        for i in $(inquirer:gen_index ${#_checkbox_list[@]})
        do
            _checkbox_selected[i]=false
        done

        if [ -n "${3:-}" ]
        then
            var=("$3"[@])
            _selected_indices=("${!var}")
            for i in "${_selected_indices[@]}"
            do
                _checkbox_selected[i]=true
            done
        fi

        for i in $(inquirer:gen_index ${#_checkbox_list[@]})
        do
            tput cub "$(tput cols)"
            if [ $i = 0 ]
            then
                if [ "${_checkbox_selected[i]}" = true ]
                then
                    inquirer:print "${cyan}${arrow}${green}${checked}${normal} ${_checkbox_list[i]} ${normal}"
                else
                    inquirer:print "${cyan}${arrow}${normal}${unchecked} ${_checkbox_list[i]} ${normal}"
                fi
            else
                if [ "${_checkbox_selected[i]}" = true ]
                then
                    inquirer:print " ${green}${checked}${normal} ${_checkbox_list[i]} ${normal}"
                else
                    inquirer:print " ${unchecked} ${_checkbox_list[i]} ${normal}"
                fi
            fi
            tput el
        done

        for j in $(inquirer:gen_index ${#_checkbox_list[@]})
        do
            tput cuu1
        done

        inquirer:on_keypress inquirer:on_checkbox_input_up inquirer:on_checkbox_input_down inquirer:on_checkbox_input_space inquirer:on_checkbox_input_enter inquirer:on_default inquirer:on_default inquirer:on_checkbox_input_ascii
    }

    inquirer:checkbox_input() {
        inquirer:_checkbox_input "$1" "$2"
        _checkbox_input_output_var_name=$3
        inquirer:select_indices _checkbox_list _checkbox_selected_indices $_checkbox_input_output_var_name

        unset _checkbox_list
        unset _break_keypress
        unset _first_keystroke
        unset _current_index
        unset _checkbox_input_output_var_name
        unset _checkbox_selected_indices
        unset _checkbox_selected_options

        inquirer:cleanup
    }

    inquirer:checkbox_input_indices() {
        inquirer:_checkbox_input "$1" "$2" "$3"
        _checkbox_input_output_var_name=$3

        declare -a new_array
        for i in $(inquirer:gen_index ${#_checkbox_selected_indices[@]})
        do
            new_array+=("${_checkbox_selected_indices[i]}")
        done
        read -r -a ${_checkbox_input_output_var_name?} <<< "${new_array[@]}"
        unset new_array

        unset _checkbox_list
        unset _break_keypress
        unset _first_keystroke
        unset _current_index
        unset _checkbox_input_output_var_name
        unset _checkbox_selected_indices
        unset _checkbox_selected_options

        inquirer:cleanup
    }

    inquirer:on_list_input_up() {
        inquirer:remove_list_instructions
        tput cub "$(tput cols)"

        printf '%s' "  ${_list_options[$_list_selected_index]}"
        tput el

        if [ $_list_selected_index = 0 ]
        then
            _list_selected_index=$((${#_list_options[@]}-1))
            tput cud $((${#_list_options[@]}-1))
            tput cub "$(tput cols)"
        else
            _list_selected_index=$((_list_selected_index-1))

            tput cuu1
            tput cub "$(tput cols)"
            tput el
        fi

        printf "${cyan}${arrow} %s ${normal}" "${_list_options[$_list_selected_index]}"
    }

    inquirer:on_list_input_down() {
        inquirer:remove_list_instructions
        tput cub "$(tput cols)"

        printf '%s' "  ${_list_options[$_list_selected_index]}"
        tput el

        if [ $_list_selected_index = $((${#_list_options[@]}-1)) ]
        then
            _list_selected_index=0
            tput cuu $((${#_list_options[@]}-1))
            tput cub "$(tput cols)"
        else
            _list_selected_index=$((_list_selected_index+1))
            tput cud1
            tput cub "$(tput cols)"
            tput el
        fi
        printf "${cyan}${arrow} %s ${normal}" "${_list_options[$_list_selected_index]}"
    }

    inquirer:on_list_input_enter_space() {
        local OLD_IFS=$IFS
        IFS=$'\n'

        tput cud $((${#_list_options[@]}-_list_selected_index))
        tput cub "$(tput cols)"

        for i in $(seq $((${#_list_options[@]}+1)))
        do
            tput el1
            tput el
            tput cuu1
        done
        tput cub "$(tput cols)"

        tput cuf $((prompt_width+3))
        printf '%s' "${cyan}${_list_options[$_list_selected_index]}${normal}"
        tput el

        tput cud1
        tput cub "$(tput cols)"
        tput el

        _break_keypress=true
        IFS=$OLD_IFS
    }

    inquirer:on_list_input_input_ascii()
    {
        local key=$1
        case $key in
            "w" ) inquirer:on_list_input_up;;
            "s" ) inquirer:on_list_input_down;;
        esac
    }

    inquirer:remove_list_instructions() {
        if [ "$_first_keystroke" = true ]
        then
            tput cuu $((_list_selected_index+1))
            tput cub "$(tput cols)"
            tput cuf $((prompt_width+3))
            tput el
            tput cud $((_list_selected_index+1))
            _first_keystroke=false
        fi
    }

    inquirer:_list_input() {
        local i j var=("$2"[@])
        _list_options=("${!var}")

        _list_selected_index=0
        _first_keystroke=true

        trap inquirer:control_c SIGINT EXIT

        stty -echo
        tput civis

        inquirer:print "${green}?${normal} ${bold}${prompt}${normal} ${dim}`gettext \"(使用上下箭头选择)\"`${normal}"

        for i in $(inquirer:gen_index ${#_list_options[@]})
        do
            tput cub "$(tput cols)"
            if [ $i = 0 ]
            then
                inquirer:print "${cyan}${arrow} ${_list_options[i]} ${normal}"
            else
                inquirer:print "  ${_list_options[i]}"
            fi
            tput el
        done

        for j in $(inquirer:gen_index ${#_list_options[@]})
        do
            tput cuu1
        done

        inquirer:on_keypress inquirer:on_list_input_up inquirer:on_list_input_down inquirer:on_list_input_enter_space inquirer:on_list_input_enter_space inquirer:on_default inquirer:on_default inquirer:on_list_input_input_ascii
    }

    inquirer:list_input() {
        inquirer:_list_input "$1" "$2"
        var_name=$3
        read -r ${var_name?} <<< "${_list_options[$_list_selected_index]}"
        unset _list_selected_index
        unset _list_options
        unset _break_keypress
        unset _first_keystroke

        inquirer:cleanup
    }

    inquirer:list_input_index() {
        inquirer:_list_input "$1" "$2"
        var_name=$3
        read -r ${var_name?} <<< "$_list_selected_index"
        unset _list_selected_index
        unset _list_options
        unset _break_keypress
        unset _first_keystroke

        inquirer:cleanup
    }

    inquirer:on_text_input_left() {
        inquirer:remove_regex_failed
        if [[ $_current_pos -gt 0 ]]
        then
            local current=${_text_input:$_current_pos:1} current_width
            current_width=$(inquirer:display_length "$current")

            tput cub $current_width
            _current_pos=$((_current_pos-1))
        fi
    }

    inquirer:on_text_input_right() {
        inquirer:remove_regex_failed
        if [[ $((_current_pos+1)) -eq ${#_text_input} ]] 
        then
            tput cuf1
            _current_pos=$((_current_pos+1))
        elif [[ $_current_pos -lt ${#_text_input} ]]
        then
            local next=${_text_input:$((_current_pos+1)):1} next_width
            next_width=$(inquirer:display_length "$next")

            tput cuf $next_width
            _current_pos=$((_current_pos+1))
        fi
    }

    inquirer:on_text_input_enter() {
        inquirer:remove_regex_failed

        _text_input=${_text_input:-$_text_default_value}

        if [[ $($_text_input_validator "$_text_input") = true ]]
        then
            tput cuu 1
            tput cub "$(tput cols)"
            tput cuf $((prompt_width+3))
            printf '%s' "${cyan}${_text_input}${normal}"
            tput el
            tput cud1
            tput cub "$(tput cols)"
            tput el
            read -r ${var_name?} <<< "$_text_input"
            _break_keypress=true
        else
            _text_input_regex_failed=true
            tput civis
            tput cuu1
            tput cub "$(tput cols)"
            tput cuf $((prompt_width+3))
            tput el
            tput cud1
            tput cub "$(tput cols)"
            tput el
            tput cud1
            tput cub "$(tput cols)"
            printf '%b' "${red}$_text_input_regex_failed_msg${normal}"
            tput el
            _text_input=""
            _current_pos=0
            tput cnorm
        fi
    }

    inquirer:on_text_input_ascii() {
        inquirer:remove_regex_failed
        local c=${1:- }

        local rest=${_text_input:$_current_pos} rest_width
        local current=${_text_input:$_current_pos:1} current_width
        rest_width=$(inquirer:display_length "$rest")
        current_width=$(inquirer:display_length "$current")

        _text_input="${_text_input:0:$_current_pos}$c$rest"
        _current_pos=$((_current_pos+1))

        tput civis
        [[ $current_width -gt 1 ]] && tput cub $((current_width-1))
        printf '%s' "$c$rest"
        tput el

        if [[ $rest_width -gt 0 ]]
        then
            tput cub $((rest_width-current_width+1))
        fi
        tput cnorm
    }

    inquirer:display_length() {
        local display_length=0 byte_len
        local oLC_ALL=${LC_ALL:-} oLANG=${LANG:-} LC_ALL=${LC_ALL:-} LANG=${LANG:-}

        while IFS="" read -rsn1 char
        do
            case "$char" in
                '')
                ;;
                *[$'\x80'-$'\xFF']*) 
                    LC_ALL='' LANG=C
                    byte_len=${#char}
                    LC_ALL=$oLC_ALL LANG=$oLANG
                    if [[ $byte_len -eq 2 ]] 
                    then
                        display_length=$((display_length+1))
                    else
                        display_length=$((display_length+2))
                    fi
                ;;
                *) 
                    display_length=$((display_length+1))
                ;;
            esac
        done <<< "$1"

        echo "$display_length"
    }

    inquirer:on_text_input_not_ascii() {
        inquirer:remove_regex_failed
        local c=$1

        local rest="${_text_input:$_current_pos}" rest_width
        local current=${_text_input:$_current_pos:1} current_width
        rest_width=$(inquirer:display_length "$rest")
        current_width=$(inquirer:display_length "$current")

        _text_input="${_text_input:0:$_current_pos}$c$rest"
        _current_pos=$((_current_pos+1))

        tput civis
        [[ $current_width -gt 1 ]] && tput cub $((current_width-1))
        printf '%s' "$c$rest"
        tput el

        if [[ $rest_width -gt 0 ]]
        then
            tput cub $((rest_width-current_width+1))
        fi
        tput cnorm
    }

    inquirer:on_text_input_backspace() {
        inquirer:remove_regex_failed
        if [ $_current_pos -gt 0 ] || { [ $_current_pos -eq 0 ] && [ "${#_text_input}" -gt 0 ]; }
        then
            local start rest rest_width del del_width next next_width offset
            local current=${_text_input:$_current_pos:1} current_width
            current_width=$(inquirer:display_length "$current")

            tput civis
            if [ $_current_pos -eq 0 ] 
            then
                rest=${_text_input:$((_current_pos+1))}
                next=${_text_input:$((_current_pos+1)):1}
                rest_width=$(inquirer:display_length "$rest")
                next_width=$(inquirer:display_length "$next")
                offset=$((current_width-1))
                [[ $offset -gt 0 ]] && tput cub $offset
                printf '%s' "$rest"
                tput el
                offset=$((rest_width-next_width+1))
                [[ $offset -gt 0 ]] && tput cub $offset
                _text_input=$rest
            else
                rest=${_text_input:$_current_pos}
                start=${_text_input:0:$((_current_pos-1))}
                del=${_text_input:$((_current_pos-1)):1}
                rest_width=$(inquirer:display_length "$rest")
                del_width=$(inquirer:display_length "$del")
                _current_pos=$((_current_pos-1))
                if [[ $current_width -gt 1 ]] 
                then
                    tput cub $((del_width+current_width-1))
                    printf '%s' "$rest"
                    tput el
                    tput cub $((rest_width-current_width+1))
                else
                    tput cub $del_width
                    printf '%s' "$rest"
                    tput el
                    [[ $rest_width -gt 0 ]] && tput cub $((rest_width-current_width+1))
                fi
                _text_input="$start$rest"
            fi
            tput cnorm
        fi
    }

    inquirer:remove_regex_failed() {
        if [ "$_text_input_regex_failed" = true ]
        then
            _text_input_regex_failed=false
            tput sc
            tput cud1
            tput el1
            tput el
            tput rc
        fi
    }

    inquirer:text_input_default_validator() {
        echo true;
    }

    inquirer:text_input() {
        var_name=$2
        if [ -n "$_text_default_value" ] 
        then
            _text_default_tip=" $dim($_text_default_value)"
        else
            _text_default_tip=""
        fi
        _text_input_regex_failed_msg=${4:-$(gettext "输入验证错误")}
        _text_input_validator=${5:-inquirer:text_input_default_validator}
        _text_input_regex_failed=false

        inquirer:print "${green}?${normal} ${bold}${prompt}$_text_default_tip${normal}"

        trap inquirer:control_c SIGINT EXIT

        stty -echo
        tput cnorm

        inquirer:on_keypress inquirer:on_default inquirer:on_default inquirer:on_text_input_ascii inquirer:on_text_input_enter inquirer:on_text_input_left inquirer:on_text_input_right inquirer:on_text_input_ascii inquirer:on_text_input_backspace inquirer:on_text_input_not_ascii
        read -r ${var_name?} <<< "$_text_input"

        inquirer:cleanup
    }

    local option=$1
    shift
    local var_name prompt=${1:-} prompt_width _text_default_value=${3:-} _current_pos=0 _text_input="" _text_input_regex_failed_msg _text_input_validator _text_input_regex_failed
    prompt_width=$(inquirer:display_length "$prompt")
    inquirer:$option "$@"
}

# based on https://raw.githubusercontent.com/kahkhang/ora.sh/master/ora.sh
Spinner(){
    if [[ ! -x $(command -v tput) ]] 
    then
        DepsCheck
    fi
    local i=1 delay=0.05 FUNCTION_NAME="$2" VARIABLE_NAME="${3:-}" list tempfile
    local green cyan normal
    green=$(tput setaf 2)
    cyan=$(tput setaf 6)
    normal=$(tput sgr0)

    IFS=" " read -a list < <(echo -e '\xe2\xa0\x8b \xe2\xa0\x99 \xe2\xa0\xb9 \xe2\xa0\xb8 \xe2\xa0\xbc \xe2\xa0\xb4 \xe2\xa0\xa6 \xe2\xa0\xa7 \xe2\xa0\x87 \xe2\xa0\x8f')
    tempfile=$(mktemp)

    trap 'inquirer cleanup' SIGINT

    stty -echo && tput civis
    $FUNCTION_NAME >> "$tempfile" 2>>"$tempfile" &
    local pid=$!

    echo
    tput sc
    printf "%s %s" "${list[i]}" "${green}$1${normal}"
    tput el
    tput rc

    while ps -p $pid -o pid= >/dev/null
    do
        printf "%s" "$cyan${list[i]}${normal}"
        i=$(((i+1)%10))
        sleep $delay
        printf "\b\b\b"
    done
    tput el

    if [[ -n $VARIABLE_NAME ]]
    then
        read -r ${VARIABLE_NAME?} < "$tempfile"
    else
        awk '{print}' "$tempfile"
    fi

    rm -f "$tempfile"

    tput cnorm && stty echo

    trap - SIGINT

    wait $pid
}

ShFileCheck()
{
    if [ ! -e "$SH_FILE" ] 
    then
        DepInstall curl
        if curl -s -Lm 20 "$SH_LINK" -o "${SH_FILE}_tmp"
        then
            mv "${SH_FILE}_tmp" "$SH_FILE"
            chmod +x "$SH_FILE"
            Println "`eval_gettext \"\\\$info 脚本下载完成\"`"
        else
            Println "`eval_gettext \"\\\$error 无法连接到 Github ! 尝试备用链接...\"`"
            if curl -s -Lm 30 "$SH_LINK_BACKUP" -o "${SH_FILE}_tmp" 
            then
                mv "${SH_FILE}_tmp" "$SH_FILE"
                chmod +x "$SH_FILE"
                Println "`eval_gettext \"\\\$info 脚本下载完成\"`"
            else
                Println "`eval_gettext \"\\\$error 无法连接备用链接! 脚本下载失败, 请稍后再试\"`\n"
                exit 1
            fi
        fi
    fi

    [ ! -e "$IBM_FILE" ] && ln -s "$SH_FILE" "$IBM_FILE"
    [ ! -e "$CF_FILE" ] && ln -s "$SH_FILE" "$CF_FILE"
    [ ! -e "$OR_FILE" ] && ln -s "$SH_FILE" "$OR_FILE"
    [ ! -e "$NX_FILE" ] && ln -s "$SH_FILE" "$NX_FILE"
    [ ! -e "$V2_FILE" ] && ln -s "$SH_FILE" "$V2_FILE"
    [ ! -e "$X_FILE" ] && ln -s "$SH_FILE" "$X_FILE"
    [ ! -e "$XC_FILE" ] && ln -s "$SH_FILE" "$XC_FILE"
    [ ! -e "$ARM_FILE" ] && ln -s "$SH_FILE" "$ARM_FILE"
    [ ! -e "$PVE_FILE" ] && ln -s "$SH_FILE" "$PVE_FILE"

    return 0
}

ShFileUpdate()
{
    sh_name=${1:-iptv}

    Println "`eval_gettext \"\\\$info 更新 \\\$sh_name 脚本...\"`"

    if curl -s -Lm 20 "$SH_LINK" -o "${SH_FILE}_tmp"
    then
        mv "${SH_FILE}_tmp" "$SH_FILE"
        chmod +x "$SH_FILE"
        Println "`eval_gettext \"\\\$info \\\$sh_name 脚本更新完成\"`"
        sh_new_ver=$(grep 'sh_ver="' < "$SH_FILE" |awk -F "=" '{print $NF}'|sed 's/\"//g'|head -1)
        if [ "${sh_new_ver%.*}" != "${sh_ver%.*}" ] 
        then
            rm -f "$LOCK_FILE"
        fi
    else
        Println "`eval_gettext \"\\\$error 无法连接到 Github ! 尝试备用链接...\"`"
        if curl -s -Lm 30 "$SH_LINK_BACKUP" -o "${SH_FILE}_tmp" 
        then
            mv "${SH_FILE}_tmp" "$SH_FILE"
            chmod +x "$SH_FILE"
            Println "`eval_gettext \"\\\$info \\\$sh_name 脚本更新完成\"`"
            sh_new_ver=$(grep 'sh_ver="' < "$SH_FILE" |awk -F "=" '{print $NF}'|sed 's/\"//g'|head -1)
            if [ "${sh_new_ver%.*}" != "${sh_ver%.*}" ] 
            then
                rm -f "$LOCK_FILE"
            fi
        else
            Println "`eval_gettext \"\\\$error 无法连接备用链接! \\\$sh_name 脚本更新失败, 请稍后再试\"`\n"
        fi
    fi

    [ "$sh_locale" != "zh_CN" ] && i18nInstall "$sh_locale" > /dev/null

    return 0
}

Progress()
{
    echo -ne "\n`eval_gettext \"\\\$info 安装中, 请等待...\"`"
    while true
    do
        echo -n "."
        sleep 5
    done
}

AskIfContinue()
{
    if [ "$1" == "y" ] 
    then
        inquirer list_input "$2" yn_options yn_option
    else
        inquirer list_input "$2" ny_options yn_option
    fi

    if [ "$yn_option" == "$i18n_no" ]
    then
        Println "$i18n_canceled...\n"
        exit 1
    fi
}

ExitOnCancel()
{
    if [ "${!1}" == "$i18n_cancel" ] 
    then
        Println "$i18n_canceled...\n"
        exit 1
    fi
}

PythonInstall()
{
    ReleaseCheck
    if [ "$release" == "rpm" ] 
    then
        echo
        AskIfContinue n "`gettext \"因为是编译 python3, 耗时会很长, 是否继续\"`"

        Progress &
        progress_pid=$!
        trap '
            kill $progress_pid 2> /dev/null
        ' EXIT
        yum groupinstall -y 'Development Tools' >/dev/null 2>&1
        yum install -y gcc openssl-devel bzip2-devel libffi-devel >/dev/null 2>&1
        echo -n "...50%..."
        cd ~
        wget --timeout=10 --tries=3 --no-check-certificate https://npm.taobao.org/mirrors/python/3.8.8/Python-3.8.8.tgz -qO Python-3.8.8.tgz
        tar xzf Python-3.8.8.tgz
        cd Python-3.8.8
        ./configure >/dev/null 2>&1
        make >/dev/null 2>&1
        make install >/dev/null 2>&1
        pip3 install requests > /dev/null
        kill $progress_pid
        trap - EXIT
        echo -n "...100%" && echo
    fi
}

CrossplaneInstall()
{
    if [[ ! -x $(command -v python3) ]] 
    then
        Println "`eval_gettext \"\\\$info 安装 python3 ...\"`"
        PythonInstall
    fi

    if [[ ! -x $(command -v pip3) ]] 
    then
        Println "`eval_gettext \"\\\$info 安装 pip3 ...\"`"
        Progress &
        progress_pid=$!
        trap '
            kill $progress_pid 2> /dev/null
        ' EXIT
        apt-get -y install python3-pip >/dev/null 2>&1
        kill $progress_pid
        trap - EXIT
        echo -n "...100%" && echo
    fi

    pip3 install crossplane
}

FFmpegInstall()
{
    FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
    FFMPEG="$FFMPEG_ROOT/ffmpeg"
    if [ ! -e "$FFMPEG" ]
    then
        Println "`eval_gettext \"\\\$info 开始下载/安装 FFmpeg...\"`"
        if [ "$release_bit" -eq 64 ]
        then
            ffmpeg_package="ffmpeg-git-${arch:-amd64}-static.tar.xz"
        else
            ffmpeg_package="ffmpeg-git-i686-static.tar.xz"
        fi
        FFMPEG_PACKAGE_FILE="$IPTV_ROOT/$ffmpeg_package"
        curl -L "$FFMPEG_MIRROR_LINK/builds/$ffmpeg_package" -o "$FFMPEG_PACKAGE_FILE"
        [ ! -e "$FFMPEG_PACKAGE_FILE" ] && Println "`eval_gettext \"\\\$error FFmpeg 下载失败 !\"`" && exit 1
        tar xJf "$FFMPEG_PACKAGE_FILE" -C "$IPTV_ROOT" && rm -f "${FFMPEG_PACKAGE_FILE:-notfound}"
        FFMPEG=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
        [ ! -e "$FFMPEG" ] && Println "`eval_gettext \"\\\$error FFmpeg 解压失败 !\"`" && exit 1
        export FFMPEG
        Println "`eval_gettext \"\\\$info FFmpeg 安装成功\"`"
    else
        Println "`eval_gettext \"\\\$info FFmpeg 已安装\"`"
    fi
}

FFmpegCompile()
{
    DepsCheck

    if [ "$release" == "rpm" ] 
    then
        Println "`eval_gettext \"\\\$error 不支持 centos\"`\n"
        exit 1
    fi

    tls_options=( 'gnutls' 'openssl' )
    inquirer list_input "`gettext \"选择 tls\"`" tls_options tls_option

    nproc="-j$(nproc 2> /dev/null)" || nproc=""

    if ! grep -q "swapfile" /etc/fstab 
    then
        fallocate -l 1024M /opt/swapfile > /dev/null 2>&1 || dd if=/dev/zero of=/opt/swapfile bs=1M count=1024 > /dev/null 2>&1
        chmod 600 /opt/swapfile
        mkswap /opt/swapfile
        swapon /opt/swapfile
        echo "/opt/swapfile none swap defaults 0 0" >> /etc/fstab
    fi

    mkdir -p ~/ffmpeg_sources

    apt-get -y install autoconf automake build-essential cmake zlib1g-dev \
        libtool pkg-config texinfo frei0r-plugins-dev libopencore-amrnb-dev \
        libopencore-amrwb-dev libtheora-dev libvo-amrwbenc-dev libxvidcore-dev \
        libssl-dev libva-dev libvdpau-dev libxcb1-dev libxcb-shm0-dev \
        libxcb-xfixes0-dev flex bison libharfbuzz-dev \
        libfontconfig-dev libfreetype6-dev python3 python3-pip \
        python3-setuptools python3-wheel ninja-build doxygen git libxext-dev \
        libsndfile1-dev libasound2-dev graphviz

    export CMAKE_PREFIX_PATH="$HOME/ffmpeg_build"
    export PATH="$HOME/ffmpeg_build/bin:$PATH"
    export LDFLAGS="-L$HOME/ffmpeg_build/lib"
    # -Wl,-z,relro,-z,now
    export DYLD_LIBRARY_PATH="$HOME/ffmpeg_build/lib"
    export PKG_CONFIG_PATH="$HOME/ffmpeg_build/lib/pkgconfig"
    export CFLAGS="-I$HOME/ffmpeg_build/include $LDFLAGS"
    # -O3 -static-libgcc -fno-strict-overflow -fstack-protector-all -fPIE
    # export CXXFLAGS="-O3 -static-libgcc -fno-strict-overflow -fstack-protector-all -fPIE"

    # zlib
    cd ~/ffmpeg_sources
    if [ ! -d zlib-1.2.11 ] 
    then
        [ ! -f zlib-1.2.11.tar.gz ] && curl -L "https://www.zlib.net/zlib-1.2.11.tar.gz" -o zlib-1.2.11.tar.gz
        tar xzf zlib-1.2.11.tar.gz
    fi
    cd zlib-1.2.11
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --static
    make $nproc
    make install

    # CMake
    cmake_install=1
    if [[ -x $(command -v cmake) ]] 
    then
        cmake_ver=$(cmake --version | awk '{print $3}' | head -1)
        if [[ $cmake_ver =~ ([^.]+).([^.]+).([^.]+) ]] && [[ ${BASH_REMATCH[1]} -lt 14 ]]
        then
            apt-get -y remove cmake
            hash -r
        else
            cmake_install=0
        fi
    fi

    if [ "$cmake_install" -eq 1 ] 
    then
        cd ~/ffmpeg_sources
        if [ ! -d CMake-3.18.4 ] 
        then
            [ ! -f cmake-3.18.4.tar.gz ] && curl -L "https://github.com/Kitware/CMake/archive/v3.18.4.tar.gz" -o cmake-3.18.4.tar.gz
            tar xzf cmake-3.18.4.tar.gz
        fi
        cd CMake-3.18.4
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./bootstrap
        make $nproc
        make install
    fi

    # libbz2
    cd ~/ffmpeg_sources
    if [ ! -d bzip2-1.0.6 ] 
    then
        [ ! -f bzip2-1.0.6.tar.gz ] && curl -L "https://downloads.sourceforge.net/bzip2/bzip2-1.0.6.tar.gz" -o bzip2-1.0.6.tar.gz
        tar xzf bzip2-1.0.6.tar.gz
    fi
    cd bzip2-1.0.6
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    make
    make install PREFIX="$HOME/ffmpeg_build"
    printf '%s' 'prefix=/root/ffmpeg_build
exec_prefix=${prefix}
libdir=${prefix}/lib
includedir=${prefix}/include

Name: bzip2
Description: bzip2
Version: 1.0.6
Requires:
Libs: -L${libdir} -lbz2
Cflags: -I${includedir}    
' > "$HOME/ffmpeg_build/lib/pkgconfig/bzip2.pc"

    # yasm
    cd ~/ffmpeg_sources
    if [ ! -d yasm-1.3.0 ] 
    then
        [ ! -f yasm-1.3.0.tar.gz ] && curl -L "http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz" -o yasm-1.3.0.tar.gz
        tar xzf yasm-1.3.0.tar.gz
    fi
    cd yasm-1.3.0
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build"
    make $nproc
    make install

    # nasm
    # uname -mpi | grep -qE 'x86|i386|i686'
    if [ "$release" != "arm" ] 
    then
        cd ~/ffmpeg_sources
        if [ ! -d nasm-2.15.05 ] 
        then
            [ ! -f nasm-2.15.05.tar.gz ] && curl -L "https://www.nasm.us/pub/nasm/releasebuilds/2.15.05/nasm-2.15.05.tar.gz" -o nasm-2.15.05.tar.gz
            tar xzf nasm-2.15.05.tar.gz
        fi
        cd nasm-2.15.05
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./autogen.sh
        ./configure --prefix="$HOME/ffmpeg_build"
        make $nproc
        make install
    fi

    # x264
    cd ~/ffmpeg_sources
    git -C x264 pull 2> /dev/null || git clone --depth 1 https://code.videolan.org/videolan/x264.git
    cd x264
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --enable-static --enable-pic
    make $nproc
    make install

    # libnuma (for x265)
    cd ~/ffmpeg_sources
    git -C numactl pull 2> /dev/null || git clone --depth 1 https://github.com/numactl/numactl.git
    cd numactl
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # x265
    cd ~/ffmpeg_sources
    rm -rf x265_git
    git clone https://bitbucket.org/multicoreware/x265_git
    cd x265_git/build/linux
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DENABLE_SHARED=OFF -DSTATIC_LINK_CRT=ON -DENABLE_CLI=OFF ../../source
    make $nproc
    sed -i 's/-lgcc_s/-lgcc_eh/g' x265.pc
    make install

    # liblzma (for libxml2, ffmpeg)
    cd ~/ffmpeg_sources
    if [ ! -d xz-5.2.5 ] 
    then
        [ ! -f xz-5.2.5.tar.xz ] && curl -L "https://downloads.sourceforge.net/lzmautils/xz-5.2.5.tar.xz" -o xz-5.2.5.tar.xz
        tar xJf xz-5.2.5.tar.xz
    fi
    cd xz-5.2.5
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-static
    make $nproc
    make install

    # libiconv (for libxml2)
    cd ~/ffmpeg_sources
    if [ ! -d libiconv-1.16 ] 
    then
        [ ! -f libiconv-1.16.tar.gz ] && curl -L "https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.16.tar.gz" -o libiconv-1.16.tar.gz
        tar xzf libiconv-1.16.tar.gz
    fi
    cd libiconv-1.16
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-static
    make $nproc
    make install

    # libxml2
    cd ~/ffmpeg_sources
    rm -rf libxml2
    git clone https://github.com/GNOME/libxml2.git
    mkdir -p libxml2/build
    cd libxml2/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install
    printf '%s' "prefix=$HOME/ffmpeg_build
exec_prefix=\${prefix}
libdir=\${prefix}/lib
includedir=\${prefix}/include

Name: libxml2
Description: libxml2
Version: 2.9.10
Requires:
Libs: -L\${libdir} -lxml2
Cflags: -I\${includedir}
" > "$HOME/ffmpeg_build/lib/pkgconfig/libxml-2.0.pc"

    # libpng (for openjpeg)
    cd ~/ffmpeg_sources
    if [ ! -d libpng-1.6.37 ] 
    then
        [ ! -f libpng-1.6.37.tar.gz ] && curl -L "https://downloads.sourceforge.net/libpng/libpng-1.6.37.tar.gz" -o libpng-1.6.37.tar.gz
        tar xzf libpng-1.6.37.tar.gz
    fi
    cd libpng-1.6.37
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --enable-static=yes --enable-shared=no
    make $nproc
    make install

    # c2man (for fribidi)
    cd ~/ffmpeg_sources
    rm -rf c2man
    git clone --depth 1 https://github.com/fribidi/c2man.git
    cd c2man
    rm -rf "$HOME/ffmpeg_sources/c2man_build"
    rm -f "$HOME/ffmpeg_build/bin/c2man"
    mkdir "$HOME/ffmpeg_sources/c2man_build"
    ./Configure -dE
    echo "binexp=$HOME/ffmpeg_build/bin" >> config.sh
    echo "installprivlib=$HOME/ffmpeg_sources/c2man_build" >> config.sh
    echo "mansrc=$HOME/ffmpeg_sources/c2man_build" >> config.sh
    sh config_h.SH
    sh flatten.SH
    sh Makefile.SH
    make depend
    make
    make install

    # fribidi (for libass)
    cd ~/ffmpeg_sources
    if [ ! -d fribidi-1.0.10 ] 
    then
        [ ! -f fribidi-1.0.10.tar.gz ] && curl -L "https://github.com/fribidi/fribidi/archive/v1.0.10.tar.gz" -o fribidi-1.0.10.tar.gz
        tar xzf fribidi-1.0.10.tar.gz
    fi
    cd fribidi-1.0.10
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-static
    make $nproc
    make install

    # libass
    cd ~/ffmpeg_sources
    if [ ! -d libass-0.14.0 ] 
    then
        [ ! -f libass-0.14.0.tar.gz ] && curl -L "https://github.com/libass/libass/archive/0.14.0.tar.gz" -o libass-0.14.0.tar.gz
        tar xzf libass-0.14.0.tar.gz
    fi
    cd libass-0.14.0
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # zvbi
    cd ~/ffmpeg_sources
    if [ ! -d zvbi-0.2.35 ] 
    then
        [ ! -f zvbi-0.2.35.tar.bz2 ] && curl -L "https://downloads.sourceforge.net/zapping/zvbi/zvbi-0.2.35.tar.bz2" -o zvbi-0.2.35.tar.bz2
        tar xjf zvbi-0.2.35.tar.bz2
    fi
    cd zvbi-0.2.35
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-static
    make $nproc
    make install

    # sdl2
    cd ~/ffmpeg_sources
    rm -rf SDL2-2.0.12
    [ ! -f SDL2-2.0.12.tar.gz ] && curl -L "https://www.libsdl.org/release/SDL2-2.0.12.tar.gz" -o SDL2-2.0.12.tar.gz
    tar xzf SDL2-2.0.12.tar.gz
    mkdir -p SDL2-2.0.12/build
    cd SDL2-2.0.12/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX:PATH="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # lame
    cd ~/ffmpeg_sources
    if [ ! -d lame-3.100 ] 
    then
        [ ! -f lame-3.100.tar.gz ] && curl -L "https://downloads.sourceforge.net/lame/lame/lame-3.100.tar.gz" -o lame-3.100.tar.gz
        tar xzf lame-3.100.tar.gz
    fi
    cd lame-3.100
    # uname -a | grep -q 'aarch64'
    if [ "$release" == "arm" ] 
    then
        lame_build_target="--build=arm-linux"
    else
        lame_build_target=""
    fi
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --enable-nasm --disable-shared $lame_build_target
    make $nproc
    make install

    # opus
    cd ~/ffmpeg_sources
    rm -rf opus
    git -C opus pull 2> /dev/null || git clone --depth 1 https://github.com/xiph/opus.git
    cd opus
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # libvpx
    cd ~/ffmpeg_sources
    git -C libvpx pull 2> /dev/null || git clone --depth 1 https://chromium.googlesource.com/webm/libvpx.git
    cd libvpx
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --disable-examples --disable-unit-tests --enable-vp9-highbitdepth --as=yasm --enable-pic
    make $nproc
    make install

    # soxr
    cd ~/ffmpeg_sources
    rm -rf soxr-0.1.3-Source
    [ ! -f soxr-0.1.3-Source.tar.xz ] && curl -L "https://downloads.sourceforge.net/soxr/soxr-0.1.3-Source.tar.xz" -o soxr-0.1.3-Source.tar.xz
    tar xJf soxr-0.1.3-Source.tar.xz
    mkdir -p soxr-0.1.3-Source/build
    cd soxr-0.1.3-Source/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF -DWITH_OPENMP=OFF -DBUILD_TESTS=OFF ..
    make $nproc
    make install

    # vidstab
    cd ~/ffmpeg_sources
    rm -rf vid.stab-1.1.0
    [ ! -f vid.stab-1.1.0.tar.gz ] && curl -L "https://github.com/georgmartius/vid.stab/archive/v1.1.0.tar.gz" -o vid.stab-1.1.0.tar.gz
    tar xzf vid.stab-1.1.0.tar.gz
    mkdir -p vid.stab-1.1.0/build
    cd vid.stab-1.1.0/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX:PATH="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # openjpeg
    cd ~/ffmpeg_sources
    rm -rf openjpeg-2.3.1
    [ ! -f openjpeg-2.3.1.tar.gz ] && curl -L "https://github.com/uclouvain/openjpeg/archive/v2.3.1.tar.gz" -o openjpeg-2.3.1.tar.gz
    tar xzf openjpeg-2.3.1.tar.gz
    mkdir -p openjpeg-2.3.1/build
    cd openjpeg-2.3.1/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # zimg
    cd ~/ffmpeg_sources
    git -C zimg pull 2> /dev/null || git clone --depth 1 https://github.com/sekrit-twc/zimg.git
    cd zimg
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --enable-static  --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # libwebp
    cd ~/ffmpeg_sources
    if [ ! -d libwebp-1.0.0 ] 
    then
        [ ! -f libwebp-1.0.0.tar.gz ] && curl -L "https://github.com/webmproject/libwebp/archive/v1.0.0.tar.gz" -o libwebp-1.0.0.tar.gz
        tar xzf libwebp-1.0.0.tar.gz
    fi
    cd libwebp-1.0.0
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # fdk-aac
    cd ~/ffmpeg_sources
    git -C fdk-aac pull 2> /dev/null || git clone --depth 1 https://github.com/mstorsjo/fdk-aac.git
    cd fdk-aac
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # libogg
    cd ~/ffmpeg_sources
    if [ ! -d ogg-1.3.4 ] 
    then
        [ ! -f ogg-1.3.4.tar.gz ] && curl -L "https://github.com/xiph/ogg/archive/v1.3.4.tar.gz" -o ogg-1.3.4.tar.gz
        tar xzf ogg-1.3.4.tar.gz
    fi
    cd ogg-1.3.4
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # libvorbis
    cd ~/ffmpeg_sources
    if [ ! -d vorbis-1.3.7 ] 
    then
        [ ! -f vorbis-1.3.7.tar.gz ] && curl -L "https://github.com/xiph/vorbis/archive/v1.3.7.tar.gz" -o vorbis-1.3.7.tar.gz
        tar xzf vorbis-1.3.7.tar.gz
    fi
    cd vorbis-1.3.7
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # speex
    cd ~/ffmpeg_sources
    if [ ! -d speex-Speex-1.2.0 ] 
    then
        [ ! -f Speex-1.2.0.tar.gz ] && curl -L "https://github.com/xiph/speex/archive/Speex-1.2.0.tar.gz" -o Speex-1.2.0.tar.gz
        tar xzf Speex-1.2.0.tar.gz
    fi
    cd speex-Speex-1.2.0
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./autogen.sh
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
    make $nproc
    make install

    # gmp
    cd ~/ffmpeg_sources
    if [ ! -d gmp-6.2.0 ] 
    then
        [ ! -f gmp-6.2.0.tar.xz ] && curl -L "https://gmplib.org/download/gmp/gmp-6.2.0.tar.xz" -o gmp-6.2.0.tar.xz
        tar xJf gmp-6.2.0.tar.xz
    fi
    cd gmp-6.2.0
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --with-pic
    make $nproc
    make install

    tls_args=()
    if [ "$tls_option" == "openssl" ] 
    then
        tls_args+=( --enable-openssl )
        # openssl
        cd ~/ffmpeg_sources
        if [ ! -d openssl-OpenSSL_1_1_1h ] 
        then
            [ ! -f OpenSSL_1_1_1h.tar.gz ] && curl -L "https://github.com/openssl/openssl/archive/OpenSSL_1_1_1h.tar.gz" -o OpenSSL_1_1_1h.tar.gz
            tar xzf OpenSSL_1_1_1h.tar.gz
        fi
        cd openssl-OpenSSL_1_1_1h
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./config --prefix="$HOME/ffmpeg_build"
        make $nproc
        make install_sw
    else
        tls_args+=( --enable-gnutls )

        # libtasn1
        cd ~/ffmpeg_sources
        if [ ! -d libtasn1-4.16.0 ] 
        then
            [ ! -f libtasn1-4.16.0.tar.gz ] && curl -L "https://ftp.gnu.org/gnu/libtasn1/libtasn1-4.16.0.tar.gz" -o libtasn1-4.16.0.tar.gz
            tar xzf libtasn1-4.16.0.tar.gz
        fi
        cd libtasn1-4.16.0
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./configure --prefix="$HOME/ffmpeg_build" --disable-shared
        make $nproc
        make install

        # nettle
        cd ~/ffmpeg_sources
        if [ ! -d nettle-3.5 ] 
        then
            [ ! -f nettle-3.5.tar.gz ] && curl -L "https://ftp.gnu.org/gnu/nettle/nettle-3.5.tar.gz" -o nettle-3.5.tar.gz
            tar xzf nettle-3.5.tar.gz
        fi
        cd nettle-3.5
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-pic
        make $nproc
        make install

        # gnutls
        cd ~/ffmpeg_sources
        if [ ! -d gnutls-3.6.15 ] 
        then
            [ ! -f gnutls-3.6.15.tar.xz ] && curl -L "https://www.gnupg.org/ftp/gcrypt/gnutls/v3.6/gnutls-3.6.15.tar.xz" -o gnutls-3.6.15.tar.xz
            tar xJf gnutls-3.6.15.tar.xz
        fi
        cd gnutls-3.6.15
        if [ -f Makefile ] 
        then
            make distclean || true
        fi
        ./configure --prefix="$HOME/ffmpeg_build" --disable-shared --enable-static \
        --with-pic --with-included-libtasn1 --with-included-unistring --without-p11-kit --disable-doc
        make $nproc
        make install
    fi

    # fftw
    cd ~/ffmpeg_sources
    rm -rf fftw-3.3.8
    [ ! -f fftw-3.3.8.tar.gz ] && curl -L "http://www.fftw.org/fftw-3.3.8.tar.gz" -o fftw-3.3.8.tar.gz
    tar xzf fftw-3.3.8.tar.gz
    mkdir -p fftw-3.3.8/build
    cd fftw-3.3.8/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # libsamplerate
    cd ~/ffmpeg_sources
    rm -rf libsamplerate
    git clone https://github.com/libsndfile/libsamplerate.git
    mkdir -p libsamplerate/build
    cd libsamplerate/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # vamp-plugin-sdk
    cd ~/ffmpeg_sources
    git -C vamp-plugin-sdk pull 2> /dev/null || git clone https://github.com/c4dm/vamp-plugin-sdk.git
    cd vamp-plugin-sdk
    if [ -f Makefile ] 
    then
        make distclean || true
    fi
    ./configure --prefix="$HOME/ffmpeg_build"
    make $nproc
    make install

    # rubberband
    cd ~/ffmpeg_sources
    rm -rf rubberband-1.9
    [ ! -f rubberband-1.9.tar.gz ] && curl -L "https://github.com/breakfastquay/rubberband/archive/v1.9.tar.gz" -o rubberband-1.9.tar.gz
    tar xzf rubberband-1.9.tar.gz
    cd rubberband-1.9
    if [ ! -f CMakeLists.txt ] 
    then
        curl -L "https://raw.githubusercontent.com/breakfastquay/rubberband/8e09e4a2a9d54e627d5c80da89a0f4d2cdf8f65d/CMakeLists.txt" -o CMakeLists.txt
    fi
    mkdir build
    cd build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" ..
    make $nproc
    make install
    mkdir -p "$HOME/ffmpeg_build/include/rubberband/"
    cp -f ../rubberband/* "$HOME/ffmpeg_build/include/rubberband/"
    printf '%s' "prefix=$HOME/ffmpeg_build
exec_prefix=\${prefix}
libdir=\${prefix}/lib
includedir=\${prefix}/include

Name: rubberband
Version: 1.9
Description:
Libs: -L\${libdir} -lrubberband
Cflags: -I\${includedir}
" > "$HOME/ffmpeg_build/lib/pkgconfig/rubberband.pc"

    # libsrt
    cd ~/ffmpeg_sources
    rm -rf srt-1.4.2
    [ ! -f srt-1.4.2.tar.gz ] && curl -L "https://github.com/Haivision/srt/archive/v1.4.2.tar.gz" -o srt-1.4.2.tar.gz
    tar xzf srt-1.4.2.tar.gz
    mkdir -p srt-1.4.2/build
    cd srt-1.4.2/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DENABLE_SHARED=OFF ..
    make $nproc
    sed -i 's/-lgcc_s/-lgcc_eh/g' srt.pc
    make install

    # libgme
    cd ~/ffmpeg_sources
    rm -rf game-music-emu-0.6.2
    [ ! -f game-music-emu-0.6.2.tar.xz ] && curl -L "https://bitbucket.org/mpyne/game-music-emu/downloads/game-music-emu-0.6.2.tar.xz" -o game-music-emu-0.6.2.tar.xz
    tar xJf game-music-emu-0.6.2.tar.xz
    mkdir -p game-music-emu-0.6.2/build
    cd game-music-emu-0.6.2/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # aom
    cd ~/ffmpeg_sources
    rm -rf aom
    git clone --depth 1 https://aomedia.googlesource.com/aom
    mkdir -p aom/build
    cd aom/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF -DENABLE_NASM=on ..
    make $nproc
    make install

    # SVT-AV1
    cd ~/ffmpeg_sources
    rm -rf SVT-AV1
    git clone https://github.com/AOMediaCodec/SVT-AV1.git
    mkdir -p SVT-AV1/build
    cd SVT-AV1/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DCMAKE_BUILD_TYPE=Release -DBUILD_DEC=OFF -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # vmaf
    cd ~/ffmpeg_sources
    rm -rf vmaf-1.5.3
    [ ! -f vmaf_v1.5.3.tar.gz ] && curl -L https://github.com/Netflix/vmaf/archive/v1.5.3.tar.gz -o vmaf_v1.5.3.tar.gz
    tar zxf vmaf_v1.5.3.tar.gz
    cd vmaf-1.5.3
    pip3 install meson
    pip3 install Cython
    pip3 install numpy
    meson setup libvmaf/build libvmaf --buildtype=release --default-library=static --prefix="$HOME/ffmpeg_build"
    ninja -vC libvmaf/build install
    cp -f ~/ffmpeg_build/lib/*-linux-gnu/pkgconfig/libvmaf.pc ~/ffmpeg_build/lib/pkgconfig/

    # dav1d
    cd ~/ffmpeg_sources
    rm -rf dav1d
    git clone https://code.videolan.org/videolan/dav1d.git
    cd dav1d
    meson build --buildtype release --default-library static --prefix "$HOME/ffmpeg_build" --libdir lib
    cd build
    meson configure
    ninja
    meson test -v
    ninja install

    # graphite2
    cd ~/ffmpeg_sources
    rm -rf graphite
    git clone https://github.com/silnrsi/graphite.git
    mkdir -p graphite/build
    cd graphite/build
    cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX="$HOME/ffmpeg_build" -DBUILD_SHARED_LIBS=OFF ..
    make $nproc
    make install

    # ffmpeg
    cd ~/ffmpeg_sources
    rm -rf ffmpeg
    curl -L https://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2 -o ffmpeg-snapshot.tar.bz2
    tar xjf ffmpeg-snapshot.tar.bz2

    cd ffmpeg
    curl -L "$FFMPEG_MIRROR_LINK/Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch" -o Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch
    patch -p1 < Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch
    ./configure \
    --prefix="$HOME/ffmpeg_build" \
    --pkg-config-flags="--static" \
    --extra-cflags="-fopenmp -I$HOME/ffmpeg_build/include -I$HOME/ffmpeg_build/include/libxml2" \
    --extra-ldflags="-static -fopenmp -L$HOME/ffmpeg_build/lib" \
    --extra-libs="-lpthread -lfftw3 -lsamplerate -lz -llzma -liconv -lm -lstdc++" \
    --disable-debug \
    --disable-shared \
    --disable-indev=sndio \
    --disable-outdev=sndio \
    --enable-static \
    --enable-gpl \
    --enable-pic \
    --enable-ffplay \
    --enable-version3 \
    --enable-iconv \
    --enable-fontconfig \
    --enable-frei0r \
    --enable-gmp \
    --enable-libgme \
    --enable-gray \
    --enable-libaom \
    --enable-libfribidi \
    --enable-libass \
    --enable-libfdk-aac \
    --enable-libfreetype \
    --enable-libmp3lame \
    --enable-libopencore-amrnb \
    --enable-libopencore-amrwb \
    --enable-libopenjpeg \
    --enable-libsoxr \
    --enable-libspeex \
    --enable-libvorbis \
    --enable-libopus \
    --enable-libtheora \
    --enable-libvidstab \
    --enable-libvo-amrwbenc \
    --enable-libvpx \
    --enable-libwebp \
    --enable-libx264 \
    --enable-libx265 \
    --enable-libsvtav1 \
    --enable-libdav1d \
    --enable-libxvid \
    --enable-libzvbi \
    --enable-libzimg \
    --enable-nonfree \
    --enable-librubberband \
    --enable-libsrt \
    --enable-libvmaf \
    --enable-libxml2 ${tls_args[@]+"${tls_args[@]}"}
    make $nproc
    #make install
    #hash -r
    mv ffmpeg /usr/local/bin/ffmpeg_c
    Println "`eval_gettext \"\\\$info FFmpeg 编译成功\"`\n"
}

JQInstall()
{
    if [[ -x $(command -v armbian-config) ]] 
    then
        if ! /usr/local/bin/jq -V > /dev/null 2>&1 
        then
            Println "`eval_gettext \"\\\$info 开始下载/安装 JQ...\"`"
            cd ~
            git clone https://github.com/stedolan/jq.git > /dev/null
            cd jq
            apt-get -y install flex bison libtool make automake autoconf > /dev/null
            git submodule update --init > /dev/null
            autoreconf -fi > /dev/null
            ./configure --with-oniguruma=builtin > /dev/null
            nproc="-j$(nproc 2> /dev/null)" || nproc=""
            make $nproc > /dev/null
            make install > /dev/null
        fi
        if [ "$JQ_FILE" != "/usr/local/bin/jq" ] 
        then
            rm -f "$JQ_FILE"
            ln -sf /usr/local/bin/jq "$JQ_FILE"
        fi
        Println "`eval_gettext \"\\\$info JQ 安装完成\"`"
    elif [ ! -e "$JQ_FILE" ] || ! $JQ_FILE -V > /dev/null 2>&1 
    then
        Println "`eval_gettext \"\\\$info 开始下载/安装 JQ...\"`"
        #experimental# grep -Po '"tag_name": "jq-\K.*?(?=")'
        if jq_ver=$(curl -s -m 10 "$FFMPEG_MIRROR_LINK/jq.json" |  grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
        then
            if curl -L "$FFMPEG_MIRROR_LINK/$jq_ver/jq-linux$release_bit" -o "$JQ_FILE"
            then
                chmod +x "$JQ_FILE"
                Println "`eval_gettext \"\\\$info JQ 安装完成\"`"
            else
                rm -f "$JQ_FILE"
                Println "`eval_gettext \"\\\$error 下载 JQ 失败, 请重试 !\"`" && exit 1
            fi
        else
            Println "`eval_gettext \"\\\$error 暂时无法连接服务器, 请稍后再试 !\"`" && exit 1
        fi
    else
        Println "`eval_gettext \"\\\$info JQ 已安装\"`"
    fi
}

Install()
{
    if [ -e "$IPTV_ROOT" ]
    then
        Println "`eval_gettext \"\\\$error 目录已存在, 请先卸载...\"`\n" && exit 1
    else
        DepsCheck

        #if grep -q '\--show-progress' < <(wget --help)
        #then
        #    _PROGRESS_OPT="--show-progress"
        #else
        #    _PROGRESS_OPT=""
        #fi

        mkdir -p "$IPTV_ROOT"

        FFmpegInstall
        JQInstall

        default=$(
        $JQ_FILE -n --arg proxy '' --arg xc_proxy '' \
            --arg user_agent "$USER_AGENT_TV" \
            --arg headers '' --arg cookies 'stb_lang=en; timezone=Europe/Amsterdam' \
            --arg playlist_name '' --arg seg_dir_name '' \
            --arg seg_name '' --arg seg_length 6 \
            --arg seg_count 5 --arg video_codec "libx264" \
            --arg audio_codec "aac" --arg video_audio_shift '' \
            --arg txt_format '' --arg draw_text '' \
            --arg quality '' \
            --arg bitrates "900-1280x720" --arg const "no" \
            --arg encrypt "no" --arg encrypt_session "no" \
            --arg keyinfo_name '' --arg key_name '' \
            --arg input_flags "-copy_unknown -reconnect 1 -reconnect_at_eof 1 -reconnect_streamed 1 -reconnect_delay_max 2000 -rw_timeout 10000000 -y -nostats -nostdin -hide_banner -loglevel error" \
            --arg output_flags "-g 50 -sc_threshold 0 -sn -preset superfast -pix_fmt yuv420p -profile:v main" --arg sync "yes" \
            --arg sync_file '' --arg sync_index "data:0:channels" \
            --arg sync_pairs "chnl_name:channel_name,chnl_id:output_dir_name,chnl_pid:pid,chnl_cat=港澳台,url=http://xxx.com/live" --arg schedule_file '' \
            --arg flv_delay_seconds 20 --arg flv_restart_nums 20 \
            --arg hls_delay_seconds 120 --arg hls_min_bitrates 500 \
            --arg hls_max_seg_size 5 --arg hls_restart_nums 20 \
            --arg hls_key_period 30 --arg anti_ddos_port 80 \
            --arg anti_ddos_syn_flood "no" --arg anti_ddos_syn_flood_delay_seconds 3 \
            --arg anti_ddos_syn_flood_seconds 3600 --arg anti_ddos "no" \
            --arg anti_ddos_seconds 120 --arg anti_ddos_level 6 \
            --arg anti_leech "no" --arg anti_leech_restart_nums 3 \
            --arg anti_leech_restart_flv_changes "yes" --arg anti_leech_restart_hls_changes "yes" \
            --arg recheck_period 0 --arg version "$sh_ver" \
            '{
                proxy: $proxy,
                xc_proxy: $xc_proxy,
                user_agent: $user_agent,
                headers: $headers,
                cookies: $cookies,
                playlist_name: $playlist_name,
                seg_dir_name: $seg_dir_name,
                seg_name: $seg_name,
                seg_length: $seg_length | tonumber,
                seg_count: $seg_count | tonumber,
                video_codec: $video_codec,
                audio_codec: $audio_codec,
                video_audio_shift: $video_audio_shift,
                txt_format: $txt_format,
                draw_text: $draw_text,
                quality: $quality,
                bitrates: $bitrates,
                const: $const,
                encrypt: $encrypt,
                encrypt_session: $encrypt_session,
                keyinfo_name: $keyinfo_name,
                key_name: $key_name,
                input_flags: $input_flags,
                output_flags: $output_flags,
                sync: $sync,
                sync_file: $sync_file,
                sync_index: $sync_index,
                sync_pairs: $sync_pairs,
                schedule_file: $schedule_file,
                flv_delay_seconds: $flv_delay_seconds | tonumber,
                flv_restart_nums: $flv_restart_nums | tonumber,
                hls_delay_seconds: $hls_delay_seconds | tonumber,
                hls_min_bitrates: $hls_min_bitrates | tonumber,
                hls_max_seg_size: $hls_max_seg_size | tonumber,
                hls_restart_nums: $hls_restart_nums | tonumber,
                hls_key_period: $hls_key_period | tonumber,
                anti_ddos_port: $anti_ddos_port,
                anti_ddos_syn_flood: $anti_ddos_syn_flood,
                anti_ddos_syn_flood_delay_seconds: $anti_ddos_syn_flood_delay_seconds | tonumber,
                anti_ddos_syn_flood_seconds: $anti_ddos_syn_flood_seconds | tonumber,
                anti_ddos: $anti_ddos,
                anti_ddos_seconds: $anti_ddos_seconds | tonumber,
                anti_ddos_level: $anti_ddos_level | tonumber,
                anti_leech: $anti_leech,
                anti_leech_restart_nums: $anti_leech_restart_nums | tonumber,
                anti_leech_restart_flv_changes: $anti_leech_restart_flv_changes,
                anti_leech_restart_hls_changes: $anti_leech_restart_hls_changes,
                recheck_period: $recheck_period | tonumber,
                version: $version
            }'
        )

        $JQ_FILE -n --argjson default "$default" \
        '{
            default: $default,
            channels: []
        }' > "$CHANNELS_FILE"

        ln -sf "$IPTV_ROOT"/ffmpeg-git-*/ff* /usr/local/bin/
        Println "`eval_gettext \"\\\$info 安装完成\"`\n"
    fi
}

Uninstall()
{
    [ ! -d "$IPTV_ROOT" ] && Println "`eval_gettext \"\\\$error 尚未安装, 请检查 !\"`\n" && exit 1

    echo
    AskIfContinue n "`gettext \"确定要 卸载此脚本以及产生的全部文件\"`"

    MonitorStop
    VipDisable
    CloudflareDisableWorkersMonitor
    if [ -e "$NODE_ROOT/index.js" ] 
    then
        pm2 stop 0 2> /dev/null || true
    fi
    if crontab -l | grep -q "$LOGROTATE_CONFIG" 2> /dev/null
    then
        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        sed -i "/${LOGROTATE_CONFIG//\//\\/}/d" "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 已停止 logrotate\n"
    fi
    i18nGetMsg get_channel
    while IFS= read -r chnl_pid
    do
        GetChannel
        if [ "$chnl_flv_status" == "on" ] 
        then
            kind="flv"
            StopChannel
        elif [ "$chnl_status" == "on" ]
        then
            kind=""
            StopChannel
        fi
    done < <($JQ_FILE '.channels[].pid' $CHANNELS_FILE)
    StopChannelsForce 2> /dev/null || true
    rm -rf "${IPTV_ROOT:-notfound}"
    Println "`eval_gettext \"\\\$info 卸载完成 !\"`\n"
}

Update()
{
    [ ! -d "$IPTV_ROOT" ] && Println "`eval_gettext \"\\\$error 尚未安装, 请检查 !\"`\n" && exit 1

    while IFS= read -r line 
    do
        if [[ $line == *"built on "* ]] 
        then
            line=${line#*built on }
            git_date=${line%<*}
            break
        fi
    done < <(curl -s -Lm 10 "$FFMPEG_MIRROR_LINK/index.html" 2> /dev/null)

    if [ -z "${git_date:-}" ] 
    then
        Println "`eval_gettext \"\\\$error 暂时无法连接服务器, 请稍后再试 !\"`\n"
        exit 1
    fi

    if [ -s "$IPTV_ROOT/monitor.pid" ] || [ -s "$IPTV_ROOT/antiddos.pid" ]
    then
        echo
        AskIfContinue y "`gettext \"需要先关闭监控, 是否继续\"`"
        MonitorStop
    fi

    FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
    if [[ ${FFMPEG_ROOT##*/} == *"${git_date:-20200101}"* ]] 
    then
        echo
        yn_options=( "$i18n_no" "$i18n_yes" )
        inquirer list_input "`gettext \"FFmpeg 已经是最新, 是否重装\"`" yn_options reinstall_ffmpeg_yn
        if [[ $reinstall_ffmpeg_yn == "$i18n_no" ]]
        then
            reinstall_ffmpeg_yn="N"
        else
            reinstall_ffmpeg_yn="Y"
        fi
    else
        reinstall_ffmpeg_yn="Y"
    fi

    ReleaseCheck

    if [[ ${reinstall_ffmpeg_yn:-N} == [Yy] ]] 
    then
        rm -rf "$IPTV_ROOT"/ffmpeg-git-*/
        Spinner "`gettext \"更新 FFmpeg\"`" FFmpegInstall
    fi

    JQInstall > /dev/null

    ShFileUpdate

    ln -sf "$IPTV_ROOT"/ffmpeg-git-*/ff* /usr/local/bin/
    Println "`eval_gettext \"脚本已更新为最新版本 [ \\\${green}\\\$sh_new_ver\\\${normal} ] ! (输入: tv 使用)\"`\n" && exit 0
}

YoutubeDlInstall()
{
    Println "`eval_gettext \"\\\$info 安装 youtube-dl...\"`\n"
    curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dl
    if [ ! -s /usr/local/bin/youtube-dl ] 
    then
        curl -L https://dl.netsyms.net/programs/youtube-dl/latest/youtube-dl -o /usr/local/bin/youtube-dl
    fi
    chmod a+rx /usr/local/bin/youtube-dl
}

OpensslInstall()
{
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    ReleaseCheck
    if [ "$release" == "rpm" ] 
    then
        yum -y install openssl openssl-devel >/dev/null 2>&1
    else
        apt-get -y install openssl libssl-dev >/dev/null 2>&1
    fi
    kill $progress_pid
    trap - EXIT
    echo -n "...100%" && Println "`eval_gettext \"\\\$info openssl 安装完成\"`"
}

ImageMagickInstall()
{
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    rm -f "$IPTV_ROOT/magick"
    ReleaseCheck
    if [ "$release" == "rpm" ] 
    then
        yum -y install ImageMagick >/dev/null 2>&1
    else
        apt-get -y install imagemagick >/dev/null 2>&1
    fi
    kill $progress_pid
    trap - EXIT
    echo -n "...100%"
    Println "\n`eval_gettext \"\\\$info magick 安装完成\"`\n"
}

Pdf2htmlInstall()
{
    ReleaseCheck
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    if [ "$release" == "rpm" ] 
    then
        yum install cmake gcc gnu-getopt java-1.8.0-openjdk libpng-devel fontforge-devel cairo-devel poppler-devel libspiro-devel freetype-devel libtiff-devel openjpeg libxml2-devel giflibgiflib-devel libjpeg-turbo-devel libuninameslist-devel pango-devel make gcc-c++ >/dev/null 2>&1
    else
        apt-get -y install libpoppler-private-dev libpoppler-dev libfontforge-dev pkg-config libopenjp2-7-dev libjpeg-dev libtiff5-dev libpng-dev libfreetype6-dev libgif-dev libgtk-3-dev libxml2-dev libpango1.0-dev libcairo2-dev libspiro-dev libuninameslist-dev python3-dev ninja-build cmake build-essential >/dev/null 2>&1
    fi

    echo -n "...40%..."

    while IFS= read -r line
    do
        if [[ $line == *"latest stable release is"* ]] 
        then
            line=${line#*<a href=\"}
            poppler_name=${line%%.tar.xz*}
        elif [[ $line == *"poppler encoding data"* ]] 
        then
            line=${line#*<a href=\"}
            poppler_data_name=${line%%.tar.gz*}
            break
        fi
    done < <(wget --timeout=10 --tries=3 --no-check-certificate "https://poppler.freedesktop.org/" -qO-)

    cd ~
    if [ ! -e "./$poppler_data_name" ] 
    then
        wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/$poppler_data_name.tar.gz" -qO "$poppler_data_name.tar.gz"
        tar xzf "$poppler_data_name.tar.gz"
    fi

    cd "$poppler_data_name/"
    make install >/dev/null 2>&1

    echo -n "...50%..."

    poppler_name="poppler-0.81.0"

    cd ~
    if [ ! -e "./$poppler_name" ] 
    then
        wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/$poppler_name.tar.xz" -qO "$poppler_name.tar.xz"
        tar xJf "$poppler_name.tar.xz" >/dev/null
    fi

    cd "$poppler_name/"
    mkdir -p build
    cd build
    cmake -DENABLE_UNSTABLE_API_ABI_HEADERS=ON .. >/dev/null 2>&1
    make >/dev/null 2>&1
    make install >/dev/null 2>&1

    echo -n "...70%..."

    cd ~
    if [ ! -e "./fontforge-20190413" ] 
    then
        wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/fontforge-20190413.tar.gz" -qO "fontforge-20190413.tar.gz"
        tar xzf "fontforge-20190413.tar.gz"
    fi

    cd "fontforge-20190413/"
    ./bootstrap >/dev/null 2>&1
    ./configure >/dev/null 2>&1
    make >/dev/null 2>&1
    make install >/dev/null 2>&1
    echo -n "...90%..."

    cd ~
    if [ ! -e "./pdf2htmlEX-0.18.7-poppler-0.81.0" ] 
    then
        wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/pdf2htmlEX-0.18.7-poppler-0.81.0.zip" -qO "pdf2htmlEX-0.18.7-poppler-0.81.0.zip"
        unzip "pdf2htmlEX-0.18.7-poppler-0.81.0.zip" >/dev/null 2>&1
    fi

    cd "pdf2htmlEX-0.18.7-poppler-0.81.0/"
    ./dobuild >/dev/null 2>&1
    cd build
    make install >/dev/null 2>&1

    kill $progress_pid
    trap - EXIT
    echo -n "...100%" && echo

    if grep -q "profile.d" < "/etc/profile"
    then
        echo 'export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig' >> /etc/profile.d/pdf2htmlEX
        echo 'export LD_LIBRARY_PATH=/usr/local/lib:${LD_LIBRARY_PATH:-}' >> /etc/profile.d/pdf2htmlEX
        # shellcheck source=/dev/null
        source /etc/profile.d/pdf2htmlEX &>/dev/null
    else
        echo 'export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig' >> /etc/profile
        echo 'export LD_LIBRARY_PATH=/usr/local/lib:${LD_LIBRARY_PATH:-}' >> /etc/profile
    fi
}

PostfixInstall()
{
    if [ "$release" == "rpm" ] 
    then
        yum -y install postfix > /dev/null
    else
        DEBIAN_FRONTEND=noninteractive apt-get -y install postfix > /dev/null
    fi
}

FilterString()
{
    global_options=()
    global_flags=( 
        cpuflags y n filter_threads stats stats_period progress debug_ts qphist benchmark 
        benchmark_all timelimit dump hex filter_complex filter_complex_threads lavfi
        filter_complex_script sdp_file abort_on max_error_rate xerror auto_conversion_filters
        nostats nostdin hide_banner loglevel
    )

    for var in "${@}"
    do
        #var_new=${!var//[\^\`]/-}
        var_new=${!var}
        if [ "$var" == "input_flags" ] || [ "$var" == "output_flags" ] || [ "$var" == "chnl_input_flags" ] || [ "$var" == "chnl_output_flags" ]
        then
            var_parse=$var_new
            if [ -n "$var_parse" ] 
            then
                for global_flag in "${global_flags[@]}"
                do
                    if [[ $var_parse =~ (.*)"-$global_flag"$ ]] 
                    then
                        global_options+=("-$global_flag")
                        var_parse="${BASH_REMATCH[1]}"
                    elif [[ $var_parse =~ (.*)"-$global_flag "([^ -]*)(.*) ]] 
                    then
                        global_options+=("-$global_flag")
                        [ -n "${BASH_REMATCH[2]}" ] && global_options+=("${BASH_REMATCH[2]}")
                        var_parse="${BASH_REMATCH[1]}${BASH_REMATCH[3]}"
                    fi
                done
            fi
            read -r ${var}_command <<< "$var_parse"
        fi
        read -r ${var?} <<< "$var_new"
    done
}

RandStr()
{
    str_size=8
    str_array=(
        q w e r t y u i o p a s d f g h j k l z x c v b n m Q W E R T Y U I O P A S D
F G H J K L Z X C V B N M
    )
    str_array_size=${#str_array[*]}
    str_len=0
    rand_str=""
    while [[ $str_len -lt $str_size ]]
    do
        str_index=$((RANDOM%str_array_size))
        rand_str="$rand_str${str_array[str_index]}"
        str_len=$((str_len+1))
    done
    echo "$rand_str"
}

RandOutputDirName()
{
    while :;do
        output_dir_name=$(RandStr)
        if [[ -z $($JQ_FILE '.channels[] | select(.output_dir_name=="'"$output_dir_name"'")' "$CHANNELS_FILE") ]]
        then
            echo "$output_dir_name"
            break
        fi
    done
}

RandPlaylistName()
{
    while :;do
        playlist_name=$(RandStr)
        if [[ -z $($JQ_FILE '.channels[] | select(.playlist_name=="'"$playlist_name"'")' "$CHANNELS_FILE") ]]
        then
            echo "$playlist_name"
            break
        fi
    done
}

RandSegDirName()
{
    while :;do
        seg_dir_name=$(RandStr)
        if [[ -z $($JQ_FILE '.channels[] | select(.seg_dir_name=="'"$seg_dir_name"'")' "$CHANNELS_FILE") ]]
        then
            echo "$seg_dir_name"
            break
        fi
    done
}

# printf %s "$1" | jq -s -R -r @uri
Urlencode() {
    local LC_ALL='' LANG=C i c e=''
    for ((i=0;i<${#1};i++))
    do
        c=${1:$i:1}
        [[ $c =~ [a-zA-Z0-9\.\~\_\-] ]] || printf -v c '%%%02x' "'$c"
        e+="$c"
    done
    echo "$e"
}

UrlencodeUpper() {
    local LC_ALL='' LANG=C i c e=''
    for ((i=0;i<${#1};i++))
    do
        c=${1:$i:1}
        [[ $c =~ [a-zA-Z0-9\.\~\_\-] ]] || printf -v c '%%%02X' "'$c"
        e+="$c"
    done
    echo "$e"
}

GetServerIp()
{
    ip=$(dig +short myip.opendns.com @resolver1.opendns.com) || true
    [ -z "$ip" ] && ip=$(curl -s whatismyip.akamai.com)
    [ -z "$ip" ] && ip=$(curl -s ipv4.icanhazip.com)
    [ -z "$ip" ] && ip=$(curl -s api.ip.sb/ip)
    [ -z "$ip" ] && ip=$(curl -s ipinfo.io/ip)
    echo "$ip"
}

GetFreePort() {
    if [ -n "${1:-}" ] && [ -n "${2:-}" ]
    then
        lport=$1
        uport=$2
    else
        read lport uport < /proc/sys/net/ipv4/ip_local_port_range
    fi

    while true
    do
        candidate=$((lport+RANDOM%(uport-lport)))
        if ! ( echo -n "" >/dev/tcp/127.0.0.1/"$candidate" )  >/dev/null 2>&1
        then
            echo "$candidate"
            break
        fi
    done
}

GetRandomMac()
{
    echo $RANDOM|md5sum|sed 's/../&:/g'|cut -c 1-17
}

PrepTerm()
{
    unset term_child_pid
    unset term_kill_needed
    unset term_signal
    trap 'HandleTerm' TERM
}

HandleTerm()
{
    if [ -n "${term_child_pid:-}" ]
    then
        if [ "${pkill:-0}" -eq 1 ] 
        then
            pkill -TERM -P "$term_child_pid" 2> /dev/null || true
        elif [ "${force_exit:-0}" -eq 1 ] 
        then
            kill -9 "$term_child_pid" 2> /dev/null || true
        else
            kill -TERM "$term_child_pid" 2> /dev/null || true
        fi
    else
        term_kill_needed=1
    fi
}

WaitTerm()
{
    term_child_pid=$!
    if [ "${term_kill_needed:-0}" -eq 1 ]
    then
        if [ "${pkill:-0}" -eq 1 ] 
        then
            pkill -TERM -P "$term_child_pid" 2> /dev/null || true
        elif [ "${force_exit:-0}" -eq 1 ] 
        then
            kill -9 "$term_child_pid" 2> /dev/null || true
        else
            kill -TERM "$term_child_pid" 2> /dev/null || true
        fi
    fi
    wait $term_child_pid 2> /dev/null || term_signal=1
    trap - TERM
    wait $term_child_pid 2> /dev/null || true
    if [ "${term_signal:-0}" -eq 1 ] 
    then
        rm -rf "${delete_on_term:-notfound}"
        exit 1
    fi
}

JQ()
{
    FILE=$2
    [ ! -d "${MONITOR_LOG%/*}" ] && MONITOR_LOG="$HOME/monitor.log"

    if TMP_FILE=$(mktemp -q) 
    then
        chmod +r "$TMP_FILE"
    else
        printf -v TMP_FILE "${FILE}_%s" "$BASHPID"
    fi

    trap 'rm -f $TMP_FILE"' EXIT

    {
        flock -x 200 || { MonitorError "`eval_gettext \"\\\$FILE JQ fd 200 失败\"`"; exit 1; }
        case $1 in
            "add") 
                if [ -n "${jq_path:-}" ] 
                then
                    if [ "${4:-}" == "pre" ] 
                    then
                        $JQ_FILE --argjson path "$jq_path" --argjson value "$3" 'getpath($path) |= [$value] + .' "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                    else
                        $JQ_FILE --argjson path "$jq_path" --argjson value "$3" 'getpath($path) += [$value]' "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                    fi
                    jq_path=""
                else
                    $JQ_FILE --arg index "$3" --argjson value "$4" '.[$index] += $value' "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                fi
            ;;
            "update") 
                if [ -n "${jq_path:-}" ] 
                then
                    if [ "${4:-}" == "number" ] 
                    then
                        $JQ_FILE --argjson path "$jq_path" --arg value "$3" 'getpath($path) = ($value | tonumber)' "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                    else
                        $JQ_FILE --argjson path "$jq_path" --arg value "$3" 'getpath($path) = $value' "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                    fi
                    jq_path=""
                else
                    $JQ_FILE "$3" "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                fi
            ;;
            "replace") 
                if [ -n "${jq_path:-}" ] 
                then
                    $JQ_FILE --argjson path "$jq_path" --argjson value "$3" 'getpath($path) = $value' "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                    jq_path=""
                else
                    $JQ_FILE --arg index "$3" --argjson value "$4" '.[$index] = $value' "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                fi
            ;;
            "delete") 
                if [ -n "${jq_path:-}" ] 
                then
                    if [ -z "${3:-}" ] 
                    then
                        $JQ_FILE --argjson path "$jq_path" 'del(getpath($path))' "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                    elif [ -z "${4:-}" ] 
                    then
                        $JQ_FILE --argjson path "$jq_path" --arg index "$3" 'del(getpath($path)[$index|tonumber])' "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                    else
                        $JQ_FILE --argjson path "$jq_path" 'del(getpath($path)[] | select(.'"$3"'=='"$4"'))' "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                    fi
                    jq_path=""
                else
                    $JQ_FILE --arg index "$3" 'del(.[$index][] | select(.pid=='"$4"'))' "$FILE" > "$TMP_FILE" 2>> "$MONITOR_LOG"
                fi
            ;;
        esac

        if [ ! -s "$TMP_FILE" ] 
        then
            printf 'JQ ERROR!! action: %s, file: %s, tmp_file: %s, index: %s, other: %s' "$1" "$FILE" "$TMP_FILE" "$3" "${4:-none}" >> "$MONITOR_LOG"
        else
            mv "$TMP_FILE" "$FILE"
        fi
    } 200>"$FILE.lock"

    trap - EXIT
}

JQs()
{
    case $1 in
        "get") 
            read -r $3 < <($JQ_FILE -c --argjson path "$jq_path" 'getpath($path)' <<< "${!2}")
            jq_path=""
        ;;
        "add") 
            if [ "${4:-}" == "pre" ] 
            then
                read -r $2 < <($JQ_FILE -c --argjson path "${jq_path:-[]}" --argjson value "$3" 'getpath($path) |= [$value] + .' <<< "${!2}")
            else
                read -r $2 < <($JQ_FILE -c --argjson path "${jq_path:-[]}" --argjson value "$3" 'getpath($path) += [$value]' <<< "${!2}")
            fi
            jq_path=""
        ;;
        "update") 
            if [ "${4:-}" == "number" ] 
            then
                read -r $2 < <($JQ_FILE -c --argjson path "$jq_path" --arg value "$3" 'getpath($path) = ($value | tonumber)' <<< "${!2}")
            else
                read -r $2 < <($JQ_FILE -c --argjson path "$jq_path" --arg value "$3" 'getpath($path) = $value' <<< "${!2}")
            fi
            jq_path=""
        ;;
        "replace") 
            read -r $2 < <($JQ_FILE -c --argjson path "$jq_path" --argjson value "$3" 'getpath($path) = $value' <<< "${!2}")
            jq_path=""
        ;;
        "delete") 
            if [ -z "${3:-}" ] 
            then
                read -r $2 < <($JQ_FILE -c --argjson path "$jq_path" 'del(getpath($path))' <<< "${!2}")
            else
                read -r $2 < <($JQ_FILE -c --argjson path "$jq_path" --arg index "$3" 'del(getpath($path)[$index|tonumber])' <<< "${!2}")
            fi
            jq_path=""
        ;;
        "merge")
            read -r $2 < <($JQ_FILE -c -s '
            def merge(a;b):
                reduce b[] as $item (a;
                reduce ($item | keys_unsorted[]) as $key (.;
                $item[$key] as $val | ($val | type) as $type | .[$key] = if ($type == "object") then
                    merge({}; [if .[$key] == null then {} else .[$key] end, $val])
                elif ($type == "array") then
                    (.[$key] + $val | unique)
                else
                    $val
                end)
                );
            merge({}; .)' <<< "${!2} $3")
        ;;
        "flat")
            if [[ $2 =~ ^/ ]] 
            then
                jq_input=$(< $2)
            else
                jq_input="$2"
            fi

            $JQ_FILE --arg d1 "$5" --arg d2 "${6:-$5}" --arg d3 "${7:-$5}" --arg d4 "${8:-$5}" --arg d5 "${9:-$5}" --arg d6 "${10:-$5}" -r -c -s '
            def flat(a;b;c;d;e;f;g):
                (a[0]| type) as $type | if ($type == "object") then
                    ([a[] | keys_unsorted[]] | unique) as $keys | reduce a[] as $item ({};
                    reduce($keys[]) as $key (.;
                    $item[$key] as $val | ($val | type) as $type | (.[$key]) as $val2 | ($val2 | type) as $type2 | .[$key] = 
                        if ($type == "object") then
                            if ($type2 == "object") then
                                flat([$val2,$val];c;d;e;f;g;b)
                            elif ($val2) then
                                if ($val == {}) then
                                    $val2 + c
                                else
                                    (reduce($val2 | split(c)[]) as $item2 ([]; 
                                        . + [{}]
                                    )| if .== [] then [{}] else . end) as $x |
                                    flat($x + [$val];b;c;d;e;f;g)
                                end
                            elif ($val == {}) then
                                ""
                            else
                                flat([$val];b;c;d;e;f;g)
                            end
                        elif ($type == "array") then
                            flat($val;b;c;d;e;f;g) as $val3 | 
                            if ($type2 == "object") then
                                flat([$val2,($val3|if .== "" then {} else . end)];c;d;e;f;g;b)
                            elif ($val2) then
                                if ($val3 == {}) then
                                    $val2 + c
                                elif ($val3 | type == "object") then
                                    (reduce($val2 | split(c)[]) as $item2 ([]; 
                                        . + [{}]
                                    )| if .== [] then [{}] else . end) as $x |
                                    flat($x + [$val3];c;d;e;f;g;b)
                                else
                                    $val2 + c + $val3
                                end
                            elif ($val3 == {}) then
                                ""
                            else
                                $val3
                            end
                        elif ($type == "null") then
                            if ($type2 == "object") then
                                flat([$val2,{}];c;d;e;f;g;b)
                            elif ($val2) then
                                $val2 + c
                            else
                                ""
                            end
                        else
                            if ($val2) then
                                $val2 + c + ($val | tostring)
                            else
                                ($val | tostring)
                            end
                        end
                    ))
                elif ($type == "array") then
                    flat([flat(a[];b;c;d;e;f;g)];b;c;d;e;f;g)
                else
                    a|join(b)
                end;
            flat('"${3:-.}"';$d1;$d2;$d3;$d4;$d5;$d6)|'"$4"'' <<< "$jq_input"
        ;;
        "flat_c")
            if [[ $2 =~ ^/ ]] 
            then
                jq_input=$(< $2)
            else
                jq_input="$2"
            fi

            $JQ_FILE --arg d1 "$5" --arg d2 "${6:-$5}" --arg d3 "${7:-$5}" --arg d4 "${8:-$5}" --arg d5 "${9:-$5}" --arg d6 "${10:-$5}" -r -c -s '
            def flat(a;x;b;c;d;e;f;g):
                a as $a | (a[0]| type) as $type | if ($type == "object") then
                    ([a[] | keys_unsorted[]] | unique) as $keys | 

                    (reduce a[] as $item ({};
                        reduce($keys[]) as $key (.; ($item[$key]) as $val | ($val | type) as $type | (.[$key]) as $val2 | .[$key] = 
                            if ($val and $val != [] and $val != {}) then
                                if ($val2 and ($val2|.[-1:]) == [""]) then
                                    $val2
                                else
                                    ($val2 // []) + [""]
                                end
                            else
                                if ($val2) then
                                    if ($val2|.[-1:] == [""]) then
                                        $val2
                                    else
                                        $val2 + [{}]
                                    end
                                else
                                    [{}]
                                end
                            end
                        )
                    )) as $blank | (reduce($keys[]) as $key ({};
                        .[$key] = ($blank[$key] | .[:-1])
                    )) as $blank |

                    reduce a[] as $item ({};
                    reduce($keys[]) as $key (.;
                    $blank[$key] as $x | $item[$key] as $val | ($val | type) as $type | (.[$key]) as $val2 |($val2 | type) as $type2 | 
                    .[$key] = 
                        if ($type == "object") then
                            if ($val2) then
                                if ($type2 == "object") then
                                    if (x == [""]) then
                                        flat([$val2,$val];$x + [1];c;d;e;f;g;b)
                                    else
                                        flat([$val2,flat([$val];x;b;c;d;e;f;g)];x;c;d;e;f;g;b)
                                    end
                                elif ($val == {}) then
                                    $val2 + c
                                else
                                    if (x|.[-1:] == [1]) then
                                        flat(($x + (x | .[:-1]) + [$val]);$x + x;c;d;e;f;g;b)
                                    else
                                        flat(($x + [$val]);[];c;d;e;f;g;b)
                                    end
                                end
                            else
                                if ($val == {}) then
                                    ""
                                elif (x == [""]) then
                                    $val
                                else
                                    flat([$val];[];b;c;d;e;f;g)
                                end
                            end
                        elif ($type == "array") then
                            if ($val[0] | type == "object") then
                                if ($val2) then
                                    if ($type2 == "object") then
                                        $val2
                                    else
                                        ($a|index($item)) as $index | 
                                        if ($a|length - $index == 1) then
                                            flat(($x + [flat($val;$x;b;c;d;e;f;g)]);[];c;d;e;f;g;b)
                                        else
                                            flat(reduce($a|.[$index:]|.[]) as $obj ($x;
                                                if ($obj[$key] and $obj[$key] != []) then
                                                    . + [flat($obj[$key];[];b;c;d;e;f;g)]
                                                else
                                                    . + [{}]
                                                end
                                            );[""];c;d;e;f;g;b)
                                        end
                                    end
                                else
                                    ($a|index($item)) as $index | 
                                    if ($a|length - $index == 1) then
                                        flat($val;$x;b;c;d;e;f;g)
                                    else
                                        flat(reduce($a|.[$index:]|.[]) as $obj ([];
                                            if ($obj[$key] and $obj[$key] != []) then
                                                . + [flat($obj[$key];[];b;c;d;e;f;g)]
                                            else
                                                . + [{}]
                                            end
                                        );[""];c;d;e;f;g;b)
                                    end
                                end
                            else
                                if ($val2) then
                                    if ($type2 == "object") then
                                        $val2
                                    else
                                        $val2 + c + flat($val;$x;b;c;d;e;f;g)
                                    end
                                else
                                    flat($val;$x;b;c;d;e;f;g)
                                end
                            end
                        elif ($type == "null") then
                            if ($type2 == "object") then
                                if (x != [""] and (x|.[-1:] != [1])) then
                                    $val2
                                else
                                    flat([$val2,{}];x;c;d;e;f;g;b)
                                end
                            elif ($val2) then
                                $val2 + c
                            else
                                ""
                            end
                        else
                            if ($val2) then
                                $val2 + c + ($val | tostring)
                            else
                                ($val | tostring)
                            end
                        end
                    ))
                elif ($type == "array") then
                    flat([flat(a[];x;b;c;d;e;f;g)];x;b;c;d;e;f;g)
                else
                    a|join(b)
                end;
            flat('"${3:-.}"';[];$d1;$d2;$d3;$d4;$d5;$d6)|'"$4"'' <<< "$jq_input"
        ;;
    esac
}

SyncFile()
{
    case $action in
        "skip")
            action=""
            return
        ;;      
        "start"|"stop")
            GetDefault
        ;;
        "add")
            chnl_pid=$pid
            GetChannel
        ;;
        *)
            Println "$error $action ???" && exit 1
        ;;
    esac

    chnl_sync_file=${chnl_sync_file:-$d_sync_file}
    chnl_sync_index=${chnl_sync_index:-$d_sync_index}
    chnl_sync_pairs=${chnl_sync_pairs:-$d_sync_pairs}

    if [ "$chnl_sync_yn" == "yes" ] && [ -n "$chnl_sync_file" ] && [ -n "$chnl_sync_index" ] && [ -n "$chnl_sync_pairs" ]
    then
        IFS=" " read -ra chnl_sync_files <<< "$chnl_sync_file"
        IFS=" " read -ra chnl_sync_indices <<< "$chnl_sync_index"
        chnl_pid_key=${chnl_sync_pairs%%:pid*}
        chnl_pid_key=${chnl_pid_key##*,}
        sync_count=${#chnl_sync_files[@]}
        [ "${#chnl_sync_indices[@]}" -lt "$sync_count" ] && sync_count=${#chnl_sync_indices[@]}

        for((sync_i=0;sync_i<sync_count;sync_i++));
        do
            if [ ! -s "${chnl_sync_files[sync_i]}" ] 
            then
                $JQ_FILE -n --arg name "$(RandStr)" \
                '{
                    "ret": 0,
                    "data": [
                        {
                            "name": $name
                        }
                    ]
                }' > "${chnl_sync_files[sync_i]}"
            fi
            jq_index=""
            jq_path="["
            while IFS=':' read -ra index_arr
            do
                for a in "${index_arr[@]}"
                do
                    [ "$jq_path" != "[" ] && jq_path="$jq_path,"
                    case $a in
                        '') 
                            Println "`eval_gettext \"\\\$error sync设置错误...\"`\n" && exit 1
                        ;;
                        *[!0-9]*)
                            jq_index="$jq_index.$a"
                            jq_path="$jq_path\"$a\""
                        ;;
                        *) 
                            jq_index="${jq_index}[$a]"
                            jq_path="${jq_path}$a"
                        ;;
                    esac
                done
            done <<< "${chnl_sync_indices[sync_i]}"

            jq_path="$jq_path]"

            if [ "$action" == "stop" ]
            then
                if [[ -n $($JQ_FILE "${jq_index}[]|select(.$chnl_pid_key==$chnl_pid)" "${chnl_sync_files[sync_i]}") ]] 
                then
                    JQ delete "${chnl_sync_files[sync_i]}" "$chnl_pid_key" "$chnl_pid"
                fi
            else
                jq_channel_new=""
                jq_channel_edit=""
                while IFS=',' read -ra index_arr
                do
                    for b in "${index_arr[@]}"
                    do
                        case $b in
                            '') 
                                Println "`eval_gettext \"\\\$error sync设置错误...\"`\n" && exit 1
                            ;;
                            *) 
                                if [[ $b == *"="* ]] 
                                then
                                    key=${b%=*}
                                    value=${b#*=}
                                    if [[ $value =~ ^http ]]  
                                    then
                                        if [ -n "${kind:-}" ] 
                                        then
                                            if [ "$kind" == "flv" ] 
                                            then
                                                value=$chnl_flv_pull_link
                                            else
                                                value=""
                                            fi
                                        elif [ -z "${master:-}" ] || [ "$master" -eq 1 ]
                                        then
                                            value="$value/$chnl_output_dir_name/${chnl_playlist_name}_master.m3u8"
                                        else
                                            value="$value/$chnl_output_dir_name/${chnl_playlist_name}.m3u8"
                                        fi
                                    fi
                                else
                                    key=${b%:*}
                                    value=${b#*:}
                                    value="chnl_$value"
                                    if [ "$value" == "chnl_pid" ] 
                                    then
                                        if [ -n "${new_pid:-}" ] 
                                        then
                                            value=$new_pid
                                        else
                                            value=${!value}
                                        fi
                                    else 
                                        value=${!value}
                                    fi
                                fi

                                if [ -n "$jq_channel_new" ] 
                                then
                                    jq_channel_new="$jq_channel_new,"
                                    jq_channel_edit="$jq_channel_edit,"
                                fi

                                if [[ $value == *[!0-9]* ]] 
                                then
                                    jq_channel_new="$jq_channel_new\"$key\":\"$value\""
                                    jq_channel_edit="$jq_channel_edit$key:\"$value\""
                                else
                                    jq_channel_new="$jq_channel_new\"$key\":$value"
                                    jq_channel_edit="$jq_channel_edit$key:$value"
                                fi
                            ;;
                        esac
                    done
                done <<< "$chnl_sync_pairs"
                if [ "$action" == "add" ] || [[ -z $($JQ_FILE "${jq_index}[]|select(.$chnl_pid_key==$chnl_pid)" "${chnl_sync_files[sync_i]}") ]]
                then
                    JQ add "${chnl_sync_files[sync_i]}" "{$jq_channel_new}"
                else
                    jq_path=""
                    JQ update "${chnl_sync_files[sync_i]}" "${jq_index}|=map(select(.$chnl_pid_key==$chnl_pid) * {$jq_channel_edit} // .)"
                fi
            fi
            jq_path=""
        done

        Println "`eval_gettext \"\\\$info 频道[ \\\$chnl_channel_name ] sync 执行成功...\"`"
    fi
    action=""
}

FlvStreamCreator()
{
    trap '' HUP INT
    unset delete_on_term
    force_exit=1
    pid="$BASHPID"
    if [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$pid"')' "$CHANNELS_FILE") ]] 
    then
        true &
        rand_pid=$!
        while [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$rand_pid"')' "$CHANNELS_FILE") ]] 
        do
            true &
            rand_pid=$!
        done
        JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$pid"')|.pid)='"$rand_pid"''
    fi
    case $from in
        "AddChannel") 
            pid_file="$FFMPEG_LOG_ROOT/$pid.pid"
            {
                flock -x 201
                new_channel=$(
                $JQ_FILE -n --arg pid "$pid" --arg status "off" \
                    --arg stream_link "$stream_links" --arg live "$live_yn" \
                    --arg proxy "$proxy" --arg xc_proxy "$xc_proxy" \
                    --arg user_agent "$user_agent" --arg headers "$headers" \
                    --arg cookies "$cookies" --arg output_dir_name "$output_dir_name" \
                    --arg playlist_name "$playlist_name" --arg seg_dir_name "$seg_dir_name" \
                    --arg seg_name "$seg_name" --arg seg_length "$seg_length" \
                    --arg seg_count "$seg_count" --arg video_codec "$video_codec" \
                    --arg audio_codec "$audio_codec" --arg video_audio_shift "$video_audio_shift" \
                    --arg txt_format "$txt_format" --arg draw_text "$draw_text" \
                    --arg quality "$quality" \
                    --arg bitrates "$bitrates" --arg const "$const_yn" \
                    --arg encrypt "$encrypt_yn" --arg encrypt_session "$encrypt_session_yn" \
                    --arg keyinfo_name "$keyinfo_name" --arg key_name "$key_name" \
                    --arg input_flags "$input_flags" --arg output_flags "$output_flags" \
                    --arg channel_name "$channel_name" --arg sync "$sync_yn" \
                    --arg sync_file "$sync_file" --arg sync_index "$sync_index" \
                    --arg sync_pairs "$sync_pairs" --arg flv_status "on" --arg flv_h265 "$flv_h265_yn" \
                    --arg flv_push_link "$flv_push_link" --arg flv_pull_link "$flv_pull_link" \
                    '{
                        pid: $pid | tonumber,
                        status: $status,
                        stream_link: $stream_link,
                        live: $live,
                        proxy: $proxy,
                        xc_proxy: $xc_proxy,
                        user_agent: $user_agent,
                        headers: $headers,
                        cookies: $cookies,
                        output_dir_name: $output_dir_name,
                        playlist_name: $playlist_name,
                        seg_dir_name: $seg_dir_name,
                        seg_name: $seg_name,
                        seg_length: $seg_length | tonumber,
                        seg_count: $seg_count | tonumber,
                        video_codec: $video_codec,
                        audio_codec: $audio_codec,
                        video_audio_shift: $video_audio_shift,
                        txt_format: $txt_format,
                        draw_text: $draw_text,
                        quality: $quality,
                        bitrates: $bitrates,
                        const: $const,
                        encrypt: $encrypt,
                        encrypt_session: $encrypt_session,
                        keyinfo_name: $keyinfo_name,
                        key_name: $key_name,
                        key_time: now|strflocaltime("%s")|tonumber,
                        input_flags: $input_flags,
                        output_flags: $output_flags,
                        channel_name: $channel_name,
                        channel_time: now|strflocaltime("%s")|tonumber,
                        sync: $sync,
                        sync_file: $sync_file,
                        sync_index: $sync_index,
                        sync_pairs: $sync_pairs,
                        flv_status: $flv_status,
                        flv_h265: $flv_h265,
                        flv_push_link: $flv_push_link,
                        flv_pull_link: $flv_pull_link
                    }'
                )
                JQ add "$CHANNELS_FILE" channels "[$new_channel]"

                action="add"
                SyncFile

                trap '
                    JQ update "$CHANNELS_FILE" "(.channels[]|select(.pid==$pid)|.flv_status)=\"off\""
                    printf -v date_now "%(%m-%d %H:%M:%S)T" -1
                    printf "%s\n" "`eval_gettext \"\\\$date_now \\\$channel_name FLV 关闭\"`" >> "$MONITOR_LOG"
                    chnl_pid=$pid
                    action="stop"
                    SyncFile > /dev/null 2>> "$MONITOR_LOG"
                ' EXIT

    variants_input_command=()
    variants_output_command=()
    map_command=()
    flv_command=( -f flv "$flv_push_link" )
    headers_command=""
    [ -n "$headers" ] && printf -v headers_command '%b' "$headers"

    if [ "$flv_h265_yn" == "yes" ] 
    then
        FFMPEG="/usr/local/bin/ffmpeg_c"
    fi

    if [ "${stream_link_qualities_count:-0}" -gt 1 ] || [ "${stream_link_audio_count:-0}" -gt 0 ] || [ "${stream_link_subtitles_count:-0}" -gt 0 ]
    then
        if [ "$origin_hls_url" -eq 1 ] 
        then
            if [[ $stream_link =~ ^https?:// ]] 
            then
                [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
            elif [[ $stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
            fi
            variants_input_command+=( $input_flags_command -i "$stream_link" )
        fi

        for((i=0;i<stream_link_qualities_count;i++));
        do
            stream_links_index=${stream_link_video_indices[i]}
            if [ "$origin_hls_url" -eq 0 ] 
            then
                if [[ ${stream_links_url[stream_links_index]} =~ ^https?:// ]] 
                then
                    [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                    [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                    [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                    [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
                elif [[ ${stream_links_url[stream_links_index]} =~ ^icecast?:// ]] 
                then
                    [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                fi
                variants_input_command+=( $input_flags_command -i "${stream_links_url[stream_links_index]}" )
                map_command+=( -map $i:v )
            else
                map_command+=( -map 0:v:$stream_links_index )
            fi

            if [ "$video_codec" != "copy" ] 
            then
                variant_bitrate=${stream_link_qualities[i]%-*}
                variant_resolution=${stream_link_qualities[i]#*-}
                if [ -n "$const" ]
                then
                    variants_output_command+=( -b:v:$i ${variant_bitrate}k -bufsize:v:$i ${variant_bitrate}k -minrate:v:$i ${variant_bitrate}k -maxrate:v:$i ${variant_bitrate}k )
                else
                    variants_output_command+=( -b:v:$i ${variant_bitrate}k )
                fi
                variants_output_command+=( -s:v:$i $variant_resolution )
            fi
        done

        variants_output_command+=( -c:v "$video_codec" -c:a "$audio_codec" $output_flags_command )

        if [ -n "${stream_audio_url:-}" ] 
        then
            if [ "${stream_link_audio_count:-0}" -gt 0 ] 
            then
                for((i=0;i<stream_link_audio_count;i++));
                do
                    stream_link_audio_index=${stream_link_audio_indices[i]}
                    if [ "$origin_hls_url" -eq 0 ] 
                    then
                        if [[ ${stream_audio_url[stream_link_audio_index]} =~ ^https?:// ]] 
                        then
                            [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                            [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                            [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                            [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
                        elif [[ ${stream_audio_url[stream_link_audio_index]} =~ ^icecast?:// ]] 
                        then
                            [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                        fi
                        variants_input_command+=( $input_flags_command -i "${stream_audio_url[stream_link_audio_index]}" )
                        map_command+=( -map $((i+stream_link_qualities_count)):a )
                    else
                        map_command+=( -map 0:a:$stream_link_audio_index )
                    fi
                done
            fi
        else
            for((i=0;i<stream_link_qualities_count;i++));
            do
                if [ "$origin_hls_url" -eq 0 ] 
                then
                    map_command+=( -map $i:a )
                else
                    map_command+=( -map 0:a:$i )
                fi
            done
        fi

        PrepTerm
        $FFMPEG ${global_options[@]+"${global_options[@]}"} \
        ${variants_input_command[@]+"${variants_input_command[@]}"} \
        ${variants_output_command[@]+"${variants_output_command[@]}"} \
        ${map_command[@]+"${map_command[@]}"} \
        -flags -global_header \
        ${flv_command[@]+"${flv_command[@]}"} > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
        WaitTerm
        exit 0
    fi

    filter_complex=""
    input_command=()

    if [ "${stream_link_qualities_count:-0}" -eq 1 ] 
    then
        stream_links_index=${stream_link_video_indices[0]}
        stream_link=${stream_links_url[stream_links_index]}
    fi

    if [[ $stream_link =~ ^https?:// ]] 
    then
        [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
        [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
        [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
        [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
    elif [[ $stream_link =~ ^icecast?:// ]] 
    then
        [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
    fi

    input_command+=( $input_flags_command -i $stream_link )

    video_shift_index=0
    audio_shift_index=0
    if ! [[ $input_flags =~ -an ]] && ! [[ $output_flags =~ -an ]] 
    then
        if [ -n "${video_shift:-}" ] 
        then
            video_shift_index=1
            if [[ $stream_link =~ ^https?:// ]] 
            then
                [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
                [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
                [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
            elif [[ $stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
            fi
            input_command+=( $input_flags_command -itsoffset $video_shift -i $stream_link )
        elif [ -n "${audio_shift:-}" ] 
        then
            if [ "$audio_codec" == "copy" ] 
            then
                audio_shift_index=1
                if [[ $stream_link =~ ^https?:// ]] 
                then
                    [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
                    [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                    [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
                    [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
                elif [[ $stream_link =~ ^icecast?:// ]] 
                then
                    [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                fi
                input_command+=( $input_flags_command -itsoffset $audio_shift -i $stream_link )
            else
                input_command+=( -filter_complex "[0:a] adelay=delays=${audio_shift}s:all=1 [delayed_audio]" )
            fi
        fi
    fi

    if [ -z "$quality" ]
    then
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a variants <<< "$bitrates"

            for((i=0;i<${#variants[@]};i++));
            do
                variant=${variants[i]}

                if [[ $variant =~ - ]] 
                then
                    bitrates=${variant%-*}
                    resolution=${variant#*-}

                    if [ -n "$const" ] 
                    then
                        variants_output_command+=( -b:v:$i ${bitrates}k -bufsize:v:$i ${bitrates}k -minrate:v:$i ${bitrates}k -maxrate:v:$i ${bitrates}k )
                    else
                        variants_output_command+=( -b:v:$i ${bitrates}k )
                    fi

                    variants_output_command+=( -s:v:$i $resolution )
                elif [[ $variant == *"x"* ]] 
                then
                    variants_output_command+=( -s:v:$i $variant )
                else
                    if [ -n "$const" ] 
                    then
                        variants_output_command+=( -b:v:$i ${variant}k -bufsize:v:$i ${variant}k -minrate:v:$i ${variant}k -maxrate:v:$i ${variant}k )
                    else
                        variants_output_command+=( -b:v:$i ${variant}k )
                    fi
                fi

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ] 
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi
                fi
            done
        else
            if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
            then
                filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video]"
            fi

            if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
            then
                map_command+=( -map '[drawtext_video]' )
            else
                map_command+=( -map $video_shift_index:v )
            fi

            if ! [[ $input_flags =~ -an ]] && ! [[ $output_flags =~ -an ]]
            then
                if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ] 
                then
                    map_command+=( -map '[delayed_audio]' )
                else
                    map_command+=( -map $audio_shift_index:a )
                fi
            fi
        fi
    else
        IFS="," read -r -a qualities <<< "$quality"
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a variants <<< "$bitrates"

            for((i=0;i<${#variants[@]};i++));
            do
                variant=${variants[i]}

                if [[ $variant =~ - ]] 
                then
                    bitrates=${variant%-*}
                    resolution=${variant#*-}

                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -bufsize:v:$i ${bitrates}k -maxrate:v:$i ${bitrates}k )

                    if [ "$video_codec" == "libx265" ]
                    then
                        variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${bitrates}k --vbv-bufsize:v:$i ${bitrates}k )
                    fi

                    variants_output_command+=( -s:v:$i $resolution )
                elif [[ $variant == *"x"* ]] 
                then
                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -s:v:$i $variant )
                else
                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -bufsize:v:$i ${variant}k -maxrate:v:$i ${variant}k )

                    if [ "$video_codec" == "libx265" ]
                    then
                        variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${variant}k --vbv-bufsize:v:$i ${variant}k )
                    fi
                fi

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ]
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi
                fi
            done
        else
            for((i=0;i<${#qualities[@]};i++));
            do
                variants_output_command+=( -crf:v:$i ${qualities[i]} )

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ]
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi
                fi
            done
        fi
    fi

    variants_output_command+=( -c:v "$video_codec" -c:a "$audio_codec" $output_flags_command )

    if [ -n "$filter_complex" ] 
    then
        input_command+=( -filter_complex "$filter_complex" )
    fi

    PrepTerm
    $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    ${input_command[@]+"${input_command[@]}"} \
    ${variants_output_command[@]+"${variants_output_command[@]}"} \
    ${map_command[@]+"${map_command[@]}"} \
    -flags -global_header \
    ${flv_command[@]+"${flv_command[@]}"} > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
    WaitTerm
            } 201>"$pid_file"
        ;;
        "StartChannel") 
            new_pid=$pid
            pid_file="$FFMPEG_LOG_ROOT/$new_pid.pid"
            {
                flock -x 201
                JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
                {
                    pid: '"$new_pid"',
                    flv_status: "on",
                    stream_link: "'"$chnl_stream_links"'",
                    user_agent: "'"$chnl_user_agent"'",
                    headers: "'"$chnl_headers"'",
                    cookies: "'"$chnl_cookies"'",
                    flv_push_link: "'"$chnl_flv_push_link"'",
                    flv_pull_link: "'"$chnl_flv_pull_link"'",
                    channel_time: '"$chnl_channel_time"'
                } // .)'

                action="start"
                SyncFile

                trap '
                    JQ update "$CHANNELS_FILE" ".channels|=map(select(.pid==$new_pid) * { flv_status: \"off\" } // .)"
                    printf -v date_now "%(%m-%d %H:%M:%S)T" -1
                    printf "%s\n" "`eval_gettext \"\\\$date_now \\\$chnl_channel_name FLV 关闭\"`" >> "$MONITOR_LOG"
                    chnl_pid=$new_pid
                    action="stop"
                    SyncFile > /dev/null 2>> "$MONITOR_LOG"
                ' EXIT

    chnl_variants_input_command=()
    chnl_variants_output_command=()
    chnl_map_command=()
    chnl_flv_command=( -f flv "$chnl_flv_push_link" )
    chnl_headers_command=""
    [ -n "$chnl_headers" ] && printf -v chnl_headers_command '%b' "$chnl_headers"

    if [ "$chnl_flv_h265_yn" == "yes" ] 
    then
        FFMPEG="/usr/local/bin/ffmpeg_c"
    fi

    if [ "${chnl_stream_link_qualities_count:-0}" -gt 1 ] || [ -n "${chnl_stream_link_audio_indices:-}" ]
    then
        if [ "$chnl_origin_hls_url" -eq 1 ] 
        then
            if [[ $chnl_stream_link =~ ^https?:// ]] 
            then
                [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
            elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
            fi
            chnl_variants_input_command+=( $chnl_input_flags_command -i "$chnl_stream_link" )
        fi

        for((i=0;i<chnl_stream_link_qualities_count;i++));
        do
            chnl_stream_links_index=${chnl_stream_link_video_indices[i]}
            if [ "$chnl_origin_hls_url" -eq 0 ] 
            then
                if [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^https?:// ]] 
                then
                    [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                    [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                    [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                    [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
                elif [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^icecast?:// ]] 
                then
                    [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                fi
                chnl_variants_input_command+=( $chnl_input_flags_command -i "${chnl_stream_links_url[chnl_stream_links_index]}" )
                chnl_map_command+=( -map $i:v )
            else
                chnl_map_command+=( -map 0:v:$chnl_stream_links_index )
            fi

            if [ "$chnl_video_codec" != "copy" ] 
            then
                chnl_variant_bitrate=${chnl_stream_link_qualities[i]%-*}
                chnl_variant_resolution=${chnl_stream_link_qualities[i]#*-}
                if [ -n "$chnl_const" ]
                then
                    chnl_variants_output_command+=( -b:v:$i ${chnl_variant_bitrate}k -bufsize:v:$i ${chnl_variant_bitrate}k -minrate:v:$i ${chnl_variant_bitrate}k -maxrate:v:$i ${chnl_variant_bitrate}k )
                else
                    chnl_variants_output_command+=( -b:v:$i ${chnl_variant_bitrate}k )
                fi
                chnl_variants_output_command+=( -s:v:$i $chnl_variant_resolution )
            fi
        done

        chnl_variants_output_command+=( -c:v "$chnl_video_codec" -c:a "$chnl_audio_codec" $chnl_output_flags_command )

        if [ -n "${chnl_stream_audio_url:-}" ] 
        then
            if [ -n "${chnl_stream_link_audio_indices:-}" ] 
            then
                for((i=0;i<${#chnl_stream_link_audio_indices[@]};i++));
                do
                    chnl_stream_link_audio_index=${chnl_stream_link_audio_indices[i]}
                    if [ "$chnl_origin_hls_url" -eq 0 ] 
                    then
                        if [[ ${chnl_stream_audio_url[chnl_stream_link_audio_index]} =~ ^https?:// ]] 
                        then
                            [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                            [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                            [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                            [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
                        elif [[ ${chnl_stream_audio_url[chnl_stream_link_audio_index]} =~ ^icecast?:// ]] 
                        then
                            [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                        fi
                        chnl_variants_input_command+=( $chnl_input_flags_command -i "${chnl_stream_audio_url[chnl_stream_link_audio_index]}" )
                        chnl_map_command+=( -map $((i+chnl_stream_link_qualities_count)):a )
                    else
                        chnl_map_command+=( -map 0:a:$chnl_stream_link_audio_index )
                    fi
                done
            fi
        else
            for((i=0;i<chnl_stream_link_qualities_count;i++));
            do
                if [ "$chnl_origin_hls_url" -eq 0 ] 
                then
                    chnl_map_command+=( -map $i:a )
                else
                    chnl_map_command+=( -map 0:a:$i )
                fi
            done
        fi

        PrepTerm
        $FFMPEG ${global_options[@]+"${global_options[@]}"} \
        ${chnl_variants_input_command[@]+"${chnl_variants_input_command[@]}"} \
        ${chnl_variants_output_command[@]+"${chnl_variants_output_command[@]}"} \
        ${chnl_map_command[@]+"${chnl_map_command[@]}"} \
        -flags -global_header \
        ${chnl_flv_command[@]+"${chnl_flv_command[@]}"} > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
        WaitTerm
        exit 0
    fi

    chnl_filter_complex=""
    chnl_input_command=()

    if [ "${chnl_stream_link_qualities_count:-0}" -eq 1 ] 
    then
        chnl_stream_links_index=${chnl_stream_link_video_indices[0]}
        chnl_stream_link=${chnl_stream_links_url[chnl_stream_links_index]}
    fi

    if [[ $chnl_stream_link =~ ^https?:// ]] 
    then
        [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
        [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
        [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
        [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
    elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
    then
        [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
    fi

    chnl_input_command+=( $chnl_input_flags_command -i $chnl_stream_link )

    chnl_video_shift_index=0
    chnl_audio_shift_index=0
    if ! [[ $chnl_input_flags =~ -an ]] && ! [[ $chnl_output_flags =~ -an ]] 
    then
        if [ -n "${chnl_video_shift:-}" ] 
        then
            chnl_video_shift_index=1
            if [[ $chnl_stream_link =~ ^https?:// ]] 
            then
                [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
                [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
                [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
            elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
            fi
            chnl_input_command+=( $chnl_input_flags_command -itsoffset $chnl_video_shift -i $chnl_stream_link )
        elif [ -n "${chnl_audio_shift:-}" ] 
        then
            if [ "$chnl_audio_codec" == "copy" ] 
            then
                chnl_audio_shift_index=1
                if [[ $chnl_stream_link =~ ^https?:// ]] 
                then
                    [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
                    [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                    [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
                    [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
                elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
                then
                    [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                fi
                chnl_input_command+=( $chnl_input_flags_command -itsoffset $chnl_audio_shift -i $chnl_stream_link )
            else
                chnl_input_command+=( -filter_complex "[0:a] adelay=delays=${chnl_audio_shift}s:all=1 [delayed_audio]" )
            fi
        fi
    fi

    if [ "$chnl_video_codec" == "copy" ] && [ "$chnl_audio_codec" == "copy" ]
    then
        chnl_quality=""
        chnl_bitrates=""
    fi

    if [ -z "$chnl_quality" ]
    then
        if [ -n "$chnl_bitrates" ] 
        then
            IFS="," read -r -a chnl_variants <<< "$chnl_bitrates"

            for((i=0;i<${#chnl_variants[@]};i++));
            do
                chnl_variant=${chnl_variants[i]}

                if [[ $chnl_variant =~ - ]] 
                then
                    chnl_bitrates=${chnl_variant%-*}
                    chnl_resolution=${chnl_variant#*-}

                    if [ -n "$chnl_const" ] 
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_bitrates}k -bufsize:v:$i ${chnl_bitrates}k -minrate:v:$i ${chnl_bitrates}k -maxrate:v:$i ${chnl_bitrates}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_bitrates}k )
                    fi

                    chnl_variants_output_command+=( -s:v:$i $chnl_resolution )
                elif [[ $chnl_variant == *"x"* ]] 
                then
                    chnl_variants_output_command+=( -s:v:$i $chnl_variant )
                else
                    if [ -n "$chnl_const" ] 
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant}k -bufsize:v:$i ${chnl_variant}k -minrate:v:$i ${chnl_variant}k -maxrate:v:$i ${chnl_variant}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant}k )
                    fi
                fi

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ] 
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi
                fi
            done
        else
            if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
            then
                chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video]"
            fi

            if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
            then
                chnl_map_command+=( -map '[drawtext_video]' )
            else
                chnl_map_command+=( -map $chnl_video_shift_index:v )
            fi

            if ! [[ $chnl_input_flags =~ -an ]] && ! [[ $chnl_output_flags =~ -an ]]
            then
                if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ] 
                then
                    chnl_map_command+=( -map '[delayed_audio]' )
                else
                    chnl_map_command+=( -map $chnl_audio_shift_index:a )
                fi
            fi
        fi
    else
        IFS="," read -r -a chnl_qualities <<< "$chnl_quality"
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a chnl_variants <<< "$chnl_bitrates"

            for((i=0;i<${#chnl_variants[@]};i++));
            do
                chnl_variant=${chnl_variants[i]}

                if [[ $chnl_variant =~ - ]] 
                then
                    chnl_bitrates=${chnl_variant%-*}
                    chnl_resolution=${chnl_variant#*-}

                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -bufsize:v:$i ${chnl_bitrates}k -maxrate:v:$i ${chnl_bitrates}k )

                    if [ "$chnl_video_codec" == "libx265" ]
                    then
                        chnl_variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${chnl_bitrates}k --vbv-bufsize:v:$i ${chnl_bitrates}k )
                    fi

                    chnl_variants_output_command+=( -s:v:$i $chnl_resolution )
                elif [[ $chnl_variant == *"x"* ]] 
                then
                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -s:v:$i $chnl_variant )
                else
                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -bufsize:v:$i ${chnl_variant}k -maxrate:v:$i ${chnl_variant}k )

                    if [ "$chnl_video_codec" == "libx265" ]
                    then
                        chnl_variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${chnl_variant}k --vbv-bufsize:v:$i ${chnl_variant}k )
                    fi
                fi

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ]
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi
                fi
            done
        else
            for((i=0;i<${#chnl_qualities[@]};i++));
            do
                chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]} )

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ]
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi
                fi
            done
        fi
    fi

    chnl_variants_output_command+=( -c:v "$chnl_video_codec" -c:a "$chnl_audio_codec" $chnl_output_flags_command )

    if [ -n "$chnl_filter_complex" ] 
    then
        chnl_input_command+=( -filter_complex "$chnl_filter_complex" )
    fi

    PrepTerm
    $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    ${chnl_input_command[@]+"${chnl_input_command[@]}"} \
    ${chnl_variants_output_command[@]+"${chnl_variants_output_command[@]}"} \
    ${chnl_map_command[@]+"${chnl_map_command[@]}"} \
    -flags -global_header \
    ${chnl_flv_command[@]+"${chnl_flv_command[@]}"} > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
    WaitTerm
            } 201>"$pid_file"
        ;;
    esac
}

HlsStreamCreatorPlus()
{
    trap '' HUP INT
    force_exit=1
    pid="$BASHPID"
    if [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$pid"')' "$CHANNELS_FILE") ]] 
    then
        true &
        rand_pid=$!
        while [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$rand_pid"')' "$CHANNELS_FILE") ]] 
        do
            true &
            rand_pid=$!
        done

        JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$pid"')|.pid)='"$rand_pid"''
    fi
    case $from in
        "AddChannel") 
            delete_on_term=$output_dir_root
            pid_file="$FFMPEG_LOG_ROOT/$pid.pid"
            {
                flock -x 201
                new_channel=$(
                $JQ_FILE -n --arg pid "$pid" --arg status "on" \
                    --arg stream_link "$stream_links" --arg live "$live_yn" \
                    --arg proxy "$proxy" --arg xc_proxy "$xc_proxy" \
                    --arg user_agent "$user_agent" --arg headers "$headers" \
                    --arg cookies "$cookies" --arg output_dir_name "$output_dir_name" \
                    --arg playlist_name "$playlist_name" --arg seg_dir_name "$seg_dir_name" \
                    --arg seg_name "$seg_name" --arg seg_length "$seg_length" \
                    --arg seg_count "$seg_count" --arg video_codec "$video_codec" \
                    --arg audio_codec "$audio_codec" --arg video_audio_shift "$video_audio_shift" \
                    --arg txt_format "$txt_format" --arg draw_text "$draw_text" \
                    --arg quality "$quality" \
                    --arg bitrates "$bitrates" --arg const "$const_yn" \
                    --arg encrypt "$encrypt_yn" --arg encrypt_session "$encrypt_session_yn" \
                    --arg keyinfo_name "$keyinfo_name" --arg key_name "$key_name" \
                    --arg input_flags "$input_flags" --arg output_flags "$output_flags" \
                    --arg channel_name "$channel_name" --arg sync "$sync_yn" \
                    --arg sync_file "$sync_file" --arg sync_index "$sync_index" \
                    --arg sync_pairs "$sync_pairs" --arg flv_status "off" --arg flv_h265 "$flv_h265_yn" \
                    --arg flv_push_link '' --arg flv_pull_link '' \
                    '{
                        pid: $pid | tonumber,
                        status: $status,
                        stream_link: $stream_link,
                        live: $live,
                        proxy: $proxy,
                        xc_proxy: $xc_proxy,
                        user_agent: $user_agent,
                        headers: $headers,
                        cookies: $cookies,
                        output_dir_name: $output_dir_name,
                        playlist_name: $playlist_name,
                        seg_dir_name: $seg_dir_name,
                        seg_name: $seg_name,
                        seg_length: $seg_length | tonumber,
                        seg_count: $seg_count | tonumber,
                        video_codec: $video_codec,
                        audio_codec: $audio_codec,
                        video_audio_shift: $video_audio_shift,
                        txt_format: $txt_format,
                        draw_text: $draw_text,
                        quality: $quality,
                        bitrates: $bitrates,
                        const: $const,
                        encrypt: $encrypt,
                        encrypt_session: $encrypt_session,
                        keyinfo_name: $keyinfo_name,
                        key_name: $key_name,
                        key_time: now|strflocaltime("%s")|tonumber,
                        input_flags: $input_flags,
                        output_flags: $output_flags,
                        channel_name: $channel_name,
                        channel_time: now|strflocaltime("%s")|tonumber,
                        sync: $sync,
                        sync_file: $sync_file,
                        sync_index: $sync_index,
                        sync_pairs: $sync_pairs,
                        flv_status: $flv_status,
                        flv_h265: $flv_h265,
                        flv_push_link: $flv_push_link,
                        flv_pull_link: $flv_pull_link
                    }'
                )

    JQ add "$CHANNELS_FILE" channels "[$new_channel]"

    action="add"
    SyncFile

    trap '
        JQ update "$CHANNELS_FILE" "(.channels[]|select(.pid==$pid)|.status)=\"off\""
        printf -v date_now "%(%m-%d %H:%M:%S)T" -1
        printf "%s\n" "`eval_gettext \"\\\$date_now \\\$channel_name HLS 关闭\"`" >> "$MONITOR_LOG"
        chnl_pid=$pid
        action="stop"
        SyncFile > /dev/null 2>> "$MONITOR_LOG"
        rm -rf "$delete_on_term"
    ' EXIT

    mkdir -p "$delete_on_term"

    variants_input_command=()
    variants_output_command=()
    map_command=()
    var_stream_map_command=()
    hls_command=( -hls_time "$seg_length" -hls_list_size "$seg_count" )
    # segment_command=()
    hls_master_list="#EXTM3U\n#EXT-X-VERSION:7\n"
    var_stream_map=""
    headers_command=""
    [ -n "$headers" ] && printf -v headers_command '%b' "$headers"

    if [ "$seg_count" -gt 0 ] 
    then
        hls_command+=( -hls_delete_threshold $seg_count )
    fi

    if [ -n "$live" ] 
    then
        # segment_command+=( -segment_list_flags +live -segment_list_size $seg_count -segment_wrap $((seg_count * 2)) )

        if [ "$seg_count" -gt 0 ] 
        then
            hls_command+=( -hls_flags periodic_rekey+delete_segments )
        else
            hls_command+=( -hls_flags periodic_rekey )
        fi
    else
        hls_command+=( -hls_flags periodic_rekey )
    fi

    seg_dir_path=""
    if [ -n "$seg_dir_name" ] 
    then
        seg_dir_path="$seg_dir_name/"
    fi

    if [ -n "${stream_link_cdn:-}" ] 
    then
        stream_link=$stream_link_cdn
    fi

    if [ "${stream_link_qualities_count:-0}" -gt 1 ] || [ "${stream_link_audio_count:-0}" -gt 0 ] || [ "${stream_link_subtitles_count:-0}" -gt 0 ]
    then
        if [ "$origin_hls_url" -eq 1 ] 
        then
            if [[ $stream_link =~ ^https?:// ]] 
            then
                [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
            elif [[ $stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
            fi
            variants_input_command+=( $input_flags_command -i "$stream_link" )
        fi

        for((i=0;i<stream_link_qualities_count;i++));
        do
            var_stream_map="$var_stream_map v:$i"

            stream_links_index=${stream_link_video_indices[i]}

            hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=${stream_links_bitrate[stream_links_index]},AVERAGE-BANDWIDTH=${stream_links_bitrate[stream_links_index]},RESOLUTION=${stream_links_resolution[stream_links_index]}"

            if [ -n "${stream_links_audio[stream_links_index]}" ] 
            then
                if [ "${stream_link_audio_count:-0}" -gt 0 ] 
                then
                    for stream_link_audio_index in "${stream_link_audio_indices[@]}"
                    do
                        if [ "${stream_audio_group_id[stream_link_audio_index]}" == "${stream_links_audio[stream_links_index]}" ] 
                        then
                            hls_master_list="$hls_master_list,AUDIO=\"${stream_links_audio[stream_links_index]}\""
                            var_stream_map="$var_stream_map,agroup:${stream_links_audio[stream_links_index]}"
                            break
                        fi
                    done
                fi
            else
                var_stream_map="$var_stream_map,a:$i"
            fi

            if [ -n "${stream_links_subtitles[stream_links_index]}" ] && [ "${stream_link_subtitles_count:-0}" -gt 0 ]
            then
                for stream_link_subtitles_index in "${stream_link_subtitles_indices[@]}"
                do
                    if [ "${stream_subtitles_group_id[stream_link_subtitles_index]}" == "${stream_links_subtitles[stream_links_index]}" ] 
                    then
                        hls_master_list="$hls_master_list,SUBTITLES=\"${stream_links_subtitles[stream_links_index]}\""
                        var_stream_map="$var_stream_map,sgroup:${stream_links_subtitles[stream_links_index]}"
                        break
                    fi
                done
            fi

            hls_master_list="$hls_master_list\n${playlist_name}_${stream_links_resolution[stream_links_index]}.m3u8\n\n"
            var_stream_map="$var_stream_map,name:${stream_links_resolution[stream_links_index]}"

            if [ "$origin_hls_url" -eq 0 ] 
            then
                if [[ ${stream_links_url[stream_links_index]} =~ ^https?:// ]] 
                then
                    [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                    [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                    [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                    [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
                elif [[ ${stream_links_url[stream_links_index]} =~ ^icecast?:// ]] 
                then
                    [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                fi
                variants_input_command+=( $input_flags_command -i "${stream_links_url[stream_links_index]}" )
                map_command+=( -map $i:v )
            else
                map_command+=( -map 0:v:$stream_links_index )
            fi

            if [ "$video_codec" != "copy" ] 
            then
                if [[ ${stream_link_qualities[i]} =~ - ]] 
                then
                    variant_bitrate=${stream_link_qualities[i]%-*}
                    variant_resolution=${stream_link_qualities[i]#*-}

                    if [ -n "$const" ]
                    then
                        variants_output_command+=( -b:v:$i ${variant_bitrate}k -bufsize:v:$i ${variant_bitrate}k -minrate:v:$i ${variant_bitrate}k -maxrate:v:$i ${variant_bitrate}k )
                    else
                        variants_output_command+=( -b:v:$i ${variant_bitrate}k )
                    fi

                    variants_output_command+=( -s:v:$i $variant_resolution )
                elif [[ ${stream_link_qualities[i]} =~ x ]] 
                then
                    variants_output_command+=( -s:v:$i ${stream_link_qualities[i]} )
                else
                    if [ -n "$const" ]
                    then
                        variants_output_command+=( -b:v:$i ${stream_link_qualities[i]}k -bufsize:v:$i ${stream_link_qualities[i]}k -minrate:v:$i ${stream_link_qualities[i]}k -maxrate:v:$i ${stream_link_qualities[i]}k )
                    else
                        variants_output_command+=( -b:v:$i ${stream_link_qualities[i]}k )
                    fi
                fi
            fi
        done

        variants_output_command+=( -c:v "$video_codec" -c:a "$audio_codec" )

        if [ -n "${stream_audio_url:-}" ] 
        then
            if [ "${stream_link_audio_count:-0}" -gt 0 ] 
            then
                for((i=0;i<stream_link_audio_count;i++));
                do
                    stream_link_audio_index=${stream_link_audio_indices[i]}

                    hls_master_list="$hls_master_list#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"${stream_audio_group_id[stream_link_audio_index]}\",NAME=\"${stream_audio_name[stream_link_audio_index]}\",DEFAULT=\"${stream_audio_default[stream_link_audio_index]}\",AUTOSELECT=YES,LANGUAGE=\"${stream_audio_language[stream_link_audio_index]}\",URI=\"${playlist_name}_${stream_audio_name[stream_link_audio_index]}.m3u8\"\n"
                    var_stream_map="$var_stream_map a:$i,agroup:${stream_audio_group_id[stream_link_audio_index]},default:${stream_audio_default[stream_link_audio_index]},language:${stream_audio_language[stream_link_audio_index]},name:${stream_audio_name[stream_link_audio_index]}"

                    if [ "$origin_hls_url" -eq 0 ] 
                    then
                        if [[ ${stream_audio_url[stream_link_audio_index]} =~ ^https?:// ]] 
                        then
                            [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                            [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                            [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                            [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
                        elif [[ ${stream_audio_url[stream_link_audio_index]} =~ ^icecast?:// ]] 
                        then
                            [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                        fi
                        variants_input_command+=( $input_flags_command -i "${stream_audio_url[stream_link_audio_index]}" )
                        map_command+=( -map $((i+stream_link_qualities_count)):a )
                    else
                        map_command+=( -map 0:a:$stream_link_audio_index )
                    fi
                done
            fi
        else
            for((i=0;i<stream_link_qualities_count;i++));
            do
                if [ "$origin_hls_url" -eq 0 ] 
                then
                    map_command+=( -map $i:a )
                else
                    map_command+=( -map 0:a:$i )
                fi
            done
        fi

        if [ "${stream_link_subtitles_count:-0}" -gt 0 ] 
        then
            for((i=0;i<stream_link_subtitles_count;i++));
            do
                stream_link_subtitles_index=${stream_link_subtitles_indices[i]}

                if [[ ${stream_subtitles_url[stream_link_subtitles_index]} =~ $hboasia_host/(.+)$ ]] 
                then
                    hls_master_list="$hls_master_list#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"${stream_subtitles_group_id[stream_link_subtitles_index]}\",NAME=\"${stream_subtitles_name[stream_link_subtitles_index]}\",DEFAULT=\"${stream_subtitles_default[stream_link_subtitles_index]}\",AUTOSELECT=YES,LANGUAGE=\"${stream_subtitles_language[stream_link_subtitles_index]}\",URI=\"https://hboasia.epub.fun/${BASH_REMATCH[1]%%\?*}\"\n"
                    continue
                fi

                hls_master_list="$hls_master_list#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"${stream_subtitles_group_id[stream_link_subtitles_index]}\",NAME=\"${stream_subtitles_name[stream_link_subtitles_index]}\",DEFAULT=\"${stream_subtitles_default[stream_link_subtitles_index]}\",AUTOSELECT=YES,LANGUAGE=\"${stream_subtitles_language[stream_link_subtitles_index]}\",URI=\"${stream_subtitles_group_id[stream_link_subtitles_index]}_${stream_subtitles_name[stream_link_subtitles_index]}_vtt.m3u8\"\n"
                var_stream_map="$var_stream_map s:$i,sgroup:${stream_subtitles_group_id[stream_link_subtitles_index]},default:${stream_subtitles_default[stream_link_subtitles_index]},language:${stream_subtitles_language[stream_link_subtitles_index]},name:${stream_subtitles_name[stream_link_subtitles_index]}"

                if [ "$origin_hls_url" -eq 0 ] 
                then
                    if [[ ${stream_subtitles_url[stream_link_subtitles_index]} =~ ^https?:// ]] 
                    then
                        [ -n "$proxy" ] && variants_input_command+=( -http_proxy "$proxy" )
                        [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                        [ -n "$headers_command" ] && variants_input_command+=( -headers "$headers_command" )
                        [ -n "$cookies" ] && variants_input_command+=( -cookies "$cookies" )
                    elif [[ ${stream_subtitles_url[stream_link_subtitles_index]} =~ ^icecast?:// ]] 
                    then
                        [ -n "$user_agent" ] && variants_input_command+=( -user_agent "$user_agent" )
                    fi
                    variants_input_command+=( $input_flags_command -i "${stream_subtitles_url[stream_link_subtitles_index]}" )
                    map_command+=( -map $((i+stream_link_qualities_count+stream_link_audio_count)):s )
                else
                    map_command+=( -map 0:s:${stream_link_subtitles_index}? )
                fi
            done

            variants_output_command+=( -c:s webvtt )
        fi

        variants_output_command+=( $output_flags_command )
        var_stream_map_command+=( -var_stream_map "$var_stream_map" )

        if [ "$encrypt_yn" == "yes" ] 
        then
            openssl rand 16 > "$output_dir_root/$key_name.key"
            if [ "$encrypt_session_yn" == "yes" ] 
            then
                echo -e "/keys?key=$key_name&channel=$output_dir_name\n$output_dir_root/$key_name.key\n$(openssl rand -hex 16)" > "$output_dir_root/$keyinfo_name.keyinfo"
            else
                echo -e "$key_name.key\n$output_dir_root/$key_name.key\n$(openssl rand -hex 16)" > "$output_dir_root/$keyinfo_name.keyinfo"
            fi
            hls_command+=( -hls_key_info_file "$output_dir_root/$keyinfo_name.keyinfo" )
        fi

        echo -e "$hls_master_list" > "$output_dir_root/${playlist_name}_master.m3u8"
        hls_command+=( -hls_segment_filename "$output_dir_root/$seg_dir_path${seg_name}"_%v_%05d.ts )
        hls_command+=( "$output_dir_root/${playlist_name}_%v.m3u8" )

        PrepTerm
        $FFMPEG ${global_options[@]+"${global_options[@]}"} \
        ${variants_input_command[@]+"${variants_input_command[@]}"} \
        ${variants_output_command[@]+"${variants_output_command[@]}"} \
        ${map_command[@]+"${map_command[@]}"} \
        -flags -global_header \
        -f hls ${var_stream_map_command[@]+"${var_stream_map_command[@]}"} \
        ${hls_command[@]+"${hls_command[@]}"} > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
        WaitTerm
        exit 0
    fi

    input_command=()
    filter_complex=""

    if [ "${stream_link_qualities_count:-0}" -eq 1 ] 
    then
        stream_links_index=${stream_link_video_indices[0]}
        stream_link=${stream_links_url[stream_links_index]}
    fi

    if [[ $stream_link =~ ^https?:// ]] 
    then
        [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
        [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
        [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
        [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
    elif [[ $stream_link =~ ^icecast?:// ]] 
    then
        [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
    fi

    input_command+=( $input_flags_command -i $stream_link )

    video_shift_index=0
    audio_shift_index=0
    if ! [[ $input_flags =~ -an ]] && ! [[ $output_flags =~ -an ]] 
    then
        if [ -n "${video_shift:-}" ] 
        then
            video_shift_index=1
            if [[ $stream_link =~ ^https?:// ]] 
            then
                [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
                [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
                [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
            elif [[ $stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
            fi
            input_command+=( $input_flags_command -itsoffset $video_shift -i $stream_link )
        elif [ -n "${audio_shift:-}" ] 
        then
            if [ "$audio_codec" == "copy" ] 
            then
                audio_shift_index=1
                if [[ $stream_link =~ ^https?:// ]] 
                then
                    [ -n "$proxy" ] && input_command+=( -http_proxy "$proxy" )
                    [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                    [ -n "$headers_command" ] && input_command+=( -headers "$headers_command" )
                    [ -n "$cookies" ] && input_command+=( -cookies "$cookies" )
                elif [[ $stream_link =~ ^icecast?:// ]] 
                then
                    [ -n "$user_agent" ] && input_command+=( -user_agent "$user_agent" )
                fi
                input_command+=( $input_flags_command -itsoffset $audio_shift -i $stream_link )
            else
                input_command+=( -filter_complex "[0:a] adelay=delays=${audio_shift}s:all=1 [delayed_audio]" )
            fi
        fi
    fi

    if [ -z "$quality" ]
    then
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a variants <<< "$bitrates"

            for((i=0;i<${#variants[@]};i++));
            do
                variant=${variants[i]}

                if [[ $variant =~ - ]] 
                then
                    bitrates=${variant%-*}
                    resolution=${variant#*-}

                    if [ -n "$const" ] 
                    then
                        variants_output_command+=( -b:v:$i ${bitrates}k -bufsize:v:$i ${bitrates}k -minrate:v:$i ${bitrates}k -maxrate:v:$i ${bitrates}k )
                    else
                        variants_output_command+=( -b:v:$i ${bitrates}k )
                    fi

                    variants_output_command+=( -s:v:$i $resolution )
                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((bitrates*1000)),RESOLUTION=$resolution$subtitle_append\n"
                elif [[ $variant =~ x ]] 
                then
                    variants_output_command+=( -s:v:$i $variant )
                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=$variant$subtitle_append\n"
                else
                    if [ -n "$const" ] 
                    then
                        variants_output_command+=( -b:v:$i ${variant}k -bufsize:v:$i ${variant}k -minrate:v:$i ${variant}k -maxrate:v:$i ${variant}k )
                    else
                        variants_output_command+=( -b:v:$i ${variant}k )
                    fi
                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((variant*1000))$subtitle_append\n"
                fi

                hls_master_list="$hls_master_list${playlist_name}_$variant.m3u8\n\n"

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    var_stream_map="$var_stream_map v:$i,name:$variant"
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ] 
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi

                    var_stream_map="$var_stream_map v:$i,a:$i,name:$variant"
                fi
            done
        else
            if [ -n "$subtitle_append" ] 
            then
                hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000$subtitle_append\n${playlist_name}_vtt.m3u8\n\n"
            fi

            if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
            then
                filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video]"
                map_command+=( -map '[drawtext_video]' )
            else
                map_command+=( -map $video_shift_index:v )
            fi

            if ! [[ $input_flags =~ -an ]] && ! [[ $output_flags =~ -an ]]
            then
                if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ] 
                then
                    map_command+=( -map '[delayed_audio]' )
                else
                    map_command+=( -map $audio_shift_index:a )
                fi
            fi
        fi
    else
        IFS="," read -r -a qualities <<< "$quality"
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a variants <<< "$bitrates"

            for((i=0;i<${#variants[@]};i++));
            do
                variant=${variants[i]}

                if [[ $variant =~ - ]] 
                then
                    bitrates=${variant%-*}
                    resolution=${variant#*-}

                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -bufsize:v:$i ${bitrates}k -maxrate:v:$i ${bitrates}k )

                    if [ "$video_codec" == "libx265" ]
                    then
                        variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${bitrates}k --vbv-bufsize:v:$i ${bitrates}k )
                    fi

                    variants_output_command+=( -s:v:$i $resolution )
                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((bitrates*1000)),RESOLUTION=$resolution$subtitle_append\n"
                elif [[ $variant =~ x ]] 
                then
                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -s:v:$i $variant )
                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=$variant$subtitle_append\n"
                else
                    variants_output_command+=( -crf:v:$i ${qualities[i]:-${quality[0]}} -bufsize:v:$i ${variant}k -maxrate:v:$i ${variant}k )

                    if [ "$video_codec" == "libx265" ]
                    then
                        variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${variant}k --vbv-bufsize:v:$i ${variant}k )
                    fi

                    hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((variant*1000))$subtitle_append\n"
                fi

                hls_master_list="$hls_master_list${playlist_name}_crf_${qualities[i]:-${quality[0]}}_$variant.m3u8\n\n"

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    var_stream_map="$var_stream_map v:$i,name:crf_${qualities[i]:-${quality[0]}}_$variant"
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ]
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi

                    var_stream_map="$var_stream_map v:$i,a:$i,name:crf_${qualities[i]:-${quality[0]}}_$variant"
                fi
            done
        else
            for((i=0;i<${#qualities[@]};i++));
            do
                variants_output_command+=( -crf:v:$i ${qualities[i]} )

                if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                then
                    [ -n "$filter_complex" ] && filter_complex="$filter_complex;"
                    filter_complex="${filter_complex}[$video_shift_index:v] ${extra_filters}drawtext=$draw_text [drawtext_video_$i]"
                fi

                if [[ $input_flags =~ -an ]] || [[ $output_flags =~ -an ]] 
                then
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    var_stream_map="$var_stream_map v:$i,name:crf_${qualities[i]}"
                else
                    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
                    then
                        map_command+=( -map "[drawtext_video_$i]" )
                    else
                        map_command+=( -map $video_shift_index:v )
                    fi

                    if [ -n "${audio_shift:-}" ] && [ "$audio_codec" != "copy" ]
                    then
                        map_command+=( -map '[delayed_audio]' )
                    else
                        map_command+=( -map $audio_shift_index:a )
                    fi

                    var_stream_map="$var_stream_map v:$i,a:$i,name:crf_${qualities[i]}"
                fi

                hls_master_list="$hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$(((22-qualities[i])*100000+4200000))$subtitle_append\n"
                hls_master_list="$hls_master_list${playlist_name}_crf_${qualities[i]}.m3u8\n\n"
            done
        fi
    fi

    variants_output_command+=( -c:v "$video_codec" -c:a "$audio_codec" )

    if [ -n "$subtitle_append" ] 
    then
        variants_output_command+=( -c:s webvtt )
    fi

    variants_output_command+=( $output_flags_command )

    if [ -n "$filter_complex" ] 
    then
        input_command+=( -filter_complex "$filter_complex" )
    fi

    if [ -n "$var_stream_map" ] 
    then
        var_stream_map_command+=( -var_stream_map "$var_stream_map" )
    fi

    if [ "$encrypt_yn" == "yes" ] 
    then
        openssl rand 16 > "$output_dir_root/$key_name.key"
        if [ "$encrypt_session_yn" == "yes" ] 
        then
            echo -e "/keys?key=$key_name&channel=$output_dir_name\n$output_dir_root/$key_name.key\n$(openssl rand -hex 16)" > "$output_dir_root/$keyinfo_name.keyinfo"
        else
            echo -e "$key_name.key\n$output_dir_root/$key_name.key\n$(openssl rand -hex 16)" > "$output_dir_root/$keyinfo_name.keyinfo"
        fi
        hls_command+=( -hls_key_info_file "$output_dir_root/$keyinfo_name.keyinfo" )
    fi

    if [ "$master" -eq 0 ] 
    then
        hls_command+=( -hls_segment_filename "$output_dir_root/$seg_dir_path${seg_name}_%05d.ts" )
        hls_command+=( "$output_dir_root/$playlist_name.m3u8" )
    else
        echo -e "$hls_master_list" > "$output_dir_root/${playlist_name}_master.m3u8"
        hls_command+=( -hls_segment_filename "$output_dir_root/$seg_dir_path${seg_name}_%v_%05d.ts" )
        hls_command+=( "$output_dir_root/${playlist_name}_%v.m3u8" )
    fi

    PrepTerm
    $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    ${input_command[@]+"${input_command[@]}"} \
    ${variants_output_command[@]+"${variants_output_command[@]}"} \
    ${map_command[@]+"${map_command[@]}"} \
    -flags -global_header \
    -f hls ${var_stream_map_command[@]+"${var_stream_map_command[@]}"} \
    ${hls_command[@]+"${hls_command[@]}"} > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
    WaitTerm

    # seg
    # PrepTerm
    # $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    # ${input_command[@]+"${input_command[@]}"} \
    # ${variants_output_command[@]+"${variants_output_command[@]}"} \
    # ${map_command[@]+"${map_command[@]}"} \
    # -flags -global_header \
    # -f segment ${var_stream_map_command[@]+"${var_stream_map_command[@]}"} \
    # -segment_time "$seg_length" -segment_format mpeg_ts \
    # -segment_list $output_dir_root/$playlist_name.m3u8 $output_dir_root/$seg_dir_path${seg_name}_%05d.ts \
    # ${segment_command[@]+"${segment_command[@]}"} > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
    # WaitTerm
            } 201>"$pid_file"
        ;;
        "StartChannel") 
            new_pid=$pid
            delete_on_term=$chnl_output_dir_root
            pid_file="$FFMPEG_LOG_ROOT/$new_pid.pid"
            {
                flock -x 201
                JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
                {
                    pid: '"$new_pid"',
                    status: "on",
                    stream_link: "'"$chnl_stream_links"'",
                    user_agent: "'"$chnl_user_agent"'",
                    headers: "'"$chnl_headers"'",
                    cookies: "'"$chnl_cookies"'",
                    playlist_name: "'"$chnl_playlist_name"'",
                    seg_name: "'"$chnl_seg_name"'",
                    key_name: "'"$chnl_key_name"'",
                    key_time: '"$chnl_key_time"',
                    channel_time: '"$chnl_channel_time"'
                } // .)'

                action="start"
                SyncFile

                trap '
                    JQ update "$CHANNELS_FILE" ".channels|=map(select(.pid==$new_pid) * { status: \"off\" } // .)"
                    printf -v date_now "%(%m-%d %H:%M:%S)T" -1
                    printf "%s\n" "`eval_gettext \"\\\$date_now \\\$chnl_channel_name HLS 关闭\"`" >> "$MONITOR_LOG"
                    chnl_pid=$new_pid
                    action="stop"
                    SyncFile > /dev/null 2>> "$MONITOR_LOG"
                    rm -rf "$delete_on_term"
                ' EXIT

    mkdir -p "$delete_on_term"

    chnl_variants_input_command=()
    chnl_variants_output_command=()
    chnl_map_command=()
    chnl_var_stream_map_command=()
    chnl_hls_command=( -hls_time "$chnl_seg_length" -hls_list_size "$chnl_seg_count" )
    # chnl_segment_command=()
    chnl_hls_master_list="#EXTM3U\n#EXT-X-VERSION:7\n"
    chnl_var_stream_map=""
    chnl_headers_command=""
    [ -n "$chnl_headers" ] && printf -v chnl_headers_command '%b' "$chnl_headers"

    if [ "$chnl_seg_count" -gt 0 ] 
    then
        chnl_hls_command+=( -hls_delete_threshold $chnl_seg_count )
    fi

    if [ -n "$chnl_live" ] 
    then
        # chnl_segment_command+=( -segment_list_flags +live -segment_list_size $chnl_seg_count -segment_wrap $((chnl_seg_count * 2)) )

        if [ "$chnl_seg_count" -gt 0 ] 
        then
            chnl_hls_command+=( -hls_flags periodic_rekey+delete_segments )
        else
            chnl_hls_command+=( -hls_flags periodic_rekey )
        fi
    else
        chnl_hls_command+=( -hls_flags periodic_rekey )
    fi

    chnl_seg_dir_path=""
    if [ -n "$chnl_seg_dir_name" ] 
    then
        chnl_seg_dir_path="$chnl_seg_dir_name/"
    fi

    if [ -n "${chnl_stream_link_cdn:-}" ] 
    then
        chnl_stream_link=$chnl_stream_link_cdn
    fi

    if [ "${chnl_stream_link_qualities_count:-0}" -gt 1 ] || [ "${chnl_stream_link_audio_count:-0}" -gt 0 ] || [ "${chnl_stream_link_subtitles_count:-0}" -gt 0 ]
    then
        if [ "$chnl_origin_hls_url" -eq 1 ] 
        then
            if [[ $chnl_stream_link =~ ^https?:// ]] 
            then
                [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
            elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
            fi
            chnl_variants_input_command+=( $chnl_input_flags_command -i "$chnl_stream_link" )
        fi

        for((i=0;i<chnl_stream_link_qualities_count;i++));
        do
            chnl_var_stream_map="$chnl_var_stream_map v:$i"

            chnl_stream_links_index=${chnl_stream_link_video_indices[i]}

            chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=${chnl_stream_links_bitrate[chnl_stream_links_index]},AVERAGE-BANDWIDTH=${chnl_stream_links_bitrate[chnl_stream_links_index]},RESOLUTION=${chnl_stream_links_resolution[chnl_stream_links_index]}"

            if [ -n "${chnl_stream_links_audio[chnl_stream_links_index]}" ] 
            then
                if [ "${chnl_stream_link_audio_count:-0}" -gt 0 ] 
                then
                    for chnl_stream_link_audio_index in "${chnl_stream_link_audio_indices[@]}"
                    do
                        if [ "${chnl_stream_audio_group_id[chnl_stream_link_audio_index]}" == "${chnl_stream_links_audio[chnl_stream_links_index]}" ] 
                        then
                            chnl_hls_master_list="$chnl_hls_master_list,AUDIO=\"${chnl_stream_links_audio[chnl_stream_links_index]}\""
                            chnl_var_stream_map="$chnl_var_stream_map,agroup:${chnl_stream_links_audio[chnl_stream_links_index]}"
                            break
                        fi
                    done
                fi
            else
                chnl_var_stream_map="$chnl_var_stream_map,a:$i"
            fi

            if [ -n "${chnl_stream_links_subtitles[chnl_stream_links_index]}" ] && [ "${chnl_stream_link_subtitles_count:-0}" -gt 0 ]
            then
                for chnl_stream_link_subtitles_index in "${chnl_stream_link_subtitles_indices[@]}"
                do
                    if [ "${chnl_stream_subtitles_group_id[chnl_stream_link_subtitles_index]}" == "${chnl_stream_links_subtitles[chnl_stream_links_index]}" ] 
                    then
                        chnl_hls_master_list="$chnl_hls_master_list,SUBTITLES=\"${chnl_stream_links_subtitles[chnl_stream_links_index]}\""
                        chnl_var_stream_map="$chnl_var_stream_map,sgroup:${chnl_stream_links_subtitles[chnl_stream_links_index]}"
                        break
                    fi
                done
            fi

            chnl_hls_master_list="$chnl_hls_master_list\n${chnl_playlist_name}_${chnl_stream_links_resolution[chnl_stream_links_index]}.m3u8\n\n"
            chnl_var_stream_map="$chnl_var_stream_map,name:${chnl_stream_links_resolution[chnl_stream_links_index]}"

            if [ "$chnl_origin_hls_url" -eq 0 ] 
            then
                if [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^https?:// ]] 
                then
                    [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                    [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                    [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                    [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
                elif [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^icecast?:// ]] 
                then
                    [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                fi
                chnl_variants_input_command+=( $chnl_input_flags_command -i "${chnl_stream_links_url[chnl_stream_links_index]}" )
                chnl_map_command+=( -map $i:v )
            else
                chnl_map_command+=( -map 0:v:$chnl_stream_links_index )
            fi

            if [ "$chnl_video_codec" != "copy" ] 
            then
                if [[ ${chnl_stream_link_qualities[i]} =~ - ]] 
                then
                    chnl_variant_bitrate=${chnl_stream_link_qualities[i]%-*}
                    chnl_variant_resolution=${chnl_stream_link_qualities[i]#*-}

                    if [ -n "$chnl_const" ]
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant_bitrate}k -bufsize:v:$i ${chnl_variant_bitrate}k -minrate:v:$i ${chnl_variant_bitrate}k -maxrate:v:$i ${chnl_variant_bitrate}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant_bitrate}k )
                    fi

                    chnl_variants_output_command+=( -s:v:$i $chnl_variant_resolution )
                elif [[ ${chnl_stream_link_qualities[i]} =~ x ]] 
                then
                    chnl_variants_output_command+=( -s:v:$i ${chnl_stream_link_qualities[i]} )
                else
                    if [ -n "$chnl_const" ]
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_stream_link_qualities[i]}k -bufsize:v:$i ${chnl_stream_link_qualities[i]}k -minrate:v:$i ${chnl_stream_link_qualities[i]}k -maxrate:v:$i ${chnl_stream_link_qualities[i]}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_stream_link_qualities[i]}k )
                    fi
                fi
            fi
        done

        chnl_variants_output_command+=( -c:v "$chnl_video_codec" -c:a "$chnl_audio_codec" )

        if [ -n "${chnl_stream_audio_url:-}" ] 
        then
            if [ "${chnl_stream_link_audio_count:-0}" -gt 0 ] 
            then
                for((i=0;i<chnl_stream_link_audio_count;i++));
                do
                    chnl_stream_link_audio_index=${chnl_stream_link_audio_indices[i]}

                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"${chnl_stream_audio_group_id[chnl_stream_link_audio_index]}\",NAME=\"${chnl_stream_audio_name[chnl_stream_link_audio_index]}\",DEFAULT=\"${chnl_stream_audio_default[chnl_stream_link_audio_index]}\",AUTOSELECT=YES,LANGUAGE=\"${chnl_stream_audio_language[chnl_stream_link_audio_index]}\",URI=\"${chnl_playlist_name}_${chnl_stream_audio_name[chnl_stream_link_audio_index]}.m3u8\"\n"
                    chnl_var_stream_map="$chnl_var_stream_map a:$i,agroup:${chnl_stream_audio_group_id[chnl_stream_link_audio_index]},default:${chnl_stream_audio_default[chnl_stream_link_audio_index]},language:${chnl_stream_audio_language[chnl_stream_link_audio_index]},name:${chnl_stream_audio_name[chnl_stream_link_audio_index]}"

                    if [ "$chnl_origin_hls_url" -eq 0 ] 
                    then
                        if [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^https?:// ]] 
                        then
                            [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                            [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                            [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                            [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
                        elif [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^icecast?:// ]] 
                        then
                            [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                        fi
                        chnl_variants_input_command+=( $chnl_input_flags_command -i "${chnl_stream_audio_url[chnl_stream_link_audio_index]}" )
                        chnl_map_command+=( -map $((i+chnl_stream_link_qualities_count)):a )
                    else
                        chnl_map_command+=( -map 0:a:$chnl_stream_link_audio_index )
                    fi
                done
            fi
        else
            for((i=0;i<chnl_stream_link_qualities_count;i++));
            do
                if [ "$chnl_origin_hls_url" -eq 0 ] 
                then
                    chnl_map_command+=( -map $i:a )
                else
                    chnl_map_command+=( -map 0:a:$i )
                fi
            done
        fi

        if [ "${chnl_stream_link_subtitles_count:-0}" -gt 0 ] 
        then
            for((i=0;i<chnl_stream_link_subtitles_count;i++));
            do
                chnl_stream_link_subtitles_index=${chnl_stream_link_subtitles_indices[i]}

                if [[ ${chnl_stream_subtitles_url[chnl_stream_link_subtitles_index]} =~ $hboasia_host/(.+)$ ]] 
                then
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"${chnl_stream_subtitles_group_id[chnl_stream_link_subtitles_index]}\",NAME=\"${chnl_stream_subtitles_name[chnl_stream_link_subtitles_index]}\",DEFAULT=\"${chnl_stream_subtitles_default[chnl_stream_link_subtitles_index]}\",AUTOSELECT=YES,LANGUAGE=\"${chnl_stream_subtitles_language[chnl_stream_link_subtitles_index]}\",URI=\"https://hboasia.epub.fun/${BASH_REMATCH[1]%%\?*}\"\n"
                    continue
                fi

                chnl_hls_master_list="$chnl_hls_master_list#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"${chnl_stream_subtitles_group_id[chnl_stream_link_subtitles_index]}\",NAME=\"${chnl_stream_subtitles_name[chnl_stream_link_subtitles_index]}\",DEFAULT=\"${chnl_stream_subtitles_default[chnl_stream_link_subtitles_index]}\",AUTOSELECT=YES,LANGUAGE=\"${chnl_stream_subtitles_language[chnl_stream_link_subtitles_index]}\",URI=\"${chnl_stream_subtitles_group_id[chnl_stream_link_subtitles_index]}_${chnl_stream_subtitles_name[chnl_stream_link_subtitles_index]}_vtt.m3u8\"\n"
                chnl_var_stream_map="$chnl_var_stream_map s:$i,sgroup:${chnl_stream_subtitles_group_id[chnl_stream_link_subtitles_index]},default:${chnl_stream_subtitles_default[chnl_stream_link_subtitles_index]},language:${chnl_stream_subtitles_language[chnl_stream_link_subtitles_index]},name:${chnl_stream_subtitles_name[chnl_stream_link_subtitles_index]}"

                if [ "$chnl_origin_hls_url" -eq 0 ] 
                then
                    if [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^https?:// ]] 
                    then
                        [ -n "$chnl_proxy" ] && chnl_variants_input_command+=( -http_proxy "$chnl_proxy" )
                        [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                        [ -n "$chnl_headers_command" ] && chnl_variants_input_command+=( -headers "$chnl_headers_command" )
                        [ -n "$chnl_cookies" ] && chnl_variants_input_command+=( -cookies "$chnl_cookies" )
                    elif [[ ${chnl_stream_links_url[chnl_stream_links_index]} =~ ^icecast?:// ]] 
                    then
                        [ -n "$chnl_user_agent" ] && chnl_variants_input_command+=( -user_agent "$chnl_user_agent" )
                    fi
                    chnl_variants_input_command+=( $chnl_input_flags_command -i "${chnl_stream_subtitles_url[chnl_stream_link_subtitles_index]}" )
                    chnl_map_command+=( -map $((i+chnl_stream_link_qualities_count+chnl_stream_link_audio_count)):s )
                else
                    chnl_map_command+=( -map 0:s:${chnl_stream_link_subtitles_index}? )
                fi
            done

            chnl_variants_output_command+=( -c:s webvtt )
        fi

        chnl_variants_output_command+=( $chnl_output_flags_command )
        chnl_var_stream_map_command+=( -var_stream_map "$chnl_var_stream_map" )

        if [ "$chnl_encrypt_yn" == "yes" ] 
        then
            openssl rand 16 > "$chnl_output_dir_root/$chnl_key_name.key"
            if [ "$chnl_encrypt_session_yn" == "yes" ] 
            then
                echo -e "/keys?key=$chnl_key_name&channel=$chnl_output_dir_name\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
            else
                echo -e "$chnl_key_name.key\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
            fi
            chnl_hls_command+=( -hls_key_info_file "$chnl_output_dir_root/$chnl_keyinfo_name".keyinfo )
        fi

        echo -e "$chnl_hls_master_list" > "$chnl_output_dir_root/${chnl_playlist_name}_master.m3u8"
        chnl_hls_command+=( -hls_segment_filename "$chnl_output_dir_root/$chnl_seg_dir_path${chnl_seg_name}"_%v_%05d.ts )
        chnl_hls_command+=( "$chnl_output_dir_root/${chnl_playlist_name}_%v.m3u8" )

        PrepTerm
        $FFMPEG ${global_options[@]+"${global_options[@]}"} \
        ${chnl_variants_input_command[@]+"${chnl_variants_input_command[@]}"} \
        ${chnl_variants_output_command[@]+"${chnl_variants_output_command[@]}"} \
        ${chnl_map_command[@]+"${chnl_map_command[@]}"} \
        -flags -global_header \
        -f hls ${chnl_var_stream_map_command[@]+"${chnl_var_stream_map_command[@]}"} \
        ${chnl_hls_command[@]+"${chnl_hls_command[@]}"} > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
        WaitTerm
        exit 0
    fi

    chnl_input_command=()
    chnl_filter_complex=""

    if [ "${chnl_stream_link_qualities_count:-0}" -eq 1 ] 
    then
        chnl_stream_links_index=${chnl_stream_link_video_indices[0]}
        chnl_stream_link=${chnl_stream_links_url[chnl_stream_links_index]}
    fi

    if [[ $chnl_stream_link =~ ^https?:// ]] 
    then
        [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
        [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
        [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
        [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
    elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
    then
        [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
    fi

    chnl_input_command+=( $chnl_input_flags_command -i $chnl_stream_link )

    chnl_video_shift_index=0
    chnl_audio_shift_index=0
    if ! [[ $chnl_input_flags =~ -an ]] && ! [[ $chnl_output_flags =~ -an ]] 
    then
        if [ -n "${chnl_video_shift:-}" ] 
        then
            chnl_video_shift_index=1
            if [[ $chnl_stream_link =~ ^https?:// ]] 
            then
                [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
                [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
                [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
            elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
            then
                [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
            fi
            chnl_input_command+=( $chnl_input_flags_command -itsoffset $chnl_video_shift -i $chnl_stream_link )
        elif [ -n "${chnl_audio_shift:-}" ] 
        then
            if [ "$chnl_audio_codec" == "copy" ] 
            then
                chnl_audio_shift_index=1
                if [[ $chnl_stream_link =~ ^https?:// ]] 
                then
                    [ -n "$chnl_proxy" ] && chnl_input_command+=( -http_proxy "$chnl_proxy" )
                    [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                    [ -n "$chnl_headers_command" ] && chnl_input_command+=( -headers "$chnl_headers_command" )
                    [ -n "$chnl_cookies" ] && chnl_input_command+=( -cookies "$chnl_cookies" )
                elif [[ $chnl_stream_link =~ ^icecast?:// ]] 
                then
                    [ -n "$chnl_user_agent" ] && chnl_input_command+=( -user_agent "$chnl_user_agent" )
                fi
                chnl_input_command+=( $chnl_input_flags_command -itsoffset $chnl_audio_shift -i $chnl_stream_link )
            else
                chnl_input_command+=( -filter_complex "[0:a] adelay=delays=${chnl_audio_shift}s:all=1 [delayed_audio]" )
            fi
        fi
    fi

    if [ -z "$chnl_quality" ]
    then
        if [ -n "$chnl_bitrates" ] 
        then
            IFS="," read -r -a chnl_variants <<< "$chnl_bitrates"

            for((i=0;i<${#chnl_variants[@]};i++));
            do
                chnl_variant=${chnl_variants[i]}

                if [[ $chnl_variant =~ - ]] 
                then
                    chnl_bitrates=${chnl_variant%-*}
                    chnl_resolution=${chnl_variant#*-}

                    if [ -n "$chnl_const" ] 
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_bitrates}k -bufsize:v:$i ${chnl_bitrates}k -minrate:v:$i ${chnl_bitrates}k -maxrate:v:$i ${chnl_bitrates}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_bitrates}k )
                    fi

                    chnl_variants_output_command+=( -s:v:$i $chnl_resolution )
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((chnl_bitrates*1000)),RESOLUTION=$chnl_resolution$chnl_subtitle_append\n"
                elif [[ $chnl_variant == *"x"* ]] 
                then
                    chnl_variants_output_command+=( -s:v:$i $chnl_variant )
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=$chnl_variant$chnl_subtitle_append\n"
                else
                    if [ -n "$chnl_const" ] 
                    then
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant}k -bufsize:v:$i ${chnl_variant}k -minrate:v:$i ${chnl_variant}k -maxrate:v:$i ${chnl_variant}k )
                    else
                        chnl_variants_output_command+=( -b:v:$i ${chnl_variant}k )
                    fi
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((chnl_variant*1000))$chnl_subtitle_append\n"
                fi

                chnl_hls_master_list="$chnl_hls_master_list${chnl_playlist_name}_$chnl_variant.m3u8\n\n"

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,name:$chnl_variant"
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ] 
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,a:$i,name:$chnl_variant"
                fi
            done
        else
            if [ -n "$chnl_subtitle_append" ] 
            then
                chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000$chnl_subtitle_append\n${chnl_playlist_name}_vtt.m3u8\n\n"
            fi

            if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
            then
                chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video]"
                chnl_map_command+=( -map '[drawtext_video]' )
            else
                chnl_map_command+=( -map $chnl_video_shift_index:v )
            fi

            if ! [[ $chnl_input_flags =~ -an ]] && ! [[ $chnl_output_flags =~ -an ]]
            then
                if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ] 
                then
                    chnl_map_command+=( -map '[delayed_audio]' )
                else
                    chnl_map_command+=( -map $chnl_audio_shift_index:a )
                fi
            fi
        fi
    else
        IFS="," read -r -a chnl_qualities <<< "$chnl_quality"
        if [ -n "$bitrates" ] 
        then
            IFS="," read -r -a chnl_variants <<< "$chnl_bitrates"

            for((i=0;i<${#chnl_variants[@]};i++));
            do
                chnl_variant=${chnl_variants[i]}

                if [[ $chnl_variant =~ - ]] 
                then
                    chnl_bitrates=${chnl_variant%-*}
                    chnl_resolution=${chnl_variant#*-}

                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -bufsize:v:$i ${chnl_bitrates}k -maxrate:v:$i ${chnl_bitrates}k )

                    if [ "$chnl_video_codec" == "libx265" ]
                    then
                        chnl_variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${chnl_bitrates}k --vbv-bufsize:v:$i ${chnl_bitrates}k )
                    fi

                    chnl_variants_output_command+=( -s:v:$i $chnl_resolution )
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((chnl_bitrates*1000)),RESOLUTION=$chnl_resolution$chnl_subtitle_append\n"
                elif [[ $chnl_variant == *"x"* ]] 
                then
                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -s:v:$i $chnl_variant )
                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=$chnl_variant$chnl_subtitle_append\n"
                else
                    chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]:-${chnl_quality[0]}} -bufsize:v:$i ${chnl_variant}k -maxrate:v:$i ${chnl_variant}k )

                    if [ "$chnl_video_codec" == "libx265" ]
                    then
                        chnl_variants_output_command+=( -x265-params:v:$i --vbv-maxrate:v:$i ${chnl_variant}k --vbv-bufsize:v:$i ${chnl_variant}k )
                    fi

                    chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$((chnl_variant*1000))$chnl_subtitle_append\n"
                fi

                chnl_hls_master_list="$chnl_hls_master_list${chnl_playlist_name}_crf_${chnl_qualities[i]:-${chnl_quality[0]}}_$chnl_variant.m3u8\n\n"

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,name:crf_${chnl_qualities[i]:-${chnl_quality[0]}}_$chnl_variant"
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ]
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,a:$i,name:crf_${chnl_qualities[i]:-${chnl_quality[0]}}_$chnl_variant"
                fi
            done
        else
            for((i=0;i<${#chnl_qualities[@]};i++));
            do
                chnl_variants_output_command+=( -crf:v:$i ${chnl_qualities[i]} )

                if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                then
                    [ -n "$chnl_filter_complex" ] && chnl_filter_complex="$chnl_filter_complex;"
                    chnl_filter_complex="${chnl_filter_complex}[$chnl_video_shift_index:v] ${chnl_extra_filters}drawtext=$chnl_draw_text [drawtext_video_$i]"
                fi

                if [[ $chnl_input_flags =~ -an ]] || [[ $chnl_output_flags =~ -an ]] 
                then
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,name:crf_${chnl_qualities[i]}"
                else
                    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
                    then
                        chnl_map_command+=( -map "[drawtext_video_$i]" )
                    else
                        chnl_map_command+=( -map $chnl_video_shift_index:v )
                    fi

                    if [ -n "${chnl_audio_shift:-}" ] && [ "$chnl_audio_codec" != "copy" ]
                    then
                        chnl_map_command+=( -map '[delayed_audio]' )
                    else
                        chnl_map_command+=( -map $chnl_audio_shift_index:a )
                    fi

                    chnl_var_stream_map="$chnl_var_stream_map v:$i,a:$i,name:crf_${chnl_qualities[i]}"
                fi

                chnl_hls_master_list="$chnl_hls_master_list#EXT-X-STREAM-INF:BANDWIDTH=$(((22-chnl_qualities[i])*100000+4200000))$chnl_subtitle_append\n"
                chnl_hls_master_list="$chnl_hls_master_list${chnl_playlist_name}_crf_${chnl_qualities[i]}.m3u8\n\n"
            done
        fi
    fi

    chnl_variants_output_command+=( -c:v "$chnl_video_codec" -c:a "$chnl_audio_codec" )

    if [ -n "$chnl_subtitle_append" ] 
    then
        chnl_variants_output_command+=( -c:s webvtt )
    fi

    chnl_variants_output_command+=( $chnl_output_flags_command )

    if [ -n "$chnl_filter_complex" ] 
    then
        chnl_input_command+=( -filter_complex "$chnl_filter_complex" )
    fi

    if [ -n "$chnl_var_stream_map" ] 
    then
        chnl_var_stream_map_command=( -var_stream_map "$chnl_var_stream_map" )
    fi

    if [ "$chnl_encrypt_yn" == "yes" ] 
    then
        openssl rand 16 > "$chnl_output_dir_root/$chnl_key_name.key"
        if [ "$chnl_encrypt_session_yn" == "yes" ] 
        then
            echo -e "/keys?key=$chnl_key_name&channel=$chnl_output_dir_name\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
        else
            echo -e "$chnl_key_name.key\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
        fi
        chnl_hls_command+=( -hls_key_info_file "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo" )
    fi

    if [ "$master" -eq 0 ] 
    then
        chnl_hls_command+=( -hls_segment_filename "$chnl_output_dir_root/$chnl_seg_dir_path${chnl_seg_name}_%05d.ts" )
        chnl_hls_command+=( "$chnl_output_dir_root/$chnl_playlist_name.m3u8" )
    else
        echo -e "$chnl_hls_master_list" > "$chnl_output_dir_root/${chnl_playlist_name}_master.m3u8"
        chnl_hls_command+=( -hls_segment_filename "$chnl_output_dir_root/$chnl_seg_dir_path${chnl_seg_name}_%v_%05d.ts" )
        chnl_hls_command+=( "$chnl_output_dir_root/${chnl_playlist_name}_%v.m3u8" )
    fi

    # https://stackoverflow.com/questions/23235651/how-can-i-do-ansi-c-quoting-of-an-existing-bash-variable
    PrepTerm
    $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    ${chnl_input_command[@]+"${chnl_input_command[@]}"} \
    ${chnl_variants_output_command[@]+"${chnl_variants_output_command[@]}"} \
    ${chnl_map_command[@]+"${chnl_map_command[@]}"} \
    -flags -global_header \
    -f hls ${chnl_var_stream_map_command[@]+"${chnl_var_stream_map_command[@]}"} \
    ${chnl_hls_command[@]+"${chnl_hls_command[@]}"} > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
    WaitTerm

    # seg
    # PrepTerm
    # $FFMPEG ${global_options[@]+"${global_options[@]}"} \
    # ${chnl_input_command[@]+"${chnl_input_command[@]}"} \
    # ${variants_output_command[@]+"${variants_output_command[@]}"} \
    # ${chnl_map_command[@]+"${chnl_map_command[@]}"} \
    # -flags -global_header $chnl_output_flags \
    # -f segment ${chnl_var_stream_map_command[@]+"${chnl_var_stream_map_command[@]}"} \
    # -segment_time "$chnl_seg_length" -segment_format mpeg_ts \
    # -segment_list $chnl_output_dir_root/$chnl_playlist_name.m3u8 $chnl_output_dir_root/$chnl_seg_dir_path${chnl_seg_name}_%05d.ts \
    # ${chnl_segment_command[@]+"${chnl_segment_command[@]}"} > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
    # WaitTerm
            } 201>"$pid_file"
        ;;
    esac
}

HlsStreamCreator()
{
    trap '' HUP INT
    unset force_exit
    pkill=1
    pid="$BASHPID"
    if [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$pid"')' "$CHANNELS_FILE") ]] 
    then
        true &
        rand_pid=$!
        while [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$rand_pid"')' "$CHANNELS_FILE") ]] 
        do
            true &
            rand_pid=$!
        done

        JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$pid"')|.pid)='"$rand_pid"''
    fi
    case $from in
        "AddChannel") 
            delete_on_term=$output_dir_root
            pid_file="$FFMPEG_LOG_ROOT/$pid.pid"
            {
                flock -x 201
                new_channel=$(
                $JQ_FILE -n --arg pid "$pid" --arg status "on" \
                    --arg stream_link "$stream_links" --arg live "$live_yn" \
                    --arg proxy "$proxy" --arg xc_proxy "$xc_proxy" \
                    --arg user_agent "$user_agent" --arg headers "$headers" \
                    --arg cookies "$cookies" --arg output_dir_name "$output_dir_name" \
                    --arg playlist_name "$playlist_name" --arg seg_dir_name "$seg_dir_name" \
                    --arg seg_name "$seg_name" --arg seg_length "$seg_length" \
                    --arg seg_count "$seg_count" --arg video_codec "$video_codec" \
                    --arg audio_codec "$audio_codec" --arg video_audio_shift "$video_audio_shift" \
                    --arg txt_format "$txt_format" --arg draw_text "$draw_text" \
                    --arg quality "$quality" \
                    --arg bitrates "$bitrates" --arg const "$const_yn" \
                    --arg encrypt "$encrypt_yn" --arg encrypt_session "$encrypt_session_yn" \
                    --arg keyinfo_name "$keyinfo_name" --arg key_name "$key_name" \
                    --arg input_flags "$input_flags" --arg output_flags "$output_flags" \
                    --arg channel_name "$channel_name" --arg sync "$sync_yn" \
                    --arg sync_file "$sync_file" --arg sync_index "$sync_index" \
                    --arg sync_pairs "$sync_pairs" --arg flv_status "off" --arg flv_h265 "$flv_h265_yn" \
                    --arg flv_push_link '' --arg flv_pull_link '' \
                    '{
                        pid: $pid | tonumber,
                        status: $status,
                        stream_link: $stream_link,
                        live: $live,
                        proxy: $proxy,
                        xc_proxy: $xc_proxy,
                        user_agent: $user_agent,
                        headers: $headers,
                        cookies: $cookies,
                        output_dir_name: $output_dir_name,
                        playlist_name: $playlist_name,
                        seg_dir_name: $seg_dir_name,
                        seg_name: $seg_name,
                        seg_length: $seg_length | tonumber,
                        seg_count: $seg_count | tonumber,
                        video_codec: $video_codec,
                        audio_codec: $audio_codec,
                        video_audio_shift: $video_audio_shift,
                        txt_format: $txt_format,
                        draw_text: $draw_text,
                        quality: $quality,
                        bitrates: $bitrates,
                        const: $const,
                        encrypt: $encrypt,
                        encrypt_session: $encrypt_session,
                        keyinfo_name: $keyinfo_name,
                        key_name: $key_name,
                        key_time: now|strflocaltime("%s")|tonumber,
                        input_flags: $input_flags,
                        output_flags: $output_flags,
                        channel_name: $channel_name,
                        channel_time: now|strflocaltime("%s")|tonumber,
                        sync: $sync,
                        sync_file: $sync_file,
                        sync_index: $sync_index,
                        sync_pairs: $sync_pairs,
                        flv_status: $flv_status,
                        flv_h265: $flv_h265,
                        flv_push_link: $flv_push_link,
                        flv_pull_link: $flv_pull_link
                    }'
                )

                JQ add "$CHANNELS_FILE" channels "[$new_channel]"

                action="add"
                SyncFile

                trap '
                    JQ update "$CHANNELS_FILE" "(.channels[]|select(.pid==$pid)|.status)=\"off\""
                    printf -v date_now "%(%m-%d %H:%M:%S)T" -1
                    printf "%s\n" "`eval_gettext \"\\\$date_now \\\$channel_name HLS 关闭\"`" >> "$MONITOR_LOG"
                    chnl_pid=$pid
                    action="stop"
                    SyncFile > /dev/null 2>> "$MONITOR_LOG"
                    rm -rf "$delete_on_term"
                ' EXIT

                mkdir -p "$delete_on_term"

                if [ -n "$live" ]
                then
                    seg_count_command="-c $seg_count"
                else
                    seg_count_command=""
                fi

                if [ -n "$encrypt" ] 
                then
                    key_name_command="-K $key_name"
                else
                    key_name_command=""
                fi

                if [ -n "$quality" ] 
                then
                    quality_command="-q ${quality%%,*}"
                else
                    quality_command=""
                fi

                if [ -n "$bitrates" ] 
                then
                    bitrates_command="-b $bitrates"
                else
                    bitrates_command=""
                fi

                if [ -n "$seg_dir_name" ] 
                then
                    seg_dir_name_command="-S $seg_dir_name"
                else
                    seg_dir_name_command=""
                fi

                if [[ $stream_link =~ ^https?:// ]] 
                then
                    export FFMPEG_PROXY=$proxy
                    export FFMPEG_USER_AGENT=$user_agent
                    export FFMPEG_HEADERS=$headers
                    export FFMPEG_COOKIES=$cookies
                elif [[ $stream_link =~ ^icecast:// ]] 
                then
                    export FFMPEG_USER_AGENT=$user_agent
                fi

                export FFMPEG_INPUT_FLAGS=$input_flags
                export FFMPEG_FLAGS=$output_flags
                export AUDIO_CODEC=$audio_codec
                export VIDEO_CODEC=$video_codec

                PrepTerm
                $CREATOR_FILE $live -i "$stream_link" -s "$seg_length" \
                -o "$output_dir_root" $seg_count_command $bitrates_command $seg_dir_name_command \
                -p "$playlist_name" -t "$seg_name" $key_name_command $quality_command \
                $const $encrypt > "$FFMPEG_LOG_ROOT/$pid.log" 2> "$FFMPEG_LOG_ROOT/$pid.err" &
                WaitTerm
            } 201>"$pid_file"
        ;;
        "StartChannel") 
            new_pid=$pid
            delete_on_term=$chnl_output_dir_root
            pid_file="$FFMPEG_LOG_ROOT/$new_pid.pid"
            {
                flock -x 201
                JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
                {
                    pid: '"$new_pid"',
                    status: "on",
                    stream_link: "'"$chnl_stream_links"'",
                    user_agent: "'"$chnl_user_agent"'",
                    headers: "'"$chnl_headers"'",
                    cookies: "'"$chnl_cookies"'",
                    playlist_name: "'"$chnl_playlist_name"'",
                    seg_name: "'"$chnl_seg_name"'",
                    key_name: "'"$chnl_key_name"'",
                    key_time: '"$chnl_key_time"',
                    channel_time: '"$chnl_channel_time"'
                } // .)'

                action="start"
                SyncFile

                trap '
                    JQ update "$CHANNELS_FILE" ".channels|=map(select(.pid==$new_pid) * { status: \"off\" } // .)"
                    printf -v date_now "%(%m-%d %H:%M:%S)T" -1
                    printf "%s\n" "`eval_gettext \"\\\$date_now \\\$chnl_channel_name HLS 关闭\"`" >> "$MONITOR_LOG"
                    chnl_pid=$new_pid
                    action="stop"
                    SyncFile > /dev/null 2>> "$MONITOR_LOG"
                    rm -rf "$delete_on_term"
                ' EXIT

                mkdir -p "$delete_on_term"

                if [ -n "$chnl_live" ]
                then
                    chnl_seg_count_command="-c $chnl_seg_count"
                else
                    chnl_seg_count_command=""
                fi

                if [ -n "$chnl_encrypt" ] 
                then
                    chnl_key_name_command="-K $chnl_key_name"
                else
                    chnl_key_name_command=""
                fi

                if [ -n "$chnl_quality" ] 
                then
                    chnl_quality_command="-q ${chnl_quality%%,*}"
                else
                    chnl_quality_command=""
                fi

                if [ -n "$chnl_bitrates" ] 
                then
                    chnl_bitrates_command="-b $chnl_bitrates"
                else
                    chnl_bitrates_command=""
                fi

                if [ -n "$chnl_seg_dir_name" ] 
                then
                    chnl_seg_dir_name_command="-S $chnl_seg_dir_name"
                else
                    chnl_seg_dir_name_command=""
                fi

                if [[ $chnl_stream_link =~ ^https?:// ]] 
                then
                    export FFMPEG_PROXY="$chnl_proxy"
                    export FFMPEG_USER_AGENT=$chnl_user_agent
                    export FFMPEG_HEADERS="$chnl_headers"
                    export FFMPEG_COOKIES="$chnl_cookies"
                elif [[ $chnl_stream_link =~ ^icecast:// ]] 
                then
                    export FFMPEG_USER_AGENT=$chnl_user_agent
                fi

                export FFMPEG_INPUT_FLAGS=$chnl_input_flags
                export FFMPEG_FLAGS=$chnl_output_flags
                export AUDIO_CODEC=$chnl_audio_codec
                export VIDEO_CODEC=$chnl_video_codec

                PrepTerm
                $CREATOR_FILE $chnl_live -i "$chnl_stream_link" -s "$chnl_seg_length" \
                -o "$chnl_output_dir_root" $chnl_seg_count_command $chnl_bitrates_command $chnl_seg_dir_name_command \
                -p "$chnl_playlist_name" -t "$chnl_seg_name" $chnl_key_name_command $chnl_quality_command \
                $chnl_const $chnl_encrypt > "$FFMPEG_LOG_ROOT/$new_pid.log" 2> "$FFMPEG_LOG_ROOT/$new_pid.err" &
                WaitTerm
            } 201>"$pid_file"
        ;;
    esac
}

GetDefault()
{
    if [ -n "${d_version:-}" ] 
    then
        return 0
    fi

    IFS=$'\001\t' read -r d_proxy d_xc_proxy d_user_agent d_headers d_cookies d_playlist_name \
    d_seg_dir_name d_seg_name d_seg_length d_seg_count d_video_codec d_audio_codec \
    d_video_audio_shift d_txt_format d_draw_text d_quality d_bitrates d_const_yn d_encrypt_yn d_encrypt_session_yn \
    d_keyinfo_name d_key_name d_input_flags d_output_flags d_sync_yn d_sync_file \
    d_sync_index d_sync_pairs d_schedule_file d_flv_delay_seconds d_flv_restart_nums \
    d_hls_delay_seconds d_hls_min_bitrates d_hls_max_seg_size d_hls_restart_nums \
    d_hls_key_period d_anti_ddos_port d_anti_ddos_syn_flood_yn d_anti_ddos_syn_flood_delay_seconds \
    d_anti_ddos_syn_flood_seconds d_anti_ddos_yn d_anti_ddos_seconds d_anti_ddos_level \
    d_anti_leech_yn d_anti_leech_restart_nums d_anti_leech_restart_flv_changes_yn \
    d_anti_leech_restart_hls_changes_yn d_recheck_period d_version < <($JQ_FILE -c -r '
    .default as $default | 
    reduce ({proxy,xc_proxy,user_agent,headers,cookies,playlist_name,seg_dir_name,seg_name,seg_length,
    seg_count,video_codec,audio_codec,video_audio_shift,txt_format,draw_text,quality,bitrates,const,
    encrypt,encrypt_session,keyinfo_name,key_name,input_flags,output_flags,sync,sync_file,sync_index,
    sync_pairs,schedule_file,flv_delay_seconds,flv_restart_nums,hls_delay_seconds,hls_min_bitrates,
    hls_max_seg_size,hls_restart_nums,hls_key_period,anti_ddos_port,anti_ddos_syn_flood,
    anti_ddos_syn_flood_delay_seconds,anti_ddos_syn_flood_seconds,anti_ddos,anti_ddos_seconds,
    anti_ddos_level,anti_leech,anti_leech_restart_nums,anti_leech_restart_flv_changes,
    anti_leech_restart_hls_changes,recheck_period,version}|keys_unsorted[]) as $key ([];
        $default[$key] as $val | if $val then
            . + [($val | tostring) + "\u0001"]
        else
            . + ["\u0001"]
        end
    )|@tsv' "$CHANNELS_FILE")

    if [ -z "$d_version" ]
    then
        return 0
    fi

    d_proxy=${d_proxy#\"}
    d_user_agent=${d_user_agent:-$USER_AGENT_TV}
    d_cookies=${d_cookies:-stb_lang=en; timezone=Europe/Amsterdam}
    d_playlist_name_text=${d_playlist_name:-$(gettext "随机名称")}
    d_seg_dir_name_text=${d_seg_dir_name:-$(gettext "不设置")}
    d_seg_name_text=${d_seg_name:-$(gettext "跟m3u8名称相同")}
    v_or_a=${d_video_audio_shift%_*}
    if [ "$v_or_a" == "v" ] 
    then
        d_video_shift=${d_video_audio_shift#*_}
        d_video_audio_shift_text=$(eval_gettext "画面延迟 \$d_video_shift 秒")
    elif [ "$v_or_a" == "a" ] 
    then
        d_audio_shift=${d_video_audio_shift#*_}
        d_video_audio_shift_text=$(eval_gettext "声音延迟 \$d_audio_shift 秒")
    else
        d_video_audio_shift_text=$(gettext "不设置")
    fi
    d_encrypt_yn=${d_encrypt_yn:-no}
    d_encrypt_session_yn=${d_encrypt_session_yn:-no}
    d_sync_yn=${d_sync_yn:-yes}
    d_flv_delay_seconds=${d_flv_delay_seconds:-20}
    d_flv_restart_nums=${d_flv_restart_nums:-20}
    d_hls_delay_seconds=${d_hls_delay_seconds:-120}
    d_hls_min_bitrates=${d_hls_min_bitrates:-500}
    d_hls_max_seg_size=${d_hls_max_seg_size:-5}
    d_hls_restart_nums=${d_hls_restart_nums:-20}
    d_hls_key_period=${d_hls_key_period:-30}
    d_anti_ddos_port=${d_anti_ddos_port:-80}
    d_anti_ddos_port_text=${d_anti_ddos_port//,/ }
    d_anti_ddos_port_text=${d_anti_ddos_port_text//:/-}
    [ "${d_anti_ddos_syn_flood_yn:-}" != "yes" ] && d_anti_ddos_syn_flood_yn="no"
    d_anti_ddos_syn_flood_delay_seconds=${d_anti_ddos_syn_flood_delay_seconds:-3}
    d_anti_ddos_syn_flood_seconds=${d_anti_ddos_syn_flood_seconds:-3600}
    [ "${d_anti_ddos_yn:-}" != "yes" ] && d_anti_ddos_yn="no"
    d_anti_ddos_seconds=${d_anti_ddos_seconds:-120}
    d_anti_ddos_level=${d_anti_ddos_level:-6}
    [ "${d_anti_leech_yn:-}" != "yes" ] && d_anti_leech_yn="no"
    d_anti_leech_restart_nums=${d_anti_leech_restart_nums:-0}
    [ "${d_anti_leech_restart_flv_changes_yn:-}" != "yes" ] && d_anti_leech_restart_flv_changes_yn="no"
    [ "${d_anti_leech_restart_hls_changes_yn:-}" != "yes" ] && d_anti_leech_restart_hls_changes_yn="no"
    d_recheck_period=${d_recheck_period:-0}
    if [ "$d_recheck_period" -eq 0 ] 
    then
        d_recheck_period_text=$(gettext "不设置")
    else
        d_recheck_period_text=$d_recheck_period
    fi
    d_version=${d_version%\"}
}

GetChannels()
{
    [ ! -d "$IPTV_ROOT" ] && Println "`eval_gettext \"\\\$error 尚未安装, 请检查 !\"`\n" && exit 1

    delimiters=( $'\001' )
    IFS=$'\002\t' read -r m_pid m_status m_stream_link m_live m_proxy m_xc_proxy m_user_agent m_headers m_cookies \
    m_output_dir_name m_playlist_name m_seg_dir_name m_seg_name m_seg_length m_seg_count \
    m_video_codec m_audio_codec m_video_audio_shift m_txt_format m_draw_text m_quality m_bitrates m_const m_encrypt \
    m_encrypt_session m_keyinfo_name m_key_name m_key_time m_input_flags m_output_flags \
    m_channel_name m_channel_time m_sync m_sync_file m_sync_index m_sync_pairs m_flv_status \
    m_flv_h265 m_flv_push_link m_flv_pull_link < <(JQs flat "$CHANNELS_FILE" '' '
    (.channels | if . == "" then {} else . end) as $channels |
    reduce ({pid,status,stream_link,live,proxy,xc_proxy,user_agent,headers,cookies,output_dir_name,
    playlist_name,seg_dir_name,seg_name,seg_length,seg_count,video_codec,audio_codec,video_audio_shift,
    txt_format,draw_text,quality,bitrates,const,encrypt,encrypt_session,keyinfo_name,key_name,key_time,
    input_flags,output_flags,channel_name,channel_time,sync,sync_file,sync_index,sync_pairs,flv_status,
    flv_h265,flv_push_link,flv_pull_link}|keys_unsorted[]) as $key ([];
        $channels[$key] as $val | if $val then
            . + [$val + "\u0001\u0002"]
        else
            . + ["\u0002"]
        end
    )|@tsv' "${delimiters[@]}")

    if [ -z "$m_pid" ] 
    then
        chnls_count=0
        return 0
    fi

    IFS=$'\001' read -ra chnls_pid <<< "$m_pid"
    IFS=$'\001' read -ra chnls_status <<< "$m_status"
    IFS=$'\001' read -ra chnls_stream_links <<< "$m_stream_link"

    chnls_count=${#chnls_pid[@]}
    chnls_stream_link=("${chnls_stream_links[@]%% *}")
    if_null_off=${m_status//on/off}
    if_null_empty=${if_null_off//off/}
    if_null_yes=${if_null_off//off/yes}
    if_null_no=${if_null_off//off/no}

    IFS=$'\001' read -ra chnls_live <<< "${m_live:-$if_null_yes}"
    IFS=$'\001' read -ra chnls_proxy <<< "${m_proxy:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_xc_proxy <<< "${m_xc_proxy:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_user_agent <<< "${m_user_agent:-${if_null_off//off/$USER_AGENT_TV}}"
    IFS=$'\001' read -ra chnls_headers <<< "${m_headers:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_cookies <<< "${m_cookies:-${if_null_off//off/stb_lang=en; timezone=Europe/Amsterdam}}"
    IFS=$'\001' read -ra chnls_output_dir_name <<< "$m_output_dir_name"
    IFS=$'\001' read -ra chnls_playlist_name <<< "$m_playlist_name"
    IFS=$'\001' read -ra chnls_seg_dir_name <<< "$m_seg_dir_name"
    IFS=$'\001' read -ra chnls_seg_name <<< "$m_seg_name"
    IFS=$'\001' read -ra chnls_seg_length <<< "$m_seg_length"
    IFS=$'\001' read -ra chnls_seg_count <<< "$m_seg_count"
    IFS=$'\001' read -ra chnls_video_codec <<< "$m_video_codec"
    IFS=$'\001' read -ra chnls_audio_codec <<< "$m_audio_codec"
    IFS=$'\001' read -ra chnls_video_audio_shift <<< "${m_video_audio_shift:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_txt_format <<< "${m_txt_format:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_draw_text <<< "${m_draw_text:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_quality <<< "$m_quality"
    IFS=$'\001' read -ra chnls_bitrates <<< "$m_bitrates"
    IFS=$'\001' read -ra chnls_const <<< "${m_const:-$if_null_no}"
    m_encrypt=${m_encrypt:-$if_null_no}
    m_encrypt=${m_encrypt//-e/yes}
    IFS=$'\001' read -ra chnls_encrypt <<< "${m_encrypt:-$if_null_no}"
    IFS=$'\001' read -ra chnls_encrypt_session <<< "${m_encrypt_session:-$if_null_no}"
    IFS=$'\001' read -ra chnls_keyinfo_name <<< "${m_keyinfo_name:-${if_null_off//off/keyinfo}}"
    IFS=$'\001' read -ra chnls_key_name <<< "${m_key_name:-${if_null_off//off/keyname}}"
    if [ -z "$m_key_time" ] 
    then
        printf -v now '%(%s)T' -1
        m_key_time=${if_null_off//off/${now}}
    fi
    IFS=$'\001' read -ra chnls_key_time <<< "$m_key_time"
    IFS=$'\001' read -ra chnls_input_flags <<< "$m_input_flags"
    IFS=$'\001' read -ra chnls_output_flags <<< "$m_output_flags"
    IFS=$'\001' read -ra chnls_channel_name <<< "${m_channel_name:-${if_null_off//off/channel_name}}"
    if [ -z "$m_channel_time" ] 
    then
        printf -v now '%(%s)T' -1
        m_channel_time=${if_null_off//off/${now}}
    fi
    IFS=$'\001' read -ra chnls_channel_time <<< "$m_channel_time"
    IFS=$'\001' read -ra chnls_sync <<< "${m_sync:-$if_null_yes}"
    IFS=$'\001' read -ra chnls_sync_file <<< "${m_sync_file:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_sync_index <<< "${m_sync_index:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_sync_pairs <<< "${m_sync_pairs:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_flv_status <<< "${m_flv_status:-$if_null_off}"
    IFS=$'\001' read -ra chnls_flv_h265 <<< "${m_flv_h265:-$if_null_no}"
    IFS=$'\001' read -ra chnls_flv_push_link <<< "${m_flv_push_link:-$if_null_empty}"
    IFS=$'\001' read -ra chnls_flv_pull_link <<< "${m_flv_pull_link:-$if_null_empty}"
}

ListChannels()
{
    GetChannels

    if [ "$chnls_count" -eq 0 ]
    then
        Println "`eval_gettext \"\\\$error 没有发现频道, 请检查 !\"`\n" && exit 1
    fi

    i18nGetMsg list_channels

    chnls_list=""
    for((index=0;index<chnls_count;index++))
    do
        chnls_output_dir_root="$LIVE_ROOT/${chnls_output_dir_name[index]}"

        v_or_a=${chnls_video_audio_shift[index]%_*}
        if [ "$v_or_a" == "v" ] 
        then
            chnls_video_shift=${chnls_video_audio_shift[index]#*_}
            chnls_video_audio_shift_text="$i18n_video_shift $chnls_video_shift($i18n_seconds)"
        elif [ "$v_or_a" == "a" ] 
        then
            chnls_audio_shift=${chnls_video_audio_shift[index]#*_}
            chnls_video_audio_shift_text="$i18n_audio_shift $chnls_audio_shift($i18n_seconds)"
        else
            chnls_video_audio_shift_text=$i18n_not_set
        fi

        if [ "${chnls_const[index]}" == "no" ] 
        then
            chnls_const_index_text=$i18n_const_no
        else
            chnls_const_index_text=$i18n_const_yes
        fi

        chnls_quality_text=""
        chnls_bitrates_text=""
        chnls_playlist_file_text=""

        if [ -n "${chnls_bitrates[index]}" ] 
        then
            while IFS= read -r chnls_br
            do
                if [[ $chnls_br =~ - ]]
                then
                    chnls_br_a=${chnls_br%-*}
                    chnls_br_b=" $i18n_resolution: ${chnls_br#*-}"
                    chnls_quality_text="${chnls_quality_text}[ -maxrate ${chnls_br_a}k -bufsize ${chnls_br_a}k${chnls_br_b} ] "
                    chnls_bitrates_text="${chnls_bitrates_text}[ $i18n_bitrates ${chnls_br_a}k${chnls_br_b}${chnls_const_index_text} ] "
                    chnls_playlist_file_text="$chnls_playlist_file_text$chnls_output_dir_root/${chnls_playlist_name[index]}_$chnls_br_a.m3u8 "
                elif [[ $chnls_br == *"x"* ]] 
                then
                    chnls_quality_text="${chnls_quality_text}[ $i18n_resolution: $chnls_br ] "
                    chnls_bitrates_text="${chnls_bitrates_text}[ $i18n_resolution: $chnls_br${chnls_const_index_text} ] "
                    chnls_playlist_file_text="$chnls_playlist_file_text$chnls_output_dir_root/${chnls_playlist_name[index]}.m3u8 "
                else
                    chnls_quality_text="${chnls_quality_text}[ -maxrate ${chnls_br}k -bufsize ${chnls_br}k ] "
                    chnls_bitrates_text="${chnls_bitrates_text}[ $i18n_bitrates ${chnls_br}k${chnls_const_index_text} ] "
                    chnls_playlist_file_text="$chnls_playlist_file_text$chnls_output_dir_root/${chnls_playlist_name[index]}_$chnls_br.m3u8 "
                fi
            done <<< ${chnls_bitrates[index]//,/$'\n'}
        else
            chnls_playlist_file_text="$chnls_playlist_file_text$chnls_output_dir_root/${chnls_playlist_name[index]}.m3u8 "
        fi

        if [ -n "${chnls_quality[index]}" ] 
        then
            chnls_video_quality_text="crf ${chnls_quality[index]} ${chnls_quality_text:-$i18n_not_set}"
        else
            chnls_video_quality_text="$i18n_bitrates ${chnls_bitrates_text:-$i18n_not_set}"
        fi

        if [ -z "${kind:-}" ] && [ "${chnls_video_codec[index]}" == "copy" ] && [ "${chnls_audio_codec[index]}" == "copy" ]  
        then
            chnls_video_quality_text=$i18n_original
        fi

        if [ -n "${chnls_proxy[index]}" ] 
        then
            chnls_proxy_text="[$i18n_proxy]"
        else
            chnls_proxy_text=""
        fi

        if [ -z "${kind:-}" ] 
        then
            if [ "${chnls_status[index]}" == "on" ]
            then
                chnls_status_text="${green}$i18n_enabled${normal}"
            else
                chnls_status_text="${red}$i18n_disabled${normal}"
            fi
            chnls_list=$chnls_list"# ${green}$((index+1))${normal}${indent_6}$i18n_pid: ${green}${chnls_pid[index]}${normal} $i18n_status: $chnls_status_text $i18n_channel_name: ${green}${chnls_channel_name[index]} $chnls_proxy_text${normal}\n${indent_6}$i18n_codec: ${green}${chnls_video_codec[index]}:${chnls_audio_codec[index]}${normal} $i18n_video_audio_shift: ${green}$chnls_video_audio_shift_text${normal} $i18n_video_quality: ${green}$chnls_video_quality_text${normal}\n${indent_6}$i18n_stream_link: ${chnls_stream_link[index]}\n${indent_6}$i18n_playlist_file: $chnls_playlist_file_text\n\n"
        elif [ "$kind" == "flv" ] 
        then
            if [ "${chnls_flv_status[index]}" == "on" ] 
            then
                chnls_flv_status_text="${green}$i18n_enabled${normal}"
            else
                chnls_flv_status_text="${red}$i18n_disabled${normal}"
            fi
            chnls_list=$chnls_list"# ${green}$((index+1))${normal}${indent_6}$i18n_pid: ${green}${chnls_pid[index]}${normal} $i18n_status: $chnls_flv_status_text $i18n_channel_name: ${green}${chnls_channel_name[index]} $chnls_proxy_text${normal}\n${indent_6}$i18n_codec: ${green}${chnls_video_codec[index]}:${chnls_audio_codec[index]}${normal} $i18n_video_audio_shift: ${green}$chnls_video_audio_shift_text${normal} $i18n_video_quality: ${green}$chnls_video_quality_text${normal}\n${indent_6}$i18n_stream_link: ${chnls_stream_link[index]}\n${indent_6}flv$i18n_flv_push_link: ${chnls_flv_push_link[index]:-无}\n${indent_6}$i18n_flv_pull_link: ${chnls_flv_pull_link[index]:-无}\n\n"
        fi
    done

    if [ -n "${menu_num:-}" ] 
    then
        if [ "$menu_num" -eq 7 ] 
        then
            chnls_list=$chnls_list"# ${green}$((chnls_count+1))${normal}${indent_6}`gettext \"开启所有关闭的频道\"`\n\n"
            chnls_list=$chnls_list"# ${green}$((chnls_count+2))${normal}${indent_6}`gettext \"关闭所有开启的频道\"`\n\n"
        elif [ "$menu_num" -eq 8 ] 
        then
            chnls_list=$chnls_list"# ${green}$((chnls_count+1))${normal}${indent_6}`gettext \"重启所有开启的频道\"`\n\n"
        fi
    fi

    Println "=== `gettext \"频道总数\"` ${green} $chnls_count ${normal}"
    Println "$chnls_list"
}

GetChannel()
{
    GetDefault

    if [ -z "${monitor:-}" ] 
    then
        select_index="pid"
        select_json='{ "pid": '"$chnl_pid"' }'
    elif [ "${kind:-}" == "flv" ] 
    then
        select_index="flv_push_link"
        select_json='{ "flv_push_link": "'"$chnl_flv_push_link"'" }'
    else
        select_index="output_dir_name"
        select_json='{ "output_dir_name": "'"$output_dir_name"'" }'
    fi

    IFS=$'\001\t' read -r chnl_pid chnl_status chnl_stream_links chnl_live_yn chnl_proxy chnl_xc_proxy \
    chnl_user_agent chnl_headers chnl_cookies chnl_output_dir_name chnl_playlist_name \
    chnl_seg_dir_name chnl_seg_name chnl_seg_length chnl_seg_count chnl_video_codec \
    chnl_audio_codec chnl_video_audio_shift chnl_txt_format chnl_draw_text chnl_quality chnl_bitrates chnl_const_yn \
    chnl_encrypt_yn chnl_encrypt_session_yn chnl_keyinfo_name chnl_key_name chnl_key_time \
    chnl_input_flags chnl_output_flags chnl_channel_name chnl_channel_time chnl_sync_yn \
    chnl_sync_file chnl_sync_index chnl_sync_pairs chnl_flv_status chnl_flv_h265_yn chnl_flv_push_link \
    chnl_flv_pull_link < <($JQ_FILE -c -r --arg select_index "$select_index" --argjson select_json "$select_json" '
    .channels[] | select(.[$select_index] == $select_json[$select_index]) as $channel | 
    reduce ({pid,status,stream_link,live,proxy,xc_proxy,user_agent,headers,cookies,output_dir_name,
    playlist_name,seg_dir_name,seg_name,seg_length,seg_count,video_codec,audio_codec,video_audio_shift,
    txt_format,draw_text,quality,bitrates,const,encrypt,encrypt_session,keyinfo_name,key_name,key_time,
    input_flags,output_flags,channel_name,channel_time,sync,sync_file,sync_index,sync_pairs,flv_status,
    flv_h265,flv_push_link,flv_pull_link}|keys_unsorted[]) as $key ([];
        $channel[$key] as $val | if $val then
            . + [($val | tostring) + "\u0001"]
        else
            . + ["\u0001"]
        end
    )|@tsv' "$CHANNELS_FILE")

    if [ -z "$chnl_pid" ] && [ -z "${monitor:-}" ]
    then
        Println "$error $i18n_channel_try_again\n"
        exit 1
    fi

    chnl_pid=${chnl_pid#\"}
    chnl_flv_pull_link=${chnl_flv_pull_link%\"}

    if [ "$chnl_live_yn" == "no" ]
    then
        chnl_live=""
        chnl_live_text="${red}$i18n_no${normal}"
    else
        chnl_live="-l"
        chnl_live_text="${green}$i18n_yes${normal}"
    fi

    chnl_stream_link=${chnl_stream_links%% *}

    if [ -n "$chnl_proxy" ] && { [[ $chnl_stream_link =~ ^https?:// ]] || [[ ${chnl_stream_link##*|} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]]; }
    then
        chnl_proxy_command="-http_proxy $chnl_proxy"
    else
        chnl_proxy_command=""
    fi

    chnl_xc_proxy_ori=$chnl_xc_proxy
    chnl_xc_proxy=""
    if [ -n "$chnl_xc_proxy_ori" ] && [[ $chnl_stream_link =~ ^([^|]+)|http ]]
    then
        XtreamCodesGetDomains
        for xc_domain in "${xtream_codes_domains[@]}"
        do
            if [ "$xc_domain" == "${BASH_REMATCH[1]}" ] 
            then
                chnl_xc_proxy=$chnl_xc_proxy_ori
                break
            fi
        done
    fi

    while [[ $chnl_headers =~ \\\\ ]]
    do
        chnl_headers=${chnl_headers//\\\\/\\}
    done

    if [ -n "$chnl_headers" ] && [[ ! $chnl_headers =~ \\r\\n$ ]]
    then
        chnl_headers="$chnl_headers\r\n"
    fi

    chnl_output_dir_root="$LIVE_ROOT/$chnl_output_dir_name"

    v_or_a=${chnl_video_audio_shift%_*}
    if [ "$v_or_a" == "v" ] 
    then
        chnl_video_shift=${chnl_video_audio_shift#*_}
        chnl_audio_shift=""
        chnl_video_audio_shift_text="${green}$i18n_video_shift $chnl_video_shift($i18n_seconds)${normal}"
    elif [ "$v_or_a" == "a" ] 
    then
        chnl_video_shift=""
        chnl_audio_shift=${chnl_video_audio_shift#*_}
        chnl_video_audio_shift_text="${green}$i18n_audio_shift $chnl_audio_shift($i18n_seconds)${normal}"
    else
        chnl_video_audio_shift_text="${green}$i18n_not_set${normal}"
        chnl_video_shift=""
        chnl_audio_shift=""
    fi

    if [ "$chnl_const_yn" == "no" ]
    then
        chnl_const=""
        chnl_const_text=$i18n_const_no
    else
        chnl_const="-C"
        chnl_const_text=$i18n_const_yes
    fi

    if [ "$chnl_encrypt_yn" == "no" ]
    then
        chnl_encrypt=""
        chnl_encrypt_text="${red}$i18n_no${normal}"
    else
        chnl_encrypt="-e"
        chnl_encrypt_text="${green}$i18n_yes${normal}"
    fi

    chnl_keyinfo_name=${chnl_keyinfo_name:-$(RandStr)}

    if [ -z "${monitor:-}" ] 
    then
        if [ "$chnl_sync_yn" == "no" ]
        then
            chnl_sync_text="${red}$i18n_disabled${normal}"
        else
            chnl_sync_text="${green}$i18n_enabled${normal}"
        fi

        if [ "$chnl_status" == "on" ]
        then
            chnl_status_text="${green}$i18n_enabled${normal}"
        else
            chnl_status_text="${red}$i18n_disabled${normal}"
        fi

        chnl_seg_dir_name_text=${chnl_seg_dir_name:-$i18n_not_set}
        if [ -n "$chnl_seg_dir_name" ] 
        then
            chnl_seg_dir_name_text="${green}$chnl_seg_dir_name${normal}"
        else
            chnl_seg_dir_name_text="${red}$i18n_not_set${normal}"
        fi
        chnl_seg_length_text="${green}$chnl_seg_length($i18n_seconds)${normal}"

        chnl_crf_text=""
        chnl_nocrf_text=""
        chnl_playlist_file_text=""

        if [ -n "$chnl_bitrates" ] 
        then
            while IFS= read -r chnl_br
            do
                if [[ $chnl_br =~ - ]]
                then
                    chnl_br_a=${chnl_br%-*}
                    chnl_br_b=" $i18n_resolution: ${chnl_br#*-}"
                    chnl_crf_text="${chnl_crf_text}[ -maxrate ${chnl_br_a}k -bufsize ${chnl_br_a}k${chnl_br_b} ] "
                    chnl_nocrf_text="${chnl_nocrf_text}[ $i18n_bitrates ${chnl_br_a}k${chnl_br_b}${chnl_const_text} ] "
                    chnl_playlist_file_text="$chnl_playlist_file_text${green}$chnl_output_dir_root/${chnl_playlist_name}_$chnl_br_a.m3u8${normal} "
                elif [[ $chnl_br == *"x"* ]] 
                then
                    chnl_crf_text="${chnl_crf_text}[ $i18n_resolution: $chnl_br ] "
                    chnl_nocrf_text="${chnl_nocrf_text}[ $i18n_resolution: $chnl_br${chnl_const_text} ] "
                    chnl_playlist_file_text="$chnl_playlist_file_text${green}$chnl_output_dir_root/${chnl_playlist_name}.m3u8${normal} "
                else
                    chnl_crf_text="${chnl_crf_text}[ -maxrate ${chnl_br}k -bufsize ${chnl_br}k ] "
                    chnl_nocrf_text="${chnl_nocrf_text}[ $i18n_bitrates ${chnl_br}k${chnl_const_text} ] "
                    chnl_playlist_file_text="$chnl_playlist_file_text${green}$chnl_output_dir_root/${chnl_playlist_name}_$chnl_br.m3u8${normal} "
                fi
            done <<< ${chnl_bitrates//,/$'\n'}
        else
            chnl_playlist_file_text="$chnl_playlist_file_text${green}$chnl_output_dir_root/${chnl_playlist_name}.m3u8${normal} "
        fi

        if [ "$chnl_sync_yn" == "yes" ]
        then
            sync_file=${chnl_sync_file:-$d_sync_file}
            sync_index=${chnl_sync_index:-$d_sync_index}
            sync_pairs=${chnl_sync_pairs:-$d_sync_pairs}
            if [ -n "$sync_file" ] && [ -n "$sync_index" ] && [ -n "$sync_pairs" ] && [[ $sync_pairs == *"=http"* ]]
            then
                chnl_playlist_link=${sync_pairs#*=http}
                chnl_playlist_link=${chnl_playlist_link%%,*}
                chnl_playlist_link="http$chnl_playlist_link/$chnl_output_dir_name/${chnl_playlist_name}_master.m3u8"
                chnl_playlist_link_text="${green}$chnl_playlist_link${normal}"
            else
                chnl_playlist_link_text="${red}$i18n_sync_not_set${normal}"
            fi
        else
            chnl_playlist_link_text="${red}$i18n_sync_not_enabled${normal}"
        fi

        if [ -n "$chnl_quality" ] 
        then
            chnl_video_quality_text="${green}crf $chnl_quality ${chnl_crf_text:-$i18n_not_set}${normal}"
        else
            chnl_video_quality_text="${green}$i18n_bitrates ${chnl_nocrf_text:-$i18n_not_set}${normal}"
        fi

        if [ "$chnl_flv_status" == "on" ]
        then
            chnl_flv_status_text="${green}$i18n_enabled${normal}"
        else
            chnl_flv_status_text="${red}$i18n_disabled${normal}"
        fi

        if [ -z "${kind:-}" ] && [ "$chnl_video_codec" == "copy" ]  
        then
            chnl_video_quality_text="${green}$i18n_original${normal}"
            chnl_playlist_link=${chnl_playlist_link:-}
            chnl_playlist_link=${chnl_playlist_link//_master.m3u8/.m3u8}
            chnl_playlist_link_text=${chnl_playlist_link_text//_master.m3u8/.m3u8}
        elif [ -z "$chnl_bitrates" ] 
        then
            chnl_playlist_link=${chnl_playlist_link:-}
            chnl_playlist_link=${chnl_playlist_link//_master.m3u8/.m3u8}
            chnl_playlist_link_text=${chnl_playlist_link_text//_master.m3u8/.m3u8}
        fi
    fi
}

ListChannel()
{
    Println "==================================================="
    Println " `eval_gettext \"频道 [\\\$chnl_channel_name] 的配置信息\"`: \n"
    printf "%s${indent_20}${green}%s${normal}\n" " $i18n_pid" "$chnl_pid"

    if [ -z "${kind:-}" ] 
    then
        printf ' %b' "$i18n_status${indent_20}$chnl_status_text\n"
        printf " %s${indent_20}${green}%s${normal}\n" "$i18n_playlist_name" "$chnl_playlist_name"
        printf ' %b' "$i18n_playlist_file${indent_20}$chnl_playlist_file_text\n"
        printf ' %b' "$i18n_playlist_link${indent_20}$chnl_playlist_link_text\n"
        printf ' %b' "$i18n_seg_dir_name${indent_20}$chnl_seg_dir_name_text\n"
        printf " %s${indent_20}${green}%s${normal}\n" "$i18n_seg_name" "$chnl_seg_name"
        printf ' %b' "$i18n_seg_length${indent_20}$chnl_seg_length_text\n"
        printf " %s${indent_20}${green}%s${normal}\n" "$i18n_seg_count" "$chnl_seg_count"
        printf ' %b' "$i18n_encrypt${indent_20}$chnl_encrypt_text\n"
        if [ -n "$chnl_encrypt" ] 
        then
            printf " %s${indent_20}${green}%s${normal}\n" "$i18n_keyinfo_name" "$chnl_keyinfo_name"
            printf " %s${indent_20}${green}%s${normal}\n" "$i18n_key_name" "$chnl_key_name"
        fi
    elif [ "$kind" == "flv" ] 
    then
        printf ' %b' "$i18n_status${indent_20}$chnl_flv_status_text\n"
        printf " %s${indent_20}${green}%s${normal}\n" "$i18n_flv_push_link" "${chnl_flv_push_link:-$i18n_none}"
        printf " %s${indent_20}${green}%s${normal}\n" "$i18n_flv_pull_link" "${chnl_flv_pull_link:-$i18n_none}"
    fi

    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_stream_link" "${chnl_stream_links// /, }"
    printf ' %b' "$i18n_live${indent_20}$chnl_live_text\n"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_proxy" "${chnl_proxy:-$i18n_none}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_xtream_codes_proxy" "${chnl_xc_proxy:-$i18n_none}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_user_agent" "${chnl_user_agent:-$i18n_none}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_headers" "${chnl_headers:-$i18n_none}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_cookies" "${chnl_cookies:-$i18n_none}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_video_codec" "$chnl_video_codec"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_audio_codec" "$chnl_audio_codec"
    printf ' %b' "$i18n_video_quality${indent_20}$chnl_video_quality_text\n"
    printf ' %b' "$i18n_delay${indent_20}$chnl_video_audio_shift_text\n"

    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_input_flags" "${chnl_input_flags:-$i18n_not_set}"
    printf " %s${indent_20}${green}%s${normal}\n" "$i18n_output_flags" "${chnl_output_flags:-$i18n_not_set}"
    printf ' %b' "sync${indent_20}$chnl_sync_text\n"

    [ -n "$chnl_sync_file" ] && printf " %s${indent_20}${green}%s${normal}\n" "sync_file" "${chnl_sync_file// /, }"

    [ -n "$chnl_sync_index" ] && printf " %s${indent_20}${green}%s${normal}\n" "sync_index" "${chnl_sync_index// /, }"

    [ -n "$chnl_sync_pairs" ] && printf " %s${indent_20}${green}%s${normal}\n" "sync_pairs" "${chnl_sync_pairs// /, }"

    echo
}

InputChannelsIndex()
{
    echo -e "`eval_gettext \"\\\$tip 多个序号用空格分隔 比如: 5 7 9-11\"`\n"
    while read -p "`gettext \"请输入频道的序号(默认: 取消): \"`" chnls_index_input
    do
        [ -z "$chnls_index_input" ] && Println "$i18n_canceled...\n" && exit 1

        chnls_pid_chosen=()

        if [ -n "${menu_num:-}" ] 
        then
            if [[ $menu_num -eq 7 ]] 
            then
                if [[ $chnls_index_input == $((chnls_count+1)) ]] 
                then
                    for((i=0;i<chnls_count;i++));
                    do
                        if [[ -z ${kind:-} ]] && [[ ${chnls_status[i]} == "off" ]]
                        then
                            chnls_pid_chosen+=("${chnls_pid[i]}")
                        elif [[ ${kind:-} == "flv" ]] && [[ ${chnls_flv_status[i]} == "off" ]]
                        then
                            chnls_pid_chosen+=("${chnls_pid[i]}")
                        fi
                    done
                    [ -z "${chnls_pid_chosen:-}" ] && Println "`eval_gettext \"\\\$error 没有找到关闭的频道\"`\n" && exit 1
                    break
                elif [[ $chnls_index_input == $((chnls_count+2)) ]] 
                then
                    for((i=0;i<chnls_count;i++));
                    do
                        if [[ -z ${kind:-} ]] && [[ ${chnls_status[i]} == "on" ]]
                        then
                            chnls_pid_chosen+=("${chnls_pid[i]}")
                        elif [[ ${kind:-} == "flv" ]] && [[ ${chnls_flv_status[i]} == "on" ]]
                        then
                            chnls_pid_chosen+=("${chnls_pid[i]}")
                        fi
                    done
                    [ -z "${chnls_pid_chosen:-}" ] && Println "`eval_gettext \"\\\$error 没有找到开启的频道\"`\n" && exit 1
                    break
                fi
            elif [[ $menu_num -eq 8 ]] && [[ $chnls_index_input == $((chnls_count+1)) ]]
            then
                for((i=0;i<chnls_count;i++));
                do
                    if [[ -z ${kind:-} ]] && [[ ${chnls_status[i]} == "on" ]]
                    then
                        chnls_pid_chosen+=("${chnls_pid[i]}")
                    elif [[ ${kind:-} == "flv" ]] && [[ ${chnls_flv_status[i]} == "on" ]]
                    then
                        chnls_pid_chosen+=("${chnls_pid[i]}")
                    fi
                done
                [ -z "${chnls_pid_chosen:-}" ] && Println "`eval_gettext \"\\\$error 没有找到开启的频道\"`\n" && exit 1
                break
            fi
        fi

        IFS=" " read -ra chnls_index <<< "$chnls_index_input"

        for chnl_index in "${chnls_index[@]}"
        do
            if [[ $chnl_index =~ - ]] 
            then
                chnl_index_start=${chnl_index%-*}
                chnl_index_end=${chnl_index#*-}

                if [[ $chnl_index_start == *[!0-9]* ]] || [[ $chnl_index_end == *[!0-9]* ]] 
                then
                    Println "`eval_gettext \"\\\$error 多选输入错误!\"`\n"
                    continue 2
                elif [[ $chnl_index_start -gt 0 ]] && [[ $chnl_index_end -le $chnls_count ]] && [[ $chnl_index_end -gt $chnl_index_start ]] 
                then
                    ((chnl_index_start--))
                    for((i=chnl_index_start;i<chnl_index_end;i++));
                    do
                        chnls_pid_chosen+=("${chnls_pid[i]}")
                    done
                else
                    Println "`eval_gettext \"\\\$error 多选输入错误!\"`\n"
                    continue 2
                fi
            elif [[ $chnl_index == *[!0-9]* ]] || [[ $chnl_index -eq 0 ]] || [[ $chnl_index -gt $chnls_count ]] 
            then
                Println "$i18n_input_correct_no\n"
                continue 2
            else
                ((chnl_index--))
                chnls_pid_chosen+=("${chnls_pid[chnl_index]}")
            fi
        done
        i18nGetMsg get_channel
        break
    done
}

ViewChannel(){
    ListChannels
    InputChannelsIndex
    i18nGetMsg list_channel
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel
        ListChannel
    done
}

SetStreamLink()
{
    if [ "${xc:-0}" -eq 1 ] 
    then
        Println "  `gettext \"直播源:\"` ${green} $stream_link ${normal}\n"
        return 0
    fi
    if [ -n "${chnl_stream_links:-}" ] && [[ $chnl_stream_links == *" "* ]]
    then
        echo
        inquirer list_input "`eval_gettext \"是否只是调整频道 [ \\\$chnl_channel_name ] 直播源顺序\"`" ny_options ny_option
        if [ "$ny_option" == "$i18n_yes" ] 
        then
            IFS=" " read -ra stream_links_input <<< "$chnl_stream_links"
            stream_links_count=${#stream_links_input[@]}
            stream_links_list=""
            for((i=0;i<stream_links_count;i++));
            do
                stream_links_list="$stream_links_list ${green}$((i+1)).${normal}${indent_6}${stream_links_input[i]}\n\n"
            done
            re=""
            for((i=stream_links_count;i>0;i--));
            do
                [ -n "$re" ] && re="$re "
                re="$re$i"
            done
            Println "$stream_links_list"
            echo -e "`gettext \"输入新的次序\"`"
            while read -p "(`gettext \"比如\"` $re ): " orders_input
            do
                IFS=" " read -ra orders <<< "$orders_input"
                if [ "${#orders[@]}" -eq "$stream_links_count" ] 
                then
                    flag=0
                    for order in "${orders[@]}"
                    do
                        if [[ $order == *[!0-9]* ]] || [ "$order" -lt 1 ] || [ "$order" -gt "$stream_links_count" ] || [ "$order" -eq "$flag" ] 
                        then
                            Println "`eval_gettext \"\\\$error 输入错误\"`\n"
                            continue 2
                        else
                            flag=$order
                        fi
                    done

                    stream_links=""
                    for order in "${orders[@]}"
                    do
                        index=$((order-1))
                        [ -n "$stream_links" ] && stream_links="$stream_links "
                        stream_links="$stream_links${stream_links_input[index]}"
                    done
                    break
                else
                    Println "`eval_gettext \"\\\$error 输入错误\"`\n"
                fi
            done
            return 0
        fi
    fi

    Println "`eval_gettext \"\\\$tip 可以是视频路径, 可以输入不同链接地址(监控按顺序尝试使用), 用空格分隔\"`"
    inquirer text_input "`gettext \"请输入直播源( mpegts / hls / flv / youtube ...): \"`" stream_links "$i18n_cancel"
    ExitOnCancel stream_links

    IFS=" " read -ra stream_links_input <<< "$stream_links"

    if [[ $stream_links == *"https://www.youtube.com"* ]] || [[ $stream_links == *"https://youtube.com"* ]] 
    then
        if [[ ! -x $(command -v youtube-dl) ]] 
        then
            YoutubeDlInstall
        elif [ "${youtube_dl_updated:-0}" -eq 0 ] 
        then
            youtube-dl -U > /dev/null
            youtube_dl_updated=1
        fi
        if [[ ! -x $(command -v python) ]] 
        then
            ln -s /usr/bin/python3 /usr/bin/python
        fi
        for((i=0;i<${#stream_links_input[@]};i++));
        do
            link="${stream_links_input[i]}"
            if { [ "${link:0:23}" == "https://www.youtube.com" ] || [ "${link:0:19}" == "https://youtube.com" ]; } && [[ $link != *".m3u8"* ]] && [[ $link != *"|"* ]]
            then
                Println "`eval_gettext \"$info 查询 \\\${green}\\\$link\\\${normal} 视频信息...\"`"

                youtube_found=0
                count=0
                codes=()
                format_list=""
                while IFS= read -r line 
                do
                    if [[ $line == "format code"* ]] 
                    then
                        youtube_found=1
                    elif [[ $youtube_found -eq 1 ]] 
                    then
                        count=$((count+1))
                        code=${line%% *}
                        codes+=("$code")
                        code="code: ${green}$code${normal}, "
                        line=${line#* }
                        lead=${line%%[^[:blank:]]*}
                        line=${line#${lead}}
                        extension=${line%% *}
                        extension="格式: ${green}$extension${normal}, "
                        line=${line#* }
                        lead=${line%%[^[:blank:]]*}
                        line=${line#${lead}}
                        note=${line#* , }
                        line=${line%% , *}
                        bitrate=${line##* }
                        if [[ ${line:0:1} == *[!0-9]* ]] 
                        then
                            resolution=""
                            line=${line// $bitrate/}
                            note="其它: $line$note"
                        else
                            resolution=${line%% *}
                            line=${line#* }
                            lead=${line%%[^[:blank:]]*}
                            line=${line#${lead}}
                            line=${line// $bitrate/}
                            trail=${line##*[^[:blank:]]}
                            line=${line%${trail}}
                            resolution="分辨率: ${green}$resolution${normal}, ${green}${line##* }${normal}, "
                            note="其它: $line$note"
                        fi
                        format_list=$format_list"${green}$count.${normal} $resolution$code$extension$note\n\n"
                    fi
                done < <(youtube-dl --list-formats "$link")
                if [ -n "$format_list" ] 
                then
                    Println "$format_list"
                    echo "`gettext \"输入序号\"`"
                    while read -p "(默认: $count): " format_num
                    do
                        case "$format_num" in
                            "")
                                code=${codes[count-1]}
                                break
                            ;;
                            *[!0-9]*)
                                Println "$error $i18n_input_correct_number\n"
                            ;;
                            *)
                                if [ "$format_num" -ge 1 ] && [ "$format_num" -le $count ]
                                then
                                    code=${codes[format_num-1]}
                                    break
                                else
                                    Println "$error $i18n_input_correct_number\n"
                                fi
                            ;;
                        esac
                    done
                    stream_links_input[i]="${stream_links_input[i]}|$code"
                else
                    Println "`eval_gettext \"\\\$error 无法解析链接 \\\$link\"`\n" && exit 1
                fi
            fi
        done

        Println "`eval_gettext \"\\\$info 解析 youtube 链接...\"`"
        stream_link=${stream_links_input[0]}
        code=${stream_link#*|}
        stream_link=${stream_link%|*}
        stream_link=$(youtube-dl -f "$code" -g "$stream_link")

        stream_links=""
        for link in "${stream_links_input[@]}"
        do
            [ -n "$stream_links" ] && stream_links="$stream_links "
            stream_links="$stream_links$link"
        done
    else
        stream_link=${stream_links_input[0]}
    fi

    if [ "${stream_link:13:12}" == "fengshows.cn" ] 
    then
        xc=1
        user_agent="FengWatch/3.1.8 (iPhone; iOS 13.5; Scale/2.00)"
        headers="fengshows-client: app(ios,30$(GetFreePort 4000 6000)7);iPhone12,1;13.5\r\n"
        cookies=""

        feng_id=${stream_link##*/}
        feng_id=${feng_id%%.*}
        feng_id=$(tr '[:upper:]' '[:lower:]' <<< "$feng_id")

        while IFS=" " read -r title stream_link
        do
            if { [[ $feng_id == *"pin"* ]] && [ "$title" == "資訊台" ]; } || { [[ $feng_id == *"pcc"* ]] && [ "$title" == "中文台" ]; } || { [[ $feng_id == *"phk"* ]] && [ "$title" == "香港台" ]; }
            then
                break
            fi
        done < <(curl -s -Lm 10 \
            -H "User-Agent: $user_agent" \
            -H "${headers:0:-4}" "https://api.fengshows.cn/live?live_type=tv&page=1&page_size=15" \
            | $JQ_FILE -r '.[]|[.title,.live_url_fhd]|join(" ")')

        ts=$(date +%s%3N)
        tx_time=$(printf '%X' $((ts/1000+1800)))

        stream_link=${stream_link%\?*}

        relative_path=${stream_link#*//}
        relative_path="/${relative_path#*/}"

        tx_secret=$(printf '%s' "obb9Lxyv5C${relative_path%.*}$tx_time" | md5sum)
        tx_secret=${tx_secret%% *}

        stream_link="$stream_link?txSecret=$tx_secret&txTime=$tx_time"
        if [[ $stream_links == *" "* ]] 
        then
            stream_links="$stream_link ${stream_links#* }"
        else
            stream_links=$stream_link
        fi
        #token=$(printf '%s' "$ts/${relative_path:1}ifengims" | md5sum)
        #token=${token%% *}
        #stream_link_md5="$stream_link?ts=$ts&token=$token"
    elif [[ $stream_link == *"news.tvb.com"* ]] 
    then
        xc=1
        if [ "${stream_link:0:5}" == "http:" ] 
        then
            stream_link="https${stream_link:4}"
        fi
        user_agent="$USER_AGENT_BROWSER"
        headers="Referer: $stream_link\r\n"
        cookies=""
        while IFS= read -r line 
        do
            if [[ $line =~ tag_deviceid= ]] 
            then
                line=${line#* }
                cookies=${line%% *}
            elif [[ $line =~ country_code= ]] 
            then
                line=${line#* }
                cookies="$cookies ${line%% *}"
                break
            fi
        done < <(curl -s -I -H "User-Agent: $user_agent" -H "${headers:0:-4}" -c - "$stream_link" 2> /dev/null)
        chnl="${stream_link%\?*}"
        chnl=${chnl##*/}
        token_url=$(curl -s -Lm 10 \
            -H "User-Agent: $user_agent" \
            -H "${headers:0:-4}" \
            "https://api.news.tvb.com/news/v2.2.1/live?profile=web" \
            | $JQ_FILE -r '.items[]|select(.path=="'"$chnl"'").video.ios[]|select(.type=="hd").url')
        query_string="$token_url&feed&client_ip=$(GetServerIp)"
        query_string=$(UrlencodeUpper "$query_string")
        stream_link=$(curl -s -Lm 10 \
            -H "User-Agent: $user_agent" \
            -H "${headers:0:-4}" \
            --cookie "$cookies" \
            "https://news.tvb.com/ajax_call/getVideo.php?token=$query_string" \
            | $JQ_FILE -r '.url')
        while IFS= read -r line 
        do
            if [[ $line =~ hdntl= ]] 
            then
                line=${line#* }
                cookies="$cookies ${line%% *}"
                break
            fi
        done < <(curl -s -I -H "User-Agent: $user_agent" -H "${headers:0:-4}" --cookie "$cookies" "$stream_link" 2> /dev/null)
    elif [[ $stream_link =~ ^https://embed.4gtv.tv/HiNet/(.+).html ]] 
    then
        if [[ ! -x $(command -v openssl) ]] 
        then
            echo
            AskIfContinue y "`gettext \"是否安装 openssl\"`"
            OpensslInstall
        fi
        Println "`eval_gettext \"\\\$info 解析 4gtv 链接 ...\"`"
        hinet_4gtv=(
            "litv-longturn14:寰宇新聞台"
            "4gtv-4gtv052:華視新聞資訊台"
            "4gtv-4gtv012:空中英語教室"
            "litv-ftv07:民視旅遊台"
            "litv-ftv15:i-Fun動漫台"
            "4gtv-live206:幸福空間居家台"
            "4gtv-4gtv070:愛爾達娛樂台"
            "litv-longturn17:亞洲旅遊台"
            "4gtv-4gtv025:MTV Live HD"
            "litv-longturn15:寰宇新聞台灣台"
            "4gtv-4gtv001:民視台灣台"
            "4gtv-4gtv074:中視新聞台"
            "4gtv-4gtv011:影迷數位電影台"
            "4gtv-4gtv047:靖天日本台"
            "litv-longturn11:龍華日韓台"
            "litv-longturn12:龍華偶像台"
            "4gtv-4gtv042:公視戲劇"
            "litv-ftv12:i-Fun動漫台3"
            "4gtv-4gtv002:民視無線台"
            "4gtv-4gtv027:CI 罪案偵查頻道"
            "4gtv-4gtv013:CNEX DOC CHANNEL"
            "litv-longturn03:龍華電影台"
            "4gtv-4gtv004:民視綜藝台"
            "litv-longturn20:ELTV英語學習台"
            "litv-longturn01:龍華卡通台"
            "4gtv-4gtv040:中視無線台"
            "litv-longturn02:Baby First"
            "4gtv-4gtv003:民視第一台"
            "4gtv-4gtv007:大愛電視台"
            "4gtv-4gtv076:SMART 知識頻道"
            "4gtv-4gtv030:CNBC"
            "litv-ftv10:半島電視台"
        )

        stream_link_uri_name=${BASH_REMATCH[1]}
        for channel in "${hinet_4gtv[@]}"
        do
            channel_id=${channel%%:*}
            channel_name=${channel#*:}
            channel_name_enc=$(Urlencode "$channel_name")
            if [[ $channel_name_enc == "$stream_link_uri_name" ]] 
            then
                xc=1
                user_agent="$USER_AGENT_BROWSER"
                headers="Referer: https://embed.4gtv.tv/HiNet/$channel_name_enc.html?ar=0&as=1&volume=0\r\n"
                cookies=""
                stream_link_data=$(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                -H "${headers:0:-4}" \
                "https://app.4gtv.tv/Data/HiNet/GetURL.ashx?ChannelNamecallback=channelname&Type=LIVE&Content=$channel_id&HostURL=https%3A%2F%2Fwww.hinet.net%2Ftv%2F&_=$(date +%s%3N)") || true
                if [ -n "$stream_link_data" ] 
                then
                    stream_link_data=$($JQ_FILE -r '.VideoURL' <<< "${stream_link_data:12:-1}")
                    hexkey=$(echo -n "VxzAfiseH0AbLShkQOPwdsssw5KyLeuv" | hexdump -v -e '/1 "%02x"')
                    hexiv=$(echo -n "${stream_link_data:0:16}" | hexdump -v -e '/1 "%02x"')
                    stream_link_url=$(echo "${stream_link_data:16}" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a)
                    stream_link_url_path=${stream_link_url%/*}
                    Add4gtvLink
                else
                    Println "`eval_gettext \"\\\$error 无法连接 4gtv !\"`\n" && exit 1
                fi
                break
            fi
        done
    elif [[ $stream_link == *"4gtv.tv/"* ]] 
    then
        if [[ ! -x $(command -v openssl) ]] 
        then
            echo
            AskIfContinue y "`gettext \"是否安装 openssl\"`"
            OpensslInstall
        fi
        Println "`eval_gettext \"\\\$info 解析 4gtv 链接 ...\"`"
        xc=1
        user_agent="$USER_AGENT_BROWSER"
        headers="Referer: ${stream_link%%|*}\r\n"
        cookies=""
        set_id=${stream_link#*channelSet_id=}
        set_id=${set_id%%&*}
        set_id=${set_id%%|*}
        fsVALUE=""
        if [ "$set_id" -eq 1 ] 
        then
            GetServiceAccs 4gtv
            for((i=0;i<${#_4gtv_accs_token[@]};i++));
            do
                if [ -n "${_4gtv_accs_token[i]:-}" ] 
                then
                    fsVALUE=${_4gtv_accs_token[i]}
                    break
                fi
            done
        fi
        fnCHANNEL_ID=${stream_link#*channel_id=}
        fnCHANNEL_ID=${fnCHANNEL_ID%%&*}
        fnCHANNEL_ID=${fnCHANNEL_ID%%|*}
        fsASSET_ID=${stream_link#*asset_id=}
        fsASSET_ID=${fsASSET_ID%%&*}
        fsASSET_ID=${fsASSET_ID%%|*}
        key="ilyB29ZdruuQjC45JhBBR7o2Z8WJ26Vg"
        iv="JUMxvVMmszqUTeKn"
        hexkey=$(echo -n $key | hexdump -v -e '/1 "%02x"')
        hexiv=$(echo -n $iv | hexdump -v -e '/1 "%02x"')
        post_data='{"fnCHANNEL_ID":'"$fnCHANNEL_ID"',"fsASSET_ID":"'"$fsASSET_ID"'","fsDEVICE_TYPE":"pc","clsIDENTITY_VALIDATE_ARUS":{"fsVALUE":"'"$fsVALUE"'"}}'
        post_data=$(echo -n "$post_data" | openssl enc -aes-256-cbc -iv "$hexiv" -K "$hexkey" -a)
        if [ -n "$fsVALUE" ] 
        then
            value="$(UrlencodeUpper ${post_data//[[:space:]]/})"
        else
            value="$(Urlencode ${post_data//[[:space:]]/})"
        fi

        for((try_i=0;try_i<10;try_i++));
        do
            stream_link_data=$(curl -s -Lm 10 -X POST \
            -H "User-Agent: $user_agent" \
            -H "${headers:0:-4}" \
            --data "value=$value" \
            "https://api2.4gtv.tv/Channel/GetChannelUrl3") || true
            if [ -n "$stream_link_data" ] 
            then
                break
            fi
        done

        if [ -z "$stream_link_data" ] 
        then
            Println "`eval_gettext \"\\\$error 无法连接 4gtv !\"`\n" && exit 1
        fi

        stream_link_data=$($JQ_FILE -r '.Data' <<< "$stream_link_data")
        if [ "$stream_link_data" == null ] 
        then
            Println "`eval_gettext \"\\\$error 此服务器 ip 不支持或频道不可用!\"`\n"
        else
            stream_link_url=$(echo "$stream_link_data" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a \
                | $JQ_FILE -r '.flstURLs[0]')
            stream_link_url_path=${stream_link_url%/*}
            Add4gtvLink
        fi
    elif [[ $stream_link == http://*.macaulotustv.com/* ]] 
    then
        xc=1
        user_agent="$USER_AGENT_BROWSER"
        headers="Origin: http://www.lotustv.cc\r\nReferer: http://www.lotustv.cc/index.php/index/live.html\r\n"
        cookies=""
    fi

    Println "  `gettext \"直播源:\"` ${green} $stream_link ${normal}\n"
}

SetIsHls()
{
    Println "$tip 如果直播链接重定向至 .m3u8 地址, 请选择 是"
    inquirer list_input "是否是 HLS 链接" ny_options is_hls
    if [[ $is_hls == "$i18n_yes" ]]
    then
        is_hls=1
    else
        is_hls=0
    fi
}

SetSubtitle()
{
    echo
    inquirer list_input "输入源是否有 DVB teletext 需要转换为 WebVTT 字幕" ny_options txt_format
    if [[ $txt_format == "$i18n_yes" ]]
    then
        echo
        txt_format_options=( 'text' 'ass' )
        inquirer list_input "选择字幕转码成的格式" txt_format_options txt_format
    else
        txt_format=""
    fi
}

SetDrawtext()
{
    Println "$tip 比如 fontsize=25:fontfile=/usr/local/iptv/AlibabaSans-Regular.otf:fontcolor=white:box=1:boxcolor=black@0.5:x=50:y=10:text=mtime.info"
    inquirer text_input "输入 drawtext 水印 : " draw_text "${d_draw_text:-不设置}"
    if [ "$draw_text" == "omit" ] || [ "$draw_text" == "不设置" ]
    then
        draw_text=""
    fi
}

SetLive()
{
    if [ -z "${kind:-}" ] 
    then
        Println "$tip 选择 否 则无法设置切割的分片数且无法监控"
    else
        Println "$tip 选择 否 则无法监控"
    fi
    inquirer list_input "是否是无限时长直播源" yn_options live_yn
    if [[ $live_yn == "$i18n_yes" ]]
    then
        live="-l"
        live_yn="yes"
    else
        live=""
        live_yn="no"
    fi
}

SetProxy()
{
    if [ "${xc:-0}" -eq 1 ] && [ -n "${_4gtv_proxy:-}" ]
    then
        proxy=$_4gtv_proxy
        Println "  ffmpeg 代理: ${green} $_4gtv_proxy ${normal}\n"
        return 0
    fi
    Println "$tip 可以使用脚本自带的 v2ray 管理面板添加代理, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg 代理, 比如 http://username:passsword@127.0.0.1:5555 : " proxy "${d_proxy:-不设置}"
    if [ "$proxy" == "omit" ] || [ "$proxy" == "不设置" ]
    then
        proxy=""
    fi
}

SetXtreamCodesProxy()
{
    if [ "${xc:-0}" -eq 1 ] && [ -n "${xtream_codes_proxy:-}" ]
    then
        xc_proxy=$xtream_codes_proxy
        Println "  xtream codes 代理: ${green} $xc_proxy ${normal}\n"
        return 0
    fi
    Println "$tip 可以使用脚本自带的 cloudflare workers 管理面板添加 xtream codes 代理 worker, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 xtream codes 代理: " xc_proxy "${d_xc_proxy:-不设置}"
    if [ "$xc_proxy" == "omit" ] || [ "$xc_proxy" == "不设置" ]
    then
        xc_proxy=""
    fi
}

SetUserAgent()
{
    if [ "${xc:-0}" -eq 1 ] 
    then
        Println "  ffmpeg UA: ${green} ${user_agent:-不设置} ${normal}\n"
        return 0
    fi
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg 的 user agent: " user_agent "${d_user_agent:-不设置}"
    if [ "$user_agent" == "omit" ] || [ "$user_agent" == "不设置" ]
    then
        user_agent=""
    fi
}

SetHeaders()
{
    if [ "${xc:-0}" -eq 1 ] 
    then
        Println "  ffmpeg headers: ${green} ${headers:-不设置} ${normal}\n"
        return 0
    fi
    Println "$tip 多个 header 用 \\\r\\\n 分隔, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg headers: " headers "${d_headers:-不设置}"
    if [ "$headers" == "omit" ] || [ "$headers" == "不设置" ]
    then
        headers=""
    fi
    while [[ $headers =~ \\\\ ]]
    do
        headers=${headers//\\\\/\\}
    done
    if [ -n "$headers" ] && [[ ! $headers =~ \\r\\n$ ]]
    then
        headers="$headers\r\n"
    fi
}

SetCookies()
{
    if [ "${xc:-0}" -eq 1 ] 
    then
        Println "  ffmpeg cookies: ${green} ${cookies:-不设置} ${normal}\n"
        return 0
    fi
    Println "$tip 多个 cookies 用 ; 分隔, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg cookies: " cookies "${d_cookies:-不设置}"
    if [ "$cookies" == "omit" ] || [ "$cookies" == "不设置" ]
    then
        cookies=""
    fi
}

SetOutputDirName()
{
    Println "$tip 是名称不是路径"
    while true 
    do
        inquirer text_input "请输入频道输出目录名称: " output_dir_name "随机名称"
        if [ "$output_dir_name" == "随机名称" ] 
        then
            while :;do
                output_dir_name=$(RandOutputDirName)
                if [[ -z $($JQ_FILE '.channels[] | select(.output_dir_name=="'"$output_dir_name"'")' "$CHANNELS_FILE") ]] 
                then
                    Println "  目录名称: ${green} $output_dir_name ${normal}\n"
                    break 2
                fi
            done
        elif [[ -z $($JQ_FILE '.channels[] | select(.output_dir_name=="'"$output_dir_name"'")' "$CHANNELS_FILE") ]]  
        then
            break
        else
            Println "$error 目录已存在!\n"
        fi
    done
    output_dir_root="$LIVE_ROOT/$output_dir_name"
}

SetPlaylistName()
{
    echo
    inquirer text_input "请输入 m3u8 名称(前缀) : " playlist_name "$d_playlist_name_text"
    if [ "$playlist_name" == "随机名称" ]
    then
        playlist_name=${d_playlist_name:-$(RandPlaylistName)}
        Println "  m3u8 名称: ${green} $playlist_name ${normal}\n"
    fi
}

SetSegDirName()
{
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入分片所在子目录名称: " seg_dir_name "$d_seg_dir_name_text"
    if [ "$seg_dir_name" == "omit" ] || [ "$seg_dir_name" == "不设置" ]
    then
        seg_dir_name=""
    fi
}

SetSegName()
{
    echo
    d_seg_name_text=${chnl_playlist_name:-$d_seg_name_text}
    inquirer text_input "请输入分片名称: " seg_name "${playlist_name:-$d_seg_name_text}"
    if [ "$seg_name" == "跟m3u8名称相同" ]
    then
        playlist_name=$($JQ_FILE -r '.channels[]|select(.pid=='"$chnl_pid"').playlist_name' "$CHANNELS_FILE")
        seg_name=$playlist_name
        Println "  分片名称: ${green} $seg_name ${normal}\n"
    fi
}

SetSegLength()
{
    while true 
    do
        echo
        inquirer text_input "请输入分片时长(单位: s): " seg_length "$d_seg_length"
        case "$seg_length" in
            "")
                seg_length=$d_seg_length
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>0]"
            ;;
            *)
                if [ "$seg_length" -ge 1 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]"
                fi
            ;;
        esac
    done
}

SetSegCount()
{
    Println "$tip ffmpeg分割的数目是其2倍, 如果填0就是无限"
    while true 
    do
        inquirer text_input "请输入m3u8文件包含的分片数目: " seg_count "$d_seg_count"
        case "$seg_count" in
            "")
                seg_count=$d_seg_count
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>=0]\n"
            ;;
            *)
                if [ "$seg_count" -ge 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>=0]\n"
                fi
            ;;
        esac
    done
}

SetVideoCodec()
{
    echo
    inquirer text_input "请输入视频编码(不需要转码时输入 copy): " video_codec "$d_video_codec"
}

SetAudioCodec()
{
    echo
    inquirer text_input "请输入音频编码(不需要转码时输入 copy): " audio_codec "$d_audio_codec"
}

SetVideoAudioShift()
{
    if [ "$d_video_audio_shift_text" == "不设置" ] 
    then
        video_audio_shift_options=( "$d_video_audio_shift_text" '设置 画面延迟' '设置 声音延迟' )
    else
        video_audio_shift_options=( "$d_video_audio_shift_text" '设置 画面延迟' '设置 声音延迟' '不设置' )
    fi

    while true 
    do
        echo
        inquirer list_input "画面或声音延迟" video_audio_shift_options video_audio_shift_selected

        case $video_audio_shift_selected in
            "$d_video_audio_shift_text") 
                if [ "$d_video_audio_shift_text" != "不设置" ] 
                then
                    if [ -n "${d_video_shift:-}" ] 
                    then
                        video_shift=$d_video_shift
                        video_audio_shift="v_$video_shift"
                    elif [ -n "${d_audio_shift:-}" ] 
                    then
                        audio_shift=$d_audio_shift
                        video_audio_shift="a_$audio_shift"
                    fi
                else
                    video_audio_shift=""
                fi
                video_audio_shift_text=$d_video_audio_shift_text
                break
            ;;
            "设置 画面延迟") 
                Println "请输入延迟时间(比如 0.5)"
                read -p "(默认: 返回上级选项): " video_shift
                if [ -n "$video_shift" ] 
                then
                    video_audio_shift="v_$video_shift"
                    video_audio_shift_text="画面延迟 $video_shift 秒"
                    break
                fi
            ;;
            "设置 声音延迟") 
                Println "请输入延迟时间(比如 0.5)"
                read -p "(默认: 返回上级选项): " audio_shift
                if [ -n "$audio_shift" ] 
                then
                    video_audio_shift="a_$audio_shift"
                    video_audio_shift_text="声音延迟 $audio_shift 秒"
                    break
                fi
            ;;
            "不设置"|"") 
                video_audio_shift=""
                video_audio_shift_text="不设置"
                break
            ;;
        esac
    done

    Println "  延迟: ${green} $video_audio_shift_text ${normal}\n"
}

SetQuality()
{
    Println "$tip 改变 crf, 数字越大越视频质量越差, 如果设置 crf 则无法用比特率控制视频质量, 多个 crf 用逗号分隔"
    while true 
    do
        inquirer text_input "请输入输出视频质量[0-63]: " quality "${d_quality:-不设置}"
        case "$quality" in
            "不设置")
                quality=""
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [0-63]\n"
            ;;
            *)
                if [ "$quality" -ge 0 ] && [ "$quality" -le 63 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [0-63]\n"
                fi
            ;;
        esac
    done
}

SetBitrates()
{
    if [ -z "${quality:-}" ] 
    then
        Println "$tip 用于指定输出视频比特率, 同时可以指定输出的分辨率"
    else
        Println "$tip 用于 -maxrate 和 -bufsize, 同时可以指定输出的分辨率"
    fi
    if [ -z "${kind:-}" ] 
    then
        echo -e "$tip 多个比特率(kb/s)用逗号分隔(生成自适应码流),同时可以指定输出的分辨率(比如: 800-640x360,1000-960x540,1500-1280x720)"
    fi

    inquirer text_input "请输入比特率和分辨率, 可以输入 omit 省略此选项: " bitrates "${d_bitrates:-不设置}"

    if [ "$bitrates" == "omit" ] || [ "$bitrates" == "不设置" ] 
    then
        bitrates=""
    fi
}

SetConst()
{
    echo
    if [ "$d_const_yn" == "yes" ] 
    then
        inquirer list_input "是否使用固定码率: " yn_options const_yn
    else
        inquirer list_input "是否使用固定码率: " ny_options const_yn
    fi

    if [[ $const_yn == "$i18n_yes" ]]
    then
        const="-C"
        const_yn="yes"
    else
        const=""
        const_yn="no"
    fi
}

SetEncrypt()
{
    echo
    if [ "$d_encrypt_yn" == "yes" ] 
    then
        inquirer list_input "是否加密分片: " yn_options encrypt_yn
    else
        inquirer list_input "是否加密分片: " ny_options encrypt_yn
    fi

    if [[ $encrypt_yn == "$i18n_yes" ]]
    then
        encrypt="-e"
        encrypt_yn="yes"

        if [[ ! -x $(command -v openssl) ]]
        then
            echo
            inquirer list_input "是否安装 openssl: " yn_options install_openssl_yn
            if [[ $install_openssl_yn == "$i18n_yes" ]]
            then
                OpensslInstall
            else
                encrypt=""
                encrypt_yn="no"
            fi
        fi

        if [[ -x $(command -v openssl) ]] 
        then
            Println "$tip 加密后只能通过网页浏览"

            if [ "$d_encrypt_session_yn" == "no" ] 
            then
                inquirer list_input "是否加密 session: " ny_options encrypt_session_text
            else
                inquirer list_input "是否加密 session: " yn_options encrypt_session_text
            fi

            if [[ $encrypt_session_text == "$i18n_yes" ]]
            then
                encrypt_session_yn="yes"

                if [ ! -d "/usr/local/nginx" ] && [ ! -d "/usr/local/openresty" ]
                then
                    echo
                    nginx_openresty_options=( 'nginx' 'openresty' '不安装' )
                    inquirer list_input "选择安装 nginx 或 openresty, 耗时会很长: " nginx_openresty_options nginx_openresty_selected

                    if [[ $nginx_openresty_selected == "nginx" ]] 
                    then
                        nginx_prefix="/usr/local/nginx"
                        nginx_name="nginx"
                        nginx_ctl="nx"
                        NGINX_FILE="$nginx_prefix/sbin/nginx"
                        NginxInstall
                    elif [[ $nginx_openresty_selected == "openresty" ]] 
                    then
                        nginx_prefix="/usr/local/openresty/nginx"
                        nginx_name="openresty"
                        nginx_ctl="or"
                        NGINX_FILE="$nginx_prefix/sbin/nginx"
                        OpenrestyInstall
                    else
                        encrypt_session_yn="no"
                        encrypt_session_text="$i18n_no"
                    fi
                fi

                if [ -d "/usr/local/nginx" ] || [ -d "/usr/local/openresty" ] 
                then
                    if [ -z "${nginx_name:-}" ] 
                    then
                        if [ -d "/usr/local/nginx" ] && [ -d "/usr/local/openresty" ]
                        then
                            echo
                            if [ -s "/usr/local/openresty/nginx/logs/nginx.pid" ] && kill -0 "$(< "/usr/local/openresty/nginx/logs/nginx.pid")" 2> /dev/null
                            then
                                nginx_openresty_options=( 'openresty' 'nginx' )
                            else
                                nginx_openresty_options=( 'nginx' 'openresty' )
                            fi
                            inquirer list_input "选择使用 nginx 或 openresty: " nginx_openresty_options nginx_openresty_selected
                            if [[ $nginx_openresty_selected == "nginx" ]] 
                            then
                                nginx_prefix="/usr/local/nginx"
                                nginx_name="nginx"
                                nginx_ctl="nx"
                            else
                                nginx_prefix="/usr/local/openresty/nginx"
                                nginx_name="openresty"
                                nginx_ctl="or"
                            fi
                        elif [ -d "/usr/local/nginx" ] 
                        then
                            nginx_prefix="/usr/local/nginx"
                            nginx_name="nginx"
                            nginx_ctl="nx"
                        else
                            nginx_prefix="/usr/local/openresty/nginx"
                            nginx_name="openresty"
                            nginx_ctl="or"
                        fi
                        NGINX_FILE="$nginx_prefix/sbin/nginx"
                    fi

                    if [[ ! -x $(command -v node) ]] || [[ ! -x $(command -v npm) ]]
                    then
                        echo
                        inquirer list_input "需安装配置 nodejs, 是否继续: " yn_options encrypt_session_text
                        if [[ $encrypt_session_text == "$i18n_yes" ]] 
                        then
                            NodejsInstall
                            if [[ -x $(command -v node) ]] && [[ -x $(command -v npm) ]] 
                            then
                                if [ ! -e "$NODE_ROOT/index.js" ] 
                                then
                                    NodejsConfig
                                fi
                            else
                                encrypt_session_yn="no"
                                encrypt_session_text="$i18n_no"
                                Println "$error nodejs 安装发生错误"
                                Println "  加密 session: ${green} $encrypt_session_text ${normal}"
                            fi
                        else
                            encrypt_session_yn="no"
                        fi
                    elif [ ! -e "$NODE_ROOT/index.js" ] 
                    then
                        NodejsConfig
                    fi
                fi
            else
                encrypt_session_yn="no"
            fi
        fi
    else
        encrypt=""
        encrypt_yn="no"
        encrypt_session_yn="no"
    fi
}

SetKeyInfoName()
{
    echo
    inquirer text_input "请输入 keyinfo 名称: " keyinfo_name "${d_keyinfo_name:-随机}"
    if [ "$keyinfo_name" == "随机" ]
    then
        keyinfo_name=$(RandStr)
        Println "  keyinfo 名称: ${green} $keyinfo_name ${normal}\n"
    fi
}

SetKeyName()
{
    echo
    inquirer text_input "请输入 keyinfo 名称: " key_name "${d_key_name:-随机}"
    if [ "$key_name" == "随机" ]
    then
        key_name=$(RandStr)
        Println "  key 名称: ${green} $key_name ${normal}\n"
    fi
}

SetInputFlags()
{
    stream_link=${stream_link:-}
    if [[ $stream_link == *".m3u8"* ]] || [ "${is_hls:-0}" -eq 1 ]
    then
        d_input_flags=${d_input_flags//-reconnect_at_eof 1/}
    elif [ "${stream_link:0:4}" == "rtmp" ] || [ "${is_local:-0}" -eq 1 ]
    then
        d_input_flags=${d_input_flags//-timeout 2000000000/}
        d_input_flags=${d_input_flags//-reconnect 1/}
        d_input_flags=${d_input_flags//-reconnect_at_eof 1/}
        d_input_flags=${d_input_flags//-reconnect_streamed 1/}
        d_input_flags=${d_input_flags//-reconnect_delay_max 2000/}
        lead=${d_input_flags%%[^[:blank:]]*}
        d_input_flags=${d_input_flags#${lead}}
    fi
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg 额外的输入参数: " input_flags "${d_input_flags:-不设置}"
    if [ "$input_flags" == "omit" ] || [ "$input_flags" == "不设置" ]
    then
        input_flags=""
    fi
}

SetOutputFlags()
{
    if [ -n "${kind:-}" ] 
    then
        d_output_flags=${d_output_flags//-sc_threshold 0/}
    fi
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入 ffmpeg 额外的输出参数: " output_flags "${d_output_flags:-不设置}"
    if [ "$output_flags" == "omit" ] || [ "$output_flags" == "不设置" ]
    then
        output_flags=""
    fi
}

SetChannelName()
{
    echo
    d_channel_name=${chnl_playlist_name:-跟m3u8名称相同}
    inquirer text_input "请输入频道名称(可以是中文): " channel_name "${playlist_name:-$d_channel_name}"
    if [ "$channel_name" == "跟m3u8名称相同" ]
    then
        playlist_name=$($JQ_FILE -r '.channels[]|select(.pid=='"$chnl_pid"').playlist_name' "$CHANNELS_FILE")
        channel_name=$playlist_name
        Println "  频道名称: ${green} $channel_name ${normal}\n"
    fi
}

SetSync()
{
    echo
    if [ "$d_sync_yn" == "yes" ] 
    then
        inquirer list_input "是否启用 sync: " yn_options sync_yn
    else
        inquirer list_input "是否启用 sync: " ny_options sync_yn
    fi

    if [[ $sync_yn == "$i18n_yes" ]]
    then
        sync_yn="yes"
    else
        sync_yn="no"
    fi
}

SetSyncFile()
{
    if [ "${set_default:-0}" -eq 0 ] 
    then
        Println "$tip 多个文件用空格分隔"
        inquirer text_input "设置单独的 sync_file: " sync_file "${d_sync_file:-不设置}"
        if [ "$sync_file" == "$d_sync_file" ] || [ "$sync_file" == "不设置" ]
        then
            sync_file=""
        fi
    else
        Println "$tip 多个文件用空格分隔, 可以输入 omit 省略此选项"
        inquirer text_input "设置默认 sync_file: " sync_file "${d_sync_file:-不设置}"
        if [ "$sync_file" == "omit" ] || [ "$sync_file" == "不设置" ]
        then
            sync_file=""
        fi
    fi
}

SetSyncIndex()
{
    if [ "${set_default:-0}" -eq 0 ] 
    then
        Println "$tip 多个 sync_index 用空格分隔"
        inquirer text_input "设置单独的 sync_index: " sync_index "${d_sync_index:-不设置}"
        if [ "$sync_index" == "$d_sync_index" ] || [ "$sync_index" == "不设置" ]
        then
            sync_index=""
        fi
    else
        Println "$tip 多个 sync_index 用空格分隔, 可以输入 omit 省略此选项"
        inquirer text_input "设置默认 sync_index: " sync_index "${d_sync_index:-不设置}"
        if [ "$sync_index" == "omit" ] || [ "$sync_index" == "不设置" ]
        then
            sync_index=""
        fi
    fi
}

SetSyncPairs()
{
    if [ "${set_default:-0}" -eq 0 ] 
    then
        Println "$tip 多个 sync_pairs 用空格分隔"
        inquirer text_input "设置单独的 sync_pairs: " sync_pairs "${d_sync_pairs:-不设置}"
        if [ "$sync_pairs" == "$d_sync_pairs" ] || [ "$sync_pairs" == "不设置" ]
        then
            sync_pairs=""
        fi
    else
        Println "$tip 多个 sync_pairs 用空格分隔, 可以输入 omit 省略此选项"
        inquirer text_input "设置默认 sync_pairs: " sync_pairs "${d_sync_pairs:-不设置}"
        if [ "$sync_pairs" == "omit" ] || [ "$sync_pairs" == "不设置" ]
        then
            sync_pairs=""
        fi
    fi
}

SetScheduleFile()
{
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "设置节目表文件绝对路径: " schedule_file "${d_schedule_file:-不设置}"
    if [ "$schedule_file" == "omit" ] || [ "$schedule_file" == "不设置" ]
    then
        schedule_file=""
    fi
}

SetFlvDelaySeconds()
{
    Println "设置超时多少秒自动重启频道"
    while read -p "(默认: $d_flv_delay_seconds 秒): " flv_delay_seconds
    do
        case $flv_delay_seconds in
            "") flv_delay_seconds=$d_flv_delay_seconds && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$flv_delay_seconds" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetFlvRestartNums()
{
    Println "请输入尝试重启的次数"
    while read -p "(默认: $d_flv_restart_nums次): " flv_restart_nums
    do
        case $flv_restart_nums in
            "") flv_restart_nums=$d_flv_restart_nums && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$flv_restart_nums" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsDelaySeconds()
{
    Println "设置超时多少秒自动重启频道"
    echo -e "$tip 必须大于 分片时长*分片数目"
    while read -p "(默认: $d_hls_delay_seconds 秒): " hls_delay_seconds
    do
        case $hls_delay_seconds in
            "") hls_delay_seconds=$d_hls_delay_seconds && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_delay_seconds" -gt 60 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>60]\n"
                fi
            ;;
        esac
    done
}

SetHlsMinBitrates()
{
    Println "请输入最低比特率(kb/s),低于此数值会重启频道(除加密的频道)"
    while read -p "(默认: $d_hls_min_bitrates): " hls_min_bitrates
    do
        case $hls_min_bitrates in
            "") hls_min_bitrates=$d_hls_min_bitrates && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_min_bitrates" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsMaxSegSize()
{
    Println "请输入允许的最大分片"
    while read -p "(默认: ${d_hls_max_seg_size}M): " hls_max_seg_size
    do
        case $hls_max_seg_size in
            "") hls_max_seg_size=$d_hls_max_seg_size && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_max_seg_size" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsRestartNums()
{
    Println "请输入尝试重启的次数"
    while read -p "(默认: $d_hls_restart_nums次): " hls_restart_nums
    do
        case $hls_restart_nums in
            "") hls_restart_nums=$d_hls_restart_nums && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_restart_nums" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsKeyPeriod()
{
    echo
    inquirer text_input "每隔多少秒更改加密频道的 key: " hls_key_period $d_hls_key_period
}

SetAntiDDosPort()
{
    Println "设置封禁端口"
    echo -e "$tip 多个端口用空格分隔 比如 22 80 443 12480-12489\n"
    while read -p "(默认: $d_anti_ddos_port_text): " anti_ddos_ports
    do
        anti_ddos_ports=${anti_ddos_ports:-$d_anti_ddos_port_text}
        if [ -z "$anti_ddos_ports" ] 
        then
            Println "$error $i18n_input_correct_number\n"
            continue
        fi

        IFS=" " read -ra anti_ddos_ports_arr <<< "$anti_ddos_ports"

        error_no=0
        for anti_ddos_port in "${anti_ddos_ports_arr[@]}"
        do
            case "$anti_ddos_port" in
                *"-"*)
                    anti_ddos_ports_start=${anti_ddos_port%-*}
                    anti_ddos_ports_end=${anti_ddos_port#*-}
                    if [[ $anti_ddos_ports_start == *[!0-9]* ]] || [[ $anti_ddos_ports_end == *[!0-9]* ]] || [ "$anti_ddos_ports_start" -eq 0 ] || [ "$anti_ddos_ports_end" -eq 0 ] || [ "$anti_ddos_ports_start" -ge "$anti_ddos_ports_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$anti_ddos_port" -lt 1 ]  
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                anti_ddos_ports_command=""
                anti_ddos_ports_range_command=""
                for anti_ddos_port in "${anti_ddos_ports_arr[@]}"
                do
                    if [[ $anti_ddos_port -eq 80 ]] 
                    then
                        anti_ddos_port="http"
                    elif [[ $anti_ddos_port -eq 443 ]] 
                    then
                        anti_ddos_port="https"
                    elif [[ $anti_ddos_port -eq 22 ]] 
                    then
                        anti_ddos_port="ssh"
                    elif [[ $anti_ddos_port =~ - ]] 
                    then
                        anti_ddos_ports_start=${anti_ddos_port%-*}
                        anti_ddos_ports_end=${anti_ddos_port#*-}
                        if [[ anti_ddos_ports_start -le 22 && $anti_ddos_ports_end -ge 22 ]] 
                        then
                            [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                            anti_ddos_ports_command=$anti_ddos_ports_command"ssh"
                        elif [[ anti_ddos_ports_start -le 80 && $anti_ddos_ports_end -ge 80 ]] 
                        then
                            [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                            anti_ddos_ports_command=$anti_ddos_ports_command"http"
                        elif [[ anti_ddos_ports_start -le 443 && $anti_ddos_ports_end -ge 443 ]] 
                        then
                            [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                            anti_ddos_ports_command=$anti_ddos_ports_command"https"
                        fi
                        [ -n "$anti_ddos_ports_range_command" ] && anti_ddos_ports_range_command="$anti_ddos_ports_range_command || "
                        anti_ddos_ports_range_command=$anti_ddos_ports_range_command'($4 >= '"$anti_ddos_ports_start"' && $4 <= '"$anti_ddos_ports_end"')'
                        continue
                    fi

                    [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                    anti_ddos_ports_command="$anti_ddos_ports_command$anti_ddos_port"
                done

                [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command='$4 ~ /^('"$anti_ddos_ports_command"')$/'
                if [ -n "$anti_ddos_ports_range_command" ] 
                then
                    anti_ddos_ports_range_command='$4 ~ /^[0-9]+$/ && ('"$anti_ddos_ports_range_command"')'
                    [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_range_command=' || ('"$anti_ddos_ports_range_command"')'
                fi
                if [[ $anti_ddos_ports == *" "* ]] || [[ $anti_ddos_ports =~ - ]]
                then
                    anti_ddos_port=${anti_ddos_ports// /,}
                    anti_ddos_port=${anti_ddos_port//-/:}
                    anti_ddos_port="$anti_ddos_port proto tcp"
                else
                    anti_ddos_port=$anti_ddos_ports
                fi
                break
            ;;
        esac
    done
}

SetAntiDDosSynFlood()
{
    echo
    if [ "$d_anti_ddos_syn_flood_yn" == "yes" ] 
    then
        inquirer list_input "是否开启 SYN Flood attack 防御" yn_options anti_ddos_syn_flood_yn
    else
        inquirer list_input "是否开启 SYN Flood attack 防御" ny_options anti_ddos_syn_flood_yn
    fi

    if [[ $anti_ddos_syn_flood_yn == "$i18n_yes" ]] 
    then
        anti_ddos_syn_flood_yn="yes"
        sysctl -w net.ipv4.tcp_syn_retries=6 > /dev/null
        sysctl -w net.ipv4.tcp_synack_retries=2 > /dev/null
        sysctl -w net.ipv4.tcp_syncookies=1 > /dev/null
        sysctl -w net.ipv4.tcp_max_syn_backlog=1024 > /dev/null
        #iptables -A INPUT -p tcp --syn -m limit --limit 1/s -j ACCEPT --limit 1/s

        Println "设置判断为 SYN Flood attack 的时间 (秒)"
        while read -p "(默认: $d_anti_ddos_syn_flood_delay_seconds 秒): " anti_ddos_syn_flood_delay_seconds
        do
            case $anti_ddos_syn_flood_delay_seconds in
                "") anti_ddos_syn_flood_delay_seconds=$d_anti_ddos_syn_flood_delay_seconds && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_syn_flood_delay_seconds" -gt 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number [>0]\n"
                    fi
                ;;
            esac
        done

        Println "设置封禁 SYN Flood attack ip 多少秒"
        while read -p "(默认: $d_anti_ddos_syn_flood_seconds 秒): " anti_ddos_syn_flood_seconds
        do
            case $anti_ddos_syn_flood_seconds in
                "") anti_ddos_syn_flood_seconds=$d_anti_ddos_syn_flood_seconds && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_syn_flood_seconds" -gt 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number  [>0]\n"
                    fi
                ;;
            esac
        done
    else
        anti_ddos_syn_flood_yn="no"
    fi
}

SetAntiDDos()
{
    echo
    if [ "$d_anti_ddos_yn" == "yes" ] 
    then
        inquirer list_input "是否开启 iptv 防御" yn_options anti_ddos_yn
    else
        inquirer list_input "是否开启 iptv 防御" ny_options anti_ddos_yn
    fi

    if [[ $anti_ddos_yn == "$i18n_yes" ]] 
    then
        anti_ddos_yn="yes"

        Println "设置封禁用户 ip 多少秒"
        while read -p "(默认: $d_anti_ddos_seconds 秒): " anti_ddos_seconds
        do
            case $anti_ddos_seconds in
                "") anti_ddos_seconds=$d_anti_ddos_seconds && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_seconds" -gt 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number  [>0]\n"
                    fi
                ;;
            esac
        done

        Println "设置封禁等级(1-9)"
        echo -e "$tip 数值越低越严格, 也越容易误伤, 很多情况是网络问题导致重复请求并非 DDoS\n"
        while read -p "(默认: $d_anti_ddos_level): " anti_ddos_level
        do
            case $anti_ddos_level in
                "") 
                    anti_ddos_level=$d_anti_ddos_level
                    break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_level" -gt 0 ] && [ "$anti_ddos_level" -lt 10 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number [1-9]\n"
                    fi
                ;;
            esac
        done
    else
        anti_ddos_yn="no"
    fi
}

SetAntiLeech()
{
    echo
    if [ "$d_anti_leech_yn" == "yes" ] 
    then
        inquirer list_input "是否开启防盗链" yn_options anti_leech_yn
    else
        inquirer list_input "是否开启防盗链" ny_options anti_leech_yn
    fi

    if [[ $anti_leech_yn == "$i18n_yes" ]]
    then
        anti_leech_yn="yes"

        Println "请输入每小时随机重启次数 (大于等于0)"
        while read -p "(默认: $d_anti_leech_restart_nums): " anti_leech_restart_nums
        do
            case $anti_leech_restart_nums in
                "") anti_leech_restart_nums=$d_anti_leech_restart_nums && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_leech_restart_nums" -ge 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number [>=0]\n"
                    fi
                ;;
            esac
        done

        if [ "$anti_leech_restart_nums" -gt 0 ] 
        then
            echo
            inquirer list_input "是否下个小时开始随机重启" ny_options anti_leech_restart_next_hour_yn
            if [ "$anti_leech_restart_next_hour_yn" == "$i18n_yes" ] 
            then
                printf -v current_hour '%(%-H)T' -1
                skip_hour=$current_hour
                minutes=()
            fi
        fi

        if [ -n "${flv_nums:-}" ] 
        then
            echo
            if [ "$d_anti_leech_restart_flv_changes_yn" == "yes" ] 
            then
                inquirer list_input "是否每当重启 FLV 频道更改成随机的推流和拉流地址" yn_options anti_leech_restart_flv_changes_yn
            else
                inquirer list_input "是否每当重启 FLV 频道更改成随机的推流和拉流地址" ny_options anti_leech_restart_flv_changes_yn
            fi

            if [[ $anti_leech_restart_flv_changes_yn == "$i18n_yes" ]] 
            then
                anti_leech_restart_flv_changes_yn="yes"
            else
                anti_leech_restart_flv_changes_yn="no"
            fi
        else
            anti_leech_restart_flv_changes_yn=$d_anti_leech_restart_flv_changes_yn
        fi

        if [ -n "$hls_nums" ] 
        then
            echo
            if [ "$d_anti_leech_restart_hls_changes_yn" == "yes" ] 
            then
                inquirer list_input "是否每当重启 HLS 频道更改成随机的 m3u8 名称, 分片名称, key 名称" yn_options anti_leech_restart_hls_changes_yn
            else
                inquirer list_input "是否每当重启 HLS 频道更改成随机的 m3u8 名称, 分片名称, key 名称" ny_options anti_leech_restart_hls_changes_yn
            fi

            if [[ $anti_leech_restart_hls_changes_yn == "$i18n_yes" ]] 
            then
                anti_leech_restart_hls_changes_yn="yes"
            else
                anti_leech_restart_hls_changes_yn="no"
            fi
            SetHlsKeyPeriod
            hls_key_expire_seconds=$((hls_key_period+hls_delay_seconds))
        else
            anti_leech_restart_hls_changes_yn=$d_anti_leech_restart_hls_changes_yn
        fi
    else
        anti_leech_yn="no"
        anti_leech_restart_nums=$d_anti_leech_restart_nums
        anti_leech_restart_flv_changes_yn=$d_anti_leech_restart_flv_changes_yn
        anti_leech_restart_hls_changes_yn=$d_anti_leech_restart_hls_changes_yn
    fi
}

SetRecheckPeriod()
{
    Println "设置重启频道失败后定时检查直播源(如可用即开启频道)的间隔时间(s)"
    echo -e "$tip 输入 0 关闭检查"
    while read -p "(默认: $d_recheck_period_text): " recheck_period
    do
        case $recheck_period in
            "") recheck_period=$d_recheck_period && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$recheck_period" -ge 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>=0]\n"
                fi
            ;;
        esac
    done
}

SetFlvIsH265()
{
    echo
    inquirer list_input "是否推流 h265" ny_options flv_h265_yn
    if [[ $flv_h265_yn == "$i18n_no" ]] 
    then
        flv_h265_yn="no"
    else
        flv_h265_yn="yes"
        if [[ ! -x $(command -v ffmpeg_c) ]] 
        then
            echo
            ffmpeg_c_options=( '快速安装' '编译 ffmpeg (耗时非常非常久)' )
            inquirer list_input "选择 ffmpeg (h265版本) 安装方式" ffmpeg_c_options ffmpeg_c_option
            if [[ $ffmpeg_c_option == "快速安装" ]] 
            then
                if curl -L "$FFMPEG_MIRROR_LINK/ffmpeg_c" -o /usr/local/bin/ffmpeg_c
                then
                    chmod +x /usr/local/bin/ffmpeg_c
                else
                    Println "$error 暂时无法连接服务器, 请稍后再试 !\n"
                    exit 1
                fi
            else
                FFmpegCompile
            fi
        fi
    fi
}

SetFlvPushLink()
{
    Println "$tip 比如 rtmp://127.0.0.1/flv/xxx , 如指向本机请确保已经安装 nginx 或 openresty"
    while true
    do
        inquirer text_input "请输入推流地址: " flv_push_link "本地随机地址"
        if [ "$flv_push_link" == "本地随机地址" ]
        then
            flv_push_link="rtmp://127.0.0.1/flv/$(RandStr)"
            until [[ -z $($JQ_FILE '.channels[] | select(.flv_push_link=="'"$flv_push_link"'")' "$CHANNELS_FILE") ]] 
            do
                flv_push_link=$(RandStr)
            done
            Println "  推流地址: ${green} $flv_push_link ${normal}\n"
            break
        elif [[ -z $($JQ_FILE '.channels[] | select(.flv_push_link=="'"$flv_push_link"'")' "$CHANNELS_FILE") ]]
        then
            break
        else
            Println "$error 推流地址已存在!请重新输入\n"
        fi
    done
}

SetFlvPullLink()
{
    if [ -n "${flv_push_link:-}" ] 
    then
        d_flv_pull_link="http://127.0.0.1/flv?app=flv&stream=${flv_push_link##*/}"
    elif [ -n "${chnl_flv_push_link:-}" ] 
    then
        d_flv_pull_link="http://127.0.0.1/flv?app=flv&stream=${chnl_flv_push_link##*/}"
    fi
    Println "$tip 比如 http://domain.com/flv?app=flv&stream=xxx 监控会验证此链接来确定是否重启频道, 如果不确定可以先留空, 可以输入 omit 省略此选项"
    inquirer text_input "请输入拉流(播放)地址: " flv_pull_link "${d_flv_pull_link:-不设置}"
    if [ "$flv_pull_link" == "omit" ] || [ "$flv_pull_link" == "不设置" ]
    then
        flv_pull_link=""
    fi
}

AddChannel()
{
    [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1

    origin_hls_url=0

    GetDefault

    SetStreamLink

    is_local=0
    if [ "${stream_link:0:1}" == "/" ] 
    then
        is_local=1
    fi

    if [[ $stream_link =~ \.m3u8 ]] 
    then
        is_hls=1
    elif [[ $stream_link =~ \.flv ]] || [[ $stream_link =~ \.ts ]]
    then
        is_hls=0
    else
        SetIsHls
    fi

    SetLive

    if [ "${xc:-0}" -eq 0 ] && ! [[ $stream_link =~ ^https?:// ]]
    then
        user_agent=""
        headers=""
        cookies=""
        proxy=""
    else
        SetProxy
        SetUserAgent
        SetHeaders
        SetCookies
    fi

    xc_proxy=${xc_proxy:-}
    if [[ $stream_link =~ ^http://([^/]+) ]] 
    then
        XtreamCodesGetDomains

        for xc_domain in "${xtream_codes_domains[@]}"
        do
            if [ "$xc_domain" == "${BASH_REMATCH[1]}" ] 
            then
                SetXtreamCodesProxy
                break
            fi
        done
    fi

    use_cdn=0
    hboasia_host="hbogoasia.com:8443"
    hboasia_cdn_host="dai3fd1oh325y.cloudfront.net"

    if [ "${xc:-0}" -eq 0 ] && [ "$is_hls" -eq 1 ] 
    then
        echo
        inquirer list_input "是否分析 m3u8 列表: " ny_options yn_option
        if [ "$yn_option" == "$i18n_yes" ]
        then
            stream_link_url=${stream_link%%|*}
            stream_link_url_path=${stream_link_url%/*}

            stream_link_url_path_cdn=$stream_link_url_path
            if [[ $stream_link_url_path =~ $hboasia_host/(.+)$ ]] 
            then
                if [ "$use_cdn" -eq 1 ] 
                then
                    stream_link_url_path_cdn="https://$hboasia_cdn_host/${BASH_REMATCH[1]}"
                fi
                #headers="range: \r\n"
                if [[ ! $output_flags =~ -seekable ]] 
                then
                    output_flags="$output_flags -seekable 0"
                fi
                if [[ ! $output_flags =~ -vsync ]] 
                then
                    output_flags="$output_flags -vsync 0"
                fi
            fi

            if [ "${stream_link:0:1}" == "/" ] 
            then
                m3u8_content=$(< "${stream_link%%|*}")
            else
                curl_proxy_command=()
                if [ -n "$proxy" ] 
                then
                    curl_proxy_command+=( -x "$proxy" )
                fi

                curl_cookies_command=()
                if [ -n "$cookies" ] 
                then
                curl_cookies_command+=( --cookie "$cookies" )
                fi

                curl_headers_command=()
                if [ -n "$user_agent" ] 
                then
                curl_headers_command+=( -H "User-Agent: $user_agent" )
                fi

                if [ -n "$headers" ] 
                then
                curl_headers_command+=( -H "$headers" )
                fi

                m3u8_content=$(curl -s -Lm 20 ${curl_proxy_command[@]+"${curl_proxy_command[@]}"} ${curl_cookies_command[@]+"${curl_cookies_command[@]}"} ${curl_headers_command[@]+"${curl_headers_command[@]}"} "$stream_link_url")
            fi

            stream_audio_group_id=()
            stream_audio_name=()
            stream_audio_default=()
            stream_audio_language=()
            stream_audio_url=()
            stream_subtitles_group_id=()
            stream_subtitles_name=()
            stream_subtitles_default=()
            stream_subtitles_language=()
            stream_subtitles_url=()
            stream_links_bitrate=()
            stream_links_resolution=()
            stream_links_url=()
            stream_links_audio=()
            stream_links_subtitles=()
            stream_links_list=""
            stream_links_count=0

            while IFS= read -r line 
            do
                if [[ $line =~ TYPE=AUDIO ]] 
                then
                    IFS="," read -r -a stream_audio <<< "${line#*:}"
                    stream_audio_keys=(${stream_audio[*]%%=*})
                    stream_audio_values=(${stream_audio[*]#*=})
                    for((i=0;i<${#stream_audio_keys[@]};i++));
                    do
                        if [ "${stream_audio_keys[i]}" == "GROUP-ID" ] 
                        then
                            stream_audio_group_id+=("${stream_audio_values[i]//\"/}")
                        elif [ "${stream_audio_keys[i]}" == "NAME" ] 
                        then
                            stream_audio_name+=("${stream_audio_values[i]//\"/}")
                        elif [ "${stream_audio_keys[i]}" == "DEFAULT" ] 
                        then
                            stream_audio_default+=("${stream_audio_values[i]}")
                        elif [ "${stream_audio_keys[i]}" == "LANGUAGE" ] 
                        then
                            stream_audio_language+=("${stream_audio_values[i]//\"/}")
                        elif [ "${stream_audio_keys[i]}" == "URI" ] 
                        then
                            stream_audio_uri=${stream_audio_values[i]//\"/}
                            if [[ $stream_audio_uri =~ ^https?:// ]] 
                            then
                                stream_audio_url+=("$stream_audio_uri")
                            else
                                stream_audio_url+=("$stream_link_url_path_cdn/$stream_audio_uri")
                            fi
                        fi
                    done
                elif [[ $line =~ TYPE=SUBTITLES ]] 
                then
                    IFS="," read -r -a stream_subtitles <<< "${line#*:}"
                    stream_subtitles_keys=(${stream_subtitles[*]%%=*})
                    stream_subtitles_values=(${stream_subtitles[*]#*=})
                    for((i=0;i<${#stream_subtitles_keys[@]};i++));
                    do
                        if [ "${stream_subtitles_keys[i]}" == "GROUP-ID" ] 
                        then
                            stream_subtitles_group_id+=("${stream_subtitles_values[i]//\"/}")
                        elif [ "${stream_subtitles_keys[i]}" == "NAME" ] 
                        then
                            stream_subtitles_name+=("${stream_subtitles_values[i]//\"/}")
                        elif [ "${stream_subtitles_keys[i]}" == "DEFAULT" ] 
                        then
                            stream_subtitles_default+=("${stream_subtitles_values[i]}")
                        elif [ "${stream_subtitles_keys[i]}" == "LANGUAGE" ] 
                        then
                            stream_subtitles_language+=("${stream_subtitles_values[i]//\"/}")
                        elif [ "${stream_subtitles_keys[i]}" == "URI" ] 
                        then
                            stream_subtitles_uri=${stream_subtitles_values[i]//\"/}
                            if [[ $stream_subtitles_uri =~ ^https?:// ]] 
                            then
                                stream_subtitles_url+=("$stream_subtitles_uri")
                            else
                                stream_subtitles_url+=("$stream_link_url_path_cdn/$stream_subtitles_uri")
                            fi
                        fi
                    done
                elif [[ $line =~ RESOLUTION=([^ ]+) ]] 
                then
                    stream_link_resolution=${BASH_REMATCH[1]%%,*}
                    stream_links_resolution+=("$stream_link_resolution")
                    if [[ $line =~ BANDWIDTH=([^ ]+) ]] 
                    then
                        stream_link_bitrate=${BASH_REMATCH[1]%%,*}
                        stream_link_bitrate=$((stream_link_bitrate/1000))
                    else
                        stream_link_bitrate=""
                    fi
                    stream_links_bitrate+=("$stream_link_bitrate")
                    if [ -n "$stream_link_bitrate" ] 
                    then
                        stream_link_bitrate_text=" [ $stream_link_bitrate kb/s ]"
                    else
                        stream_link_bitrate_text=""
                    fi
                    if [[ $line =~ AUDIO=([^ ]+) ]] 
                    then
                        stream_link_audio=${BASH_REMATCH[1]%%,*}
                        stream_link_audio=${stream_link_audio#\"}
                        stream_link_audio=${stream_link_audio%\"}
                    else
                        stream_link_audio=""
                    fi
                    stream_links_audio+=("$stream_link_audio")
                    if [[ $line =~ SUBTITLES=([^ ]+) ]] 
                    then
                        stream_link_subtitles=${BASH_REMATCH[1]%%,*}
                        stream_link_subtitles=${stream_link_subtitles#\"}
                        stream_link_subtitles=${stream_link_subtitles%\"}
                    else
                        stream_link_subtitles=""
                    fi
                    stream_links_subtitles+=("$stream_link_subtitles")
                    stream_links_count=$((stream_links_count+1))
                    stream_links_list="$stream_links_list ${green}$stream_links_count.${normal}${indent_6}$stream_link_resolution$stream_link_bitrate_text $stream_link_audio $stream_link_subtitles\n\n"
                elif [[ $line =~ \.m3u8 ]] 
                then
                    if [[ $line =~ ^https?:// ]] 
                    then
                        stream_links_url+=("$line")
                    else
                        stream_links_url+=("$stream_link_url_path_cdn/$line")
                    fi
                fi
            done <<< "$m3u8_content"

            if [ -n "$stream_links_list" ] 
            then
                if [ "$use_cdn" -eq 1 ] && [[ $stream_link_url =~ $hboasia_host/(.+)$ ]] 
                then
                    stream_link_cdn="https://$hboasia_cdn_host/${BASH_REMATCH[1]}?${stream_links_url[0]#*\?}"
                fi

                choose=1

                if [[ $stream_link =~ \|([^|]+)$ ]] 
                then
                    choose=0
                    stream_link_quality=${BASH_REMATCH[1]}
                    stream_audio_group_id_allow=()
                    stream_audio_name_allow=()
                    stream_subtitles_group_id_allow=()
                    stream_subtitles_name_allow=()

                    IFS="," read -r -a stream_link_qualities <<< "$stream_link_quality"
                    stream_link_qualities_count=${#stream_link_qualities[@]}

                    if [[ $stream_link =~ \|ag:([^|]+) ]] 
                    then
                        stream_audio_group_id_allow_list=${BASH_REMATCH[1]}
                        IFS="," read -ra stream_audio_group_id_allow <<< "$stream_audio_group_id_allow_list"
                    fi

                    if [[ $stream_link =~ \|a:([^|]+) ]] 
                    then
                        stream_audio_name_allow_list=${BASH_REMATCH[1]}
                        IFS="," read -ra stream_audio_name_allow <<< "$stream_audio_name_allow_list"
                    fi

                    if [[ $stream_link =~ \|sg:([^|]+) ]] 
                    then
                        stream_subtitles_group_id_allow_list=${BASH_REMATCH[1]}
                        IFS="," read -ra stream_subtitles_group_id_allow <<< "$stream_subtitles_group_id_allow_list"
                    fi

                    if [[ $stream_link =~ \|s:([^|]+) ]] 
                    then
                        stream_subtitles_name_allow_list=${BASH_REMATCH[1]}
                        IFS="," read -ra stream_subtitles_name_allow <<< "$stream_subtitles_name_allow_list"
                    fi

                    stream_link_video_indices=()

                    for((i=0;i<stream_link_qualities_count;i++));
                    do
                        for((j=0;j<stream_links_count;j++));
                        do
                            if { ! [[ ${stream_link_qualities[i]} =~ - ]] || [ "${stream_links_bitrate[j]}" == "${stream_link_qualities[i]%-*}" ]; } && [ "${stream_links_resolution[j]}" == "${stream_link_qualities[i]#*-}" ]
                            then
                                stream_link_qualities[i]="${stream_links_bitrate[j]}-${stream_links_resolution[j]}"
                                stream_link_video_indices+=("$j")
                                continue 2
                            fi
                        done
                        Println "$error ${stream_link_qualities[i]} 不存在 !"
                        choose=1
                        Println "$error 请重新选择 $channel_name 分辨率"
                        break
                    done
                fi

                if [ "$choose" -eq 1 ]
                then
                    stream_links_select_all=$((stream_links_count+1))
                    stream_links_list="$stream_links_list ${green}$stream_links_select_all.${normal}${indent_6}全部\n"
                    Println "$stream_links_list"
                    echo "选择分辨率 (多个分辨率用空格分隔 比如: 1 2 4-5)"

                    while read -p "(默认: $stream_links_count): " stream_links_num 
                    do
                        stream_links_num=${stream_links_num:-$stream_links_count}

                        if [ "$stream_links_num" == "$stream_links_select_all" ] 
                        then
                            stream_link_qualities=()
                            stream_link_video_indices=()
                            for((i=0;i<stream_links_count;i++));
                            do
                                stream_link_qualities+=("${stream_links_bitrate[i]}-${stream_links_resolution[i]}")
                                stream_link_video_indices+=("$i")
                            done
                            stream_link_qualities_count=$stream_links_count
                            printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
                            stream_link_quality=${stream_link_quality:1}
                            break
                        fi

                        IFS=" " read -ra stream_links_num_arr <<< "$stream_links_num"

                        error_no=0
                        for stream_link_num in "${stream_links_num_arr[@]}"
                        do
                            case "$stream_link_num" in
                                *"-"*)
                                    stream_link_num_start=${stream_link_num%-*}
                                    stream_link_num_end=${stream_link_num#*-}
                                    if [[ $stream_link_num_start == *[!0-9]* ]] || [[ $stream_link_num_end == *[!0-9]* ]] || [ "$stream_link_num_start" -eq 0 ] || [ "$stream_link_num_end" -eq 0 ] || [ "$stream_link_num_end" -gt "$stream_links_count" ] || [ "$stream_link_num_start" -ge "$stream_link_num_end" ]
                                    then
                                        error_no=3
                                    fi
                                ;;
                                *[!0-9]*)
                                    error_no=1
                                ;;
                                *)
                                    if [ "$stream_link_num" -lt 1 ] || [ "$stream_link_num" -gt "$stream_links_count" ] 
                                    then
                                        error_no=2
                                    fi
                                ;;
                            esac
                        done

                        case "$error_no" in
                            1|2|3)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *)
                                stream_link_qualities=()
                                stream_link_video_indices=()

                                for stream_link_num in "${stream_links_num_arr[@]}"
                                do
                                    if [[ $stream_link_num =~ - ]] 
                                    then
                                        start=${stream_link_num%-*}
                                        end=${stream_link_num#*-}
                                        for((i=start-1;i<end;i++));
                                        do
                                            stream_link_qualities+=("${stream_links_bitrate[i]}-${stream_links_resolution[i]}")
                                            stream_link_video_indices+=("$i")
                                        done
                                    else
                                        stream_link_qualities+=("${stream_links_bitrate[stream_link_num-1]}-${stream_links_resolution[stream_link_num-1]}")
                                        stream_link_video_indices+=("$((stream_link_num-1))")
                                    fi
                                done
                                stream_link_qualities_count=${#stream_link_qualities[@]}
                                printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
                                stream_link_quality=${stream_link_quality:1}
                                break
                            ;;
                        esac
                    done
                else
                    printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
                    stream_link_quality=${stream_link_quality:1}
                fi

                if [ -n "${stream_audio_name:-}" ] 
                then
                    stream_link_audio_indices=()
                    choose=1
                    if [ -n "${stream_audio_group_id_allow:-}" ] 
                    then
                        choose=0
                        if [ "${stream_audio_group_id_allow[0]}" == "none" ] 
                        then
                            stream_link_url="${stream_link_url}|ag:none"
                            stream_link_audio_count=0
                        else
                            for((i=0;i<${#stream_audio_group_id_allow[@]};i++));
                            do
                                for((j=0;j<${#stream_audio_group_id[@]};j++));
                                do
                                    if [ "${stream_audio_group_id_allow[i]}" == "${stream_audio_group_id[j]}" ] && [ "${stream_audio_name_allow[i]}" == "${stream_audio_name[j]}" ]
                                    then
                                        stream_link_audio_indices+=("$j")
                                        continue 2
                                    fi
                                done
                                choose=1
                                Println "$error 请重新选择音轨\n"
                                break
                            done
                        fi
                    fi

                    if [ "$choose" -eq 1 ] 
                    then
                        stream_audio_count=${#stream_audio_name[@]}
                        stream_audio_list=""
                        stream_audio_num_default=1

                        for((i=0;i<stream_audio_count;i++));
                        do
                            if [ "${stream_audio_default[i]}" == "YES" ] 
                            then
                                stream_audio_num_default=$((i+1))
                            fi
                            stream_audio_list="$stream_audio_list ${green}$((i+1)).${normal}${indent_6}音轨组: ${green}${stream_audio_group_id[i]}${normal} 名称: ${green}${stream_audio_name[i]}${normal} 语言: ${green}${stream_audio_language[i]}${normal}\n\n"
                        done

                        stream_audio_unselect_all=$((stream_audio_count+1))
                        stream_audio_list="$stream_audio_list ${green}$stream_audio_unselect_all.${normal}${indent_6}不启用\n\n"

                        stream_audio_select_all=$((stream_audio_count+2))
                        stream_audio_list="$stream_audio_list ${green}$stream_audio_select_all.${normal}${indent_6}全部启用"
                        Println "$stream_audio_list\n"
                        echo "选择启用音轨 (多个音轨用空格分隔 比如: 1 2 4-5)"
                        stream_audio_num_default=$stream_audio_select_all

                        while read -p "(默认: $stream_audio_num_default): " stream_audio_num 
                        do
                            stream_audio_num=${stream_audio_num:-$stream_audio_num_default}

                            if [ "$stream_audio_num" == "$stream_audio_unselect_all" ] 
                            then
                                unset 'stream_audio_group_id'
                                unset 'stream_audio_name'
                                break
                            fi

                            if [ "$stream_audio_num" == "$stream_audio_select_all" ] 
                            then
                                stream_link_audio_indices=()
                                for((i=0;i<stream_audio_count;i++));
                                do
                                    stream_link_audio_indices+=("$i")
                                done
                                break
                            fi

                            IFS=" " read -ra stream_audio_num_arr <<< "$stream_audio_num"

                            error_no=0
                            for stream_audio_num in "${stream_audio_num_arr[@]}"
                            do
                                case "$stream_audio_num" in
                                    *"-"*)
                                        stream_audio_num_start=${stream_audio_num%-*}
                                        stream_audio_num_end=${stream_audio_num#*-}
                                        if [[ $stream_audio_num_start == *[!0-9]* ]] || [[ $stream_audio_num_end == *[!0-9]* ]] || [ "$stream_audio_num_start" -eq 0 ] || [ "$stream_audio_num_end" -eq 0 ] || [ "$stream_audio_num_end" -gt "$stream_audio_count" ] || [ "$stream_audio_num_start" -ge "$stream_audio_num_end" ]
                                        then
                                            error_no=3
                                        fi
                                    ;;
                                    *[!0-9]*)
                                        error_no=1
                                    ;;
                                    *)
                                        if [ "$stream_audio_num" -lt 1 ] || [ "$stream_audio_num" -gt "$stream_audio_count" ] 
                                        then
                                            error_no=2
                                        fi
                                    ;;
                                esac
                            done

                            case "$error_no" in
                                1|2|3)
                                    Println "$error $i18n_input_correct_no\n"
                                ;;
                                *)
                                    stream_link_audio_indices=()
                                    for((i=0;i<stream_audio_count;i++));
                                    do
                                        i_num=$((i+1))
                                        for stream_audio_num in "${stream_audio_num_arr[@]}"
                                        do
                                            if [[ $stream_audio_num =~ - ]] 
                                            then
                                                if [ "$i_num" -ge "${stream_audio_num%-*}" ] && [ "$i_num" -le "${stream_audio_num#*-}" ]
                                                then
                                                    stream_link_audio_indices+=("$i")
                                                    continue 2
                                                fi
                                            elif [ "$i_num" -eq "$stream_audio_num" ] 
                                            then
                                                stream_link_audio_indices+=("$i")
                                                continue 2
                                            fi
                                        done
                                        unset 'stream_audio_group_id[i]'
                                        unset 'stream_audio_name[i]'
                                    done
                                    break
                                ;;
                            esac
                        done

                        if [ -n "${stream_audio_name[*]:-}" ] 
                        then
                            printf -v stream_audio_group_id_allow_list ',%s' "${stream_audio_group_id[@]}"
                            stream_audio_group_id_allow_list=${stream_audio_group_id_allow_list:1}
                            printf -v stream_audio_name_allow_list ',%s' "${stream_audio_name[@]}"
                            stream_audio_name_allow_list=${stream_audio_name_allow_list:1}
                            stream_link_url="$stream_link_url|ag:$stream_audio_group_id_allow_list|a:$stream_audio_name_allow_list"
                            stream_link_audio_count=${#stream_audio_name[@]}
                        else
                            stream_link_audio_count=0
                            stream_link_url="${stream_link_url}|ag:none"
                        fi
                    elif [ -n "${stream_link_audio_indices:-}" ] 
                    then
                        stream_link_url="$stream_link_url|ag:$stream_audio_group_id_allow_list|a:$stream_audio_name_allow_list"
                        stream_link_audio_count=${#stream_link_audio_indices[@]}
                    fi
                else
                    stream_link_audio_count=0
                fi

                if [ -n "${stream_subtitles_name:-}" ] 
                then
                    stream_link_subtitles_indices=()
                    choose=1
                    if [ -n "${stream_subtitles_group_id_allow:-}" ] 
                    then
                        choose=0
                        if [ "${stream_subtitles_group_id_allow[0]}" == "none" ] 
                        then
                            stream_link_url="${stream_link_url}|sg:none"
                            stream_link_subtitles_count=0
                        else
                            for((i=0;i<${#stream_subtitles_group_id_allow[@]};i++));
                            do
                                for((j=0;j<${#stream_subtitles_group_id[@]};j++));
                                do
                                    if [ "${stream_subtitles_group_id_allow[i]}" == "${stream_subtitles_group_id[j]}" ] && [ "${stream_subtitles_name_allow[i]}" == "${stream_subtitles_name[j]}" ]
                                    then
                                        stream_link_subtitles_indices+=("$j")
                                        continue 2
                                    fi
                                done
                                choose=1
                                Println "$error 请重新选择字幕\n"
                                break
                            done
                        fi
                    fi

                    if [ "$choose" -eq 1 ] 
                    then
                        stream_subtitles_count=${#stream_subtitles_name[@]}
                        stream_subtitles_list=""
                        stream_subtitles_num_default=1

                        for((i=0;i<stream_subtitles_count;i++));
                        do
                            if [ "${stream_subtitles_default[i]}" == "YES" ] 
                            then
                                stream_subtitles_num_default=$((i+1))
                            fi
                            stream_subtitles_list="$stream_subtitles_list ${green}$((i+1)).${normal}${indent_6}字幕组: ${green}${stream_subtitles_group_id[i]}${normal} 名称: ${green}${stream_subtitles_name[i]}${normal} 语言: ${green}${stream_subtitles_language[i]}${normal}\n\n"
                        done

                        stream_subtitles_unselect_all=$((stream_subtitles_count+1))
                        stream_subtitles_list="$stream_subtitles_list ${green}$stream_subtitles_unselect_all.${normal}${indent_6}不启用\n\n"

                        stream_subtitles_select_all=$((stream_subtitles_count+2))
                        stream_subtitles_list="$stream_subtitles_list ${green}$stream_subtitles_select_all.${normal}${indent_6}全部启用"
                        Println "$stream_subtitles_list\n"
                        echo "选择字幕 (多个字幕用空格分隔 比如: 1 2 4-5)"
                        stream_subtitles_num_default=$stream_subtitles_select_all

                        while read -p "(默认: $stream_subtitles_num_default): " stream_subtitles_num 
                        do
                            stream_subtitles_num=${stream_subtitles_num:-$stream_subtitles_num_default}

                            if [ "$stream_subtitles_num" == "$stream_subtitles_unselect_all" ] 
                            then
                                unset 'stream_subtitles_group_id'
                                unset 'stream_subtitles_name'
                                break
                            fi

                            if [ "$stream_subtitles_num" == "$stream_subtitles_select_all" ] 
                            then
                                stream_link_subtitles_indices=()
                                for((i=0;i<stream_subtitles_count;i++));
                                do
                                    stream_link_subtitles_indices+=("$i")
                                done
                                break
                            fi

                            IFS=" " read -ra stream_subtitles_num_arr <<< "$stream_subtitles_num"

                            error_no=0
                            for stream_subtitles_num in "${stream_subtitles_num_arr[@]}"
                            do
                                case "$stream_subtitles_num" in
                                    *"-"*)
                                        stream_subtitles_num_start=${stream_subtitles_num%-*}
                                        stream_subtitles_num_end=${stream_subtitles_num#*-}
                                        if [[ $stream_subtitles_num_start == *[!0-9]* ]] || [[ $stream_subtitles_num_end == *[!0-9]* ]] || [ "$stream_subtitles_num_start" -eq 0 ] || [ "$stream_subtitles_num_end" -eq 0 ] || [ "$stream_subtitles_num_end" -gt "$stream_subtitles_count" ] || [ "$stream_subtitles_num_start" -ge "$stream_subtitles_num_end" ]
                                        then
                                            error_no=3
                                        fi
                                    ;;
                                    *[!0-9]*)
                                        error_no=1
                                    ;;
                                    *)
                                        if [ "$stream_subtitles_num" -lt 1 ] || [ "$stream_subtitles_num" -gt "$stream_subtitles_count" ] 
                                        then
                                            error_no=2
                                        fi
                                    ;;
                                esac
                            done

                            case "$error_no" in
                                1|2|3)
                                    Println "$error $i18n_input_correct_no\n"
                                ;;
                                *)
                                    stream_link_subtitles_indices=()
                                    for((i=0;i<stream_subtitles_count;i++));
                                    do
                                        i_num=$((i+1))
                                        for stream_subtitles_num in "${stream_subtitles_num_arr[@]}"
                                        do
                                            if [[ $stream_subtitles_num =~ - ]] 
                                            then
                                                if [ "$i_num" -ge "${stream_subtitles_num%-*}" ] && [ "$i_num" -le "${stream_subtitles_num#*-}" ]
                                                then
                                                    stream_link_subtitles_indices+=("$i")
                                                    continue 2
                                                fi
                                            elif [ "$i_num" -eq "$stream_subtitles_num" ] 
                                            then
                                                stream_link_subtitles_indices+=("$i")
                                                continue 2
                                            fi
                                        done
                                        unset 'stream_subtitles_group_id[i]'
                                        unset 'stream_subtitles_name[i]'
                                    done
                                    break
                                ;;
                            esac
                        done

                        if [ -n "${stream_subtitles_name[*]:-}" ] 
                        then
                            printf -v stream_subtitles_group_id_allow_list ',%s' "${stream_subtitles_group_id[@]}"
                            stream_subtitles_group_id_allow_list=${stream_subtitles_group_id_allow_list:1}
                            printf -v stream_subtitles_name_allow_list ',%s' "${stream_subtitles_name[@]}"
                            stream_subtitles_name_allow_list=${stream_subtitles_name_allow_list:1}
                            stream_link_url="$stream_link_url|sg:$stream_subtitles_group_id_allow_list|s:$stream_subtitles_name_allow_list"
                            stream_link_subtitles_count=${#stream_subtitles_name[@]}
                        else
                            stream_link_subtitles_count=0
                            stream_link_url="${stream_link_url}|sg:none"
                        fi
                    elif [ -n "${stream_link_subtitles_indices:-}" ] 
                    then
                        stream_link_url="$stream_link_url|sg:$stream_subtitles_group_id_allow_list|s:$stream_subtitles_name_allow_list"
                        stream_link_subtitles_count=${#stream_link_subtitles_indices[@]}
                    fi
                else
                    stream_link_subtitles_count=0
                fi

                if [[ $stream_link =~ \|origin\| ]] 
                then
                    origin_hls_url=1
                    stream_link=${stream_link_url%%|*}
                    stream_link_url="$stream_link_url|origin"
                elif [[ $stream_link =~ \|parse\| ]] 
                then
                    origin_hls_url=0
                    stream_link=${stream_link_url%%|*}
                    stream_link_url="$stream_link_url|parse"
                else
                    Println "$tip 如果选 是 只修改 map 参数, FFmpeg 输入的将是原链接而非解析链接"
                    inquirer list_input "是否是需要鉴权的直播源" yn_options yn_option
                    if [ "$yn_option" == "$i18n_yes" ] 
                    then
                        origin_hls_url=1
                        stream_link=${stream_link_url%%|*}
                        stream_link_url="$stream_link_url|origin"
                    else
                        origin_hls_url=0
                        stream_link=${stream_link_url%%|*}
                        stream_link_url="$stream_link_url|parse"
                    fi
                fi

                if [[ $stream_links == *" "* ]] 
                then
                    stream_links="$stream_link_url|$stream_link_quality ${stream_links#* }"
                else
                    stream_links="$stream_link_url|$stream_link_quality"
                fi
            else
                Println "$error 没有可选分辨率"
            fi
        fi
    fi

    if [ "$use_cdn" -eq 1 ] 
    then
        hboasia_host=$hboasia_cdn_host
    fi

    SetVideoCodec
    SetAudioCodec
    SetVideoAudioShift

    quality=""
    bitrates=""
    const=""
    const_yn="no"

    if [ "$video_codec" != "copy" ] && [ "${stream_link_qualities_count:-0}" -le 1 ] 
    then
        SetQuality
        SetBitrates
    fi

    if [ -z "$quality" ] && [ -n "$bitrates" ] 
    then
        SetConst
    fi

    draw_text=""

    if [ "${kind:-}" == "flv" ] 
    then
        if [ "$video_codec" != "copy" ] 
        then
            SetDrawtext
        fi
        SetFlvIsH265
        SetFlvPushLink
        SetFlvPullLink
        output_dir_name=$(RandOutputDirName)
        playlist_name=$(RandPlaylistName)
        seg_dir_name=$d_seg_dir_name
        seg_name=$playlist_name
        seg_length=$d_seg_length
        seg_count=$d_seg_count
        encrypt=""
        encrypt_yn="no"
        encrypt_session_yn="no"
        keyinfo_name=$(RandStr)
        key_name=$(RandStr)
        txt_format=""
    else
        SetSubtitle
        if [ "$video_codec" != "copy" ] 
        then
            SetDrawtext
        fi
        flv_h265_yn="no"
        flv_push_link=""
        flv_pull_link=""
        SetOutputDirName
        SetPlaylistName
        SetSegDirName
        SetSegName
        SetSegLength
        if [ -n "$live" ] 
        then
            SetSegCount
        else
            seg_count=$d_seg_count
        fi
        SetEncrypt
        if [ -n "$encrypt" ] 
        then
            SetKeyInfoName
            SetKeyName
        else
            keyinfo_name=$(RandStr)
            key_name=$(RandStr)
        fi
    fi

    subtitle_append=""
    if [ -n "$txt_format" ]
    then
        subtitle_append=',SUBTITLES="subs"'
    fi

    master=0
    if [ "${stream_link_qualities_count:-0}" -gt 0 ] 
    then
        if [[ $bitrates =~ , ]] || [[ $quality =~ , ]] || [ "${stream_link_qualities_count:-0}" -gt 1 ] || [ "${stream_link_audio_count:-0}" -gt 0 ] || [ "${stream_link_subtitles_count:-0}" -gt 0 ] 
        then
            master=1
        fi
    elif [[ $bitrates =~ , ]] || [[ $quality =~ , ]] || [ -n "$subtitle_append" ]
    then
        master=1
    fi

    SetInputFlags
    SetOutputFlags
    SetChannelName
    SetSync

    sync_file=""
    sync_index=""
    sync_pairs=""
    if [ "$sync_yn" == "yes" ]
    then
        SetSyncFile
        SetSyncIndex
        SetSyncPairs
    fi

    FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
    FFMPEG="$FFMPEG_ROOT/ffmpeg"
    export FFMPEG

    if [[ ${input_flags:0:1} == "'" ]] 
    then
        input_flags=${input_flags%\'}
        input_flags=${input_flags#\'}
    fi
    if [[ ${output_flags:0:1} == "'" ]] 
    then
        output_flags=${output_flags%\'}
        output_flags=${output_flags#\'}
    fi

    [ ! -e $FFMPEG_LOG_ROOT ] && mkdir $FFMPEG_LOG_ROOT
    from="AddChannel"

    extra_filters=""
    if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
    then
        filters=( vf filter:v )
        for filter in "${filters[@]}"
        do
            if [[ $output_flags =~ (.*)"-$filter "([^ ]+)(.*) ]] 
            then
                extra_filters="${BASH_REMATCH[2]},"
                output_flags="${BASH_REMATCH[1]} ${BASH_REMATCH[3]}"
            fi
        done
    fi

    FilterString stream_links user_agent headers cookies output_dir_name \
        playlist_name seg_dir_name seg_name keyinfo_name key_name input_flags \
        output_flags channel_name sync_file sync_index sync_pairs flv_push_link \
        flv_pull_link

    if [ -n "${kind:-}" ] 
    then
        if [ "$kind" == "flv" ] 
        then
            if [ "$sh_debug" -eq 1 ] 
            then
                ( FlvStreamCreator ) 
            else
                ( FlvStreamCreator ) > /dev/null 2> /dev/null < /dev/null &
            fi
        else
            Println "$error 暂不支持输出 $kind ...\n" && exit 1
        fi
    else
        if [ "$sh_debug" -eq 1 ] 
        then
            ( HlsStreamCreatorPlus ) 
        else
            ( HlsStreamCreatorPlus ) > /dev/null 2> /dev/null < /dev/null &
        fi
    fi

    stream_audio_url=()
    stream_subtitles_url=()
    stream_link_qualities_count=0
    stream_link_audio_count=0
    stream_link_subtitles_count=0
    xc=0
    xc_proxy=""
    stream_link_quality=""
    stream_link_cdn=""

    Println "$info 频道添加成功 !\n"
}

EditStreamLink()
{
    SetStreamLink
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.stream_link)="'"$stream_links"'"'
    Println "$info 直播源修改成功 !\n"
}

EditLive()
{
    SetLive
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.live)="'"$live_yn"'"'
    Println "$info 无限时长直播修改成功 !\n"
}

EditProxy()
{
    SetProxy
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.proxy)="'"$proxy"'"'
    Println "$info 代理修改成功 !\n"
}

EditXtreamCodesProxy()
{
    SetXtreamCodesProxy
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.xc_proxy)="'"$xc_proxy"'"'
    Println "$info xtream codes 代理修改成功 !\n"
}

EditUserAgent()
{
    SetUserAgent
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.user_agent)="'"$user_agent"'"'
    Println "$info user agent 修改成功 !\n"
}

EditHeaders()
{
    SetHeaders
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.headers)="'"$headers"'"'
    Println "$info headers 修改成功 !\n"
}

EditCookies()
{
    SetCookies
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.cookies)="'"$cookies"'"'
    Println "$info cookies 修改成功 !\n"
}

EditOutputDirName()
{
    if [ "$chnl_status" == "on" ]
    then
        echo
        AskIfContinue n "`gettext \"检测到频道正在运行, 是否现在关闭\"`"
        StopChannel
        echo && echo
    fi
    SetOutputDirName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.output_dir_name)="'"$output_dir_name"'"'
    Println "$info 输出目录名称修改成功 !\n"
}

EditPlaylistName()
{
    SetPlaylistName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.playlist_name)="'"$playlist_name"'"'
    Println "$info m3u8名称修改成功 !\n"
}

EditSegDirName()
{
    SetSegDirName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.seg_dir_name)="'"$seg_dir_name"'"'
    Println "$info 分片所在子目录名称修改成功 !\n"
}

EditSegName()
{
    SetSegName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.seg_name)="'"$seg_name"'"'
    Println "$info 分片名称修改成功 !\n"
}

EditSegLength()
{
    SetSegLength
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.seg_length)='"$seg_length"''
    Println "$info 分片时长修改成功 !\n"
}

EditSegCount()
{
    SetSegCount
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.seg_count)='"$seg_count"''
    Println "$info 分片数目修改成功 !\n"
}

EditVideoCodec()
{
    SetVideoCodec
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.video_codec)="'"$video_codec"'"'
    Println "$info 视频编码修改成功 !\n"
}

EditAudioCodec()
{
    SetAudioCodec
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.audio_codec)="'"$audio_codec"'"'
    Println "$info 音频编码修改成功 !\n"
}

EditVideoAudioShift()
{
    SetVideoAudioShift
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.video_audio_shift)="'"$video_audio_shift"'"'
    Println "$info 视频/音频延迟修改成功 !\n"
}

EditSubtitle()
{
    SetSubtitle
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.txt_format)="'"$txt_format"'"'
    Println "$info dvb teletext 修改成功 !\n"
}

EditDrawtext()
{
    SetDrawtext
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.draw_text)="'"$draw_text"'"'
    Println "$info drawtext 水印修改成功 !\n"
}

EditQuality()
{
    SetQuality
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.quality)="'"$quality"'"'
    Println "$info crf质量值修改成功 !\n"
}

EditBitrates()
{
    SetBitrates
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.bitrates)="'"$bitrates"'"'
    Println "$info 比特率修改成功 !\n"
}

EditConst()
{
    SetConst
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.const)="'"$const_yn"'"'
    Println "$info 是否固定码率修改成功 !\n"
}

EditEncrypt()
{
    SetEncrypt
    JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
    {
        encrypt: "'"$encrypt_yn"'",
        encrypt_session: "'"$encrypt_session_yn"'"
    } // .)'
    Println "$info 加密设置修改成功 !\n"
}

EditKeyInfoName()
{
    SetKeyInfoName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.keyinfo_name)="'"$keyinfo_name"'"'
    Println "$info keyinfo 名称修改成功 !\n"
}

EditKeyName()
{
    SetKeyName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.key_name)="'"$key_name"'"'
    Println "$info key 名称修改成功 !\n"
}

EditInputFlags()
{
    SetInputFlags
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.input_flags)="'"$input_flags"'"'
    Println "$info 输入参数修改成功 !\n"
}

EditOutputFlags()
{
    SetOutputFlags
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.output_flags)="'"$output_flags"'"'
    Println "$info 输出参数修改成功 !\n"
}

EditChannelName()
{
    SetChannelName
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.channel_name)="'"$channel_name"'"'
    Println "$info 频道名称修改成功 !\n"
}

EditSync()
{
    SetSync
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.sync)="'"$sync_yn"'"'
    Println "$info 是否开启 sync 修改成功 !\n"
}

EditSyncFile()
{
    SetSyncFile
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.sync_file)="'"$sync_file"'"'
    Println "$info sync_file 修改成功 !\n"
}

EditSyncIndex()
{
    SetSyncIndex
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.sync_index)="'"$sync_index"'"'
    Println "$info sync_index 修改成功 !\n"
}

EditSyncPairs()
{
    SetSyncPairs
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.sync_pairs)="'"$sync_pairs"'"'
    Println "$info sync_pairs 修改成功 !\n"
}

EditFlvIsH265()
{
    SetFlvIsH265
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.flv_h265)="'"$flv_h265_yn"'"'
    Println "$info 是否推流 h265 修改成功 !\n"
}

EditFlvPushLink()
{
    SetFlvPushLink
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.flv_push_link)="'"$flv_push_link"'"'
    Println "$info 推流地址修改成功 !\n"
}

EditFlvPullLink()
{
    SetFlvPullLink
    JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.flv_pull_link)="'"$flv_pull_link"'"'
    Println "$info 拉流地址修改成功 !\n"
}

EditChannelAll()
{
    if [ "$chnl_flv_status" == "on" ] 
    then
        kind="flv"
        echo
        AskIfContinue n "`gettext \"检测到频道正在运行, 是否现在关闭\"`"
        StopChannel
        echo && echo
    elif [ "$chnl_status" == "on" ]
    then
        kind=""
        echo
        AskIfContinue n "`gettext \"检测到频道正在运行, 是否现在关闭\"`"
        StopChannel
        echo && echo
    fi

    SetStreamLink

    is_local=0
    if [ "${stream_link:0:1}" == "/" ] 
    then
        is_local=1
    fi

    if [[ $stream_link =~ \.m3u8 ]] 
    then
        is_hls=1
    elif [[ $stream_link =~ \.flv ]] || [[ $stream_link =~ \.ts ]]
    then
        is_hls=0
    else
        SetIsHls
    fi

    SetLive

    if [ "${xc:-0}" -eq 0 ] && ! [[ $stream_link =~ ^https?:// ]]
    then
        user_agent=""
        headers=""
        cookies=""
        proxy=""
    else
        SetProxy
        SetUserAgent
        SetHeaders
        SetCookies
    fi

    xc_proxy=${xc_proxy:-}
    if [[ $stream_link =~ ^http://([^/]+) ]] 
    then
        XtreamCodesGetDomains

        for xc_domain in "${xtream_codes_domains[@]}"
        do
            if [ "$xc_domain" == "${BASH_REMATCH[1]}" ] 
            then
                SetXtreamCodesProxy
                break
            fi
        done
    fi

    SetVideoCodec
    SetAudioCodec
    SetVideoAudioShift

    quality=""
    bitrates=""
    const=""
    const_yn="no"

    if [ "$video_codec" != "copy" ] 
    then
        SetQuality
        SetBitrates
    fi

    if [ -z "$quality" ] && [ -n "$bitrates" ] 
    then
        SetConst
    fi

    draw_text=""

    if [ "${kind:-}" == "flv" ] 
    then
        if [ "$video_codec" != "copy" ] 
        then
            SetDrawtext
        fi
        SetFlvIsH265
        SetFlvPushLink
        SetFlvPullLink
        output_dir_name=$(RandOutputDirName)
        playlist_name=$(RandPlaylistName)
        seg_dir_name=$d_seg_dir_name
        seg_name=$playlist_name
        seg_length=$d_seg_length
        seg_count=$d_seg_count
        encrypt=""
        encrypt_yn="no"
        keyinfo_name=$(RandStr)
        key_name=$(RandStr)
        txt_format=""
    else
        SetSubtitle
        if [ "$video_codec" != "copy" ] 
        then
            SetDrawtext
        fi
        flv_h265_yn="no"
        flv_push_link=""
        flv_pull_link=""
        SetOutputDirName
        SetPlaylistName
        SetSegDirName
        SetSegName
        SetSegLength
        if [ -n "$live" ] 
        then
            SetSegCount
        else
            seg_count=$d_seg_count
        fi
        SetEncrypt
        if [ -n "$encrypt" ] 
        then
            SetKeyInfoName
            SetKeyName
        else
            keyinfo_name=$(RandStr)
            key_name=$(RandStr)
        fi
    fi

    SetInputFlags
    SetOutputFlags
    SetChannelName
    SetSync

    sync_file=""
    sync_index=""
    sync_pairs=""
    if [ "$sync_yn" == "yes" ]
    then
        SetSyncFile
        SetSyncIndex
        SetSyncPairs
    fi

    JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
    {
        stream_link: "'"$stream_links"'",
        live: "'"$live_yn"'",
        proxy: "'"$proxy"'",
        xc_proxy: "'"$xc_proxy"'",
        user_agent: "'"$user_agent"'",
        headers: "'"$headers"'",
        cookies: "'"$cookies"'",
        output_dir_name: "'"$output_dir_name"'",
        playlist_name: "'"$playlist_name"'",
        seg_dir_name: "'"$seg_dir_name"'",
        seg_name: "'"$seg_name"'",
        seg_length: '"$seg_length"',
        seg_count: '"$seg_count"',
        video_codec: "'"$video_codec"'",
        audio_codec: "'"$audio_codec"'",
        video_audio_shift: "'"$video_audio_shift"'",
        txt_format: "'"$txt_format"'",
        draw_text: "'"$draw_text"'",
        quality: "'"$quality"'",
        bitrates: "'"$bitrates"'",
        const: "'"$const_yn"'",
        encrypt: "'"$encrypt_yn"'",
        encrypt_session: "'"$encrypt_session_yn"'",
        keyinfo_name: "'"$keyinfo_name"'",
        key_name: "'"$key_name"'",
        input_flags: "'"$input_flags"'",
        output_flags: "'"$output_flags"'",
        channel_name: "'"$channel_name"'",
        sync: "'"$sync_yn"'",
        sync_file: "'"$sync_file"'",
        sync_index: "'"$sync_index"'",
        sync_pairs: "'"$sync_pairs"'",
        flv_h265: "'"$flv_h265_yn"'",
        flv_push_link: "'"$flv_push_link"'",
        flv_pull_link: "'"$flv_pull_link"'"
    } // .)'

    Println "$info 频道 [ $channel_name ] 修改成功 !\n"
}

EditForSecurity()
{
    SetPlaylistName
    SetSegName

    JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"$chnl_pid"') * 
    {
        playlist_name: "'"$playlist_name"'",
        seg_name: "'"$seg_name"'"
    } // .)'

    Println "$info 分片名称, m3u8名称 修改成功 !\n"
}

EditChannelMenu()
{
    ListChannels
    InputChannelsIndex
    i18nGetMsg list_channel
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel
        ListChannel
        Println "选择修改内容

    ${green}1.${normal} 修改 直播源
    ${green}2.${normal} 修改 无限时长直播
    ${green}3.${normal} 修改 代理
    ${green}4.${normal} 修改 xtream codes 代理
    ${green}5.${normal} 修改 user agent
    ${green}6.${normal} 修改 headers
    ${green}7.${normal} 修改 cookies
    ${green}8.${normal} 修改 输出目录名称
    ${green}9.${normal} 修改 m3u8 名称
   ${green}10.${normal} 修改 分片所在子目录名称
   ${green}11.${normal} 修改 分片名称
   ${green}12.${normal} 修改 分片时长
   ${green}13.${normal} 修改 分片数目
   ${green}14.${normal} 修改 视频编码
   ${green}15.${normal} 修改 音频编码
   ${green}16.${normal} 修改 视频/音频延迟
   ${green}17.${normal} 修改 dvb teletext
   ${green}18.${normal} 修改 drawtext 水印
   ${green}19.${normal} 修改 crf 质量值
   ${green}20.${normal} 修改 比特率
   ${green}21.${normal} 修改 是否固定码率
   ${green}22.${normal} 修改 是否加密
   ${green}23.${normal} 修改 keyinfo 名称
   ${green}24.${normal} 修改 key 名称
   ${green}25.${normal} 修改 输入参数
   ${green}26.${normal} 修改 输出参数
   ${green}27.${normal} 修改 频道名称
   ${green}28.${normal} 修改 是否开启 sync
   ${green}29.${normal} 修改 sync file
   ${green}30.${normal} 修改 sync index
   ${green}31.${normal} 修改 sync pairs
   ${green}32.${normal} 修改 是否推流 h265
   ${green}33.${normal} 修改 推流地址
   ${green}34.${normal} 修改 拉流地址
   ${green}35.${normal} 修改 全部配置
    ————— 组合[常用] —————
   ${green}36.${normal} 修改 分片名称, m3u8名称 (防盗链/DDoS)

"
        read -p "$i18n_default_cancel" edit_channel_num
        [ -z "$edit_channel_num" ] && Println "$i18n_canceled...\n" && exit 1
        case $edit_channel_num in
            1)
                EditStreamLink
            ;;
            2)
                EditLive
            ;;
            3)
                EditProxy
            ;;
            4)
                EditXtreamCodesProxy
            ;;
            5)
                EditUserAgent
            ;;
            6)
                EditHeaders
            ;;
            7)
                EditCookies
            ;;
            8)
                EditOutputDirName
            ;;
            9)
                EditPlaylistName
            ;;
            10)
                EditSegDirName
            ;;
            11)
                EditSegName
            ;;
            12)
                EditSegLength
            ;;
            13)
                EditSegCount
            ;;
            14)
                EditVideoCodec
            ;;
            15)
                EditAudioCodec
            ;;
            16)
                EditVideoAudioShift
            ;;
            17)
                EditSubtitle
            ;;
            18)
                EditDrawtext
            ;;
            19)
                EditQuality
            ;;
            20)
                EditBitrates
            ;;
            21)
                EditConst
            ;;
            22)
                EditEncrypt
            ;;
            23)
                EditKeyInfoName
            ;;
            24)
                EditKeyName
            ;;
            25)
                EditInputFlags
            ;;
            26)
                EditOutputFlags
            ;;
            27)
                EditChannelName
            ;;
            28)
                EditSync
            ;;
            29)
                EditSyncFile
            ;;
            30)
                EditSyncIndex
            ;;
            31)
                EditSyncPairs
            ;;
            32)
                EditFlvIsH265
            ;;
            33)
                EditFlvPushLink
            ;;
            34)
                EditFlvPullLink
            ;;
            35)
                EditChannelAll
            ;;
            36)
                EditForSecurity
            ;;
            *)
                echo "$i18n_input_correct_no...\n" && exit 1
            ;;
        esac

        echo
        if [ "$chnl_status" == "on" ] || [ "$chnl_flv_status" == "on" ]
        then
            inquirer list_input "是否重启此频道" yn_options restart_yn

            if [[ $restart_yn == "$i18n_no" ]]
            then
                Println "不重启...\n"
            else
                StopChannel
                GetChannel
                CheckIfXtreamCodes
                if [ "$to_try" -eq 1 ] 
                then
                    continue
                fi
                StartChannel
                Println "$info 频道重启成功 !\n"
            fi
        else
            inquirer list_input "是否启动此频道" yn_options start_yn

            if [[ $start_yn == "$i18n_no" ]]
            then
                Println "不启动...\n"
            else
                GetChannel
                CheckIfXtreamCodes
                if [ "$to_try" -eq 1 ] 
                then
                    continue
                fi
                StartChannel
                Println "$info 频道启动成功 !\n"
            fi
        fi
    done
}

CheckIfXtreamCodes()
{
    XtreamCodesGetDomains

    if [ -z "${FFPROBE:-}" ] 
    then
        FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
        FFPROBE="$FFMPEG_ROOT/ffprobe"
    fi

    to_try=0

    if [[ ${chnl_stream_link##*|} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
    then
        chnl_domain=${chnl_stream_link%%|*}
        chnl_mac=${chnl_stream_link##*|}
        chnl_cmd=${chnl_stream_link%|*}
        chnl_cmd=${chnl_cmd##*|}

        chnl_cmd=${chnl_cmd%\_}
        chnl_cmd="http://localhost/ch/${chnl_cmd##*/}_"

        for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
        do
            if [ "$xc_domain" == "$chnl_domain" ] 
            then
                Println "$info 频道[ $chnl_channel_name ]检测账号中..."
                XtreamCodesGetChnls
                for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                do
                    if [ "$xc_chnl_mac" == "$chnl_domain/$chnl_mac" ] 
                    then
                        to_try=1
                        break
                    fi
                done
                break
            fi
        done

        if [ "$to_try" -eq 1 ] 
        then
            to_try=1
            try_success=0
            MonitorTryAccounts
            if [ "$try_success" -eq 0 ] 
            then
                Println "$error 没有可用账号"
            fi
        else
            GetDefault

            if [ -n "${chnl_xc_proxy:-}" ] 
            then
                server=${chnl_xc_proxy%\/}
                xc_host_header=( -H "xc_host: $chnl_domain" )
            else
                server="http://$chnl_domain"
                xc_host_header=()
            fi

            access_token=""
            profile=""
            chnl_user_agent="$USER_AGENT_TV"
            mac=$(UrlencodeUpper "$chnl_mac")
            timezone=$(UrlencodeUpper "Europe/Amsterdam")
            chnl_cookies="mac=$mac; stb_lang=en; timezone=$timezone"
            token_url="$server/portal.php?type=stb&action=handshake"
            profile_url="$server/portal.php?type=stb&action=get_profile"
            genres_url="$server/portal.php?type=itv&action=get_genres"

            access_token=$(curl -s -Lm 10 \
                -H "User-Agent: $chnl_user_agent" \
                ${xc_host_header[@]+"${xc_host_header[@]}"} \
                --cookie "$chnl_cookies" "$token_url" \
                | $JQ_FILE -r '.js.token') || true
            if [ -z "$access_token" ] 
            then
                to_try=1
                Println "$error $chnl_domain $chnl_mac"
            else
                chnl_headers="Authorization: Bearer $access_token\r\n"
                printf -v chnl_headers_command '%b' "$chnl_headers"
                profile=$(curl -s -Lm 10\
                    -H "$chnl_user_agent" \
                    ${xc_host_header[@]+"${xc_host_header[@]}"} \
                    -H "${chnl_headers:0:-4}" \
                    --cookie "$chnl_cookies" "$profile_url") || true
                if [ -z "$profile" ] 
                then
                    to_try=1
                    Println "$error $chnl_mac profile"
                fi
            fi

            if [ "$to_try" -eq 1 ] || [[ $($JQ_FILE -r '.js.id' <<< "$profile") == null ]] 
            then
                to_try=1
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 0 ] 
                then
                    Println "$error 没有可用账号"
                fi
            else
                if [ -n "$chnl_xc_proxy" ] 
                then
                    server=${chnl_xc_proxy%\/}
                    chnl_stream_link=$(curl -k -s -o /dev/null -w '%{redirect_url}' "$server" \
                        ${xc_host_header[@]+"${xc_host_header[@]}"} \
                        -H "User-Agent: $chnl_user_agent" \
                        -H "${chnl_headers:0:-4}" \
                        -H "cmd: $chnl_cmd" \
                        --cookie "$chnl_cookies")
                    if [[ ! $chnl_stream_link =~ ([^/]+)//([^/]+)/(.+) ]] 
                    then
                        Println "$error $chnl_domain $chnl_mac $chnl_xc_proxy\n" && exit 1
                    fi
                else
                    create_link_url="$server/portal.php?type=itv&action=create_link&cmd=$chnl_cmd&series=&forced_storage=undefined&disable_ad=0&download=0"
                    cmd=$(curl -s -Lm 10 \
                        -H "User-Agent: $chnl_user_agent" \
                        ${xc_host_header[@]+"${xc_host_header[@]}"} \
                        -H "${chnl_headers:0:-4}" \
                        --cookie "$chnl_cookies" "$create_link_url" \
                        | $JQ_FILE -r '.js.cmd') || true

                    if [[ ${cmd#* } =~ ([^/]+)//([^/]+)/live/([^/]+)/([^/]+)/([^/]+) ]] 
                    then
                        chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/live/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                    elif [[ ${cmd#* } =~ ([^/]+)//([^/]+)/([^/]+)/([^/]+)/([^/]+) ]] 
                    then
                        chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                    else
                        Println "$error $chnl_domain 返回 cmd: ${cmd:-无} $chnl_domain $chnl_mac\n" && exit 1
                    fi
                fi

                if [[ $chnl_stream_links == *" "* ]] 
                then
                    chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac ${chnl_stream_links#* }"
                else
                    chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac"
                fi

                Println "$info 跳过检测频道 [ $chnl_channel_name ] 直接开启 ? [y/N]"
                read -t 3 -p "(默认: 3 秒后自动检测): " skip_check_yn || true && echo
                skip_check_yn=${skip_check_yn:-N}
                if [[ $skip_check_yn == [Yy] ]] 
                then
                    return 0
                fi

                audio=0
                video=0
                while IFS= read -r line 
                do
                    if [[ $line == *"codec_type=audio"* ]] 
                    then
                        audio=1
                    elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                    then
                        audio=0
                    elif [[ $line == *"codec_type=video"* ]] 
                    then
                        video=1
                    fi
                done < <($FFPROBE $chnl_proxy_command -user_agent "$chnl_user_agent" -headers "$chnl_headers_command" -cookies "$chnl_cookies" -i "$chnl_stream_link" -rw_timeout 10000000 -show_streams -loglevel quiet)

                if [ "$audio" -eq 0 ] || [ "$video" -eq 0 ]
                then
                    to_try=1
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 0 ] 
                    then
                        Println "$error 没有可用账号"
                    fi
                fi
            fi
        fi
    elif [[ $chnl_stream_link =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]] 
    then
        chnl_domain=${BASH_REMATCH[1]}

        for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
        do
            if [ "$xc_domain" == "$chnl_domain" ] 
            then
                Println "$info 频道[ $chnl_channel_name ]检测账号中..."
                to_try=1
                break
            fi
        done

        xc_chnl_found=0
        if [ "$to_try" -eq 1 ] 
        then
            if [ "${BASH_REMATCH[2]}" == "live" ] && [[ $chnl_stream_link =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]] 
            then
                chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
            else
                chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
            fi
            XtreamCodesGetChnls
            for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
            do
                if [ "$xc_chnl" == "$chnl_domain/$chnl_account" ] 
                then
                    xc_chnl_found=1
                    break
                fi
            done
        fi

        if [ "$xc_chnl_found" -eq 1 ] 
        then
            to_try=1
            try_success=0
            MonitorTryAccounts
            if [ "$try_success" -eq 0 ] 
            then
                Println "$error 没有可用账号"
            fi
        elif [ "$to_try" -eq 1 ] 
        then
            printf -v chnl_headers_command '%b' "$chnl_headers"
            audio=0
            video=0
            while IFS= read -r line 
            do
                if [[ $line == *"codec_type=audio"* ]] 
                then
                    audio=1
                elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                then
                    audio=0
                elif [[ $line == *"codec_type=video"* ]] 
                then
                    video=1
                fi
            done < <($FFPROBE $chnl_proxy_command -user_agent "$chnl_user_agent" -headers "$chnl_headers_command" -cookies "$chnl_cookies" -i "$chnl_stream_link" -rw_timeout 10000000 -show_streams -loglevel quiet)

            if [ "$audio" -eq 0 ] || [ "$video" -eq 0 ] 
            then
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 0 ] 
                then
                    Println "$error 没有可用账号"
                fi
            else
                to_try=0
            fi
        fi
    fi
}

ToggleChannel()
{
    ListChannels
    InputChannelsIndex
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel

        if [ "${kind:-}" == "flv" ] 
        then
            if [ "$chnl_flv_status" == "on" ] 
            then
                StopChannel
            else
                CheckIfXtreamCodes
                if [ "$to_try" -eq 1 ] 
                then
                    continue
                fi
                StartChannel
            fi
        elif [ "$chnl_status" == "on" ] 
        then
            StopChannel
        else
            CheckIfXtreamCodes
            if [ "$to_try" -eq 1 ] 
            then
                continue
            fi
            StartChannel
        fi
    done
}

StartChannel()
{
    chnl_origin_hls_url=0
    chnl_use_cdn=0
    hboasia_host="hbogoasia.com:8443"
    hboasia_cdn_host="dai3fd1oh325y.cloudfront.net"

    if [ "${chnl_stream_link:0:23}" == "https://www.youtube.com" ] || [ "${chnl_stream_link:0:19}" == "https://youtube.com" ] 
    then
        chnl_user_agent="$USER_AGENT_BROWSER"
        chnl_headers=""
        chnl_cookies=""

        if [[ ! -x $(command -v youtube-dl) ]] 
        then
            YoutubeDlInstall
        elif [ "${youtube_dl_updated:-0}" -eq 0 ] 
        then
            youtube-dl -U > /dev/null
            youtube_dl_updated=1
        fi

        Println "$info 解析 youtube 链接..."
        code=${chnl_stream_link#*|}
        chnl_stream_link=${chnl_stream_link%|*}
        if ! chnl_stream_link=$(youtube-dl -f "$code" -g "$chnl_stream_link")
        then
            Println "$error 解析发生错误, 直播链接不存在 ?"
        fi
    elif [ "${chnl_stream_link:13:12}" == "fengshows.cn" ] 
    then
        chnl_user_agent="FengWatch/3.1.8 (iPhone; iOS 13.5; Scale/2.00)"
        chnl_headers="fengshows-client: app(ios,30$(GetFreePort 4000 6000)7);iPhone12,1;13.5\r\n"
        chnl_cookies=""

        feng_id=${chnl_stream_link##*/}
        feng_id=${feng_id%%.*}
        feng_id=$(tr '[:upper:]' '[:lower:]' <<< "$feng_id")

        while IFS=" " read -r title chnl_stream_link
        do
            if { [[ $feng_id == *"pin"* ]] && [ "$title" == "資訊台" ]; } || { [[ $feng_id == *"pcc"* ]] && [ "$title" == "中文台" ]; } || { [[ $feng_id == *"phk"* ]] && [ "$title" == "香港台" ]; }
            then
                break
            fi
        done < <(curl -s -Lm 10 \
            -H "User-Agent: $chnl_user_agent" \
            -H "${chnl_headers:0:-4}" "https://api.fengshows.cn/live?live_type=tv&page=1&page_size=15" \
            | $JQ_FILE -r '.[]|[.title,.live_url_fhd]|join(" ")')

        ts=$(date +%s%3N)
        tx_time=$(printf '%X' $((ts/1000+1800)))

        chnl_stream_link=${chnl_stream_link%\?*}

        relative_path=${chnl_stream_link#*//}
        relative_path="/${relative_path#*/}"

        tx_secret=$(printf '%s' "obb9Lxyv5C${relative_path%.*}$tx_time" | md5sum)
        tx_secret=${tx_secret%% *}

        chnl_stream_link="$chnl_stream_link?txSecret=$tx_secret&txTime=$tx_time"
    elif [[ $chnl_stream_link == *"news.tvb.com"* ]] 
    then
        if [ "${chnl_stream_link:0:5}" == "http:" ] 
        then
            chnl_stream_link="https${chnl_stream_link:4}"
        fi
        chnl_user_agent="$USER_AGENT_BROWSER"
        chnl_headers="Referer: $chnl_stream_link\r\n"
        chnl_cookies=""
        if [[ $chnl_stream_link =~ inews ]] 
        then
            chnl_audio_codec="aac"
            if [ "$chnl_video_codec" == "copy" ] && [[ ! $chnl_output_flags =~ -map ]] 
            then
                chnl_output_flags="$chnl_output_flags -map 0:p:0"
            fi
            if [ "$chnl_video_codec" != "copy" ] 
            then
                if [[ ! $chnl_output_flags =~ -filter:v ]] && [[ ! $chnl_output_flags =~ -vf ]]
                then
                    chnl_output_flags="$chnl_output_flags -filter:v fps=fps=25"
                fi
                if [[ ! $chnl_output_flags =~ -vsync ]] 
                then
                    chnl_output_flags="$chnl_output_flags -vsync 0"
                fi
            fi
            if [[ ! $chnl_output_flags =~ -ar ]] 
            then
                chnl_output_flags="$chnl_output_flags -ar 32000"
            fi
            if [[ ! $chnl_output_flags =~ -copyts ]] 
            then
                chnl_output_flags="$chnl_output_flags -copyts"
            fi
        fi
        while IFS= read -r line 
        do
            if [[ $line =~ tag_deviceid= ]] 
            then
                line=${line#* }
                chnl_cookies=${line%% *}
            elif [[ $line =~ country_code= ]] 
            then
                line=${line#* }
                chnl_cookies="$chnl_cookies ${line%% *}"
                break
            fi
        done < <(curl -s -I -H "User-Agent: $chnl_user_agent" -H "${chnl_headers:0:-4}" -c - "$chnl_stream_link" 2> /dev/null)
        chnl="${chnl_stream_link%\?*}"
        chnl=${chnl##*/}
        token_url=$(curl -s -Lm 10 -H "User-Agent: $chnl_user_agent" -H "${chnl_headers:0:-4}" "https://api.news.tvb.com/news/v2.2.1/live?profile=web" | $JQ_FILE -r '.items[]|select(.path=="'"$chnl"'").video.ios[]|select(.type=="hd").url')
        query_string="$token_url&feed&client_ip=$(GetServerIp)"
        query_string=$(UrlencodeUpper "$query_string")
        chnl_stream_link=$(curl -s -Lm 10 \
            -H "User-Agent: $chnl_user_agent" \
            -H "${chnl_headers:0:-4}" \
            --cookie "$chnl_cookies" \
            "https://news.tvb.com/ajax_call/getVideo.php?token=$query_string" \
            | $JQ_FILE -r '.url')
        while IFS= read -r line 
        do
            if [[ $line =~ hdntl= ]] 
            then
                line=${line#* }
                chnl_cookies="$chnl_cookies ${line%% *}"
                break
            fi
        done < <(curl -s -I -H "User-Agent: $chnl_user_agent" -H "${chnl_headers:0:-4}" --cookie "$chnl_cookies" "$chnl_stream_link" 2> /dev/null)
    elif [[ $chnl_stream_link =~ ^https://embed.4gtv.tv/HiNet/(.+).html ]] 
    then
        Println "$info 解析 [ $chnl_channel_name ] 链接 ..."
        hinet_4gtv=(
            "litv-longturn14:寰宇新聞台"
            "4gtv-4gtv052:華視新聞資訊台"
            "4gtv-4gtv012:空中英語教室"
            "litv-ftv07:民視旅遊台"
            "litv-ftv15:i-Fun動漫台"
            "4gtv-live206:幸福空間居家台"
            "4gtv-4gtv070:愛爾達娛樂台"
            "litv-longturn17:亞洲旅遊台"
            "4gtv-4gtv025:MTV Live HD"
            "litv-longturn15:寰宇新聞台灣台"
            "4gtv-4gtv001:民視台灣台"
            "4gtv-4gtv074:中視新聞台"
            "4gtv-4gtv011:影迷數位電影台"
            "4gtv-4gtv047:靖天日本台"
            "litv-longturn11:龍華日韓台"
            "litv-longturn12:龍華偶像台"
            "4gtv-4gtv042:公視戲劇"
            "litv-ftv12:i-Fun動漫台3"
            "4gtv-4gtv002:民視無線台"
            "4gtv-4gtv027:CI 罪案偵查頻道"
            "4gtv-4gtv013:CNEX DOC CHANNEL"
            "litv-longturn03:龍華電影台"
            "4gtv-4gtv004:民視綜藝台"
            "litv-longturn20:ELTV英語學習台"
            "litv-longturn01:龍華卡通台"
            "4gtv-4gtv040:中視無線台"
            "litv-longturn02:Baby First"
            "4gtv-4gtv003:民視第一台"
            "4gtv-4gtv007:大愛電視台"
            "4gtv-4gtv076:SMART 知識頻道"
            "4gtv-4gtv030:CNBC"
            "litv-ftv10:半島電視台"
        )

        for channel in "${hinet_4gtv[@]}"
        do
            channel_id=${channel%%:*}
            channel_name=${channel#*:}
            channel_name_enc=$(Urlencode "$channel_name")
            if [[ $channel_name_enc == "${BASH_REMATCH[1]}" ]] 
            then
                if [ -n "$chnl_proxy" ] 
                then
                    _4gtv_proxy_command=( -x "$chnl_proxy" )
                else
                    _4gtv_proxy_command=()
                fi
                chnl_user_agent="$USER_AGENT_BROWSER"
                chnl_headers="Referer: https://embed.4gtv.tv/HiNet/$channel_name_enc.html?ar=0&as=1&volume=0\r\n"
                chnl_cookies=""
                stream_link_data=$(curl -s -Lm 10 \
                ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} \
                -H "User-Agent: $chnl_user_agent" \
                -H "${chnl_headers:0:-4}" \
                "https://app.4gtv.tv/Data/HiNet/GetURL.ashx?ChannelNamecallback=channelname&Type=LIVE&Content=$channel_id&HostURL=https%3A%2F%2Fwww.hinet.net%2Ftv%2F&_=$(date +%s%3N)") || true
                if [ -n "$stream_link_data" ] 
                then
                    stream_link_data=$($JQ_FILE -r '.VideoURL' <<< "${stream_link_data:12:-1}")
                    hexkey=$(echo -n "VxzAfiseH0AbLShkQOPwdsssw5KyLeuv" | hexdump -v -e '/1 "%02x"')
                    hexiv=$(echo -n "${stream_link_data:0:16}" | hexdump -v -e '/1 "%02x"')
                    chnl_stream_link_url=$(echo "${stream_link_data:16}" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a)
                    chnl_stream_link_url_path=${chnl_stream_link_url%/*}
                    Start4gtvLink
                elif [ -z "${monitor:-}" ]
                then
                    Println "$error 无法连接 4gtv !\n" && exit 1
                fi
                break
            fi
        done
    elif [[ $chnl_stream_link == *"4gtv.tv/"* ]] 
    then
        Println "$info 解析 [ $chnl_channel_name ] 链接 ..."
        chnl_user_agent="$USER_AGENT_BROWSER"
        chnl_headers="Referer: ${chnl_stream_link%%|*}\r\n"
        chnl_cookies=""
        if [ -n "$chnl_proxy" ] 
        then
            _4gtv_proxy_command=( -x "$chnl_proxy" )
        else
            _4gtv_proxy_command=()
        fi
        set_id=${chnl_stream_link#*channelSet_id=}
        set_id=${set_id%%&*}
        set_id=${set_id%%|*}
        fsVALUE=""
        if [ "$set_id" -eq 1 ] 
        then
            GetServiceAccs 4gtv
            for((i=0;i<${#_4gtv_accs_token[@]};i++));
            do
                if [ -n "${_4gtv_accs_token[i]:-}" ] 
                then
                    fsVALUE=${_4gtv_accs_token[i]}
                    break
                fi
            done
        fi
        fnCHANNEL_ID=${chnl_stream_link#*channel_id=}
        fnCHANNEL_ID=${fnCHANNEL_ID%%&*}
        fnCHANNEL_ID=${fnCHANNEL_ID%%|*}
        fsASSET_ID=${chnl_stream_link#*asset_id=}
        fsASSET_ID=${fsASSET_ID%%&*}
        fsASSET_ID=${fsASSET_ID%%|*}
        key="ilyB29ZdruuQjC45JhBBR7o2Z8WJ26Vg"
        iv="JUMxvVMmszqUTeKn"
        hexkey=$(echo -n $key | hexdump -v -e '/1 "%02x"')
        hexiv=$(echo -n $iv | hexdump -v -e '/1 "%02x"')
        post_data='{"fnCHANNEL_ID":'"$fnCHANNEL_ID"',"fsASSET_ID":"'"$fsASSET_ID"'","fsDEVICE_TYPE":"pc","clsIDENTITY_VALIDATE_ARUS":{"fsVALUE":"'$fsVALUE'"}}'
        post_data=$(echo -n "$post_data" | openssl enc -aes-256-cbc -iv "$hexiv" -K "$hexkey" -a)
        if [ -n "$fsVALUE" ] 
        then
            value="$(UrlencodeUpper ${post_data//[[:space:]]/})"
        else
            value="$(Urlencode ${post_data//[[:space:]]/})"
        fi
        for((try_i=0;try_i<10;try_i++));
        do
            stream_link_data=$(curl -s -Lm 10 -X POST \
            ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} \
            -H "User-Agent: $chnl_user_agent" \
            -H "${chnl_headers:0:-4}" \
            --data "value=$value" \
            "https://api2.4gtv.tv/Channel/GetChannelUrl3") || true
            if [ -n "$stream_link_data" ] 
            then
                break
            fi
        done
        if [ -n "$stream_link_data" ] 
        then
            stream_link_data=$($JQ_FILE -r '.Data' <<< "$stream_link_data")
            if [ "$stream_link_data" != null ] 
            then
                chnl_stream_link_url=$(echo "$stream_link_data" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a \
                    | $JQ_FILE -r '.flstURLs[0]')
                chnl_stream_link_url_path=${chnl_stream_link_url%/*}
                Start4gtvLink
            elif [ -z "${monitor:-}" ] 
            then
                Println "$error 此服务器 ip 不支持或频道不可用!\n"
            fi
        elif [ -z "${monitor:-}" ] 
        then
            Println "$error 无法连接 4gtv !\n" && exit 1
        fi
    elif [[ ${chnl_stream_link##*|} =~ ([0-9]+)-([0-9]+)x([0-9]+) ]] 
    then
        chnl_stream_link_url=${chnl_stream_link%%|*}
        chnl_stream_link_url_path=${chnl_stream_link_url%/*}

        chnl_stream_link_url_path_cdn=$chnl_stream_link_url_path
        if [[ $chnl_stream_link_url_path =~ $hboasia_host/(.+)$ ]] 
        then
            if [ "$chnl_use_cdn" -eq 1 ] 
            then
                chnl_stream_link_url_path_cdn="https://$hboasia_cdn_host/${BASH_REMATCH[1]}"
            fi
            #chnl_headers="range: \r\n"
            if [[ ! $chnl_output_flags =~ -seekable ]] 
            then
                chnl_output_flags="$chnl_output_flags -seekable 0"
            fi
            if [[ ! $chnl_output_flags =~ -vsync ]] 
            then
                chnl_output_flags="$chnl_output_flags -vsync 0"
            fi
        fi

        chnl_stream_audio_group_id=()
        chnl_stream_audio_name=()
        chnl_stream_audio_default=()
        chnl_stream_audio_language=()
        chnl_stream_audio_url=()
        chnl_stream_subtitles_group_id=()
        chnl_stream_subtitles_name=()
        chnl_stream_subtitles_default=()
        chnl_stream_subtitles_language=()
        chnl_stream_subtitles_url=()
        chnl_stream_links_bitrate=()
        chnl_stream_links_resolution=()
        chnl_stream_links_url=()
        chnl_stream_links_audio=()
        chnl_stream_links_subtitles=()
        chnl_stream_links_list=""
        chnl_stream_links_count=0

        while IFS= read -r line 
        do
            if [[ $line =~ TYPE=AUDIO ]] 
            then
                IFS="," read -r -a chnl_stream_audio <<< "${line#*:}"
                chnl_stream_audio_keys=(${chnl_stream_audio[*]%%=*})
                chnl_stream_audio_values=(${chnl_stream_audio[*]#*=})
                for((i=0;i<${#chnl_stream_audio_keys[@]};i++));
                do
                    if [ "${chnl_stream_audio_keys[i]}" == "GROUP-ID" ] 
                    then
                        chnl_stream_audio_group_id+=("${chnl_stream_audio_values[i]//\"/}")
                    elif [ "${chnl_stream_audio_keys[i]}" == "NAME" ] 
                    then
                        chnl_stream_audio_name+=("${chnl_stream_audio_values[i]//\"/}")
                    elif [ "${chnl_stream_audio_keys[i]}" == "DEFAULT" ] 
                    then
                        chnl_stream_audio_default+=("${chnl_stream_audio_values[i]}")
                    elif [ "${chnl_stream_audio_keys[i]}" == "LANGUAGE" ] 
                    then
                        chnl_stream_audio_language+=("${chnl_stream_audio_values[i]//\"/}")
                    elif [ "${chnl_stream_audio_keys[i]}" == "URI" ] 
                    then
                        chnl_stream_audio_uri=${chnl_stream_audio_values[i]//\"/}
                        if [[ $chnl_stream_audio_uri =~ ^https?:// ]] 
                        then
                            chnl_stream_audio_url+=("$chnl_stream_audio_uri")
                        else
                            chnl_stream_audio_url+=("$chnl_stream_link_url_path_cdn/$chnl_stream_audio_uri")
                        fi
                    fi
                done
            elif [[ $line =~ TYPE=SUBTITLES ]] 
            then
                IFS="," read -r -a chnl_stream_subtitles <<< "${line#*:}"
                chnl_stream_subtitles_keys=(${chnl_stream_subtitles[*]%%=*})
                chnl_stream_subtitles_values=(${chnl_stream_subtitles[*]#*=})
                for((i=0;i<${#chnl_stream_subtitles_keys[@]};i++));
                do
                    if [ "${chnl_stream_subtitles_keys[i]}" == "GROUP-ID" ] 
                    then
                        chnl_stream_subtitles_group_id+=("${chnl_stream_subtitles_values[i]//\"/}")
                    elif [ "${chnl_stream_subtitles_keys[i]}" == "NAME" ] 
                    then
                        chnl_stream_subtitles_name+=("${chnl_stream_subtitles_values[i]//\"/}")
                    elif [ "${chnl_stream_subtitles_keys[i]}" == "DEFAULT" ] 
                    then
                        chnl_stream_subtitles_default+=("${chnl_stream_subtitles_values[i]}")
                    elif [ "${chnl_stream_subtitles_keys[i]}" == "LANGUAGE" ] 
                    then
                        chnl_stream_subtitles_language+=("${chnl_stream_subtitles_values[i]//\"/}")
                    elif [ "${chnl_stream_subtitles_keys[i]}" == "URI" ] 
                    then
                        chnl_stream_subtitles_uri=${chnl_stream_subtitles_values[i]//\"/}
                        if [[ $chnl_stream_subtitles_uri =~ ^https?:// ]] 
                        then
                            chnl_stream_subtitles_url+=("$chnl_stream_subtitles_uri")
                        else
                            chnl_stream_subtitles_url+=("$chnl_stream_link_url_path_cdn/$chnl_stream_subtitles_uri")
                        fi
                    fi
                done
            elif [[ $line =~ RESOLUTION=([^ ]+) ]] 
            then
                chnl_stream_link_resolution=${BASH_REMATCH[1]%%,*}
                chnl_stream_links_resolution+=("$chnl_stream_link_resolution")
                if [[ $line =~ BANDWIDTH=([^ ]+) ]] 
                then
                    chnl_stream_link_bitrate=${BASH_REMATCH[1]%%,*}
                    chnl_stream_link_bitrate=$((chnl_stream_link_bitrate/1000))
                else
                    chnl_stream_link_bitrate=""
                fi
                chnl_stream_links_bitrate+=("$chnl_stream_link_bitrate")
                if [ -n "$chnl_stream_link_bitrate" ] 
                then
                    chnl_stream_link_bitrate_text=" [ $chnl_stream_link_bitrate kb/s ]"
                else
                    chnl_stream_link_bitrate_text=""
                fi
                if [[ $line =~ AUDIO=([^ ]+) ]] 
                then
                    chnl_stream_link_audio=${BASH_REMATCH[1]%%,*}
                    chnl_stream_link_audio=${chnl_stream_link_audio#\"}
                    chnl_stream_link_audio=${chnl_stream_link_audio%\"}
                else
                    chnl_stream_link_audio=""
                fi
                chnl_stream_links_audio+=("$chnl_stream_link_audio")
                if [[ $line =~ SUBTITLES=([^ ]+) ]] 
                then
                    chnl_stream_link_subtitles=${BASH_REMATCH[1]%%,*}
                    chnl_stream_link_subtitles=${chnl_stream_link_subtitles#\"}
                    chnl_stream_link_subtitles=${chnl_stream_link_subtitles%\"}
                else
                    chnl_stream_link_subtitles=""
                fi
                chnl_stream_links_subtitles+=("$chnl_stream_link_subtitles")
                chnl_stream_links_count=$((chnl_stream_links_count+1))
                chnl_stream_links_list="$chnl_stream_links_list ${green}$chnl_stream_links_count.${normal}${indent_6}$chnl_stream_link_resolution$chnl_stream_link_bitrate_text $chnl_stream_link_audio $chnl_stream_link_subtitles\n\n"
            elif [[ $line =~ \.m3u8 ]] 
            then
                if [[ $line =~ ^https?:// ]] 
                then
                    chnl_stream_links_url+=("$line")
                else
                    chnl_stream_links_url+=("$chnl_stream_link_url_path_cdn/$line")
                fi
            fi
        done < <(curl -s -Lm 20 -H "User-Agent: $chnl_user_agent" "$chnl_stream_link_url")

        if [ -n "$chnl_stream_links_list" ] 
        then
            if [ "$chnl_use_cdn" -eq 1 ] && [[ $chnl_stream_link_url =~ $hboasia_host/(.+)$ ]] 
            then
                chnl_stream_link_cdn="https://$hboasia_cdn_host/${BASH_REMATCH[1]}?${chnl_stream_links_url[0]#*\?}"
            fi

            choose=1
            if [[ $chnl_stream_link =~ \|([^|]+)$ ]] 
            then
                choose=0
                chnl_stream_link_quality=${BASH_REMATCH[1]}
                chnl_stream_audio_group_id_allow=()
                chnl_stream_audio_name_allow=()
                chnl_stream_subtitles_group_id_allow=()
                chnl_stream_subtitles_name_allow=()

                IFS="," read -r -a chnl_stream_link_qualities <<< "$chnl_stream_link_quality"
                chnl_stream_link_qualities_count=${#chnl_stream_link_qualities[@]}

                if [[ $chnl_stream_link =~ \|ag:([^|]+) ]] 
                then
                    chnl_stream_audio_group_id_allow_list=${BASH_REMATCH[1]}
                    IFS="," read -ra chnl_stream_audio_group_id_allow <<< "$chnl_stream_audio_group_id_allow_list"
                fi

                if [[ $chnl_stream_link =~ \|a:([^|]+) ]] 
                then
                    chnl_stream_audio_name_allow_list=${BASH_REMATCH[1]}
                    IFS="," read -ra chnl_stream_audio_name_allow <<< "$chnl_stream_audio_name_allow_list"
                fi

                if [[ $chnl_stream_link =~ \|sg:([^|]+) ]] 
                then
                    chnl_stream_subtitles_group_id_allow_list=${BASH_REMATCH[1]}
                    IFS="," read -ra chnl_stream_subtitles_group_id_allow <<< "$chnl_stream_subtitles_group_id_allow_list"
                fi

                if [[ $chnl_stream_link =~ \|s:([^|]+) ]] 
                then
                    chnl_stream_subtitles_name_allow_list=${BASH_REMATCH[1]}
                    IFS="," read -ra chnl_stream_subtitles_name_allow <<< "$chnl_stream_subtitles_name_allow_list"
                fi

                chnl_stream_link_video_indices=()

                for((i=0;i<chnl_stream_link_qualities_count;i++));
                do
                    for((j=0;j<chnl_stream_links_count;j++));
                    do
                        if { ! [[ ${chnl_stream_link_qualities[i]} =~ - ]] || [ "${chnl_stream_links_bitrate[j]}" == "${chnl_stream_link_qualities[i]%-*}" ] || [ -n "${monitor:-}" ]; } && [ "${chnl_stream_links_resolution[j]}" == "${chnl_stream_link_qualities[i]#*-}" ]
                        then
                            chnl_stream_link_qualities[i]="${chnl_stream_links_bitrate[j]}-${chnl_stream_links_resolution[j]}"
                            chnl_stream_link_video_indices+=("$j")
                            continue 2
                        fi
                    done
                    Println "$error ${chnl_stream_link_qualities[i]} 不存在 !"
                    choose=1
                    Println "$error 请重新选择 $chnl_channel_name 分辨率"
                    break
                done
            fi

            if [ "$choose" -eq 1 ]
            then
                if [ -z "${monitor:-}" ] 
                then
                    chnl_stream_links_select_all=$((chnl_stream_links_count+1))
                    chnl_stream_links_list="$chnl_stream_links_list ${green}$chnl_stream_links_select_all.${normal}${indent_6}全部\n"
                    Println "$chnl_stream_links_list"
                    echo "选择分辨率 (多个分辨率用空格分隔 比如: 1 2 4-5)"

                    while read -p "(默认: $chnl_stream_links_count): " chnl_stream_links_num 
                    do
                        chnl_stream_links_num=${chnl_stream_links_num:-$chnl_stream_links_count}

                        if [ "$chnl_stream_links_num" == "$chnl_stream_links_select_all" ] 
                        then
                            chnl_stream_link_qualities=()
                            chnl_stream_link_video_indices=()
                            for((i=0;i<chnl_stream_links_count;i++));
                            do
                                chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[i]}-${chnl_stream_links_resolution[i]}")
                                chnl_stream_link_video_indices+=("$i")
                            done
                            chnl_stream_link_qualities_count=$chnl_stream_links_count
                            printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
                            chnl_stream_link_quality=${chnl_stream_link_quality:1}
                            break
                        fi

                        IFS=" " read -ra chnl_stream_links_num_arr <<< "$chnl_stream_links_num"

                        error_no=0
                        for chnl_stream_link_num in "${chnl_stream_links_num_arr[@]}"
                        do
                            case "$chnl_stream_link_num" in
                                *"-"*)
                                    chnl_stream_link_num_start=${chnl_stream_link_num%-*}
                                    chnl_stream_link_num_end=${chnl_stream_link_num#*-}
                                    if [[ $chnl_stream_link_num_start == *[!0-9]* ]] || [[ $chnl_stream_link_num_end == *[!0-9]* ]] || [ "$chnl_stream_link_num_start" -eq 0 ] || [ "$chnl_stream_link_num_end" -eq 0 ] || [ "$chnl_stream_link_num_end" -gt "$chnl_stream_links_count" ] || [ "$chnl_stream_link_num_start" -ge "$chnl_stream_link_num_end" ]
                                    then
                                        error_no=3
                                    fi
                                ;;
                                *[!0-9]*)
                                    error_no=1
                                ;;
                                *)
                                    if [ "$chnl_stream_link_num" -lt 1 ] || [ "$chnl_stream_link_num" -gt "$chnl_stream_links_count" ] 
                                    then
                                        error_no=2
                                    fi
                                ;;
                            esac
                        done

                        case "$error_no" in
                            1|2|3)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *)
                                chnl_stream_link_qualities=()
                                chnl_stream_link_video_indices=()
                                for chnl_stream_link_num in "${chnl_stream_links_num_arr[@]}"
                                do
                                    if [[ $chnl_stream_link_num =~ - ]] 
                                    then
                                        start=${chnl_stream_link_num%-*}
                                        end=${chnl_stream_link_num#*-}
                                        for((i=start-1;i<end;i++));
                                        do
                                            chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[i]}-${chnl_stream_links_resolution[i]}")
                                            chnl_stream_link_video_indices+=("$i")
                                        done
                                    else
                                        chnl_stream_links_index=$((chnl_stream_link_num-1))
                                        chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[chnl_stream_links_index]}-${chnl_stream_links_resolution[chnl_stream_links_index]}")
                                        chnl_stream_link_video_indices+=("$chnl_stream_links_index")
                                    fi
                                done
                                chnl_stream_link_qualities_count=${#chnl_stream_link_qualities[@]}
                                printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
                                chnl_stream_link_quality=${chnl_stream_link_quality:1}
                                break
                            ;;
                        esac
                    done
                else
                    chnl_stream_link_qualities=("$((chnl_stream_links_count-1))")
                    chnl_stream_link_quality="${chnl_stream_links_bitrate[chnl_stream_links_count-1]}-${chnl_stream_links_resolution[chnl_stream_links_count-1]}"
                    chnl_stream_link_qualities_count=1
                fi
            else
                printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
                chnl_stream_link_quality=${chnl_stream_link_quality:1}
            fi

            if [ -n "${chnl_stream_audio_name:-}" ] 
            then
                chnl_stream_link_audio_indices=()
                choose=1
                if [ -n "${chnl_stream_audio_group_id_allow:-}" ] 
                then
                    choose=0
                    if [ "${chnl_stream_audio_group_id_allow[0]}" == "none" ] 
                    then
                        chnl_stream_link_url="${chnl_stream_link_url}|ag:none"
                        chnl_stream_link_audio_count=0
                    else
                        for((i=0;i<${#chnl_stream_audio_group_id_allow[@]};i++));
                        do
                            for((j=0;j<${#chnl_stream_audio_group_id[@]};j++));
                            do
                                if [ "${chnl_stream_audio_group_id_allow[i]}" == "${chnl_stream_audio_group_id[j]}" ] && [ "${chnl_stream_audio_name_allow[i]}" == "${chnl_stream_audio_name[j]}" ]
                                then
                                    chnl_stream_link_audio_indices+=("$j")
                                    continue 2
                                fi
                            done
                            if [ -n "${monitor:-}" ] 
                            then
                                MonitorError "$chnl_channel_name 请重新选择音轨"
                                return 0
                            fi
                            choose=1
                            Println "$error 请重新选择音轨\n"
                            break
                        done
                    fi
                fi

                if [ "$choose" -eq 1 ] 
                then
                    chnl_stream_audio_count=${#chnl_stream_audio_name[@]}
                    chnl_stream_audio_list=""
                    chnl_stream_audio_num_default=1

                    for((i=0;i<chnl_stream_audio_count;i++));
                    do
                        if [ "${chnl_stream_audio_default[i]}" == "YES" ] 
                        then
                            chnl_stream_audio_num_default=$((i+1))
                        fi
                        chnl_stream_audio_list="$chnl_stream_audio_list ${green}$((i+1)).${normal}${indent_6}音轨组: ${green}${chnl_stream_audio_group_id[i]}${normal} 名称: ${green}${chnl_stream_audio_name[i]}${normal} 语言: ${green}${chnl_stream_audio_language[i]}${normal}\n\n"
                    done

                    chnl_stream_audio_unselect_all=$((chnl_stream_audio_count+1))
                    chnl_stream_audio_list="$chnl_stream_audio_list ${green}$chnl_stream_audio_unselect_all.${normal}${indent_6}不启用\n\n"

                    chnl_stream_audio_select_all=$((chnl_stream_audio_count+2))
                    chnl_stream_audio_list="$chnl_stream_audio_list ${green}$chnl_stream_audio_select_all.${normal}${indent_6}全部启用"
                    Println "$chnl_stream_audio_list\n"
                    echo "选择启用音轨 (多个音轨用空格分隔 比如: 1 2 4-5)"
                    chnl_stream_audio_num_default=$chnl_stream_audio_select_all

                    while read -p "(默认: $chnl_stream_audio_num_default): " chnl_stream_audio_num 
                    do
                        chnl_stream_audio_num=${chnl_stream_audio_num:-$chnl_stream_audio_num_default}

                        if [ "$chnl_stream_audio_num" == "$chnl_stream_audio_unselect_all" ] 
                        then
                            unset 'chnl_stream_audio_group_id'
                            unset 'chnl_stream_audio_name'
                            break
                        fi

                        if [ "$chnl_stream_audio_num" == "$chnl_stream_audio_select_all" ] 
                        then
                            chnl_stream_link_audio_indices=()
                            for((i=0;i<chnl_stream_audio_count;i++));
                            do
                                chnl_stream_link_audio_indices+=("$i")
                            done
                            break
                        fi

                        IFS=" " read -ra chnl_stream_audio_num_arr <<< "$chnl_stream_audio_num"

                        error_no=0
                        for chnl_stream_audio_num in "${chnl_stream_audio_num_arr[@]}"
                        do
                            case "$chnl_stream_audio_num" in
                                *"-"*)
                                    chnl_stream_audio_num_start=${chnl_stream_audio_num%-*}
                                    chnl_stream_audio_num_end=${chnl_stream_audio_num#*-}
                                    if [[ $chnl_stream_audio_num_start == *[!0-9]* ]] || [[ $chnl_stream_audio_num_end == *[!0-9]* ]] || [ "$chnl_stream_audio_num_start" -eq 0 ] || [ "$chnl_stream_audio_num_end" -eq 0 ] || [ "$chnl_stream_audio_num_end" -gt "$chnl_stream_audio_count" ] || [ "$chnl_stream_audio_num_start" -ge "$chnl_stream_audio_num_end" ]
                                    then
                                        error_no=3
                                    fi
                                ;;
                                *[!0-9]*)
                                    error_no=1
                                ;;
                                *)
                                    if [ "$chnl_stream_audio_num" -lt 1 ] || [ "$chnl_stream_audio_num" -gt "$chnl_stream_audio_count" ] 
                                    then
                                        error_no=2
                                    fi
                                ;;
                            esac
                        done

                        case "$error_no" in
                            1|2|3)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *)
                                chnl_stream_link_audio_indices=()
                                for((i=0;i<chnl_stream_audio_count;i++));
                                do
                                    i_num=$((i+1))
                                    for chnl_stream_audio_num in "${chnl_stream_audio_num_arr[@]}"
                                    do
                                        if [[ $chnl_stream_audio_num =~ - ]] 
                                        then
                                            if [ "$i_num" -ge "${chnl_stream_audio_num%-*}" ] && [ "$i_num" -le "${chnl_stream_audio_num#*-}" ]
                                            then
                                                chnl_stream_link_audio_indices+=("$i")
                                                continue 2
                                            fi
                                        elif [ "$i_num" -eq "$chnl_stream_audio_num" ] 
                                        then
                                            chnl_stream_link_audio_indices+=("$i")
                                            continue 2
                                        fi
                                    done
                                    unset 'chnl_stream_audio_group_id[i]'
                                    unset 'chnl_stream_audio_name[i]'
                                done
                                break
                            ;;
                        esac
                    done

                    if [ -n "${chnl_stream_audio_name[*]:-}" ] 
                    then
                        printf -v chnl_stream_audio_group_id_allow_list ',%s' "${chnl_stream_audio_group_id[@]}"
                        chnl_stream_audio_group_id_allow_list=${chnl_stream_audio_group_id_allow_list:1}
                        printf -v chnl_stream_audio_name_allow_list ',%s' "${chnl_stream_audio_name[@]}"
                        chnl_stream_audio_name_allow_list=${chnl_stream_audio_name_allow_list:1}
                        chnl_stream_link_url="$chnl_stream_link_url|ag:$chnl_stream_audio_group_id_allow_list|a:$chnl_stream_audio_name_allow_list"
                        chnl_stream_link_audio_count=${#chnl_stream_audio_name[@]}
                    else
                        chnl_stream_link_audio_count=0
                        chnl_stream_link_url="${chnl_stream_link_url}|ag:none"
                    fi
                elif [ -n "${chnl_stream_link_audio_indices:-}" ] 
                then
                    chnl_stream_link_audio_count=${#chnl_stream_link_audio_indices[@]}
                    chnl_stream_link_url="${chnl_stream_link_url}|ag:$chnl_stream_audio_group_id_allow_list|a:$chnl_stream_audio_name_allow_list"
                fi
            else
                chnl_stream_link_audio_count=0
            fi

            if [ -n "${chnl_stream_subtitles_name:-}" ] 
            then
                chnl_stream_link_subtitles_indices=()
                choose=1
                if [ -n "${chnl_stream_subtitles_group_id_allow:-}" ] 
                then
                    choose=0
                    if [ "${chnl_stream_subtitles_group_id_allow[0]}" == "none" ] 
                    then
                        chnl_stream_link_url="${chnl_stream_link_url}|sg:none"
                        chnl_stream_link_subtitles_count=0
                    else
                        for((i=0;i<${#chnl_stream_subtitles_group_id_allow[@]};i++));
                        do
                            for((j=0;j<${#chnl_stream_subtitles_group_id[@]};j++));
                            do
                                if [ "${chnl_stream_subtitles_group_id_allow[i]}" == "${chnl_stream_subtitles_group_id[j]}" ] && [ "${chnl_stream_subtitles_name_allow[i]}" == "${chnl_stream_subtitles_name[j]}" ]
                                then
                                    chnl_stream_link_subtitles_indices+=("$j")
                                    continue 2
                                fi
                            done
                            if [ -n "${monitor:-}" ] 
                            then
                                MonitorError "$chnl_channel_name 请重新选择字幕"
                                return 0
                            fi
                            choose=1
                            Println "$error 请重新选择字幕\n"
                            break
                        done
                    fi
                fi

                if [ "$choose" -eq 1 ] 
                then
                    chnl_stream_subtitles_count=${#chnl_stream_subtitles_name[@]}
                    chnl_stream_subtitles_list=""
                    chnl_stream_subtitles_num_default=1

                    for((i=0;i<chnl_stream_subtitles_count;i++));
                    do
                        if [ "${chnl_stream_subtitles_default[i]}" == "YES" ] 
                        then
                            chnl_stream_subtitles_num_default=$((i+1))
                        fi
                        chnl_stream_subtitles_list="$chnl_stream_subtitles_list ${green}$((i+1)).${normal}${indent_6}字幕组: ${green}${chnl_stream_subtitles_group_id[i]}${normal} 名称: ${green}${chnl_stream_subtitles_name[i]}${normal} 语言: ${green}${chnl_stream_subtitles_language[i]}${normal}\n\n"
                    done

                    chnl_stream_subtitles_unselect_all=$((chnl_stream_subtitles_count+1))
                    chnl_stream_subtitles_list="$chnl_stream_subtitles_list ${green}$chnl_stream_subtitles_unselect_all.${normal}${indent_6}不启用\n\n"

                    chnl_stream_subtitles_select_all=$((chnl_stream_subtitles_count+2))
                    chnl_stream_subtitles_list="$chnl_stream_subtitles_list ${green}$chnl_stream_subtitles_select_all.${normal}${indent_6}全部启用"
                    Println "$chnl_stream_subtitles_list\n"
                    echo "选择字幕 (多个字幕用空格分隔 比如: 1 2 4-5)"
                    chnl_stream_subtitles_num_default=$chnl_stream_subtitles_select_all

                    while read -p "(默认: $chnl_stream_subtitles_num_default): " chnl_stream_subtitles_num 
                    do
                        chnl_stream_subtitles_num=${chnl_stream_subtitles_num:-$chnl_stream_subtitles_num_default}

                        if [ "$chnl_stream_subtitles_num" == "$chnl_stream_subtitles_unselect_all" ] 
                        then
                            unset 'chnl_stream_subtitles_group_id'
                            unset 'chnl_stream_subtitles_name'
                            break
                        fi

                        if [ "$chnl_stream_subtitles_num" == "$chnl_stream_subtitles_select_all" ] 
                        then
                            chnl_stream_link_subtitles_indices=()
                            for((i=0;i<chnl_stream_subtitles_count;i++));
                            do
                                chnl_stream_link_subtitles_indices+=("$i")
                            done
                            break
                        fi

                        IFS=" " read -ra chnl_stream_subtitles_num_arr <<< "$chnl_stream_subtitles_num"

                        error_no=0
                        for chnl_stream_subtitles_num in "${chnl_stream_subtitles_num_arr[@]}"
                        do
                            case "$chnl_stream_subtitles_num" in
                                *"-"*)
                                    chnl_stream_subtitles_num_start=${chnl_stream_subtitles_num%-*}
                                    chnl_stream_subtitles_num_end=${chnl_stream_subtitles_num#*-}
                                    if [[ $chnl_stream_subtitles_num_start == *[!0-9]* ]] || [[ $chnl_stream_subtitles_num_end == *[!0-9]* ]] || [ "$chnl_stream_subtitles_num_start" -eq 0 ] || [ "$chnl_stream_subtitles_num_end" -eq 0 ] || [ "$chnl_stream_subtitles_num_end" -gt "$chnl_stream_subtitles_count" ] || [ "$chnl_stream_subtitles_num_start" -ge "$chnl_stream_subtitles_num_end" ]
                                    then
                                        error_no=3
                                    fi
                                ;;
                                *[!0-9]*)
                                    error_no=1
                                ;;
                                *)
                                    if [ "$chnl_stream_subtitles_num" -lt 1 ] || [ "$chnl_stream_subtitles_num" -gt "$chnl_stream_subtitles_count" ] 
                                    then
                                        error_no=2
                                    fi
                                ;;
                            esac
                        done

                        case "$error_no" in
                            1|2|3)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *)
                                chnl_stream_link_subtitles_indices=()
                                for((i=0;i<chnl_stream_subtitles_count;i++));
                                do
                                    i_num=$((i+1))
                                    for chnl_stream_subtitles_num in "${chnl_stream_subtitles_num_arr[@]}"
                                    do
                                        if [[ $chnl_stream_subtitles_num =~ - ]] 
                                        then
                                            if [ "$i_num" -ge "${chnl_stream_subtitles_num%-*}" ] && [ "$i_num" -le "${chnl_stream_subtitles_num#*-}" ]
                                            then
                                                chnl_stream_link_subtitles_indices+=("$i")
                                                continue 2
                                            fi
                                        elif [ "$i_num" -eq "$chnl_stream_subtitles_num" ] 
                                        then
                                            chnl_stream_link_subtitles_indices+=("$i")
                                            continue 2
                                        fi
                                    done
                                    unset 'chnl_stream_subtitles_group_id[i]'
                                    unset 'chnl_stream_subtitles_name[i]'
                                done
                                break
                            ;;
                        esac
                    done

                    if [ -n "${chnl_stream_subtitles_name[*]:-}" ] 
                    then
                        printf -v chnl_stream_subtitles_group_id_allow_list ',%s' "${chnl_stream_subtitles_group_id[@]}"
                        chnl_stream_subtitles_group_id_allow_list=${chnl_stream_subtitles_group_id_allow_list:1}
                        printf -v chnl_stream_subtitles_name_allow_list ',%s' "${chnl_stream_subtitles_name[@]}"
                        chnl_stream_subtitles_name_allow_list=${chnl_stream_subtitles_name_allow_list:1}
                        chnl_stream_link_url="$chnl_stream_link_url|sg:$chnl_stream_subtitles_group_id_allow_list|s:$chnl_stream_subtitles_name_allow_list"
                        chnl_stream_link_subtitles_count=${#chnl_stream_subtitles_name[@]}
                    else
                        chnl_stream_link_subtitles_count=0
                        chnl_stream_link_url="${chnl_stream_link_url}|sg:none"
                    fi
                elif [ -n "${chnl_stream_link_subtitles_indices:-}" ] 
                then
                    chnl_stream_link_subtitles_count=${#chnl_stream_link_subtitles_indices[@]}
                    chnl_stream_link_url="${chnl_stream_link_url}|sg:$chnl_stream_subtitles_group_id_allow_list|s:$chnl_stream_subtitles_name_allow_list"
                fi
            else
                chnl_stream_link_subtitles_count=0
            fi

            if [[ $chnl_stream_link =~ \|parse\| ]] 
            then
                chnl_origin_hls_url=0
                chnl_stream_link=${chnl_stream_link_url%%|*}
                chnl_stream_link_url="$chnl_stream_link_url|parse"
            elif [[ $chnl_stream_link =~ \|origin\| ]] || [ -n "${monitor:-}" ]
            then
                chnl_origin_hls_url=1
                chnl_stream_link=${chnl_stream_link_url%%|*}
                chnl_stream_link_url="${chnl_stream_link_url}|origin"
            else
                Println "$tip 如果选 是 只修改 map 参数, FFmpeg 输入的将是原链接而非解析链接"
                inquirer list_input "是否是需要鉴权的直播源" yn_options yn_option
                if [ "$yn_option" == "$i18n_yes" ] 
                then
                    chnl_origin_hls_url=1
                    chnl_stream_link=${chnl_stream_link_url%%|*}
                    chnl_stream_link_url="$chnl_stream_link_url|origin"
                else
                    chnl_origin_hls_url=0
                    chnl_stream_link=${chnl_stream_link_url%%|*}
                    chnl_stream_link_url="$chnl_stream_link_url|parse"
                fi
            fi

            if [[ $chnl_stream_links == *" "* ]] 
            then
                chnl_stream_links="$chnl_stream_link_url|$chnl_stream_link_quality ${chnl_stream_links#* }"
            else
                chnl_stream_links="$chnl_stream_link_url|$chnl_stream_link_quality"
            fi
        fi
    elif [[ $chnl_stream_link == http://*.macaulotustv.com/* ]] 
    then
        chnl_user_agent="$USER_AGENT_BROWSER"
        chnl_headers="Origin: http://www.lotustv.cc\r\nReferer: http://www.lotustv.cc/index.php/index/live.html\r\n"
        chnl_cookies=""
    elif [ "${chnl_stream_link:0:4}" == "rtmp" ] || [ "${chnl_stream_link:0:1}" == "/" ]
    then
        chnl_input_flags=${chnl_input_flags//-timeout 2000000000/}
        chnl_input_flags=${chnl_input_flags//-reconnect 1/}
        chnl_input_flags=${chnl_input_flags//-reconnect_at_eof 1/}
        chnl_input_flags=${chnl_input_flags//-reconnect_streamed 1/}
        chnl_input_flags=${chnl_input_flags//-reconnect_delay_max 2000/}
        lead=${chnl_input_flags%%[^[:blank:]]*}
        chnl_input_flags=${chnl_input_flags#${lead}}
    elif [[ $chnl_stream_link == *"pngquant.com"* ]] 
    then
        chnl_headers="x-forwarded-for: 127.0.0.1\r\n"
        if [[ ! $chnl_output_flags =~ -vsync ]] 
        then
            chnl_output_flags="$chnl_output_flags -vsync 0"
        fi
        if [[ ! $chnl_output_flags =~ -copyts ]] 
        then
            chnl_output_flags="$chnl_output_flags -copyts"
        fi
    fi

    if [ "$chnl_use_cdn" -eq 1 ] 
    then
        hboasia_host=$hboasia_cdn_host
    fi

    if [[ $chnl_stream_link == *".m3u8"* ]] 
    then
        chnl_input_flags=${chnl_input_flags//-reconnect_at_eof 1/}
    fi

    chnl_subtitle_append=""
    if [ -n "$chnl_txt_format" ]
    then
        chnl_subtitle_append=',SUBTITLES="subs"'
    fi

    master=0
    if [ "${chnl_stream_link_qualities_count:-0}" -gt 0 ] 
    then
        if [[ $chnl_bitrates =~ , ]] || [[ $chnl_quality =~ , ]] || [ "${chnl_stream_link_qualities_count:-0}" -gt 1 ] || [ "${chnl_stream_link_audio_count:-0}" -gt 0 ] || [ "${chnl_stream_link_subtitles_count:-0}" -gt 0 ] 
        then
            master=1
        fi
    elif [[ $chnl_bitrates =~ , ]] || [[ $chnl_quality =~ , ]] || [ -n "$chnl_subtitle_append" ]
    then
        master=1
    fi

    if [ "$chnl_video_codec" == "copy" ]
    then
        chnl_quality=""
        chnl_bitrates=""
        chnl_const=""
    fi

    if [ -n "${chnl_txt_format:-}" ] && [ -z "${kind:-}" ]
    then
        if [ -z "$chnl_input_flags" ] 
        then
            chnl_input_flags="-txt_format $chnl_txt_format -fix_sub_duration"
        else
            if [[ ! $chnl_input_flags =~ -fix_sub_duration ]] 
            then
                chnl_input_flags="-fix_sub_duration $chnl_input_flags"
            fi
            if [[ ! $chnl_input_flags =~ -txt_format ]] 
            then
                chnl_input_flags="-txt_format $chnl_txt_format $chnl_input_flags"
            fi
        fi
    else
        chnl_txt_format=""
        chnl_input_flags=${chnl_input_flags//-txt_format bitmap/}
        chnl_input_flags=${chnl_input_flags//-txt_format text/}
        chnl_input_flags=${chnl_input_flags//-txt_format ass/}
        chnl_input_flags=${chnl_input_flags//-fix_sub_duration/}
    fi

    FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
    FFMPEG="$FFMPEG_ROOT/ffmpeg"
    export FFMPEG

    if [[ ${chnl_input_flags:0:1} == "'" ]] 
    then
        chnl_input_flags=${chnl_input_flags%\'}
        chnl_input_flags=${chnl_input_flags#\'}
    fi
    if [[ ${chnl_output_flags:0:1} == "'" ]] 
    then
        chnl_output_flags=${chnl_output_flags%\'}
        chnl_output_flags=${chnl_output_flags#\'}
    fi

    [ ! -e $FFMPEG_LOG_ROOT ] && mkdir $FFMPEG_LOG_ROOT
    from="StartChannel"

    printf -v start_time '%(%s)T' -1
    chnl_channel_time=$start_time

    chnl_extra_filters=""
    if [ "$chnl_video_codec" != "copy" ] && [ -n "$chnl_draw_text" ] 
    then
        filters=( vf filter:v )
        for filter in "${filters[@]}"
        do
            if [[ $chnl_output_flags =~ (.*)"-$filter "([^ ]+)(.*) ]] 
            then
                chnl_extra_filters="${BASH_REMATCH[2]},"
                chnl_output_flags="${BASH_REMATCH[1]} ${BASH_REMATCH[3]}"
            fi
        done
    fi

    FilterString chnl_stream_links chnl_user_agent chnl_headers chnl_cookies \
        chnl_output_dir_name chnl_playlist_name chnl_seg_dir_name chnl_seg_name \
        chnl_keyinfo_name chnl_key_name chnl_input_flags chnl_output_flags chnl_channel_name \
        chnl_sync_file chnl_sync_index chnl_sync_pairs chnl_flv_push_link chnl_flv_pull_link

    if [ -n "${kind:-}" ] 
    then
        if [ "$chnl_status" == "on" ] 
        then
            Println "$error HLS 频道正开启, 走错片场了？\n" && exit 1
        fi
        if [ "$chnl_flv_h265_yn" == "yes" ] 
        then
            if [[ ! -x $(command -v ffmpeg_c) ]]  
            then
                if [ -z "${monitor:-}" ] 
                then
                    echo
                    ffmpeg_c_options=( '快速安装' '编译 ffmpeg (耗时非常非常久)' )
                    inquirer list_input "选择 ffmpeg (h265版本) 安装方式" ffmpeg_c_options ffmpeg_c_option
                    if [[ $ffmpeg_c_option == "快速安装" ]] 
                    then
                        if curl -L "$FFMPEG_MIRROR_LINK/ffmpeg_c" -o /usr/local/bin/ffmpeg_c
                        then
                            chmod +x /usr/local/bin/ffmpeg_c
                        else
                            Println "$error 暂时无法连接服务器, 请稍后再试 !\n"
                            exit 1
                        fi
                    else
                        FFmpegCompile
                    fi
                else
                    chnl_flv_h265_yn="no"
                fi
            fi
        fi
        chnl_output_flags=${chnl_output_flags//-sc_threshold 0/}
        if [ "$kind" == "flv" ] 
        then
            rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.log"
            rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.err"
            rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
            if [ "$sh_debug" -eq 1 ] 
            then
                ( FlvStreamCreator ) 
            else
                ( FlvStreamCreator ) > /dev/null 2> /dev/null < /dev/null &
            fi
        else
            Println "$error 暂不支持输出 $kind ...\n" && exit 1
        fi
    else
        if [ "$chnl_flv_status" == "on" ] 
        then
            Println "$error FLV 频道正开启, 走错片场了？\n" && exit 1
        fi
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.log"
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.err"
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
        if [ "$sh_debug" -eq 1 ] 
        then
            ( HlsStreamCreatorPlus )
        else
            ( HlsStreamCreatorPlus ) > /dev/null 2> /dev/null < /dev/null &
        fi
    fi

    chnl_stream_audio_url=()
    chnl_stream_subtitles_url=()
    chnl_stream_link_qualities_count=0
    chnl_stream_link_audio_count=0
    chnl_stream_link_subtitles_count=0
    xc=0
    chnl_xc_proxy=""
    chnl_stream_link_quality=""
    chnl_stream_link_cdn=""

    Println "$info 频道 [ $chnl_channel_name ] 已开启 !\n"
}

StopChannel()
{
    if [ -n "${kind:-}" ]
    then
        if [ "$kind" != "flv" ] 
        then
            Println "$error 暂不支持 $kind ...\n" && exit 1
        elif [ "$chnl_status" == "on" ]
        then
            Println "$error HLS 频道正开启, 走错片场了？\n" && exit 1
        fi
    elif [ "$chnl_flv_status" == "on" ]
    then
        Println "$error FLV 频道正开启, 走错片场了？\n" && exit 1
    fi

    Println "$info 关闭频道, 请稍等..."
    if [ "${kind:-}" == "flv" ] 
    then
        if ! kill -0 "$chnl_pid" 2> /dev/null 
        then
            MonitorError "频道[ $chnl_channel_name ] 进程 $chnl_pid 不存在"
            JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.flv_status)="off"'
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            printf '%s\n' "$date_now $chnl_channel_name FLV 关闭" >> "$MONITOR_LOG"
            action="stop"
            SyncFile
            rm -rf "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
        else
            kill "$chnl_pid" 2> /dev/null || true
            if ! flock -E 1 -w 30 -x "$FFMPEG_LOG_ROOT/$chnl_pid.pid" rm -rf "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
            then
                MonitorError "频道[ $chnl_channel_name ] 进程 $chnl_pid 不存在"
                JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.flv_status)="off"'
                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                printf '%s\n' "$date_now $chnl_channel_name FLV 关闭" >> "$MONITOR_LOG"
                action="stop"
                SyncFile
            fi
        fi
        chnl_flv_status="off"
    else
        if ! kill -0 "$chnl_pid" 2> /dev/null
        then
            MonitorError "频道[ $chnl_channel_name ] 进程 $chnl_pid 不存在"
            JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.status)="off"'
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            printf '%s\n' "$date_now $chnl_channel_name HLS 关闭" >> "$MONITOR_LOG"
            action="stop"
            SyncFile
            rm -rf "$chnl_output_dir_root"
            rm -rf "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
        else
            kill "$chnl_pid" 2> /dev/null
            if ! flock -E 1 -w 30 -x "$FFMPEG_LOG_ROOT/$chnl_pid.pid" rm -rf "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
            then
                MonitorError "频道[ $chnl_channel_name ] 进程 $chnl_pid 不存在"
                JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.status)="off"'
                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                printf '%s\n' "$date_now $chnl_channel_name HLS 关闭" >> "$MONITOR_LOG"
                action="stop"
                SyncFile
                rm -rf "$chnl_output_dir_root"
            fi
        fi
        chnl_status="off"
    fi
    Println "$info 频道[ $chnl_channel_name ]已关闭 !\n"
}

StopChannelsForce()
{
    pkill -9 -f ffmpeg 2> /dev/null || true
    pkill -f 'tv m' 2> /dev/null || true
    rm -rf "$CHANNELS_FILE.lockdir"

    GetChannels
    GetDefault

    for((i=0;i<chnls_count;i++));
    do
        JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"${chnls_pid[i]}"') * 
        {
            status: "off",
            flv_status: "off"
        } // .)'

        chnl_sync_file=${chnls_sync_file[i]}
        chnl_sync_file=${chnl_sync_file:-$d_sync_file}
        IFS=" " read -ra chnl_sync_files <<< "$chnl_sync_file"

        for sync_file in ${chnl_sync_files[@]+"${chnl_sync_files[@]}"}
        do
            rm -rf "$sync_file.lockdir"
        done

        action="stop"
        SyncFile > /dev/null

        if [ "${chnls_live[i]}" == "yes" ] 
        then
            rm -rf "${chnls_output_dir_root[i]}"
        fi
    done
    Println "$info 全部频道已关闭 !\n"
}

RestartChannel()
{
    ListChannels
    InputChannelsIndex
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel
        if [ "${kind:-}" == "flv" ] 
        then
            if [ "$chnl_flv_status" == "on" ] 
            then
                action="skip"
                StopChannel
            fi
        elif [ "$chnl_status" == "on" ] 
        then
            action="skip"
            StopChannel
        fi
        CheckIfXtreamCodes
        if [ "$to_try" -eq 1 ] 
        then
            continue
        fi
        StartChannel
        Println "$info 频道重启成功 !\n"
    done
}

ViewChannelLog()
{
    ListChannels
    InputChannelsIndex
    i18nGetMsg list_channel
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel
        ListChannel

        Println "${green}输出日志:${normal}\n"
        if [ -s "$FFMPEG_LOG_ROOT/$chnl_pid.log" ] 
        then
            tail -n 10 "$FFMPEG_LOG_ROOT/$chnl_pid.log"
        else
            echo "无"
        fi

        Println "${red}错误日志:${normal}\n"
        if [ -s "$FFMPEG_LOG_ROOT/$chnl_pid.err" ] 
        then
            cat "$FFMPEG_LOG_ROOT/$chnl_pid.err"
        else
            echo "无"
        fi
        echo
    done
}

DelChannel()
{
    ListChannels
    InputChannelsIndex
    for chnl_pid in "${chnls_pid_chosen[@]}"
    do
        GetChannel
        if [ "${kind:-}" == "flv" ] 
        then
            if [ "$chnl_flv_status" == "on" ] 
            then
                StopChannel
            fi
        elif [ "$chnl_status" == "on" ] 
        then
            StopChannel
        fi
        JQ delete "$CHANNELS_FILE" channels "$chnl_pid"
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.log"
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.err"
        rm -f "$FFMPEG_LOG_ROOT/$chnl_pid.pid"
        Println "$info 频道[ $chnl_channel_name ]删除成功 !\n"
    done
}

EditDefault()
{
    jq_path='["default","'"$1"'"]'
    if [ -n "${2:-}" ] 
    then
        JQ update "$CHANNELS_FILE" "$2"
    else
        JQ update "$CHANNELS_FILE" "${!1}"
    fi
    Println "$info $1 修改成功\n"
}

EditDefaultMenu()
{
    Println "选择修改内容

    ${green}1.${normal} 默认 代理
    ${green}2.${normal} 默认 xtream codes 代理
    ${green}3.${normal} 默认 user agent
    ${green}4.${normal} 默认 headers
    ${green}5.${normal} 默认 cookies
    ${green}6.${normal} 默认 m3u8 名称
    ${green}7.${normal} 默认 分片目录名称
    ${green}8.${normal} 默认 分片名称
    ${green}9.${normal} 默认 分片时长
   ${green}10.${normal} 默认 分片数目
   ${green}11.${normal} 默认 视频编码
   ${green}12.${normal} 默认 音频编码
   ${green}13.${normal} 默认 视频/音频延迟
   ${green}14.${normal} 默认 dvb teletext
   ${green}15.${normal} 默认 drawtext 水印
   ${green}16.${normal} 默认 crf 质量值
   ${green}17.${normal} 默认 比特率
   ${green}18.${normal} 默认 是否固定码率
   ${green}19.${normal} 默认 是否加密
   ${green}20.${normal} 默认 keyinfo 名称
   ${green}21.${normal} 默认 key 名称
   ${green}22.${normal} 默认 输入参数
   ${green}23.${normal} 默认 输出参数
   ${green}24.${normal} 默认 sync 开关
   ${green}25.${normal} 默认 sync file
   ${green}26.${normal} 默认 sync index
   ${green}27.${normal} 默认 sync pairs
   ${green}28.${normal} 默认 节目表文件
   ${green}29.${normal} 默认 flv 超时时间
   ${green}30.${normal} 默认 flv 重启次数
   ${green}31.${normal} 默认 hls 超时时间
   ${green}32.${normal} 默认 hls 最低比特率
   ${green}33.${normal} 默认 hls 允许最大分片
   ${green}34.${normal} 默认 hls 重启次数
   ${green}35.${normal} 默认 hls key 持续时间
   ${green}36.${normal} 默认 anti ddos 封禁端口
   ${green}37.${normal} 默认 SYN Flood 防御
   ${green}38.${normal} 默认 anti ddos
   ${green}39.${normal} 默认 anti leech
   ${green}40.${normal} 默认 重启失败后定时检查间隔时间

"
    read -p "$i18n_default_cancel" edit_default_num
    [ -z "$edit_default_num" ] && Println "$i18n_canceled...\n" && exit 1

    GetDefault
    set_default=1

    case $edit_default_num in
        1)
            SetProxy
            EditDefault proxy
        ;;
        2)
            SetXtreamCodesProxy
            EditDefault xc_proxy
        ;;
        3)
            SetUserAgent
            EditDefault user_agent
        ;;
        4)
            SetHeaders
            EditDefault headers
        ;;
        5)
            SetCookies
            EditDefault cookies
        ;;
        6)
            SetPlaylistName
            EditDefault playlist_name
        ;;
        7)
            SetSegDirName
            EditDefault seg_dir_name
        ;;
        8)
            SetSegName
            EditDefault seg_name
        ;;
        9)
            SetSegLength
            EditDefault seg_length
        ;;
        10)
            SetSegCount
            EditDefault seg_count
        ;;
        11)
            SetVideoCodec
            EditDefault video_codec
        ;;
        12)
            SetAudioCodec
            EditDefault audio_codec
        ;;
        13)
            SetVideoAudioShift
            EditDefault video_audio_shift
        ;;
        14)
            SetSubtitle
            EditDefault txt_format
        ;;
        15)
            SetDrawtext
            EditDefault draw_text
        ;;
        16)
            SetQuality
            EditDefault quality
        ;;
        17)
            SetBitrates
            EditDefault bitrates
        ;;
        18)
            SetConst
            EditDefault const "$const_yn"
        ;;
        19)
            SetEncrypt
            EditDefault encrypt "$encrypt_yn"
            EditDefault encrypt_session "$encrypt_session_yn"
        ;;
        20)
            SetKeyInfoName
            EditDefault keyinfo_name
        ;;
        21)
            SetKeyName
            EditDefault key_name
        ;;
        22)
            SetInputFlags
            EditDefault input_flags
        ;;
        23)
            SetOutputFlags
            EditDefault output_flags
        ;;
        24)
            SetSync
            EditDefault sync "$sync_yn"
        ;;
        25)
            SetSyncFile
            EditDefault sync_file
        ;;
        26)
            SetSyncIndex
            EditDefault sync_index
        ;;
        27)
            SetSyncPairs
            EditDefault sync_pairs
        ;;
        28)
            SetScheduleFile
            EditDefault schedule_file
        ;;
        29)
            SetFlvDelaySeconds
            EditDefault flv_delay_seconds
        ;;
        30)
            SetFlvRestartNums
            EditDefault flv_restart_nums
        ;;
        31)
            SetHlsDelaySeconds
            EditDefault hls_delay_seconds
        ;;
        32)
            SetHlsMinBitrates
            EditDefault hls_min_bitrates
        ;;
        33)
            SetHlsMaxSegSize
            EditDefault hls_max_seg_size
        ;;
        34)
            SetHlsRestartNums
            EditDefault hls_restart_nums
        ;;
        35)
            SetHlsKeyPeriod
            EditDefault hls_key_period
        ;;
        36)
            SetAntiDDosPort
            EditDefault anti_ddos_port
        ;;
        37)
            SetAntiDDosSynFlood
            EditDefault anti_ddos_syn_flood "$anti_ddos_syn_flood_yn"
            if [ "$anti_ddos_syn_flood_yn" == "yes" ] 
            then
                EditDefault anti_ddos_syn_flood_delay_seconds
                EditDefault anti_ddos_syn_flood_seconds
            fi
        ;;
        38)
            SetAntiDDos
            EditDefault anti_ddos "$anti_ddos_yn"
            if [ "$anti_ddos_yn" == "yes" ] 
            then
                EditDefault anti_ddos_seconds
                EditDefault anti_ddos_level
            fi
        ;;
        39)
            SetAntiLeech
            EditDefault anti_leech "$anti_leech_yn"
            if [ "$anti_leech_yn" == "yes" ] 
            then
                EditDefault anti_leech_restart_nums
                EditDefault anti_leech_restart_flv_changes "$anti_leech_restart_flv_changes_yn"
                EditDefault anti_leech_restart_hls_changes "$anti_leech_restart_hls_changes_yn"
            fi
        ;;
        40)
            SetRecheckPeriod
            EditDefault recheck_period
        ;;
        *)
            Println "$i18n_input_correct_no...\n"
            exit 1
        ;;
    esac
}

Set4gtvAccEmail()
{
    Println "输入新账号邮箱"
    while read -p "(默认: 随机): " _4gtv_acc_email 
    do
        [ -z "$_4gtv_acc_email" ] && _4gtv_acc_email="$(RandStr)_$(printf '%(%s)T' -1)@gmail.com"
        if [[ $_4gtv_acc_email =~ ^[A-Za-z0-9]([a-zA-Z0-9_\.\-]*)@([A-Za-z0-9]+)([a-zA-Z0-9\.\-]*)\.([A-Za-z]{2,})$ ]] 
        then
            break
        else
            Println "$error 邮箱格式错误, 请重新输入\n"
        fi
    done
    Println "  4gtv 账号邮箱: ${green} $_4gtv_acc_email ${normal}\n"
}

Set4gtvAccPass()
{
    Println "输入新账号密码(字母或数字 8-12 位)"
    while read -p "(默认: 随机): " _4gtv_acc_pass 
    do
        [ -z "$_4gtv_acc_pass" ] && _4gtv_acc_pass=$(RandStr)
        if [[ $_4gtv_acc_pass =~ ^[A-Za-z0-9]{8,12}$ ]] 
        then
            break
        else
            Println "$error 账号密码格式错误, 请重新输入\n"
        fi
    done
    Println "  4gtv 账号密码: ${green} $_4gtv_acc_pass ${normal}\n"
}

Reg4gtvAcc()
{
    Set4gtvAccEmail
    Set4gtvAccPass
    IFS=" " read -r result msg < <(curl -s -Lm 10 'https://api2.4gtv.tv/Account/Register' \
        -H "User-Agent: $user_agent" \
        -H 'Origin: https://www.4gtv.tv' \
        -H 'Referer: https://www.4gtv.tv/signup.html' \
        -d "fnREGISTER_TYPE=1&fsLOGIN_TYPE=&fsLINK_ID=&fsUSER=$_4gtv_acc_email&fsLOGIN_TYPE=&fsLINK_ID=&fsPASSWORD=$_4gtv_acc_pass&fsPASSWORD1=$_4gtv_acc_pass&fnBIRTH_YEAR=$((RANDOM%20+1980))&fsSEX=male" \
        | $JQ_FILE -r '[.Success,.ErrMessage]|join(" ")'
    ) || true

    if [ "$result" == "true" ]
    then
        if [ ! -s "$SERVICES_FILE" ] 
        then
            printf '{"%s":{"%s":[]}}' "4gtv" "accounts" > "$SERVICES_FILE"
        fi
        new_acc=$(
        $JQ_FILE -n --arg email "$_4gtv_acc_email" --arg password "$_4gtv_acc_pass" \
            '{
                email: $email,
                password: $password
            }'
        )
        jq_path='["4gtv","accounts"]'
        JQ add "$SERVICES_FILE" "$new_acc"
        Println "$info 账号注册成功\n"
    else
        Println "$error 账号注册失败, 请重试\n\n$msg\n"
    fi
}

GetServiceAccs()
{
    local service_name=$1
    if [ ! -s "$SERVICES_FILE" ] 
    then
        printf '{"%s":{"%s":[]}}' "$service_name" "accounts" > "$SERVICES_FILE"
    fi
    case $service_name in
        "4gtv") 
            delimiters=( $'\001' )
            IFS=$'\002\t' read -r _4gtv_acc_email _4gtv_acc_pass _4gtv_acc_token < <(JQs flat "$SERVICES_FILE" '' '
            ."'"$service_name"'".accounts as $accounts |
            reduce ({email,password,token}|keys_unsorted[]) as $key ([];
            $accounts[$key] as $val | if $val then
                . + [$val + "\u0001\u0002"]
            else
                . + ["\u0002"]
            end
            )|@tsv' "${delimiters[@]}")

            IFS=$'\001' read -r -a _4gtv_accs_email <<< "$_4gtv_acc_email"
            IFS=$'\001' read -r -a _4gtv_accs_pass <<< "$_4gtv_acc_pass"
            IFS=$'\001' read -r -a _4gtv_accs_token <<< "$_4gtv_acc_token"
        ;;
        *) 
        ;;
    esac
}

List4gtvAccs()
{
    GetServiceAccs 4gtv
    _4gtv_accs_count=${#_4gtv_accs_email[@]}
    _4gtv_accs_list=""
    for((i=0;i<_4gtv_accs_count;i++));
    do
        if [ -n "${_4gtv_accs_token[i]:-}" ]
        then
            is_login="${green} [ 已登录 ] ${normal}"
        else
            is_login=""
        fi
        _4gtv_accs_list="$_4gtv_accs_list ${green}$((i+1)).${normal}${indent_6}邮箱: ${green}${_4gtv_accs_email[i]}${normal}$is_login\n${indent_6}密码: ${green}${_4gtv_accs_pass[i]}${normal}\n\n"
    done
    if [ -n "$_4gtv_accs_list" ] 
    then
        Println "$_4gtv_accs_list"
    else
        Println "$error 没有账号\n"
    fi
}

Login4gtvAcc()
{
    if [ ! -e "/usr/local/bin/imgcat" ] 
    then
        InstallImgcat
    fi

    List4gtvAccs

    _4gtv_input_acc_num=$((_4gtv_accs_count+1))
    echo -e " ${green}$_4gtv_input_acc_num.${normal}${indent_6}手动输入\n"

    echo -e "选择账号"
    while read -p "$i18n_default_cancel" _4gtv_accs_num
    do
        case "$_4gtv_accs_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            $_4gtv_input_acc_num)
                _4gtv_accs_index=$((_4gtv_accs_num-1))
                Set4gtvAccEmail
                Set4gtvAccPass
                new_acc=$(
                $JQ_FILE -n --arg email "$_4gtv_acc_email" --arg password "$_4gtv_acc_pass" \
                    '{
                        email: $email,
                        password: $password
                    }'
                )
                jq_path='["4gtv","accounts"]'
                JQ add "$SERVICES_FILE" "$new_acc"
                Println "$info 账号添加成功\n"
                break
            ;;
            *)
                if [ "$_4gtv_accs_num" -gt 0 ] && [ "$_4gtv_accs_num" -le "$_4gtv_accs_count" ]
                then
                    _4gtv_accs_index=$((_4gtv_accs_num-1))
                    _4gtv_acc_email=${_4gtv_accs_email[_4gtv_accs_index]}
                    _4gtv_acc_pass=${_4gtv_accs_pass[_4gtv_accs_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    IMG_FILE="$IPTV_ROOT/4gtv.png"

    if [[ ! -x $(command -v convert) ]] 
    then
        Println "$info 安装 ImageMagick"
        ImageMagickInstall
    fi

    while true 
    do
        if curl -s -Lm 20 "https://www.4gtv.tv/validatecode?t=$(date +%s%3N)" \
            -H 'authority: www.4gtv.tv' \
            -H "User-Agent: $user_agent" \
            -H 'referer: https://www.4gtv.tv/channel.html' -o "$IMG_FILE" && /usr/local/bin/imgcat --half-height "$IMG_FILE"
        then
            rm -f "${IMG_FILE:-notfound}"
            Println "$info 输入图片验证码: "
            read -p "(默认: 刷新验证码): " validatecode
            [ -z "$validatecode" ] && continue
        else
            Println "$info 尝试修复 magick ..."
            ImageMagickInstall
            rm -f "${IMG_FILE:-notfound}"
            Println "$error 连接发生错误, 请重试\n"
            exit 1
        fi

        Println "$info 登录账号..."
        IFS="^" read -r result msg token < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/SignIn' \
            -H "User-Agent: $user_agent" \
            -H 'Origin: https://www.4gtv.tv' \
            -H 'Referer: https://www.4gtv.tv/channel.html' \
            -d "fsUSER=$_4gtv_acc_email&fsPASSWORD=$_4gtv_acc_pass&fsVALIDATE_CODE=$validatecode" \
            | $JQ_FILE -r '[.Success,.ErrMessage,.Data]|join("^")'
        ) || true

        if [ "$result" == "true" ]
        then
            break
        else
            Println "$error 账号登录失败, 请重试\n\n$msg\n"
        fi
    done

    jq_path='["4gtv","accounts",'"$_4gtv_accs_index"',"token"]'
    JQ update "$SERVICES_FILE" "$token"
    Println "$info 账号登录成功"
    Println "$info 验证账号..."
    for((i=0;i<3;i++));
    do
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        random_number=${random_number: -12}
        fsLINK_ID="$random_number${random_number:0:9}"
        IFS="^" read -r result < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/SignIn' \
            -H "User-Agent: $user_agent" \
            -H 'Origin: https://www.4gtv.tv' \
            -H 'Referer: https://www.4gtv.tv/channel_sub.html?channelSet_id=1&asset_id=4gtv-4gtv003&channel_id=1' \
            -d "fsLOGIN_TYPE=03&fsLINK_ID=$fsLINK_ID&clsIDENTITY_VALIDATE_ARUS%5BfsVALUE%5D=$(UrlencodeUpper $token)" \
            | $JQ_FILE -r '.Success'
        ) || true

        if [ "$result" == "true" ] 
        then
            break
        fi
    done
    Println "$info 账号验证成功"
    Println "$info 开启 7 天豪华套餐"

    IFS="^" read -r result msg < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/AccountPromo' \
        -H "User-Agent: $user_agent" \
        -H 'Origin: https://www.4gtv.tv' \
        -H 'Referer: https://www.4gtv.tv/channel_sub.html?channelSet_id=1&asset_id=4gtv-4gtv003&channel_id=1' \
        -d "fsVALUE=$(UrlencodeUpper $token)" \
        | $JQ_FILE -r '[.Success,.ErrMessage]|join("^")'
    ) || true

    if [ "$result" == "true" ] 
    then
        Println "$info 7 天豪华套餐开启成功\n"
    else
        Println "$error 开启 7 天豪华套餐发生错误, 请重试\n\n$msg\n"
    fi
}

List4gtvAcc()
{
    List4gtvAccs

    if [ "$_4gtv_accs_count" -eq 0 ] 
    then
        exit 1
    fi

    echo -e "选择账号"
    while read -p "$i18n_default_cancel" _4gtv_accs_num
    do
        case "$_4gtv_accs_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$_4gtv_accs_num" -gt 0 ] && [ "$_4gtv_accs_num" -le "$_4gtv_accs_count" ]
                then
                    _4gtv_accs_index=$((_4gtv_accs_num-1))
                    fsVALUE=${_4gtv_accs_token[_4gtv_accs_index]:-}
                    if [ -z "$fsVALUE" ] 
                    then
                        Println "$error 请先登录此账号\n"
                        exit 1
                    else
                        Println "$info 查询中..."
                        IFS="^" read -r result msg fnLEFT_PROMO_DAYS < <(curl -s -Lm 20 'https://api2.4gtv.tv//Account/GetAccountInfo' \
                            -H "User-Agent: $user_agent" \
                            -H 'Origin: https://www.4gtv.tv' \
                            -H 'Referer: https://www.4gtv.tv/channel.html' \
                            -d "clsIDENTITY_VALIDATE_ARUS%5BfsVALUE%5D=$(UrlencodeUpper $fsVALUE)" \
                            | $JQ_FILE -r '[.Success,.ErrMessage,.Data.fnLEFT_PROMO_DAYS]|join("^")'
                        ) || true
                        if [ "$result" == "true" ] 
                        then
                            if [ "$fnLEFT_PROMO_DAYS" -eq -1 ] 
                            then
                                days_left="${red}未开通${normal}"
                            else
                                days_left="还剩 ${green}$fnLEFT_PROMO_DAYS${normal} 天"
                            fi
                            Println "$info 豪华套餐: $days_left\n"
                        else
                            Println "$error 查询遇到错误\n\n$msg\n"
                        fi
                    fi
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

Edit4gtvAcc()
{
    List4gtvAccs

    if [ "$_4gtv_accs_count" -eq 0 ] 
    then
        exit 1
    fi

    echo -e "选择账号"
    while read -p "$i18n_default_cancel" _4gtv_accs_num
    do
        case "$_4gtv_accs_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$_4gtv_accs_num" -gt 0 ] && [ "$_4gtv_accs_num" -le "$_4gtv_accs_count" ]
                then
                    _4gtv_accs_index=$((_4gtv_accs_num-1))
                    Set4gtvAccEmail
                    Set4gtvAccPass
                    new_acc=$(
                    $JQ_FILE -n --arg email "$_4gtv_acc_email" --arg password "$_4gtv_acc_pass" \
                        '{
                            email: $email,
                            password: $password
                        }'
                    )
                    jq_path='["4gtv","accounts",'"$_4gtv_accs_index"']'
                    JQ replace "$SERVICES_FILE" "$new_acc"
                    Println "$info 账号修改成功\n"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

Del4gtvAcc()
{
    List4gtvAccs

    if [ "$_4gtv_accs_count" -eq 0 ] 
    then
        exit 1
    fi

    echo -e "选择账号"
    while read -p "$i18n_default_cancel" _4gtv_accs_num
    do
        case "$_4gtv_accs_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$_4gtv_accs_num" -gt 0 ] && [ "$_4gtv_accs_num" -le "$_4gtv_accs_count" ]
                then
                    _4gtv_accs_index=$((_4gtv_accs_num-1))
                    jq_path='["4gtv","accounts"]'
                    JQ delete "$SERVICES_FILE" "$_4gtv_accs_index"
                    Println "$info 账号删除成功\n"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

Get4gtvAccToken()
{
    List4gtvAccs

    if [ "$_4gtv_accs_count" -eq 0 ] 
    then
        exit 1
    fi

    echo -e "选择账号"
    while read -p "$i18n_default_cancel" _4gtv_accs_num
    do
        case "$_4gtv_accs_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$_4gtv_accs_num" -gt 0 ] && [ "$_4gtv_accs_num" -le "$_4gtv_accs_count" ]
                then
                    _4gtv_accs_index=$((_4gtv_accs_num-1))
                    fsVALUE=${_4gtv_accs_token[_4gtv_accs_index]:-}
                    if [ -z "$fsVALUE" ] 
                    then
                        Println "$error 请先登录此账号\n"
                        exit 1
                    fi
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

Use4gtvProxy()
{
    GetDefault
    Println "$tip 可以使用脚本自带的 v2ray 管理面板添加代理, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 4gtv 代理, 比如 http://username:passsword@127.0.0.1:5555 : " _4gtv_proxy "${d_proxy:-不设置}"
    if [ "$_4gtv_proxy" == "omit" ] || [ "$_4gtv_proxy" == "不设置" ]
    then
        _4gtv_proxy=""
        _4gtv_proxy_command=()
    else
        _4gtv_proxy_command=( -x "$_4gtv_proxy" )
    fi
}

_4gtvCron()
{
    _4gtv_acc_email="$(RandStr)_$(printf '%(%s)T' -1)@gmail.com"
    _4gtv_acc_pass=$(RandStr)
    IFS=" " read -r result msg < <(curl -s -Lm 10 'https://api2.4gtv.tv/Account/Register' \
        -H "User-Agent: $user_agent" \
        -H 'Origin: https://www.4gtv.tv' \
        -H 'Referer: https://www.4gtv.tv/signup.html' \
        -d "fnREGISTER_TYPE=1&fsLOGIN_TYPE=&fsLINK_ID=&fsUSER=$_4gtv_acc_email&fsLOGIN_TYPE=&fsLINK_ID=&fsPASSWORD=$_4gtv_acc_pass&fsPASSWORD1=$_4gtv_acc_pass&fnBIRTH_YEAR=$((RANDOM%20+1980))&fsSEX=male" \
        | $JQ_FILE -r '[.Success,.ErrMessage]|join(" ")'
    ) || true

    if [ "$result" == "true" ]
    then
        if [ ! -s "$SERVICES_FILE" ] 
        then
            printf '{"%s":{"%s":[]}}' "4gtv" "accounts" > "$SERVICES_FILE"
        fi
        new_acc=$(
        $JQ_FILE -n --arg email "$_4gtv_acc_email" --arg password "$_4gtv_acc_pass" \
            '{
                email: $email,
                password: $password
            }'
        )
        jq_path='["4gtv","accounts"]'
        JQ add "$SERVICES_FILE" "$new_acc"
        Println "$info 账号注册成功\n"
    else
        Println "$error 账号注册失败, 请重试\n\n$msg\n"
    fi

    exit 0

    IMG_FILE="$IPTV_ROOT/4gtv.png"

    if [[ ! -x $(command -v convert) ]] 
    then
        Println "$info 安装 ImageMagick"
        ImageMagickInstall
    fi

    for((i=0;i<5;i++));
    do
        if curl -s -Lm 20 "https://www.4gtv.tv/validatecode?t=$(date +%s%3N)" \
            -H 'authority: www.4gtv.tv' \
            -H "User-Agent: $user_agent" \
            -H 'referer: https://www.4gtv.tv/channel.html' -o "$IMG_FILE" && /usr/local/bin/imgcat --half-height "$IMG_FILE"
        then
            rm -f "${IMG_FILE:-notfound}"
            Println "$info 输入图片验证码: "
            read -p "(默认: 刷新验证码): " validatecode
            [ -z "$validatecode" ] && continue
        else
            Println "$info 尝试修复 magick ..."
            ImageMagickInstall
            rm -f "${IMG_FILE:-notfound}"
        fi

        Println "$info 登录账号..."
        IFS="^" read -r result msg token < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/SignIn' \
            -H "User-Agent: $user_agent" \
            -H 'Origin: https://www.4gtv.tv' \
            -H 'Referer: https://www.4gtv.tv/channel.html' \
            -d "fsUSER=$_4gtv_acc_email&fsPASSWORD=$_4gtv_acc_pass&fsVALIDATE_CODE=$validatecode" \
            | $JQ_FILE -r '[.Success,.ErrMessage,.Data]|join("^")'
        ) || true

        if [ "$result" == "true" ]
        then
            break
        elif [ "$i" -eq 4 ] 
        then
            Println "$error 账号登录失败, 请重试\n\n$msg\n"
            exit 1
        fi
    done

    JQ update "$SERVICES_FILE" '(.4gtv.accounts[]|select(.email=="'"$_4gtv_acc_email"'")|.token)="'"$token"'"'
    Println "$info 账号登录成功"
    Println "$info 验证账号..."
    for((i=0;i<3;i++));
    do
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        random_number=${random_number: -12}
        fsLINK_ID="$random_number${random_number:0:9}"
        IFS="^" read -r result < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/SignIn' \
            -H "User-Agent: $user_agent" \
            -H 'Origin: https://www.4gtv.tv' \
            -H 'Referer: https://www.4gtv.tv/channel_sub.html?channelSet_id=1&asset_id=4gtv-4gtv003&channel_id=1' \
            -d "fsLOGIN_TYPE=03&fsLINK_ID=$fsLINK_ID&clsIDENTITY_VALIDATE_ARUS%5BfsVALUE%5D=$(UrlencodeUpper $token)" \
            | $JQ_FILE -r '.Success'
        ) || true

        if [ "$result" == "true" ] 
        then
            break
        fi
    done
    Println "$info 账号验证成功"
    Println "$info 开启 7 天豪华套餐"

    IFS="^" read -r result msg < <(curl -s -Lm 20 'https://api2.4gtv.tv/Account/AccountPromo' \
        -H "User-Agent: $user_agent" \
        -H 'Origin: https://www.4gtv.tv' \
        -H 'Referer: https://www.4gtv.tv/channel_sub.html?channelSet_id=1&asset_id=4gtv-4gtv003&channel_id=1' \
        -d "fsVALUE=$(UrlencodeUpper $token)" \
        | $JQ_FILE -r '[.Success,.ErrMessage]|join("^")'
    ) || true

    if [ "$result" == "true" ] 
    then
        Println "$info 7 天豪华套餐开启成功\n"
    else
        Println "$error 开启 7 天豪华套餐发生错误, 请重试\n\n$msg\n"
    fi
}

Enable4gtvCron()
{
    if crontab -l | grep -q "/usr/local/bin/tv 4g -" 2> /dev/null
    then
        Println "$error 定时任务 (每5天注册账号) 已开启 !\n"
    else
        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        printf '%s\n' "0 0 */5 * * /usr/local/bin/tv 4g -" >> "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 定时任务 (每5天注册账号) 开启成功\n"
    fi
}

Disable4gtvCron()
{
    if crontab -l | grep -q "/usr/local/bin/tv 4g -" 2> /dev/null
    then
        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        sed -i "/\/usr\/local\/bin\/tv 4g -/d" "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 定时任务 (每5天注册账号) 关闭成功\n"
    else
        Println "$error 定时任务 (每5天注册账号) 未开启 !\n"
    fi
}

Add4gtvLink()
{
    if [[ $stream_link_url =~ \.m3u8$ ]] 
    then
        Println "$error 你的 IP 可能已被禁\n"
        if [ -n "${monitor:-}" ] 
        then
            return 0
        fi
        exit 1
    fi

    stream_links_bitrate=()
    stream_links_resolution=()
    stream_links_url=()
    stream_links_list=""
    stream_links_count=0

    while IFS= read -r line 
    do
        if [[ $line =~ RESOLUTION=([^ ]+) ]] 
        then
            stream_link_resolution=${BASH_REMATCH[1]%%,*}
            stream_links_resolution+=("$stream_link_resolution")
            if [[ $line =~ BANDWIDTH=([^ ]+) ]] 
            then
                stream_link_bitrate=${BASH_REMATCH[1]%%,*}
                stream_link_bitrate=$((stream_link_bitrate/1000))
            else
                stream_link_bitrate=""
            fi
            stream_links_bitrate+=("$stream_link_bitrate")
            if [ -n "$stream_link_bitrate" ] 
            then
                stream_link_bitrate_text=" [ $stream_link_bitrate kb/s ]"
            else
                stream_link_bitrate_text=""
            fi
            stream_links_count=$((stream_links_count+1))
            stream_links_list="$stream_links_list ${green}$stream_links_count.${normal}${indent_6}$stream_link_resolution$stream_link_bitrate_text\n\n"
        elif [[ $line =~ m3u8 ]] 
        then
            stream_links_url+=("$stream_link_url_path/$line")
        fi
    done < <(curl -s -Lm 20 ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} -H "User-Agent: $user_agent" -H "${headers:0:-4}" "$stream_link_url")

    if [ -n "$stream_links_list" ] 
    then
        stream_link_root=${stream_link%%|*}
        choose=1

        if [[ $stream_link =~ \|([^|]+)$ ]] 
        then
            choose=0
            stream_link_quality=${BASH_REMATCH[1]}

            IFS="," read -r -a stream_link_qualities <<< "$stream_link_quality"
            stream_link_qualities_count=${#stream_link_qualities[@]}

            stream_link_video_indices=()

            for((i=0;i<stream_link_qualities_count;i++));
            do
                for((j=0;j<stream_links_count;j++));
                do
                    if { ! [[ ${stream_link_qualities[i]} =~ - ]] || [ "${stream_links_bitrate[j]}" == "${stream_link_qualities[i]%-*}" ]; } && [ "${stream_links_resolution[j]}" == "${stream_link_qualities[i]#*-}" ]
                    then
                        stream_link_qualities[i]="${stream_links_bitrate[j]}-${stream_links_resolution[j]}"
                        stream_link_video_indices+=("$j")
                        continue 2
                    fi
                done
                Println "$error ${stream_link_qualities[i]} 不存在 !"
                choose=1
                Println "$error 请重新选择 $channel_name 分辨率"
            done
        fi

        if [ "$choose" -eq 1 ] 
        then
            if [ -z "${kind:-}" ] 
            then
                stream_links_select_all=$((stream_links_count+1))
                stream_links_list="$stream_links_list ${green}$stream_links_select_all.${normal}${indent_6}全部\n"
                Println "$stream_links_list"
                echo "选择分辨率 (多个分辨率用空格分隔 比如: 1 2 4-5)"
            else
                stream_links_select_all=""
                Println "$stream_links_list"
                echo "选择分辨率"
            fi

            while read -p "(默认: $stream_links_count): " stream_links_num 
            do
                stream_links_num=${stream_links_num:-$stream_links_count}

                if [ "$stream_links_num" == "$stream_links_select_all" ] 
                then
                    stream_link_qualities=()
                    stream_link_video_indices=()
                    for((i=0;i<stream_links_count;i++));
                    do
                        stream_link_qualities+=("${stream_links_bitrate[i]}-${stream_links_resolution[i]}")
                        stream_link_video_indices+=("$i")
                    done
                    stream_link_qualities_count=$stream_links_count
                    printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
                    stream_link_quality=${stream_link_quality:1}
                    break
                fi

                IFS=" " read -ra stream_links_num_arr <<< "$stream_links_num"

                error_no=0
                for stream_link_num in "${stream_links_num_arr[@]}"
                do
                    case "$stream_link_num" in
                        *"-"*)
                            stream_link_num_start=${stream_link_num%-*}
                            stream_link_num_end=${stream_link_num#*-}
                            if [[ $stream_link_num_start == *[!0-9]* ]] || [[ $stream_link_num_end == *[!0-9]* ]] || [ "$stream_link_num_start" -eq 0 ] || [ "$stream_link_num_end" -eq 0 ] || [ "$stream_link_num_end" -gt "$stream_links_count" ] || [ "$stream_link_num_start" -ge "$stream_link_num_end" ]
                            then
                                error_no=3
                            fi
                        ;;
                        *[!0-9]*)
                            error_no=1
                        ;;
                        *)
                            if [ "$stream_link_num" -lt 1 ] || [ "$stream_link_num" -gt "$stream_links_count" ] 
                            then
                                error_no=2
                            fi
                        ;;
                    esac
                done

                case "$error_no" in
                    1|2|3)
                        Println "$error $i18n_input_correct_no\n"
                    ;;
                    *)
                        stream_link_qualities=()
                        stream_link_video_indices=()

                        for stream_link_num in "${stream_links_num_arr[@]}"
                        do
                            if [[ $stream_link_num =~ - ]] 
                            then
                                start=${stream_link_num%-*}
                                end=${stream_link_num#*-}
                                for((i=start-1;i<end;i++));
                                do
                                    stream_link_qualities+=("${stream_links_bitrate[i]}-${stream_links_resolution[i]}")
                                    stream_link_video_indices+=("$i")
                                done
                            else
                                stream_links_index=$((stream_link_num-1))
                                stream_link_qualities+=("${stream_links_bitrate[stream_links_index]}-${stream_links_resolution[stream_links_index]}")
                                stream_link_video_indices+=("$stream_links_index")
                            fi
                        done
                        stream_link_qualities_count=${#stream_link_qualities[@]}
                        printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
                        stream_link_quality=${stream_link_quality:1}
                        break
                    ;;
                esac
            done
        else
            printf -v stream_link_quality ',%s' "${stream_link_qualities[@]}"
            stream_link_quality=${stream_link_quality:1}
        fi

        if [[ $stream_links == *" "* ]] 
        then
            stream_links="$stream_link_root|$stream_link_quality ${stream_links#* }"
        else
            stream_links="$stream_link_root|$stream_link_quality"
        fi

        if [ -n "${_4gtv_proxy_command:-}" ] 
        then
            stream_link="http://${stream_link:8}"
        fi
    else
        Println "$error 频道 [$channel_name] 不可用\n"
    fi
}

Start4gtvLink()
{
    if [[ $chnl_stream_link_url =~ \.m3u8$ ]] 
    then
        Println "$error 你的 IP 可能已被禁\n"
        if [ -n "${monitor:-}" ] 
        then
            return 0
        fi
        exit 1
    fi

    chnl_stream_links_bitrate=()
    chnl_stream_links_resolution=()
    chnl_stream_links_url=()
    chnl_stream_links_list=""
    chnl_stream_links_count=0

    while IFS= read -r line 
    do
        if [[ $line =~ RESOLUTION=([^ ]+) ]] 
        then
            chnl_stream_link_resolution=${BASH_REMATCH[1]%%,*}
            chnl_stream_links_resolution+=("$chnl_stream_link_resolution")
            if [[ $line =~ BANDWIDTH=([^ ]+) ]] 
            then
                chnl_stream_link_bitrate=${BASH_REMATCH[1]%%,*}
                chnl_stream_link_bitrate=$((chnl_stream_link_bitrate/1000))
            else
                chnl_stream_link_bitrate=""
            fi
            chnl_stream_links_bitrate+=("$chnl_stream_link_bitrate")
            if [ -n "$chnl_stream_link_bitrate" ] 
            then
                chnl_stream_link_bitrate_text=" [ $chnl_stream_link_bitrate kb/s ]"
            else
                chnl_stream_link_bitrate_text=""
            fi
            chnl_stream_links_count=$((chnl_stream_links_count+1))
            chnl_stream_links_list="$chnl_stream_links_list ${green}$chnl_stream_links_count.${normal}${indent_6}$chnl_stream_link_resolution$chnl_stream_link_bitrate_text\n\n"
        elif [[ $line =~ m3u8 ]] 
        then
            chnl_stream_links_url+=("$chnl_stream_link_url_path/$line")
        fi
    done < <(curl -s -Lm 20 ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} -H "User-Agent: $chnl_user_agent" -H "${chnl_headers:0:-4}" "$chnl_stream_link_url")

    if [ -n "$chnl_stream_links_list" ] 
    then
        chnl_stream_link_root=${chnl_stream_link%%|*}
        choose=1

        if [[ $chnl_stream_link =~ \|([^|]+)$ ]] 
        then
            choose=0
            chnl_stream_link_quality=${BASH_REMATCH[1]}

            IFS="," read -r -a chnl_stream_link_qualities <<< "$chnl_stream_link_quality"
            chnl_stream_link_qualities_count=${#chnl_stream_link_qualities[@]}

            chnl_stream_link_video_indices=()

            for((i=0;i<chnl_stream_link_qualities_count;i++));
            do
                for((j=0;j<chnl_stream_links_count;j++));
                do
                    if { [ "${auto_select_yn:-}" == "$i18n_yes" ] || ! [[ ${chnl_stream_link_qualities[i]} =~ - ]] || [ "${chnl_stream_links_bitrate[j]}" == "${chnl_stream_link_qualities[i]%-*}" ] || [ -n "${monitor:-}" ]; } && [ "${chnl_stream_links_resolution[j]}" == "${chnl_stream_link_qualities[i]#*-}" ]
                    then
                        chnl_stream_link_qualities[i]="${chnl_stream_links_bitrate[j]}-${chnl_stream_links_resolution[j]}"
                        chnl_stream_link_video_indices+=("$j")
                        continue 2
                    fi
                done
                Println "$error ${chnl_stream_link_qualities[i]} 不存在 !"
                if [ -z "${auto_select_yn:-}" ] 
                then
                    echo
                    inquirer list_input "是否按分辨率自动选择" yn_options auto_select_yn
                    if [ "$auto_select_yn" == "$i18n_yes" ] 
                    then
                        i=$((i-1))
                        continue
                    fi
                fi
                choose=1
                Println "$error 请重新选择 $chnl_channel_name 分辨率"
                break
            done
        fi

        if [ "$choose" -eq 1 ] 
        then
            if [ -z "${monitor:-}" ] 
            then
                if [ -z "${kind:-}" ] 
                then
                    chnl_stream_links_select_all=$((chnl_stream_links_count+1))
                    chnl_stream_links_list="$chnl_stream_links_list ${green}$chnl_stream_links_select_all.${normal}${indent_6}全部\n"
                    Println "$chnl_stream_links_list"
                    echo "选择分辨率 (多个分辨率用空格分隔 比如: 1 2 4-5)"
                else
                    chnl_stream_links_select_all=""
                    Println "$chnl_stream_links_list"
                    echo "选择分辨率"
                fi

                while read -p "(默认: $chnl_stream_links_count): " chnl_stream_links_num 
                do
                    chnl_stream_links_num=${chnl_stream_links_num:-$chnl_stream_links_count}

                    if [ "$chnl_stream_links_num" == "$chnl_stream_links_select_all" ] 
                    then
                        chnl_stream_link_qualities=()
                        chnl_stream_link_video_indices=()
                        for((i=0;i<chnl_stream_links_count;i++));
                        do
                            chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[i]}-${chnl_stream_links_resolution[i]}")
                            chnl_stream_link_video_indices+=("$i")
                        done
                        chnl_stream_link_qualities_count=$chnl_stream_links_count
                        printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
                        chnl_stream_link_quality=${chnl_stream_link_quality:1}
                        break
                    fi

                    IFS=" " read -ra chnl_stream_links_num_arr <<< "$chnl_stream_links_num"

                    error_no=0
                    for chnl_stream_link_num in "${chnl_stream_links_num_arr[@]}"
                    do
                        case "$chnl_stream_link_num" in
                            *"-"*)
                                chnl_stream_link_num_start=${chnl_stream_link_num%-*}
                                chnl_stream_link_num_end=${chnl_stream_link_num#*-}
                                if [[ $chnl_stream_link_num_start == *[!0-9]* ]] || [[ $chnl_stream_link_num_end == *[!0-9]* ]] || [ "$chnl_stream_link_num_start" -eq 0 ] || [ "$chnl_stream_link_num_end" -eq 0 ] || [ "$chnl_stream_link_num_end" -gt "$chnl_stream_links_count" ] || [ "$chnl_stream_link_num_start" -ge "$chnl_stream_link_num_end" ]
                                then
                                    error_no=3
                                fi
                            ;;
                            *[!0-9]*)
                                error_no=1
                            ;;
                            *)
                                if [ "$chnl_stream_link_num" -lt 1 ] || [ "$chnl_stream_link_num" -gt "$chnl_stream_links_count" ] 
                                then
                                    error_no=2
                                fi
                            ;;
                        esac
                    done

                    case "$error_no" in
                        1|2|3)
                            Println "$error $i18n_input_correct_no\n"
                        ;;
                        *)
                            chnl_stream_link_qualities=()
                            chnl_stream_link_video_indices=()

                            for chnl_stream_link_num in "${chnl_stream_links_num_arr[@]}"
                            do
                                if [[ $chnl_stream_link_num =~ - ]] 
                                then
                                    start=${chnl_stream_link_num%-*}
                                    end=${chnl_stream_link_num#*-}
                                    for((i=start-1;i<end;i++));
                                    do
                                        chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[i]}-${chnl_stream_links_resolution[i]}")
                                        chnl_stream_link_video_indices+=("$i")
                                    done
                                else
                                    chnl_stream_links_index=$((chnl_stream_link_num-1))
                                    chnl_stream_link_qualities+=("${chnl_stream_links_bitrate[chnl_stream_links_index]}-${chnl_stream_links_resolution[chnl_stream_links_index]}")
                                    chnl_stream_link_video_indices+=("$chnl_stream_links_index")
                                fi
                            done
                            chnl_stream_link_qualities_count=${#chnl_stream_link_qualities[@]}
                            printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
                            chnl_stream_link_quality=${chnl_stream_link_quality:1}
                            break
                        ;;
                    esac
                done
            else
                chnl_stream_link_qualities=("$((chnl_stream_links_count-1))")
                chnl_stream_link_quality="${chnl_stream_links_bitrate[chnl_stream_links_count-1]}-${chnl_stream_links_resolution[chnl_stream_links_count-1]}"
                chnl_stream_link_qualities_count=1
            fi
        else
            printf -v chnl_stream_link_quality ',%s' "${chnl_stream_link_qualities[@]}"
            chnl_stream_link_quality=${chnl_stream_link_quality:1}
        fi

        if [[ $chnl_stream_links == *" "* ]] 
        then
            chnl_stream_links="$chnl_stream_link_root|$chnl_stream_link_quality ${chnl_stream_links#* }"
        else
            chnl_stream_links="$chnl_stream_link_root|$chnl_stream_link_quality"
        fi

        if [ -n "${_4gtv_proxy_command:-}" ] 
        then
            chnl_stream_link="http://${chnl_stream_link:8}"
        fi
    else
        Println "$error 频道 [$chnl_channel_name] 不可用\n"
    fi
}

ScheduleNowtv()
{
    for chnl in "${nowtv_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        nowtv_id=${chnl#*:}
        chnl_name=${nowtv_id#*:}
        nowtv_id=${nowtv_id%%:*}
        SCHEDULE_LINK_NOWTV="https://nowplayer.now.com/tvguide/epglist?channelIdList%5B%5D=$nowtv_id&day=1"

        if [ ! -s "$SCHEDULE_JSON" ] 
        then
            printf '{"%s":[]}' "fhwszx" > "$SCHEDULE_JSON"
        fi

        schedule=""
        while IFS="=" read -r program_time program_sys_time program_title
        do
            program_time=${program_time#\"}
            program_title=${program_title%\"}
            program_sys_time=${program_sys_time:0:10}
            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" --cookie "LANG=zh" "$SCHEDULE_LINK_NOWTV" | $JQ_FILE '.[0][] | [.startTime,.start,.name] | join("=")')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name nowtv [$chnl_id] 节目表更新成功"
        else
            Println "$error $chnl_name nowtv [$chnl_id] 节目表更新失败"
        fi
    done
}

ScheduleNiotv()
{
    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "msxw" > "$SCHEDULE_JSON"
    fi

    niotv_proxy=()
    if [ -s "$IPTV_ROOT/niotv_proxy" ] 
    then
        niotv_proxy+=( -x $(< $IPTV_ROOT/niotv_proxy) )
    fi

    printf -v today '%(%Y-%m-%d)T' -1
    SCHEDULE_LINK_NIOTV="http://www.niotv.com/i_index.php?cont=day"

    for chnl in "${niotv_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        niotv_id=${chnl#*:}
        chnl_name=${niotv_id#*:}
        niotv_id=${niotv_id%%:*}
        empty=1
        check=1
        schedule=""
        while IFS= read -r line
        do
            if [[ $line == *"<td class=epg_tab_tm>"* ]] 
            then
                empty=0
                line=${line#*<td class=epg_tab_tm>}
                start_time=${line%%~*}
                end_time=${line#*~}
                end_time=${end_time%%</td>*}
            fi

            if [[ $line == *"</a></td>"* ]] 
            then
                line=${line%% </a></td>*}
                line=${line%%</a></td>*}
                title=${line#*target=_blank>}
                title=${title//\"/}
                title=${title//\'/}
                title=${title//\\/\'}
                sys_time=$(date -d "$today $start_time" +%s)

                start_time_num=$sys_time
                end_time_num=$(date -d "$today $end_time" +%s)

                if [ "$check" -eq 1 ] && [ "$start_time_num" -gt "$end_time_num" ] 
                then
                    continue
                fi

                check=0

                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$title"'",
                    "time":"'"$start_time"'",
                    "sys_time":"'"$sys_time"'"
                }'
            fi
        done < <(curl ${niotv_proxy[@]+"${niotv_proxy[@]}"} -s -Lm 10 -H "User-Agent: $user_agent" -X POST --data "act=select&day=$today&sch_id=$niotv_id" "$SCHEDULE_LINK_NIOTV")
        #curl -d "day=$today&sch_id=$niotv_id" -X POST "$SCHEDULE_LINK_NIOTV" || true

        if [ "$empty" -eq 1 ] 
        then
            Println "$error $chnl_name niotv [$chnl_id] 节目表更新失败"
            continue
        fi

        JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
        Println "$info $chnl_name niotv [$chnl_id] 节目表更新成功"
    done
}

ScheduleIcable()
{
    printf -v today '%(%Y%m%d)T' -1
    sys_time=$(date --date="today 0" +"%s")
    yesterday=$(date --date="yesterday" +"%Y%m%d")

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "hkopen" > "$SCHEDULE_JSON"
    fi

    for chnl in "${icable_chnls[@]}"
    do
        if [[ $chnl =~ ([^:]+):([^:]+):([^:]+) ]] 
        then
            chnl_id=${BASH_REMATCH[1]}
            chnl_num=${BASH_REMATCH[2]}
            chnl_name=${BASH_REMATCH[3]}
        fi

        schedule=""

        while IFS= read -r line
        do
            if [[ $line =~ ch_time ]] 
            then
                while [[ $line =~ ch_time ]] 
                do
                    line=${line#*ch_time }
                    if [ "${line%%_*}" == "nm" ] 
                    then
                        program_time=${line#*f_eng\">}
                        program_time=${program_time%%<*}
                        program_title=${line#*ch_prog\">}
                        program_title=${program_title%%<*}
                        program_sys_time=$(date -d "$today $program_time" +%s)
                        [ -n "$schedule" ] && schedule="$schedule,"
                        schedule=$schedule'{
                            "title":"'"$program_title"'",
                            "time":"'"$program_time"'AM",
                            "sys_time":"'"$program_sys_time"'"
                        }'
                    fi
                done
                break
            fi
        done < <(curl -s -Lm 20 -H "User-Agent: $user_agent" "http://epg.i-cable.com/new/ch_getcontent.php?lang=chi&ch=$chnl_num&date=$yesterday" 2> /dev/null)

        while IFS= read -r line
        do
            if [[ $line =~ ch_time ]] 
            then
                while [[ $line =~ ch_time ]] 
                do
                    line=${line#*ch_time }
                    if [ "${line%%_*}" == "am" ] 
                    then
                        time_flag="AM"
                    elif [ "${line%%_*}" == "pm" ] 
                    then
                        time_flag="PM"
                    else
                        break
                    fi
                    program_time=${line#*f_eng\">}
                    program_time="${program_time%%<*}$time_flag"
                    program_title=${line#*ch_prog\">}
                    program_title=${program_title%%<*}
                    program_sys_time=$(date -d "$today $program_time" +%s)
                    [ -n "$schedule" ] && schedule="$schedule,"
                    schedule=$schedule'{
                        "title":"'"$program_title"'",
                        "time":"'"$program_time"'",
                        "sys_time":"'"$program_sys_time"'"
                    }'
                done
                break
            fi
        done < <(curl -s -Lm 20 -H "User-Agent: $user_agent" "http://epg.i-cable.com/new/ch_getcontent.php?lang=chi&ch=$chnl_num&date=$today" 2> /dev/null)

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] i-cable 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] i-cable 节目表更新失败"
        fi
    done
}

ScheduleJiushi()
{
    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "tvbfc" > "$SCHEDULE_JSON"
    fi

    for chnl in "${jiushi_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_name=${chnl#*:}
        chnl_name=${chnl_name// /-}
        chnl_name_encode=$(UrlencodeUpper "$chnl_name")

        printf -v today '%(%Y-%m-%d)T' -1

        SCHEDULE_LINK="https://xn--i0yt6h0rn.tw/channel/$chnl_name_encode/index.json"

        schedule=""
        while IFS="=" read -r program_time program_title
        do
            program_time=${program_time#\"}
            program_title=${program_title%\"}
            program_sys_time=$(date -d "$today $program_time" +%s)

            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "$SCHEDULE_LINK" | $JQ_FILE '.list[] | select(.key=="'"$today"'").values[] | [.time,.name] | join("=")')

        if [ -z "$schedule" ]
        then
            today=${today//-/\/}
            while IFS="=" read -r program_time program_title
            do
                program_time=${program_time#\"}
                program_title=${program_title%\"}
                program_sys_time=$(date -d "$today $program_time" +%s)

                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$program_title"'",
                    "time":"'"$program_time"'",
                    "sys_time":"'"$program_sys_time"'"
                }'
            done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "$SCHEDULE_LINK" | $JQ_FILE '.list[] | select(.key=="'"$today"'").values[] | [.time,.name] | join("=")')

            if [ -z "$schedule" ] 
            then
                Println "$error $chnl_name [$chnl_id] 就是节目表更新失败"
                continue
            fi
        fi

        JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
        Println "$info $chnl_name [$chnl_id] 就是节目表更新成功"
    done
}

ScheduleHbozw()
{
    printf -v today '%(%Y-%m-%d)T' -1

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "hbo" > "$SCHEDULE_JSON"
    fi

    hboasia_proxy=()
    if [ -s "$IPTV_ROOT/hboasia_proxy" ] 
    then
        hboasia_proxy+=( -x $(< $IPTV_ROOT/hboasia_proxy) )
    fi

    for chnl in "${hbozw_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_feed=${chnl#*:}
        chnl_name=${chnl_feed#*:}
        chnl_feed=${chnl_feed%:*}

        SCHEDULE_LINK="https://hboasia.com/HBO/zh-cn/ajax/home_schedule?date=$today&channel=${chnl_id//$chnl_feed/}&feed=$chnl_feed"

        schedule=""
        while IFS="^" read -r program_id program_time program_sys_time program_title program_title_local
        do
            program_id=${program_id#\"}
            program_title_local=${program_title_local%\"}

            if [ -n "$program_title_local" ] 
            then
                program_title="$program_title_local $program_title"
            fi

            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "id":"'"$program_id"'",
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl ${hboasia_proxy[@]+"${hboasia_proxy[@]}"} -s -Lm 20 -H "User-Agent: $user_agent" "$SCHEDULE_LINK" | $JQ_FILE '.[] | [.id,.time,.sys_time,.title,.title_local] | join("^")')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] hbo 中文节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] hbo 中文节目表更新失败"
        fi
    done
}

ScheduleHbous()
{
    printf -v today '%(%Y-%m-%d)T' -1
    sys_time=$(date -d $today +%s)
    min_sys_time=$((sys_time-7200))
    max_sys_time=$((sys_time+86400))
    yesterday=$(date --date="yesterday" +"%Y-%m-%d")

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "us_hbo" > "$SCHEDULE_JSON"
    fi

    if [ "${1:-}" == "WEST" ] || [ "${1:-}" == "west" ]
    then
        zone="WEST"
    else
        zone="EAST"
    fi

    for chnl in "${hbous_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl=${chnl#*:}
        hbous_name=${chnl%%:*}
        chnl_zone=${chnl#*:}
        chnl_name=${chnl_zone#*:}
        chnl_zone=${chnl_zone%%:*}

        if [ "$zone" != "$chnl_zone" ]
        then
            continue
        fi

        schedule=""

        while IFS="=" read -r program_time program_title
        do
            program_time=${program_time#\"}
            program_title=${program_title%\"}
            program_sys_time=$(date -d "$program_time" +%s)
            if [ "$program_sys_time" -ge "$min_sys_time" ] 
            then
                program_time=$(printf '%(%H:%M)T' "$program_sys_time")
                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$program_title"'",
                    "time":"'"$program_time"'",
                    "sys_time":"'"$program_sys_time"'"
                }'
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "https://proxy-v4.cms.hbo.com/v1/schedule?date=$yesterday" | $JQ_FILE --arg channelName "$hbous_name" --arg channelZone "$chnl_zone" '.channels | to_entries | map(select(.value.channelName==$channelName and .value.channelZone==$channelZone))[].value.programAirings | to_entries | map("\(.value.airing.playDate)=\(.value.program.title)")[]')

        min_sys_time=${program_sys_time:-$sys_time}

        while IFS="=" read -r program_time program_title
        do
            program_time=${program_time#\"}
            program_title=${program_title%\"}
            program_sys_time=$(date -d "$program_time" +%s)
            if [ "$program_sys_time" -le "$max_sys_time" ] && [ "$program_sys_time" -gt "$min_sys_time" ]
            then
                program_time=$(printf '%(%H:%M)T' "$program_sys_time")
                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$program_title"'",
                    "time":"'"$program_time"'",
                    "sys_time":"'"$program_sys_time"'"
                }'
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "https://proxy-v4.cms.hbo.com/v1/schedule?date=$today" | $JQ_FILE --arg channelName "$hbous_name" --arg channelZone "$chnl_zone" '.channels | to_entries | map(select(.value.channelName==$channelName and .value.channelZone==$channelZone))[].value.programAirings | to_entries | map("\(.value.airing.playDate)=\(.value.program.title)")[]')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] hbous 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] hbous 节目表更新失败"
        fi
    done
}

ScheduleOntvtonight()
{
    printf -v today '%(%Y-%m-%d)T' -1
    sys_time=$(date -d $today +%s)
    min_sys_time=$((sys_time-7200))
    max_sys_time=$((sys_time+86400))
    yesterday=$(date --date="yesterday" +"%Y-%m-%d")

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "us_abc" > "$SCHEDULE_JSON"
    fi

    for chnl in "${ontvtonight_chnls[@]}"
    do
        IFS="@" read -r chnl_id chnl_name chnl_no chnl_zone <<< "$chnl"

        chnl_zone=${chnl_zone%:*}
        schedule=""
        start=0

        if [ "${chnl_id%_*}" == "us" ] 
        then
            ct=""
        else
            ct="${chnl_id%_*}/"
        fi

        while IFS= read -r line
        do
            if [[ $line == *"<tbody>"* ]] 
            then
                start=1
            elif [ "$start" -eq 1 ] && [[ $line == *"<h5"* ]] && [[ $line == *"</h5>"* ]]
            then
                line=${line#*>}
                program_time=${line%<*}
                new_program_time=${program_time% *}
                hour=${new_program_time%:*}
                if [ "${program_time#* }" == "pm" ] && [ "$hour" -lt 12 ]
                then
                    hour=$((hour+12))
                    new_program_time="$hour:${new_program_time#*:}"
                elif [ "${program_time#* }" == "am" ] && [ "$hour" -eq 12 ]
                then
                    new_program_time="00:${new_program_time#*:}"
                fi
            elif [ "$start" -eq 1 ] && [[ $line == *"</a></h5>"* ]] 
            then
                line=${line%%<\/a>*}
                lead=${line%%[^[:blank:]]*}
                program_title=${line#${lead}}
                program_title=${program_title//amp;/}
                program_title=${program_title//&#039;/\'}
                program_sys_time=$(date -d "${yesterday}T$new_program_time$chnl_zone" +%s)
                if [ "$program_sys_time" -ge "$min_sys_time" ] 
                then
                    program_time=$(printf '%(%H:%M)T' "$program_sys_time")
                    [ -n "$schedule" ] && schedule="$schedule,"
                    schedule=$schedule'{
                        "title":"'"$program_title"'",
                        "time":"'"$program_time"'",
                        "sys_time":"'"$program_sys_time"'"
                    }'
                fi
            elif [ "$start" -eq 1 ] && [[ $line == *"</tbody>"* ]] 
            then
                break
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "https://www.ontvtonight.com/${ct}guide/listings/channel/$chnl_no/$chnl_name.html?dt=$yesterday" 2> /dev/null)

        while IFS= read -r line
        do
            if [[ $line == *"<tbody>"* ]] 
            then
                start=1
            elif [ "$start" -eq 1 ] && [[ $line == *"<h5"* ]] && [[ $line == *"</h5>"* ]] 
            then
                line=${line#*>}
                program_time=${line%<*}
                new_program_time=${program_time% *}
                hour=${new_program_time%:*}
                if [ "${program_time#* }" == "pm" ] && [ "$hour" -lt 12 ]
                then
                    hour=$((hour+12))
                    new_program_time="$hour:${new_program_time#*:}"
                elif [ "${program_time#* }" == "am" ] && [ "$hour" -eq 12 ]
                then
                    new_program_time="00:${new_program_time#*:}"
                fi
            elif [ "$start" -eq 1 ] && [[ $line == *"</a></h5>"* ]] 
            then
                line=${line%%<\/a>*}
                lead=${line%%[^[:blank:]]*}
                program_title=${line#${lead}}
                program_title=${program_title//amp;/}
                program_title=${program_title//&#039;/\'}
                program_sys_time=$(date -d "${today}T$new_program_time$chnl_zone" +%s)
                if [ "$program_sys_time" -le "$max_sys_time" ] 
                then
                    program_time=$(printf '%(%H:%M)T' "$program_sys_time")
                    [ -n "$schedule" ] && schedule="$schedule,"
                    schedule=$schedule'{
                        "title":"'"$program_title"'",
                        "time":"'"$program_time"'",
                        "sys_time":"'"$program_sys_time"'"
                    }'
                fi
            elif [ "$start" -eq 1 ] && [[ $line == *"</tbody>"* ]] 
            then
                break
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "https://www.ontvtonight.com/${ct}guide/listings/channel/$chnl_no/$chnl_name.html?dt=$today" 2> /dev/null)

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] ontvtonight 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] ontvtonight 节目表更新失败"
        fi
    done
}

ScheduleDisneyjr()
{
    printf -v today '%(%Y%m%d)T' -1
    SCHEDULE_LINK="https://disney.com.tw/_schedule/full/$today/8/%2Fepg"

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "disneyjr" > "$SCHEDULE_JSON"
    fi

    schedule=""
    while IFS= read -r program 
    do
        program_title=${program#*show_title: }
        program_title=${program_title%%, time: *}
        program_time=${program#*, time: }
        program_time=${program_time%%, iso8601_utc_time: *}
        program_sys_time=${program#*, iso8601_utc_time: }
        program_sys_time=${program_sys_time%\"}
        program_sys_time=$(date -d "$program_sys_time" +%s)

        [ -n "$schedule" ] && schedule="$schedule,"
        schedule=$schedule'{
            "title":"'"$program_title"'",
            "time":"'"$program_time"'",
            "sys_time":"'"$program_sys_time"'"
        }'
    done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "$SCHEDULE_LINK" | $JQ_FILE '.schedule | to_entries | map(.value.schedule_items[]) | to_entries | map("show_title: \(.value.show_title), time: \(.value.time), iso8601_utc_time: \(.value.iso8601_utc_time)")[]')

    if [ -n "$schedule" ] 
    then
        JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
        Println "$info $chnl_name [$chnl_id] 节目表更新成功"
    else
        Println "$error $chnl_name [$chnl_id] 节目表更新失败"
    fi
}

ScheduleFoxmovies()
{
    printf -v today '%(%Y-%-m-%-d)T' -1
    SCHEDULE_LINK="https://www.fng.tw/foxmovies/program.php?go=$today"

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "foxmovies" > "$SCHEDULE_JSON"
    fi

    schedule=""
    while IFS= read -r line
    do
        if [[ $line == *"<td>"* ]] 
        then
            line=${line#*<td>}
            line=${line%%<\/td>*}

            if [[ $line == *"<br>"* ]]  
            then
                line=${line%% <br>*}
                line=${line//\"/}
                line=${line//\'/}
                line=${line//\\/\'}
                sys_time=$(date -d "$today $time" +%s)
                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$line"'",
                    "time":"'"$time"'",
                    "sys_time":"'"$sys_time"'"
                }'
            else
                time=${line#* }
            fi
        fi
    done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "$SCHEDULE_LINK")

    if [ -n "$schedule" ] 
    then
        JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
        Println "$info $chnl_name [$chnl_id] 节目表更新成功"
    else
        Println "$error $chnl_name [$chnl_id] 节目表更新失败"
    fi
}

ScheduleAmlh()
{
    printf -v today '%(%Y-%-m-%-d)T' -1
    timestamp=$(date -d $today +%s)

    SCHEDULE_LINK="http://www.lotustv.cc/index.php/index/getdetail.html"

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "amlh" > "$SCHEDULE_JSON"
    fi

    schedule=""

    line=$(curl -s -Lm 10 -H "User-Agent: $user_agent" --data "d=$((timestamp-86400))" "$SCHEDULE_LINK") || true

    if [[ $line == *"<li>"* ]] 
    then
        line=${line#*<em>}
        time=${line%%<*}
        while [ -n "$time" ] 
        do
            time=${time:0:5}
            line=${line#*<span>}
            if [ "${flag:-0}" -gt 0 ] && [ "${time:0:1}" -eq 0 ]
            then
                title=${line%%<*}
                title=${title//\\t/ }
                title=$(printf %b "$title")
                if [ "${title:0:4}" == "經典影院" ] 
                then
                    title=${title:5}
                fi
                sys_time=$(date -d "$today $time" +%s)
                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$title"'",
                    "time":"'"$time"'",
                    "sys_time":"'"$sys_time"'"
                }'
            else
                flag=${time:0:1}
            fi
            if [[ $line == *"<em>"* ]] 
            then
                line=${line#*<em>}
                time=${line%%<*}
            else
                break
            fi
        done
    fi

    flag=0
    line=$(curl -s -Lm 10 -H "User-Agent: $user_agent" --data "d=$timestamp" "$SCHEDULE_LINK") || true

    if [[ $line == *"<li>"* ]] 
    then
        line=${line#*<em>}
        time=${line%%<*}
        while [ -n "$time" ] 
        do
            time=${time:0:5}
            line=${line#*<span>}
            if [ ! "$flag" -gt "${time:0:1}" ]
            then
                flag=${time:0:1}
                title=${line%%<*}
                title=${title//\\t/ }
                title=$(printf %b "$title")
                if [ "${title:0:4}" == "經典影院" ] 
                then
                    title=${title:5}
                fi
                sys_time=$(date -d "$today $time" +%s)
                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$title"'",
                    "time":"'"$time"'",
                    "sys_time":"'"$sys_time"'"
                }'
            else
                break 2
            fi
            line=${line#*<em>}
            time=${line%%<*}
        done
    fi

    if [ -n "$schedule" ] 
    then
        JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
        Println "$info $chnl_name [$chnl_id] 节目表更新成功"
    else
        Println "$error $chnl_name [$chnl_id] 节目表更新失败"
    fi
}

ScheduleTvbhk()
{
    printf -v today '%(%Y-%m-%d)T' -1
    sys_time=$(date -d $today +%s)
    max_sys_time=$((sys_time+86400))
    yesterday=$(date --date="yesterday" +"%Y-%m-%d")

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "tvbhk_pearl" > "$SCHEDULE_JSON"
    fi

    for chnl in "${tvbhk_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_code=${chnl#*:}
        chnl_name=${chnl_code#*:}
        chnl_code=${chnl_code%%:*}

        schedule=""

        while IFS= read -r line
        do
            if [[ $line == *"<li"* ]] 
            then
                while [[ $line == *"<li"* ]] 
                do
                    line=${line#*time=\"}
                    program_sys_time=${line%%\"*}
                    if [ "$program_sys_time" -ge "$sys_time" ]
                    then
                        line=${line#*<span class=\"time\">}
                        program_time=${line%%</span>*}
                        line=${line#*<p class=\"ftit\">}
                        if [ "${line:0:7}" == "<a href" ] 
                        then
                            line=${line#*>}
                        fi
                        program_title=${line%%</p>*}
                        program_title=${program_title%% <cite*}
                        program_title=${program_title%%</a>*}
                        program_title=${program_title%%<em *}
                        program_title=${program_title//&nbsp;/ }
                        [ -n "$schedule" ] && schedule="$schedule,"
                        schedule=$schedule'{
                            "title":"'"$program_title"'",
                            "time":"'"$program_time"'",
                            "sys_time":"'"$program_sys_time"'"
                        }'
                    fi
                done
                break
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "https://programme.tvb.com/ajax.php?action=channellist&code=$chnl_code&date=$yesterday" 2> /dev/null)

        while IFS= read -r line
        do
            if [[ $line == *"<li"* ]] 
            then
                while [[ $line == *"<li"* ]] 
                do
                    line=${line#*time=\"}
                    program_sys_time=${line%%\"*}
                    if [ "$program_sys_time" -ge "$sys_time" ] && [ "$program_sys_time" -le "$max_sys_time" ]
                    then
                        line=${line#*<span class=\"time\">}
                        program_time=${line%%</span>*}
                        line=${line#*<p class=\"ftit\">}
                        if [ "${line:0:7}" == "<a href" ] 
                        then
                            line=${line#*>}
                        fi
                        program_title=${line%%</p>*}
                        program_title=${program_title%% <cite*}
                        program_title=${program_title%%</a>*}
                        program_title=${program_title%%<em *}
                        program_title=${program_title//&nbsp;/ }
                        [ -n "$schedule" ] && schedule="$schedule,"
                        schedule=$schedule'{
                            "title":"'"$program_title"'",
                            "time":"'"$program_time"'",
                            "sys_time":"'"$program_sys_time"'"
                        }'
                    fi
                done
                break
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "https://programme.tvb.com/ajax.php?action=channellist&code=$chnl_code&date=$today" 2> /dev/null)

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] tvbhk 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] tvbhk 节目表更新失败"
        fi
    done
}

ScheduleTvbhd()
{
    if [[ ! -x $(command -v pdf2htmlEX) ]] 
    then
        echo
        AskIfContinue n "`gettext \"需要先安装 pdf2htmlEX, 因为是编译 pdf2htmlEX, 耗时会很长, 是否继续\"`"

        Pdf2htmlInstall
        Println "$info pdf2htmlEX 安装完成\n"
        if ! pdf2htmlEX -v > /dev/null 2>&1
        then
            Println "$info 请先输入 source /etc/profile 以启用 pdf2htmlEX\n" && exit 1
        fi
    fi

    wget --timeout=10 --tries=3 --no-check-certificate "https://schedule.tvbusa.com/current/tvb_hd.pdf" -qO "$IPTV_ROOT/tvb_hd.pdf"
    cd "$IPTV_ROOT"
    pdf2htmlEX --zoom 1.3 "./tvb_hd.pdf"

    printf -v today '%(%Y-%m-%d)T' -1
    sys_time=$(date -d $today +%s)
    yesterday=$(date --date="yesterday" +"%Y-%m-%d")

    weekday_program_title=()
    weekday_program_time=()
    saturday_program_title=()
    saturday_program_time=()
    sunday_program_title=()
    sunday_program_time=()

    while IFS= read -r line 
    do
        if [[ $line == *"節目表"* ]] 
        then
            line=${line#*"星期日"}
            line=${line#*"日期"}
            line=${line//"<span class=\"_ _28\"></span>"/}
            line=${line//"<div class=\"t m0 x10 ha ya ff2 fs3 fc0 sc0 ls0 ws0\">11:30</div></div>"/}
            old_program_time=""
            skips=(
                "4:saturday sunday"
                "7:saturday"
                "9:saturday sunday"
                "10:weekday"
                "11:weekday saturday"
                "12:sunday"
                "13:sunday"
                "16:saturday sunday"
                "17:weekday"
                "18:saturday"
                "19:sunday"
                "20:saturday"
                "22:saturday sunday"
                "23:sunday"
                "24:weekday"
                "25:weekday"
                "26:sunday"
                "27:saturday sunday"
                "28:saturday sunday"
                "29:weekday"
                "30:saturday sunday"
                "32:saturday sunday"
                "33:saturday"
                "34:sunday"
                "36:weekday"
                "37:sunday"
                "38:saturday sunday"
                "39:sunday"
                "40:saturday sunday"
                "41:sunday"
                "43:weekday"
                "44:weekday"
                "47:sunday"
                "48:weekday saturday"
                "49:sunday"
                "50:weekday"
                "51:saturday"
                "52:sunday"
                "53:saturday"
                "54:sunday"
                "55:saturday"
                "56:saturday sunday"
                "57:saturday sunday"
                "58:saturday sunday"
                "59:saturday sunday"
                "60:saturday sunday"
            )
            loop=1
            count=0
            day="weekday"
            while true 
            do
                class=${line%%\">*}
                class=${class#*<div class=\"}
                line=${line#*>}
                content=${line%%<*}

                case $content in
                    ""|" "|"AM"|"PM"|"東岸"|"西岸"|"星期日"|"星期一"|"星期二至六"|"日期"|"Next Day") continue
                    ;;
                    *"夏令時間"*) continue
                    ;;
                    *"將時鐘"*) continue
                    ;;
                    "高清台") 
                        if [[ -n ${program_title:-} ]] 
                        then
                            if [[ -n ${program_start_date:-} ]] 
                            then
                                program_title="$program_title $program_start_date"
                            fi
                            program_title=${program_title//amp;/}
                            program_title=${program_title//&#039;/\'}
                            if [ "$day" == "weekday" ] 
                            then
                                if [[ -n $old_program_time ]] 
                                then
                                    weekday_program_title+=("$program_title")
                                    weekday_program_time+=("$old_program_time")
                                else
                                    index=${#weekday_program_title[@]}
                                    index=$((index-1))
                                    weekday_program_title[index]="${weekday_program_title[index]} $program_title"
                                fi
                            elif [ "$day" == "saturday" ] 
                            then
                                if [[ -n $old_program_time ]] 
                                then
                                    saturday_program_title+=("$program_title")
                                    saturday_program_time+=("$old_program_time")
                                else
                                    index=${#saturday_program_title[@]}
                                    index=$((index-1))
                                    saturday_program_title[index]="${saturday_program_title[index]} $program_title"
                                fi
                            elif [ "$day" == "sunday" ] 
                            then
                                if [[ -n $old_program_time ]] 
                                then
                                    sunday_program_title+=("$program_title")
                                    sunday_program_time+=("$old_program_time")
                                else
                                    index=${#sunday_program_title[@]}
                                    index=$((index-1))
                                    sunday_program_title[index]="${sunday_program_title[index]} $program_title"
                                fi
                            fi
                            program_title=""
                            old_program_time=""
                            program_sys_time=""
                            program_start_date=""
                        fi
                        break
                    ;;
                    *) 
                        if [[ ${content:1:1} == "/" ]] && [[ ! ${content:0:1} == *[!0-9]* ]] && [[ ! ${content:2} == *[!0-9]* ]] 
                        then
                            program_start_date=$content
                        elif [[ ${content:2:1} == "/" ]] && [[ ! ${content:0:2} == *[!0-9]* ]] && [[ ! ${content:3} == *[!0-9]* ]] 
                        then
                            program_start_date=$content
                        elif [[ ${content:1:1} == ":" ]] 
                        then
                            if [[ ! ${content:0:1} == *[!0-9]* ]] && [[ ! ${content:2} == *[!0-9]* ]] 
                            then
                                [ -n "${program_time:-}" ] && program_time=""
                                if [[ -z ${program_time_east:-} ]] 
                                then
                                    program_time_east=$content
                                else
                                    program_time=$content
                                    program_time_east=""
                                fi
                            fi
                        elif [[ ${content:2:1} == ":" ]] 
                        then
                            if [[ ! ${content:0:2} == *[!0-9]* ]] && [[ ! ${content:3} == *[!0-9]* ]] 
                            then
                                [ -n "${program_time:-}" ] && program_time=""
                                if [[ -z ${program_time_east:-} ]] 
                                then
                                    program_time_east=$content
                                else
                                    program_time=$content
                                    program_time_east=""
                                fi
                            fi
                        else
                            old_day=$day

                            if [ "$count" -gt 0 ] 
                            then
                                if [ "$old_day" == "sunday" ] 
                                then
                                    day="weekday"
                                elif [ "$old_day" == "weekday" ] 
                                then
                                    day="saturday"
                                elif [ "$old_day" == "saturday" ] 
                                then
                                    day="sunday"
                                fi
                            fi

                            count=$((count+1))
                            if [[ $((count % 3)) -eq 0 ]] 
                            then
                                loop=$((count/3))
                            else
                                loop=$((count/3 + 1))
                            fi

                            redo=1
                            while [ "$redo" -eq 1 ] 
                            do
                                redo=0
                                for skip in "${skips[@]}"
                                do
                                    if [ "${skip%:*}" == "$loop" ] 
                                    then
                                        redo=1
                                        IFS=" " read -ra days <<< "${skip#*:}"
                                        for ele in "${days[@]}"
                                        do
                                            if [ "$ele" == "$day" ] 
                                            then
                                                count=$((count+1))
                                                if [ "$day" == "sunday" ] 
                                                then
                                                    day="weekday"
                                                elif [ "$day" == "weekday" ] 
                                                then
                                                    day="saturday"
                                                elif [ "$day" == "saturday" ] 
                                                then
                                                    day="sunday"
                                                fi
                                            fi
                                        done
                                        if [[ $((count % 3)) -eq 0 ]] 
                                        then
                                            new_loop=$((count/3))
                                        else
                                            new_loop=$((count/3 + 1))
                                        fi
                                        if [ "$new_loop" == "$loop" ] 
                                        then
                                            redo=0
                                        else
                                            loop=$new_loop
                                        fi
                                        break
                                    fi
                                done
                            done

                            case $((count%3)) in
                                0) day="sunday"
                                ;;
                                1) day="weekday"
                                ;;
                                2) day="saturday"
                                ;;
                            esac

                            if [[ -n ${program_title:-} ]] 
                            then
                                if [[ -n ${program_start_date:-} ]] 
                                then
                                    program_title="$program_title $program_start_date"
                                fi
                                program_title=${program_title//amp;/}
                                program_title=${program_title//&#039;/\'}
                                if [ "$old_day" == "weekday" ] 
                                then
                                    if [[ -n $old_program_time ]] 
                                    then
                                        weekday_program_title+=("$program_title")
                                        weekday_program_time+=("$old_program_time")
                                    else
                                        index=${#weekday_program_title[@]}
                                        index=$((index-1))
                                        weekday_program_title[index]="${weekday_program_title[index]} $program_title"
                                    fi
                                elif [ "$old_day" == "saturday" ] 
                                then
                                    if [[ -n $old_program_time ]] 
                                    then
                                        saturday_program_title+=("$program_title")
                                        saturday_program_time+=("$old_program_time")
                                    else
                                        index=${#saturday_program_title[@]}
                                        index=$((index-1))
                                        saturday_program_title[index]="${saturday_program_title[index]} $program_title"
                                    fi
                                elif [ "$old_day" == "sunday" ] 
                                then
                                    if [[ -n $old_program_time ]] 
                                    then
                                        sunday_program_title+=("$program_title")
                                        sunday_program_time+=("$old_program_time")
                                    else
                                        index=${#sunday_program_title[@]}
                                        index=$((index-1))
                                        sunday_program_title[index]="${sunday_program_title[index]} $program_title"
                                    fi
                                fi
                                program_title=""
                                old_program_time=""
                                program_start_date=""
                            fi

                            if [ -n "${program_time_east:-}" ] 
                            then
                                program_time=$program_time_east
                                program_time_east=""
                            fi

                            program_title=$content

                            if [ -n "$program_time" ] 
                            then
                                old_program_time=$program_time
                                program_time=""
                            fi
                        fi
                    ;;
                esac
            done
            break
        fi
    done < "./tvb_hd.html"
    weekday=$(printf '%(%u)T' -1)
    if [ "$weekday" -eq 1 ] 
    then
        p_title=("${sunday_program_title[@]}")
        p_time=("${sunday_program_time[@]}")
    elif [ "$weekday" -eq 0 ] 
    then
        p_title=("${saturday_program_title[@]}")
        p_time=("${saturday_program_time[@]}")
    else
        p_title=("${weekday_program_title[@]}")
        p_time=("${weekday_program_time[@]}")
    fi

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "tvbhd" > "$SCHEDULE_JSON"
    fi

    schedule=""
    change=0
    date=$yesterday
    for((i=0;i<${#p_time[@]};i++));
    do
        [ -n "${program_time:-}" ] && program_time_old=$program_time

        program_time=${p_time[i]}

        if [ -n "${program_time_old:-}" ] &&[ "${program_time%:*}" -lt "${program_time_old%:*}" ]
        then
            change=$((change+1))
        fi

        if [ "$change" -eq 1 ] 
        then
            hour=${program_time%:*}
            hour=$((hour+12))
            if [ "$hour" -eq 24 ] 
            then
                hour="0"
                date=$today
            fi
            new_program_time="$hour:${program_time#*:}"
        elif [ "$change" -eq 2 ] 
        then
            date=$today
            new_program_time=$program_time
        else
            new_program_time=$program_time
        fi

        if [[ ${new_program_time:1:1} == ":" ]] 
        then
            new_program_time="0$new_program_time"
        else
            new_program_time=$new_program_time
        fi

        program_sys_time=$(date -d "${date}T$new_program_time-08:00" +%s)
        new_program_time=$(printf '%(%H:%M)T' "$program_sys_time")

        program_title=${p_title[i]}

        [ -n "$schedule" ] && schedule="$schedule,"
        schedule=$schedule'{
            "title":"'"$program_title"'",
            "time":"'"$new_program_time"'",
            "sys_time":"'"$program_sys_time"'"
        }'
    done

    if [ -n "$schedule" ] 
    then
        JQ replace "$SCHEDULE_JSON" "tvbhd" "[$schedule]"
        Println "$info tvbhd [$chnl_id] 节目表更新成功"
    else
        Println "$error tvbhd [$chnl_id] 节目表更新失败"
    fi
}

ScheduleSingteltv()
{
    if [ "${singteltv_status:-1}" -eq 2 ] 
    then
        return 0
    fi

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "my_tvbjade" > "$SCHEDULE_JSON"
    fi

    if [ "${singteltv_status:-0}" -eq 0 ] 
    then
        Println "$info 解析 singteltv ..."
        singteltv_status=0
        while IFS= read -r line 
        do
            if [[ $line =~ epgEndPoint ]] 
            then
                line=${line#*epgEndPoint&#34;:&#34;}
                singteltv_epg_end_point=${line%%&#34*}
                line=${line#*tvChannelLists&#34;:}
                singteltv_tv_channel_lists=${line%%,&#34;errorMessage*}
                singteltv_tv_channel_lists=${singteltv_tv_channel_lists//&#34;/\"}
                singteltv_status=1
                break
            fi
        done < <(curl -s -L "https://www.singtel.com/personal/products-services/tv/tv-programme-guide" 2> /dev/null)
    fi

    if [ "$singteltv_status" -eq 0 ] 
    then
        Println "$error 无法连接 singteltv ?"
        singteltv_status=2
        return 0
    fi

    printf -v today '%(%d%m%Y)T' -1
    epg_data=$(curl -s -L "https://www.singtel.com$singteltv_epg_end_point/$today.json")

    IFS=$'\t' read -r title channel_id epg_channel_id < <($JQ_FILE -r '[
        ([.[]|.title|. + "^"]|join("")),
        ([.[]|.channelId|. + "^"]|join("")),
        ([.[]|.epgChannelId|. + "^"]|join(""))
    ]|@tsv' <<< "$singteltv_tv_channel_lists")

    IFS="^" read -r -a titles <<< "$title"
    IFS="^" read -r -a channel_ids <<< "$channel_id"
    IFS="^" read -r -a epg_channel_ids <<< "$epg_channel_id"

    IFS=$'\t' read -r schedule_id schedule_title schedule_time < <($JQ_FILE -r '[
        ([to_entries[]|.key|tostring|. + "^"]|join("")),
        ([to_entries[]|([.value[].program.title|. + "|"]|join(""))|. + "^"]|join("")),
        ([to_entries[]|([.value[].startDateTime|. + "|"]|join(""))|. + "^"]|join(""))
    ]|@tsv' <<< "$epg_data")

    IFS="^" read -r -a schedule_ids <<< "$schedule_id"
    IFS="^" read -r -a schedule_titles <<< "$schedule_title"
    IFS="^" read -r -a schedule_times <<< "$schedule_time"

    for chnl in "${singteltv_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        singteltv_id=${chnl#*:}
        chnl_name=${singteltv_id#*:}
        singteltv_id=${singteltv_id%%:*}

        schedule=""
        for((singteltv_i=0;singteltv_i<${#channel_ids[@]};singteltv_i++));
        do
            if [ "${channel_ids[singteltv_i]}" == "$singteltv_id" ] 
            then
                for((schedule_i=0;schedule_i<${#schedule_ids[@]};schedule_i++));
                do
                    if [ "${schedule_ids[schedule_i]}" == "${epg_channel_ids[singteltv_i]}" ] 
                    then
                        IFS="|" read -r -a program_titles <<< "${schedule_titles[schedule_i]}"
                        IFS="|" read -r -a program_times <<< "${schedule_times[schedule_i]}"
                        for((program_i=0;program_i<${#program_titles[@]};program_i++));
                        do
                            program_time=${program_times[program_i]#*T}
                            program_time=${program_time%:*}
                            program_sys_time=$(date -d "${program_times[program_i]}" +%s)
                            [ -n "$schedule" ] && schedule="$schedule,"
                            schedule=$schedule'{
                                "title":"'"${program_titles[program_i]}"'",
                                "time":"'"$program_time"'",
                                "sys_time":"'"$program_sys_time"'"
                            }'
                        done
                        break
                    fi
                done
                break
            fi
        done

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] singteltv 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] singteltv 节目表更新失败"
        fi
    done
}

ScheduleCntv()
{
    printf -v today '%(%Y%m%d)T' -1

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "cctv13" > "$SCHEDULE_JSON"
    fi

    for chnl in "${cntv_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_name=${chnl#*:}
        schedule=""

        while IFS="=" read -r program_sys_time program_time program_title
        do
            program_sys_time=${program_sys_time#\"}
            program_title=${program_title%\"}
            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "http://api.cntv.cn/epg/getEpgInfoByChannelNew?c=$chnl_id&serviceId=tvcctv&d=$today" | $JQ_FILE '.data.'"$chnl_id"'.list[]|[.startTime,.showTime,.title]|join("=")')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] cntv 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] cntv 节目表更新失败"
        fi
    done
}

ScheduleTvbs()
{
    printf -v today '%(%Y-%m-%d)T' -1

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "tvbs" > "$SCHEDULE_JSON"
    fi

    lang=2

    for chnl in "${tvbs_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_order=${chnl#*:}
        chnl_name=${chnl_order#*:}
        chnl_order=${chnl_order%%:*}

        schedule=""

        while IFS="=" read -r program_time program_title
        do
            program_time=${program_time#\"}
            program_title=${program_title%\"}
            program_sys_time=$(date -d "$today $program_time" +%s)
            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "https://tvbsapp.tvbs.com.tw/pg_api/pg_list/$chnl_order/$today/1/$lang" | $JQ_FILE '.data|to_entries|map(select(.value.date=="'"$today"'"))|.[].value.data|to_entries|map("\(.value.pg_hour)=\(.value.pg_name)")|.[]')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] tvbs 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] tvbs 节目表更新失败"
        fi
    done
}

ScheduleAstro()
{
    printf -v today '%(%Y-%m-%d)T' -1

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "iqiyi" > "$SCHEDULE_JSON"
    fi

    for chnl in "${astro_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        astro_id=${chnl#*:}
        chnl_name=${astro_id#*:}
        astro_id=${astro_id%%:*}

        schedule=""

        while IFS="=" read -r program_time program_title
        do
            program_time=${program_time#\"}
            program_sys_time=$(date -d "$program_time" +%s)
            program_time=${program_time#* }
            program_time=${program_time:0:5}
            program_title=${program_title%\"}
            [ -n "$schedule" ] && schedule="$schedule,"
            schedule=$schedule'{
                "title":"'"$program_title"'",
                "time":"'"$program_time"'",
                "sys_time":"'"$program_sys_time"'"
            }'
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "https://contenthub-api.eco.astro.com.my/channel/$astro_id.json" | $JQ_FILE '.response.schedule["'"$today"'"][]|[.datetime,.title]|join("=")')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] astro 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] astro 节目表更新失败"
        fi
    done
}

Schedule_4gtv()
{
    printf -v today '%(%Y-%m-%d)T' -1

    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "minshidiyi" > "$SCHEDULE_JSON"
    fi

    for chnl in "${_4gtv_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        _4gtv_id=${chnl#*:}
        chnl_name=${_4gtv_id#*:}
        _4gtv_id=${_4gtv_id%%:*}

        schedule=""

        while IFS="=" read -r program_date program_time program_title
        do
            program_date=${program_date#\"}
            if [ "$today" == "$program_date" ] 
            then
                program_sys_time=$(date -d "$program_date $program_time" +%s)
                program_time=${program_time%:*}
                program_title=${program_title%\"}
                [ -n "$schedule" ] && schedule="$schedule,"
                schedule=$schedule'{
                    "title":"'"$program_title"'",
                    "time":"'"$program_time"'",
                    "sys_time":"'"$program_sys_time"'"
                }'
            elif [ -n "$schedule" ] 
            then
                break
            fi
        done < <(curl -s -Lm 20 "https://www.4gtv.tv/proglist/$_4gtv_id.txt" \
            -H "User-Agent: $USER_AGENT_BROWSER" \
            -H "Referer: https://www.4gtv.tv/channel_sub.html?channelSet_id=1&asset_id=$_4gtv_id&channel_id=1" \
            | $JQ_FILE '.[]|[.sdate,.stime,.title]|join("=")')

        if [ -n "$schedule" ] 
        then
            JQ replace "$SCHEDULE_JSON" "$chnl_id" "[$schedule]"
            Println "$info $chnl_name [$chnl_id] 4gtv 节目表更新成功"
        else
            Println "$error $chnl_name [$chnl_id] 4gtv 节目表更新失败"
        fi
    done
}

ScheduleOther()
{
    if [ ! -s "$SCHEDULE_JSON" ] 
    then
        printf '{"%s":[]}' "amlh" > "$SCHEDULE_JSON"
    fi

    for chnl in "${other_chnls[@]}"
    do
        chnl_id=${chnl%%:*}
        chnl_name=${chnl#*:}
        chnl_id_upper=$(tr '[:lower:]' '[:upper:]' <<< "${chnl_id:0:1}")"${chnl_id:1}"
        Schedule"$chnl_id_upper"
    done
}

GetCronChnls()
{
    cron_providers=()
    cron_chnls=()
    cron_providers_list=""
    cron_providers_count=0
    while IFS= read -r line 
    do
        if [[ $line == *"|"* ]] 
        then
            cron_providers_count=$((cron_providers_count+1))
            cron_provider=${line%%|*}
            for provider in "${providers[@]}"
            do
                if [ "${provider%:*}" == "$cron_provider" ] 
                then
                    cron_provider_name="${provider#*:}"
                    break
                fi
            done

            cron_providers+=("$cron_provider")
            cron_chnls+=("${line#*|}")
            cron_providers_list="$cron_providers_list ${green}$cron_providers_count.${normal}${indent_6}$cron_provider_name\n\n"
        fi
    done < <($JQ_FILE -r '.schedule[]|[.provider,.chnls[]]|join("|")' "$CRON_FILE")
}

ScheduleView()
{
    GetCronChnls

    providers_list=""
    providers_count=0

    for provider in "${providers[@]}"
    do
        providers_count=$((providers_count+1))
        providers_list="$providers_list ${green}$providers_count.${normal}${indent_6}${provider#*:} [${provider%%:*}]\n\n"
    done

    Println "节目表来源\n\n$providers_list"

    while read -p "$i18n_default_cancel" provider_num
    do
        case "$provider_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$provider_num" -gt 0 ] && [ "$provider_num" -le "$providers_count" ]
                then
                    provider="${providers[$((provider_num-1))]%:*}"
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    var=("$provider"_chnls[@])

    for((i=0;i<cron_providers_count;i++));
    do
        if [ "${cron_providers[i]}" == "$provider" ] 
        then
            IFS="|" read -r -a cron_chnls <<< "${cron_chnls[i]}|"
            break
        fi
    done

    chnls_list=""
    chnls_count=0

    for chnl in "${!var}"
    do
        using=""
        for cron_chnl in "${cron_chnls[@]}"
        do
            if [ "$cron_chnl" == "$chnl" ] 
            then
                using="${green}[已添加]${normal}"
                break
            fi
        done
        chnl_name=${chnl##*:}
        if [ "$provider" == "ontvtonight" ] 
        then
            chnl_id=${chnl%%@*}
        else
            chnl_id=${chnl%%:*}
        fi
        chnls_count=$((chnls_count+1))
        chnls_list="$chnls_list ${green}$chnls_count.${normal}${indent_6}$chnl_name [$chnl_id] $using\n\n"
    done

    chnls=("${!var}")

    echo -e "\n$chnls_list"
}

ScheduleAddChannel()
{
    for cron_chnl in "${cron_chnls[@]}"
    do
        if [ "$cron_chnl" == "$chnl" ] 
        then
            return 0
        fi
    done
    if [ "${add_provider:-1}" -eq 1 ] && [[ -z $($JQ_FILE '.schedule[] | select(.provider=="'"$provider"'")' "$CRON_FILE") ]]
    then
        add_provider=0
        new_provider=$(
        $JQ_FILE -n --arg provider "$provider" --arg chnl "$chnl" \
        '{
            "provider": $provider,
            "chnls": [
                $chnl
            ]
        }')
        JQ add "$CRON_FILE" schedule "[$new_provider]"
    else
        JQ update "$CRON_FILE" '(.schedule[]|select(.provider=="'"$provider"'").chnls) += ["'"$chnl"'"]'
        add_provider=0
    fi
    Println "$info 频道 [ ${chnl##*:} ] 添加成功"
}

ScheduleAdd()
{
    ScheduleView
    echo -e " ${green}$((chnls_count+1)).${normal}${indent_6}全部"

    Println "$tip (多个频道用空格分隔 比如: 5 7 9-11)"

    while read -p "$i18n_default_cancel" chnls_num
    do
        if [ -z "$chnls_num" ] 
        then
            Println "$i18n_canceled...\n" && exit 1
        fi

        if [ "$chnls_num" == $((chnls_count+1)) ] 
        then
            for chnl in "${chnls[@]}"
            do
                ScheduleAddChannel
            done
            break
        fi

        IFS=" " read -ra chnls_num_arr <<< "$chnls_num"

        error_no=0
        for chnl_num in "${chnls_num_arr[@]}"
        do
            case "$chnl_num" in
                *"-"*)
                    chnl_num_start=${chnl_num%-*}
                    chnl_num_end=${chnl_num#*-}
                    if [[ $chnl_num_start == *[!0-9]* ]] || [[ $chnl_num_end == *[!0-9]* ]] || [ "$chnl_num_start" -eq 0 ] || [ "$chnl_num_end" -eq 0 ] || [ "$chnl_num_end" -gt "$chnls_count" ] || [ "$chnl_num_start" -ge "$chnl_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$chnl_num" -lt 1 ] || [ "$chnl_num" -gt "$chnls_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                for chnl_num in "${chnls_num_arr[@]}"
                do
                    if [[ $chnl_num =~ - ]] 
                    then
                        start=${chnl_num%-*}
                        end=${chnl_num#*-}
                        for((i=start-1;i<end;i++));
                        do
                            chnl="${chnls[i]}"
                            ScheduleAddChannel
                        done
                    else
                        chnl="${chnls[chnl_num-1]}"
                        ScheduleAddChannel
                    fi
                done
                break
            ;;
        esac
    done
}

ScheduleDelChannel()
{
    JQ update "$CRON_FILE" '(.schedule[]|select(.provider=="'"$provider"'").chnls) -= ["'"$chnl"'"]'
}

ScheduleViewCron()
{
    GetCronChnls

    [ -z "$cron_providers_list" ] && Println "$error 没有计划任务\n" && exit 1

    Println "计划任务节目表\n\n$cron_providers_list"

    while read -p "$i18n_default_cancel" provider_num
    do
        case "$provider_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$provider_num" -gt 0 ] && [ "$provider_num" -le "$cron_providers_count" ]
                then
                    provider="${cron_providers[provider_num-1]}"
                    IFS="|" read -r -a chnls <<< "${cron_chnls[provider_num-1]}|"
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    chnls_list=""
    chnls_count=0

    for chnl in ${chnls[@]+"${chnls[@]}"}
    do
        chnl_name=${chnl##*:}
        chnls_count=$((chnls_count+1))
        chnls_list="$chnls_list ${green}$chnls_count.${normal}${indent_6}$chnl_name\n\n"
    done

    Println "计划任务频道\n\n$chnls_list"
}

ScheduleDel()
{
    ScheduleViewCron

    echo -e " ${green}$((chnls_count+1)).${normal}${indent_6}全部"

    Println "$tip (多个频道用空格分隔 比如: 5 7 9-11)"

    while read -p "选择删除的频道(默认: 取消): " chnls_num
    do
        if [ -z "$chnls_num" ] 
        then
            Println "$i18n_canceled...\n" && exit 1
        fi

        if [ "$chnls_num" == $((chnls_count+1)) ] 
        then
            JQ update "$CRON_FILE" '(.schedule[]|select(.provider=="'"$provider"'").chnls) = []'
            break
        fi

        IFS=" " read -ra chnls_num_arr <<< "$chnls_num"

        error_no=0
        for chnl_num in "${chnls_num_arr[@]}"
        do
            case "$chnl_num" in
                *"-"*)
                    chnl_num_start=${chnl_num%-*}
                    chnl_num_end=${chnl_num#*-}
                    if [[ $chnl_num_start == *[!0-9]* ]] || [[ $chnl_num_end == *[!0-9]* ]] || [ "$chnl_num_start" -eq 0 ] || [ "$chnl_num_end" -eq 0 ] || [ "$chnl_num_end" -gt "$chnls_count" ] || [ "$chnl_num_start" -ge "$chnl_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$chnl_num" -lt 1 ] || [ "$chnl_num" -gt "$chnls_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                for chnl_num in "${chnls_num_arr[@]}"
                do
                    if [[ $chnl_num =~ - ]] 
                    then
                        start=${chnl_num%-*}
                        end=${chnl_num#*-}
                        for((i=start-1;i<end;i++));
                        do
                            chnl="${chnls[i]}"
                            ScheduleDelChannel
                        done
                    else
                        chnl="${chnls[chnl_num-1]}"
                        ScheduleDelChannel
                    fi
                done
                break
            ;;
        esac
    done
    Println "$info 删除成功\n"
}

ScheduleExec()
{
    if [ -s "$CRON_FILE" ] && [[ $($JQ_FILE '.schedule' "$CRON_FILE") != null ]]
    then
        printf '{"%s":[]}' "hbo" > "$SCHEDULE_JSON"
        while IFS="=" read -r provider chnls option
        do
            if [ "$chnls" != null ] 
            then
                var=("$provider"_chnls[@])
                if [[ -n ${!var:-} ]] 
                then
                    unset "$provider"_chnls
                    IFS="|" read -r -a "$provider"_chnls <<< "${chnls}|"
                fi
                if [ "$provider" == "other" ] 
                then
                    for chnl in "${other_chnls[@]}"
                    do
                        chnl_id=${chnl%%:*}
                        chnl_name=${chnl#*:}
                        chnl_id_upper=$(tr '[:lower:]' '[:upper:]' <<< "${chnl_id:0:1}")"${chnl_id:1}"
                        Schedule"$chnl_id_upper"
                    done
                else
                    provider=$(tr '[:lower:]' '[:upper:]' <<< "${provider:0:1}")"${provider:1}"
                    Schedule"$provider" "$option"
                fi
            fi
        done < <($JQ_FILE -r '.schedule[]|[.provider,(.chnls|sort|join("|")| if .=="" then "null" else . end),.option]|join("=")' "$CRON_FILE")
        if [ -e "$IPTV_ROOT/vip.pid" ] 
        then
            printf '%s' "" > "$VIP_USERS_ROOT/epg.update"
        fi
    else
        Println "$error 计划任务为空, 请先添加频道 !\n"
    fi
}

ScheduleBackup()
{
    if [ ! -s "$CRON_FILE" ] 
    then
        Println "$error 请先添加频道\n"
        exit 1
    fi
    echo
    inquirer text_input "输入备份名称: " backup_name "无"
    backup_schedule=""
    while IFS="=" read -r provider chnls option
    do
        if [ "$chnls" != null ] 
        then
            [ -n "$backup_schedule" ] && backup_schedule="$backup_schedule,"
            backup_schedule=$backup_schedule'{
                "provider":"'"$provider"'",
                "chnls":"'"$chnls"'"
            }'
        fi
    done < <($JQ_FILE -r '.schedule[]|[.provider,(.chnls|sort|join("|")| if .=="" then "null" else . end),.option]|join("=")' "$CRON_FILE")
    if [ -z "$backup_schedule" ] 
    then
        Println "$error 请先添加频道\n"
        exit 1
    fi
    new_backup=$(
    $JQ_FILE -n --arg name "$backup_name" --argjson schedule "[$backup_schedule]" \
        '{
            name: $name,
            date: now|strflocaltime("%s")|tonumber,
            schedule: $schedule
        }'
    )
    jq_path='["schedule_backup"]'
    JQ add "$CRON_FILE" "$new_backup"
    Println "$info 任务备份成功\n"
}

ScheduleListBackup()
{
    schedule_backup_names=()
    schedule_backup_dates=()
    schedule_backup_schedules=()
    schedule_backup_count=0
    schedule_backup_list=""
    while IFS="^" read -r backup_name backup_date backup_schedule
    do
        schedule_backup_count=$((schedule_backup_count+1))
        schedule_backup_names+=("$backup_name")
        schedule_backup_dates+=("$backup_date")
        schedule_backup_schedules+=("$backup_schedule")
        printf -v date '%(%m-%d %H:%M:%S)T' "$backup_date"
        schedule_backup_list="$schedule_backup_list $schedule_backup_count. 备份名称: ${green}$backup_name${normal} 备份日期: ${green}$date${normal}\n\n"
    done < <($JQ_FILE -r '(.schedule_backup| if .== null then [] else . end)[]|([.name,.date,(.schedule|to_entries|map([.value.provider,.value.chnls]|join("="))|join(","))]|join("^"))' "$CRON_FILE")

    if [ "$schedule_backup_count" -eq 0 ] 
    then
        Println "$error 没有备份\n"
        exit 1
    fi

    Println "$schedule_backup_list"
}

ScheduleViewBackup()
{
    ScheduleListBackup

    while read -p "$i18n_default_cancel" backup_num
    do
        case "$backup_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$backup_num" -gt 0 ] && [ "$backup_num" -le "$schedule_backup_count" ]
                then
                    schedule="${schedule_backup_schedules[backup_num-1]}"
                    IFS="," read -r -a schedules <<< "$schedule"
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    schedules_list=""

    for((i=0;i<${#schedules[@]};i++));
    do
        schedule_provider=${schedules[i]%=*}
        for provider in "${providers[@]}"
        do
            if [ "${provider%:*}" == "$schedule_provider" ] 
            then
                schedule_provider_name="${provider#*:}"
                break
            fi
        done
        schedule_chnl=${schedules[i]#*=}
        IFS="|" read -r -a schedule_chnls <<< "$schedule_chnl"
        schedule_chnls_list=""
        for schedule_chnl in "${schedule_chnls[@]}"
        do
            if [ "$schedule_provider" == "ontvtonight" ] 
            then
                schedule_chnl_id=${schedule_chnl%%@*}
            else
                schedule_chnl_id=${schedule_chnl%%:*}
            fi
            schedule_chnls_list="$schedule_chnls_list${indent_6}${schedule_chnl##*:} ($schedule_chnl_id)\n"
        done
        schedules_list="$schedules_list ${green}$((i+1)).${normal}${indent_6}$schedule_provider_name\n\n$schedule_chnls_list\n"
    done

    Println "$schedules_list"
}

ScheduleEditBackup()
{
    ScheduleListBackup

    while read -p "$i18n_default_cancel" backup_num
    do
        case "$backup_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$backup_num" -gt 0 ] && [ "$backup_num" -le "$schedule_backup_count" ]
                then
                    backup_index=$((backup_num-1))
                    backup_name_old=${schedule_backup_names[backup_index]}
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    echo
    inquirer text_input "输入新的备份名称: " backup_name "$backup_name_old"

    jq_path='["schedule_backup",'"$backup_index"',"name"]'
    JQ update "$CRON_FILE" "$backup_name"
    Println "$info 备份修改成功\n"
}

ScheduleDelBackup()
{
    ScheduleListBackup

    while read -p "$i18n_default_cancel" backup_num
    do
        case "$backup_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$backup_num" -gt 0 ] && [ "$backup_num" -le "$schedule_backup_count" ]
                then
                    backup_index=$((backup_num-1))
                    backup_name=${schedule_backup_names[backup_index]}
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    jq_path='["schedule_backup"]'
    JQ delete "$CRON_FILE" "$backup_index"
    Println "$info 备份 $backup_name 删除成功\n"
}

ScheduleRestoreBackup()
{
    ScheduleListBackup

    while read -p "$i18n_default_cancel" backup_num
    do
        case "$backup_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$backup_num" -gt 0 ] && [ "$backup_num" -le "$schedule_backup_count" ]
                then
                    backup_index=$((backup_num-1))
                    backup_name=${schedule_backup_names[backup_index]}
                    backup_schedule="${schedule_backup_schedules[backup_index]}"
                    IFS="," read -r -a backup_schedules <<< "$backup_schedule"
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    schedules_list=""
    for((i=0;i<${#backup_schedules[@]};i++));
    do
        schedule_provider=${backup_schedules[i]%=*}
        schedule_chnl=${backup_schedules[i]#*=}
        IFS="|" read -r -a schedule_chnls <<< "$schedule_chnl"
        schedule_chnls_list=""
        for schedule_chnl in "${schedule_chnls[@]}"
        do
            [ -n "$schedule_chnls_list" ] && schedule_chnls_list="$schedule_chnls_list,"
            schedule_chnls_list=$schedule_chnls_list'"'$schedule_chnl'"'
        done
        [ -n "$schedules_list" ] && schedules_list="$schedules_list,"
        schedules_list=$schedules_list'{
            "provider":"'"$schedule_provider"'",
            "chnls":['"$schedule_chnls_list"']
        }'
    done

    jq_path='["schedule"]'
    JQ replace "$CRON_FILE" "[$schedules_list]"
    Println "$info 备份 $backup_name 恢复成功\n"
}

ScheduleEnableCron()
{
    if crontab -l | grep -q "/usr/local/bin/tv s" 2> /dev/null
    then
        Println "$error 计划任务已开启 !\n"
    else
        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        printf '%s\n' "0 0 * * * /usr/local/bin/tv s -" >> "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 计划任务开启成功 !\n"
    fi
}

ScheduleDisableCron()
{
    if crontab -l | grep -q "/usr/local/bin/tv s" 2> /dev/null
    then
        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        sed -i "/\/usr\/local\/bin\/tv s/d" "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 计划任务已关闭\n"
    else
        Println "$error 计划任务未开启 !\n"
    fi
}

Schedule()
{
    GetDefault

    if [ -n "$d_schedule_file" ] 
    then
        SCHEDULE_JSON=$d_schedule_file
    else
        Println "$error 请先设置 schedule_file 位置!\n" && exit 1
    fi

    if [ ! -s "$CRON_FILE" ] 
    then
        printf '{"%s":[]}' "schedule" > "$CRON_FILE"
    fi

    jiushi_chnls=( 
#        "foxmovies:FOX MOVIES"
#        "disney:Disney"
        "minshi:民視"
        "minshidiyi:民視第一台"
        "minshitaiwan:民視台灣台"
        "mtvlivetw:MTV-Live"
        "tvbfc:TVB 翡翠台"
        "tvbpearl:TVB Pearl"
        "tvbj2:TVB J2"
        "tvbwxxw:TVB 互動新聞台"
        "xgws:香港衛視綜合台"
        "foxfamily:福斯家庭電影台"
        "hlwdy:好萊塢電影"
        "xwdy:星衛HD電影台"
        "mydy:美亞電影台"
        "mycinemaeurope:My Cinema Europe HD我的歐洲電影台"
        "ymjs:影迷數位紀實台"
        "ymdy:影迷數位電影台"
        "hyyj:華藝影劇台"
        "catchplaydy:CatchPlay電影台"
        "ccyj:采昌影劇台"
        "lxdy:LS龍祥電影"
        "cinemax:Cinemax"
        "cinemaworld:CinemaWorld"
        "axn:AXN HD"
        "channelv:Channel V國際娛樂台HD"
        "dreamworks:DREAMWORKS"
        "nickasia:Nickelodeon Asia(尼克兒童頻道)"
        "cbeebies:CBeebies"
        "babytv:Baby TV"
        "boomerang:Boomerang"
        "mykids:MY-KIDS TV"
        "dwxq:動物星球頻道"
        "eltvshyy:ELTV生活英語台"
        "ifundm:i-Fun動漫台"
        "momoqz:momo親子台"
        "cnkt:CN卡通台"
        "ffxw:非凡新聞"
        "hycj:寰宇財經台"
        "hyzh:寰宇HD綜合台"
        "hyxw:寰宇新聞台"
        "hyxw2:寰宇新聞二台"
        "aedzh:愛爾達綜合台"
        "aedyj:愛爾達影劇台"
        "jtzx:靖天資訊台"
        "jtzh:靖天綜合台"
        "jtyl:靖天育樂台"
        "jtxj:靖天戲劇台"
        "jthl:Nice TV 靖天歡樂台"
        "jtyh:靖天映畫"
        "jtgj:KLT-靖天國際台"
        "jtrb:靖天日本台"
        "jtdy:靖天電影台"
        "jtkt:靖天卡通台"
        "jyxj:靖洋戲劇台"
        "jykt:靖洋卡通台Nice Bingo"
        "lhxj:龍華戲劇"
        "lhox:龍華偶像"
        "lhyj:龍華影劇"
        "lhdy:龍華電影"
        "lhjd:龍華經典"
        "lhyp:龍華洋片"
        "lhdh:龍華動畫"
        "wszw:衛視中文台"
        "wsdy:衛視電影台"
        "gxws:國興衛視"
        "gs:公視"
        "gs2:公視2台"
        "gs3:公視3台"
        "ts:台視"
        "tszh:台視綜合台"
        "tscj:台視財經台"
        "hs:華視"
        "hsjywh:華視教育文化"
        "zs:中視"
        "zsxw:中視新聞台"
        "zsjd:中視經典台"
        "sltw:三立台灣台"
        "sldh:三立都會台"
        "slzh:三立綜合台"
        "slxj:三立戲劇台"
        "bdzh:八大綜合"
        "bddy:八大第一"
        "bdxj:八大戲劇"
        "bdyl:八大娛樂"
        "gdyl:高點育樂"
        "gdzh:高點綜合"
        "ydsdy:壹電視電影台"
        "ydszxzh:壹電視資訊綜合台"
        "wlty:緯來體育台"
        "wlxj:緯來戲劇台"
        "wlrb:緯來日本台"
        "wldy:緯來電影台"
        "wlzh:緯來綜合台"
        "wlyl:緯來育樂台"
        "wljc:緯來精采台"
        "dszh:東森綜合台"
        "dsxj:東森戲劇台"
        "dsyy:東森幼幼台"
        "dsdy:東森電影台"
        "dsyp:東森洋片台"
        "dsxw:東森新聞台"
        "dscjxw:東森財經新聞台"
        "dscs:超級電視台"
        "ztxw:中天新聞台"
        "ztyl:中天娛樂台"
        "ztzh:中天綜合台"
        "msxq:美食星球頻道"
        "yzms:亞洲美食頻道"
        "yzly:亞洲旅遊台"
        "yzzh:亞洲綜合台"
        "yzxw:亞洲新聞台"
        "pltw:霹靂台灣"
        "titvyjm:原住民"
        "history:歷史頻道"
        "history2:HISTORY 2"
        "gjdl:國家地理高畫質頻道"
        "gjdlyr:國家地理高畫質悠人頻道"
        "gjdlys:國家地理高畫質野生頻道"
        "bbcearth:BBC Earth"
        "bbcworldnews:BBC World News"
        "bbclifestyle:BBC Lifestyle Channel"
        "wakawakajapan:WAKUWAKU JAPAN"
        "luxe:LUXE TV Channel"
        "bswx:博斯無限台"
        "bsgq1:博斯高球一台"
        "bsgq2:博斯高球二台"
        "bsml:博斯魅力網"
        "bswq:博斯網球台"
        "bsyd1:博斯運動一台"
        "bsyd2:博斯運動二台"
        "zlty:智林體育台"
        "eurosport:EUROSPORT"
        "fox:FOX頻道"
        "foxsports:FOX SPORTS"
        "foxsports2:FOX SPORTS 2"
        "foxsports3:FOX SPORTS 3"
        "elevensportsplus:ELEVEN SPORTS PLUS"
        "elevensports2:ELEVEN SPORTS 2"
        "discoveryasia:Discovery Asia"
        "discovery:Discovery"
        "discoverykx:Discovery科學頻道"
        "tracesportstars:TRACE Sport Stars"
        "dw:DW(Deutsch)"
        "lifetime:Lifetime"
        "foxcrime:FOXCRIME"
        "animax:Animax"
        "mtvtw:MTV綜合電視台"
        "ndmuch:年代MUCH"
        "ndxw:年代新聞"
        "nhk:NHK"
        "euronews:Euronews"
        "skynews:SKY NEWS HD"
        "nhkxwzx:NHK新聞資訊台"
        "jetzh:JET綜合"
        "tlclysh:旅遊生活"
        "z:Z頻道"
        "itvchoice:ITV Choice"
        "mdrb:曼迪日本台"
        "smartzs:Smart知識台"
        "tv5monde:TV5MONDE"
        "outdoor:Outdoor-Channel"
        "fashionone:Fashion-One"
        "ifundm:i-Fun動漫台"
        "eentertainment:E! Entertainment"
        "davinci:DaVinCi Learning達文西頻道"
        "my101zh:MY101綜合台"
        "blueantextreme:BLUE ANT EXTREME"
        "blueantentertainmet:BLUE ANT EXTREME"
        "eyetvxj:EYE TV戲劇台"
        "eyetvly:EYE TV旅遊台"
        "travel:Travel Channel"
        "dmax:DMAX頻道"
        "hitshd:HITS"
        "fx:FX"
        "tvbshd:TVBS"
        "tvbshl:TVBS歡樂"
        "tvbsjc:TVBS精采台"
        "tvbxh:TVB星河頻道"
        "tvn:tvN"
        "hgyl:韓國娛樂台KMTV"
        "xfkjjj:幸福空間居家台"
        "xwyl:星衛娛樂台"
        "amc:AMC"
        "animaxhd:Animax HD"
        "diva:Diva"
        "bloomberg:Bloomberg TV"
        "fgss:時尚頻道"
        "warner:Warner TV"
        "ettodayzh:ETtoday綜合台" )

    niotv_chnls=( 
        "hbohd:629:HBO HD 亚洲"
        "hits:501:HBO 强档巨献 亚洲"
        "signature:503:HBO 原创巨献 亚洲"
        "family:502:HBO 温馨家庭 亚洲"
        "cinemax:49:CINEMAX 亚洲"
        "msxw:45:民视新闻"
        "tsxw:637:台视新闻"
        "slxw:38:三立新闻"
        "slinews:172:三立 iNews"
        "tvbsxw:41:TVBS 新闻"
        "minshi:16:民视"
        "minshidiyi:638:民视第一台"
        "minshitaiwan:742:民视台湾台"
        "mtvlivetw:751:MTV Live 台湾"
        "foxmovies:47:Fox 电影"
        "foxfamily:540:Fox 家庭电影"
        "foxaction:543:FOX 警匪"
        "disney:63:迪士尼 台湾"
        "dreamworks:758:梦工厂"
        "nickasia:705:尼克亚洲"
        "cbeebies:771:CBeebies"
        "babytv:553:Baby TV:Boomerang卡通"
        "boomerang:766:Boomerang"
        "dwxq:61:动物星球"
        "momoqz:148:momo 亲子"
        "cnkt:65:CN 卡通"
        "hyxw:695:寰宇新闻"
        "jtzx:709:靖天资讯"
        "jtzh:710:靖天综合"
        "jtyl:202:靖天育乐"
        "jtxj:721:靖天戏剧"
        "jthl:708:靖天欢乐"
        "jtyh:727:靖天映画"
        "jtrb:711:靖天日本"
        "jtkt:707:靖天卡通"
        "jyxj:203:靖洋戏剧"
        "jykt:706:靖洋卡通"
        "wszw:19:卫视中文"
        "wsdy:55:卫视电影"
        "gxws:73:国兴卫视"
        "gs:17:公视"
        "gs2:759:公视台语"
        "gs3:177:公视3台"
        "ts:11:台视"
        "tszh:632:台视综合"
        "tscj:633:台视财经"
        "hs:15:华视"
        "hsjywh:138:华视教育体育文化"
        "zs:13:中视"
        "zsxw:668:中视新闻"
        "zsjd:714:中视经典"
        "sltw:34:三立台湾"
        "sldh:35:三立都会"
        "bdzh:21:八大综合"
        "bddy:33:八大电影"
        "bdxj:22:八大戏剧"
        "bdyl:60:八大娱乐"
        "gdyl:170:高点育乐"
        "gdzh:143:高点综合"
        "ydsdy:187:壹电视电影"
        "ydszh:681:壹电视综合"
        "wlty:66:玮来体育"
        "wlxj:29:玮来戏剧"
        "wlrb:72:玮来日本"
        "wldy:57:玮来电影"
        "wlzh:24:玮来综合"
        "wlyl:53:玮来育乐"
        "wljc:546:玮来精采"
        "dszh:23:东森综合"
        "dsxj:36:东森戏剧"
        "dsyy:64:东森幼幼"
        "dsdy:56:东森电影"
        "dsyp:48:东森洋片"
        "dsxw:42:东森新闻"
        "dscjxw:43:东森财经新闻"
        "dscs:18:东森超视"
        "ztxw:668:中天新闻"
        "ztyl:14:中天娱乐"
        "ztzh:27:中天综合"
        "yzly:778:亚洲旅游"
        "yzms:733:亚洲美食"
        "yzxw:554:亚洲新闻"
        "pltw:26:霹雳台湾"
        "titvyjm:133:原住民"
        "history:549:历史频道"
        "history2:198:历史频道2"
        "gjdl:59:国家地理 台湾"
        "gjdlyr:670:国家地理悠人"
        "gjdlys:161:国家地理野生"
        "gjdlgj:519:国家地理国际"
        "discoveryasia:563:探索亚洲频道"
        "discovery:58:探索频道"
        "discoverykx:520:探索科学频道"
        "bbcearth:698:BBC 地球"
        "bbcworldnews:144:BBC 世界新闻"
        "bbclifestyle:646:BBC Lifestyle"
        "bswx:587:博斯无限"
        "bsgq1:529:博斯高球"
        "bsgq2:526:博斯高球2"
        "bsml:588:博斯魅力"
        "bsyd2:635:博斯运动2"
        "bsyd1:527:博斯运动"
        "eurosport:581:欧洲体育"
        "fox:70:FOX"
        "foxsports:67:FOX 体育"
        "foxsports2:68:FOX 体育2"
        "foxsports3:547:FOX 体育3"
        "elevensportsplus:787:ELEVEN 体育 plus"
        "elevensports1:769:ELEVEN 体育1"
        "elevensports2:770:ELEVEN 体育2"
        "lifetime:199:Lifetime"
        "foxcrime:543:FOX CRIME"
        "hlwdy:52:好莱坞电影"
        "animax:84:ANIMAX"
        "mtvtw:69:MTV 台湾"
        "ndmuch:25:年代 MUCH"
        "ndxw:40:年代新闻"
        "nhk:74:NHK"
        "euronews:591:欧洲新闻"
        "ffxw:79:非凡新闻"
        "jetzh:71:JET 综合"
        "tlclysh:62:TLC 旅途生活"
        "axn:50:AXN"
        "z:75:Z 频道"
        "luxe:590:LUXE TV"
        "catchplaydy:582:CatchPlay 电影"
        "tv5monde:574:法国 TV5"
        "channelv:584:Channel [v] 国际"
        "davinci:669:达芬奇频道"
        "blueantextreme:779:BLUE ANT Extreme"
        "blueantentertainmet:785:BLUE ANT Entertainment"
        "travel:684:Travel"
        "cnn:107:CNN"
        "dmax:521:DMAX"
        "hitshd:692:HITS"
        "lxdy:141:龙祥电影"
        "fx:544:FX"
        "tvn:757:tvN"
        "hgyl:568:韩国娱乐"
        "xfkjjj:672:幸福空间居家"
        "nhkxwzx:773:NHK 新闻资讯"
        "zlty:676:智林体育"
        "xwdy:558:星卫电影"
        "xwyl:539:星卫娱乐"
        "mycinemaeurope:775:我的欧洲电影"
        "amc:682:AMC 台湾"
        "animaxhd:772:ANIMAX HD"
        "wakawakajapan:765:Wakawaka Japan"
        "tvbshd:20:TVBS"
        "tvbshl:32:TVBS 欢乐"
        "tvbsjc:774:TVBS 精采"
        "cinemaworld:559:Cinema World"
        "warner:688:Warner TV" )

    nowtv_chnls=( 
        "hbohd:115:HBO HD 亚洲"
        "hits:111:HBO 强档巨献 亚洲"
        "signature:114:HBO 原创巨献 亚洲"
        "family:112:HBO 温馨家庭 亚洲"
        "cinemax:113:CINEMAX 亚洲"
        "foxmovies:117:Fox 电影"
        "foxfamily:120:Fox 家庭电影"
        "foxaction:118:Fox 警匪"
        "wsdy:139:卫视电影台"
        "animaxhd:150:Animax"
        "tvn:155:tvN"
        "wszw:160:卫视中文台"
        "discoveryasia:208:探索亚洲频道"
        "discovery:209:探索频道"
        "dwxq:210:动物星球"
        "discoverykx:211:探索科学频道"
        "dmax:212:DMAX"
        "tlclysh:213:TLC 旅游生活"
        "gjdlhk:215:国家地理 香港"
        "gjdlys:216:国家地理野生"
        "gjdlyr:217:国家地理悠人"
        "gjdlgj:218:国家地理国际"
        "bbcearth:220:BBC 地球"
        "history:223:历史频道"
        "historyhd:225:历史频道高清"
        "cnn:316:CNN"
        "foxnews:318:FOX News"
        "bbcworldnews:320:BBC 世界新闻"
        "bloomberg:321:Bloomberg 电视"
        "yzxw:322:亚洲新闻台"
        "skynews:323:天空新闻"
        "dw:324:DW 英文"
        "euronews:326:欧洲新闻"
        "nhk:328:NHK WORLD-JAPAN"
        "fhwszx:366:凤凰卫视资讯"
        "fhwsxg:367:凤凰卫视香港"
        "fhwszw:548:凤凰卫视中文"
        "xgws:368:香港卫视"
        "disney:441:迪士尼"
        "boomerang:445:Boomerang"
        "cbeebies:447:BBC CBeebies"
        "babytv:448:Baby tv"
        "bbclifestyle:502:BBC lifestyle"
        "comedycentral:505:Comedy Central"
        "warner:510:WarnerTV"
        "AXN:512:AXN"
        "blueantextreme:516:BLUE ANT Extreme"
        "blueantentertainmet:517:BLUE ANT Entertainment"
        "fox:518:FOX"
        "foxcrime:523:FOX CRIME"
        "fx:524:FX"
        "lifetime:525:Lifetime"
        "yzms:527:亚洲美食"
        "channelv:534:Channel [v] 国际"
        "zgzwws:556:浙江卫视"
        "foxsports:670:Fox 体育"
        "foxsports2:671:Fox 体育2"
        "foxsports3:672:Fox 体育3" )

    icable_chnls=(
        "hkopen:001:香港开电视"
        "hkibc:002:香港国际财经台"
        "cjzx:108:财经资讯台"
        "xw:109:新闻台"
        "zbxw:110:直播新闻台"
        "cctv13:111:中央电视台新闻频道"
        "cctv4:112:中央电视台中文国际频道"
        "fhwszx:113:凤凰卫视资讯台"
        "dsyzxw:114:东森亚洲新闻台"
        "bbcworldnews:122:BBC WorldNews"
        "foxnews:123:FOX News"
        "cnni:124:CNNI"
        "cnnhlnnews:125:CNN HLN News"
        "nhkworldjapan:126:NHK World-Japan"
        "cnbchk:127:CNBC HK"
        "bloomberg:128:Bloomberg TV HD"
        "zghqdsw:129:中国环球电视网"
        "yzxw:130:亚洲新闻台"
        "russiatoday:131:Russia Today"
        "dw:140:DW (Deutsch)"
        "yxdy:201:有线电影台"
        "gyoz:202:光影欧洲"
        "wsdy:204:卫视电影台"
        "wsks:205:卫视卡式台"
        "foxmovies:214:FOX Movies"
        "foxfamily:215:FOX Family Movies"
        "foxaction:216:FOX Action Movies"
        "gqsryy:218:高清私人影院"
        "jsdy:219:惊悚电影台"
        "zhyl:301:综合娱乐台"
        "fhwsxg:304:凤凰卫视香港台"
        "zjpd:305:珠江频道"
        "fox:311:FOX"
        "foxlife:312:FOXlife"
        "fx:313:FX"
        "blueantentertainmet:317:Blue Ant 综合娱乐 HD"
        "blueantextreme:318:Blue Ant 超级娱乐 HD"
        "fashiontv:319:Fashion TV HD"
        "tvn:320:tvN HD"
        "nhkworldpr:322:NHK World Pr"
        "comedycentral:324:Comedy Central 爆笑台"
        "arirangtv:325:Arirang TV"
        "abcaustralia:326:ABC Australia"
        "dsyzws:331:东森亚洲卫视"
        "wszw:332:卫视中文台"
        "mtvchina:333:MTV China"
        "dfwsgj:334:东方卫视国际频道"
        "szds:335:深圳电视台"
        "hbws:337:湖北卫视"
        "cctv11:340:中央电视台戏曲频道"
        "cctv1:341:中央电视台综合频道"
        "fhwszw:376:凤凰卫视中文台"
        "dsyzyy:502:东森亚洲幼幼台"
        "dreamworks:510:梦工厂"
        "ktpd:511:卡通频道"
        "boomerang:512:Boomerang 频道"
        "dwx:513:达文西频道"
        "nickelodeon:514:Nickelodeon"
        "nickasia:515:Nick Jr."
        "babytv:516:Baby TV"
        "cbeebies:517:CBeebies"
        "zoomoo:518:ZooMoo"
        "fixfoxi:519:Fix & Foxi"
        "ybb:520:鸭宝宝"
        "disney:530:Disney Channel"
        "disneyjr:531:Disney Junior"
        "gqty:601:高清体育台"
        "sportsplus1:602:Sports Plus 1 HD"
        "gq603:603:高清603台"
        "sportsplus2:604:Sports Plus 2 HD"
        "sportsplus3:605:Sports Plus 3 HD"
        "foxsports:611:Fox Sports"
        "foxsports2:612:Fox Sports 2"
        "foxsports3:613:Fox Sports 3"
        "beinsports1:614:beIN Sports 1"
        "beinsports2:615:beIN Sports 2"
        "beinsportsmax:616:beIN SPORTS MAX"
        "yx18:618:有线18台"
        "yxty:661:有线体育台"
        "sm1:668:赛马1台"
        "sm2:669:赛马2台"
        "gjdlys:701:国家地理野生高清频道"
        "gjdlgq:702:国家地理高清频道"
        "gjdlyr:703:国家地理悠人高清频道"
        "discoveryasia:710:Discovery Asia"
        "discovery:711:Discovery 高清频道"
        "tlclysh:712:旅遊生活高清频道"
        "eve:713:EVE 高清频道"
        "dwxq:714:动物星球高清频道"
        "discoverykx:715:Discovery 科学高清频道"
        "dmax:716:DMAX 高清频道"
        "bbclifestyle:720:BBC Lifestyle 高清频道"
        "bbcearth:721:BBC Earth"
        "zghqdswjl:722:中国环球电视网记录频道"
        "petclubtv:730:Pet Club TV"
        "zeetv:851:Zee TV"
        "zeenews:852:Zee News"
        "zeecinema:853:Zee Cinema"
        "zing:854:Zing"
        "hl:901:欢乐台"
        "rh:902:惹火台"
    )

    hbozw_chnls=(
        "hbo:satellite:HBO 亚洲"
        "hbohd:satellite:HBO HD 亚洲"
        "hits:satellite:HBO 强档巨献 亚洲"
        "signature:satellite:HBO 原创巨献 亚洲"
        "family:satellite:HBO 温馨家庭 亚洲"
        "red:satellite:HBO RED 亚洲"
        "cinemax:satellite:CINEMAX 亚洲"
        "hbocn:cn:HBO 中国"
        "hbotw:tw:HBO 台湾"
    )

    hbous_chnls=(
        "us_hbo:HBO:EAST:HBO East"
        "us_hbo2:HBO2:EAST:HBO 2 EAST"
        "us_hbosignature:HBO SIGNATURE:EAST:HBO Signature East"
        "us_hbofamily:HBO FAMILY:EAST:HBO family East"
        "us_hbocomedy:HBO COMEDY:EAST:HBO comedy East"
        "us_hbozone:HBO ZONE:EAST:HBO Zone East"
        "us_hbolatino:HBO LATINO:EAST:HBO Lation East"
        "us_hbo:HBO:WEST:HBO West"
        "us_hbo2:HBO2:WEST:HBO 2 West"
        "us_hbosignature:HBO SIGNATURE:WEST:HBO Signature West"
        "us_hbofamily:HBO FAMILY:WEST:HBO family West"
        "us_hbocomedy:HBO COMEDY:WEST:HBO COMEDY  West"
        "us_hbozone:HBO ZONE:WEST:HBO Zone West"
        "us_hbolatino:HBO LATINO:WEST:HBO Lation West" )

    ontvtonight_chnls=(
        "us_abc@abc@69048344@-04:00:ABC"
        "au_abcnews@abc-news@2141@+02:00:ABC NEWS"
        "us_cbs@cbs@69048345@-04:00:CBS"
        "us_nbc@nbc@69048423@-04:00:NBC"
        "us_fox@fox@69048367@-04:00:FOX"
        "us_msnbc@msnbc@69023101@-04:00:MSNBC"
        "us_amc@amc-east@69047124@-04:00:AMC"
        "us_nickjr@nick-jr@69047681@-04:00:Nick Jr"
        "us_universalkids@universal-kids@69027178@-04:00:Universal Kids"
        "us_disneyjr@disney-junior-hdtv-east@69044944@-04:00:Disney Junior"
        "us_mtvhd@mtv-hdtv-east@69032459@-04:00:MTV HD 美国"
        "us_mtvlive@mtv-live-hdtv@69027734@-04:00:MTV Live 美国"
        "uk_mtvlivehd@mtv-live-hdtv@69038784@+01:00:MTV Live HD 英国"
        "uk_mtvmusic@mtv-music-uk@69042501@+04:00:MTV Music 英国"
        "uk_mtvbase@mtv-base@69036338@+01:00:MTV Base 英国"
        "uk_mtvclassic@mtv-classic@69043201@+01:00:MTV Classic 英国"
        "uk_mtvhits@mtv-hits-eu@69036341@+01:00:MTV Hits 英国"
        "us_comedycentral@comedy-central-east@69036536@-04:00:Comedy Central" )

    tvbhk_chnls=(
        "tvbhk_pearl:P:TVB 明珠台"
        "tvbhk_jade:J:TVB 翡翠台"
        "tvbhk_j2:B:TVB J2"
        "tvbhk_tvbnewschannel:C:TVB 无线新闻台"
        "tvbhk_tvbfinanceinformationchannel:A:TVB 无线财经资讯台"
        "tvbhk_xinghe:X:TVB 星河频道"
        "tvbhk_tvbclassic:E:TVB 经典台"
        "tvbhk_tvbkoreandrama:K:TVB 韩剧台"
        "tvbhk_tvbasiandrama:D:TVB 亚洲剧台"
        "tvbhk_tvbchinesedrama:U:TVB 华语剧台"
        "tvbhk_asianvariety:V:TVB 综艺旅游台"
        "tvbhk_tvbfood:L:TVB 为食台"
        "tvbhk_tvbclassicmovies:W:粤语片台" )

    singteltv_chnls=(
        "my_ch5:2:Channel 5"
        "my_ch8:3:Channel 8"
        "my_chu:7:Channel U"
        "my_kidschannel:243:少儿频道"
        "my_ele:501:e-Le"
        "my_jiale:502:佳乐"
        "my_starchinese:507:卫视中文台"
        "my_tvbjade:511:TVB 翡翠台 东南亚"
        "my_nowjelli:512:now Jelli 紫金国际台"
        "my_one:513:One HD"
        "my_xingkong:516:星空卫视"
        "my_xinghe:517:TVB 星河"
        "my_tvn:518:tvN HD"
        "my_gem:519:GEM"
        "my_ettvasia:521:东森亚洲卫视"
        "my_oh!k:525:Oh!K"
        "my_entertainment:531:Entertainment"
        "my_cbo:532:中国电视剧频道"
        "my_foodandhealth:533:美食健康频道"
        "my_cctventertainment:534:CCTV 娱乐"
        "my_dragontvintl:535:东方卫视"
        "my_channelvchina:547:Channel [V] 中国"
        "my_mtvchina:550:MTV 中国"
        "my_cctv4:555:CCTV 4"
        "my_ctiasia:557:中天亚洲台"
        "my_ettvnews:561:ETTV 东森新闻"
        "my_scmhd:571:卫视电影台"
        "my_scmlegend:573:卫视卡式台"
        "my_ccm:580:天映经典频道"
        "my_celestialmovies:585:天映频道" )

    cntv_chnls=(
        "cctv1"
        "cctv2"
        "cctv3"
        "cctv4"
        "cctv5"
        "cctv6"
        "cctv7"
        "cctv8"
        "cctvjilu:CCTV 9 纪录频道"
        "cctv10"
        "cctv11"
        "cctv12"
        "cctv13"
        "cctvchild:CCTV 14 少儿频道"
        "cctv15"
        "cctv5plus:CCTV 5+"
        "cctv17"
        "cctveurope:CCTV 中文国际频道"
        "cctvamerica:CCTV America" )

    tvbs_chnls=( 
        "tvbsxw:1:TVBS 新闻"
        "tvbshl:2:TVBS 欢乐台"
        "tvbshd:3:TVBS HD"
        "tvbsjc:4:TVBS 精采台"
        "tvbsyz:5:TVBS 亚洲"
    )

    astro_chnls=( 
        "iqiyi:355:astro 爱奇艺"
        "my_tvbclassic:425:TVB 经典台"
    )

    _4gtv_chnls=(
        "minshidiyi:4gtv-4gtv003:民視第一台"
        "minshitaiwan:4gtv-4gtv001:民視台灣台"
        "minshi:4gtv-4gtv002:民視"
        "zsjc:4gtv-4gtv064:中視菁采台"
        "zs:4gtv-4gtv040:中視"
        "zsjd:4gtv-4gtv080:中視經典台"
        "hs:4gtv-4gtv041:華視"
        "slzh:4gtv-live207:三立綜合台"
        "kjds:4gtv-4gtv043:客家電視台"
        "bdzy:4gtv-4gtv039:八大綜藝台"
        "tvbsjc:4gtv-4gtv086:TVBS精采台"
        "aedyl:4gtv-4gtv070:愛爾達娛樂台"
        "jtzh:4gtv-4gtv046:靖天綜合台"
        "jtrb:4gtv-4gtv047:靖天日本台"
        "xtryt:4gtv-4gtv050:新唐人亞太台"
        "ztzh:4gtv-4gtv033:中天綜合台"
        "kzyyjs:4gtv-4gtv012:空中英語教室"
        "dwx:4gtv-4gtv018:達文西頻道"
        "eltvshyy:litv-longturn20:ELTV生活英語台"
        "nickjr:4gtv-4gtv032:Nick Jr. 兒童頻道"
        "nickelodeon:4gtv-live105:Nickelodeon"
        "lhkt:litv-longturn01:龍華卡通台"
        "jtkt:4gtv-4gtv044:靖天卡通台"
        "jykt:4gtv-4gtv057:靖洋卡通Nice Bingo"
        "ifundm:litv-ftv15:i-Fun動漫台"
        "ifundm2:litv-ftv11:i-Fun動漫台2"
        "ifundm3:litv-ftv12:i-Fun動漫台3"
        "babyfirst:litv-longturn02:Baby First"
        "momoqz:4gtv-4gtv107:MOMO親子台"
        "cnkt:4gtv-live205:CN卡通"
        "dsgw1:4gtv-live047:東森購物一台"
        "dsxw:litv-ftv14:東森新聞台"
        "ztxw:4gtv-4gtv009:中天新聞台"
        "msxw:litv-ftv13:民視新聞台"
        "slcjxw:4gtv-4gtv089:三立財經新聞iNEWS"
        "tvbsxw:4gtv-4gtv072:TVBS新聞"
        "dscjxw:4gtv-4gtv019:東森財經新聞台"
        "zsxw:4gtv-4gtv074:中視新聞"
        "hsxw:4gtv-4gtv052:華視新聞"
        "hyxw:litv-longturn14:寰宇新聞台"
        "hyxwtw:litv-longturn15:寰宇新聞台灣台"
        "zhcj:4gtv-4gtv060:中華財經台"
        "dsgw2:4gtv-live046:東森購物二台"
        "mszy:4gtv-4gtv004:民視綜藝台"
        "zglgtx:4gtv-4gtv006:豬哥亮歌廳秀"
        "jtyl:4gtv-4gtv062:靖天育樂台"
        "jtgj:4gtv-4gtv063:KLT-靖天國際台"
        "jthl:4gtv-4gtv054:Nice TV 靖天歡樂台"
        "jtzx:4gtv-4gtv065:靖天資訊台"
        "hymbczh:4gtv-4gtv015:華藝MBC綜合台"
        "hgyl:4gtv-4gtv016:韓國娛樂台 KMTV"
        "comedycentral:4gtv-4gtv024:Comedy Central 爆笑頻道"
        "lifetime:4gtv-4gtv029:Lifetime 娛樂頻道"
        "dyys:4gtv-4gtv031:電影原聲台CMusic"
        "traceurban:4gtv-4gtv082:TRACE Urban"
        "mtvlivetw:4gtv-4gtv025:MTV Live HD 音樂頻道"
        "mezzolive:4gtv-4gtv083:Mezzo Live HD"
        "classica:4gtv-4gtv059:CLASSICA 古典樂"
        "mdqys:litv-longturn16:梅迪奇藝術頻道"
        "bsgq:litv-longturn05:博斯高球台"
        "bsgq2:litv-longturn06:博斯高球二台"
        "bsyd:litv-longturn07:博斯運動一台"
        "bswx:litv-longturn10:博斯無限台"
        "bswq:litv-longturn09:博斯網球台"
        "bsyd2:litv-longturn08:博斯運動二台"
        "bsml:litv-longturn04:博斯魅力台"
        "tracesportstars:4gtv-4gtv077:TRACE Sport Stars"
        "zlty:4gtv-4gtv101:智林體育台"
        "ssydx:4gtv-4gtv014:時尚運動X"
        "cmtv:4gtv-live201:車迷TV"
        "ginxesportstv:4gtv-4gtv053:GINX Esports TV"
        "yzly:litv-longturn17:亞洲旅遊台"
        "msly:litv-ftv07:民視旅遊台"
        "outdoor:4gtv-4gtv078:Outdoor Channel"
        "travel:4gtv-4gtv079:Travel Channel"
        "fashionone:litv-longturn19:Fashion One"
        "xfkjjj:4gtv-live206:幸福空間居家台"
        "lovenature:4gtv-live208:Love Nature"
        "history:4gtv-4gtv026:History 歷史頻道"
        "history2:4gtv-4gtv028:HISTORY 2 頻道"
        "smithsonian:4gtv-4gtv088:Smithsonian Channel"
        "smartzs:4gtv-4gtv076:SMART 知識頻道"
        "techstorm:4gtv-live109:TechStorm"
        "luxe:4gtv-live121:LUXE TV Channel"
        "tv5monde:4gtv-live122:TV5MONDE STYLE HD 生活時尚"
        "gsxj:4gtv-4gtv042:公視戲劇"
        "msyj:litv-ftv09:民視影劇台"
        "lhxj:litv-longturn18:龍華戲劇台"
        "lhox:litv-longturn12:龍華偶像台"
        "lhrh:litv-longturn11:龍華日韓台"
        "bdjc:4gtv-4gtv034:八大精彩台"
        "tyjd:4gtv-4gtv112:天映經典頻道"
        "jtxj:4gtv-4gtv058:靖天戲劇台"
        "jyxj:4gtv-4gtv045:靖洋戲劇台"
        "cizazt:4gtv-4gtv027:CI 罪案偵查頻道"
        "snhrjs:4gtv-4gtv013:視納華仁紀實頻道"
        "ymjs:4gtv-4gtv105:影迷數位紀實台"
        "jgbdx:4gtv-4gtv144:金光布袋戲"
        "blueantextreme:4gtv-live138:BLUE ANT EXTREME"
        "ccyj:4gtv-4gtv049:采昌影劇台"
        "jtyh:4gtv-4gtv055:靖天映畫"
        "jtdy:4gtv-4gtv061:靖天電影台"
        "lhdy:litv-longturn03:龍華電影台"
        "ydy1:4gtv-4gtv075:优電影一台"
        "ydy2:4gtv-4gtv081:优電影二台"
        "ydy3:4gtv-4gtv087:优電影三台"
        "ymdy:4gtv-4gtv011:影迷數位電影台"
        "amc:4gtv-4gtv017:AMC"
        "cinemaworld:4gtv-4gtv069:CinemaWorld"
        "warner:4gtv-4gtv037:Warner TV"
        "catchplaydy:4gtv-live048:CATCHPLAY電影台"
        "mycinemaeurope:4gtv-live157:My Cinema Europe HD 我的歐洲電影"
        "hxx2:litv-ftv17:好消息2台"
        "hxx:litv-ftv16:好消息"
        "dads:4gtv-4gtv007:大愛電視"
        "da2:4gtv-4gtv106:大愛二台"
        "rjws:4gtv-4gtv008:人間衛視"
        "bdgjxw:litv-ftv10:半島國際新聞台"
        "voamgzy:litv-ftv03:VOA美國之音"
        "cnbcasiacj:4gtv-4gtv030:CNBC Asia 財經台"
        "dwdgzs:4gtv-4gtv071:DW德國之聲"
        "vtv4:4gtv-4gtv108:VTV4"
        "cnnttxw:4gtv-live203:CNN頭條新聞台"
        "cnngjxw:4gtv-live204:CNN國際新聞台"
        "gh1:4gtv-4gtv084:國會頻道1"
        "gh2:4gtv-4gtv085:國會頻道2"
        "petclubtv:4gtv-live110:Pet Club TV"
        "tvbshd:4gtv-4gtv073:TVBS"
        "hitshd:4gtv-live620:HITS"
        "sbnqqcj:4gtv-4gtv060:sbn 全球财经台"
        "tvbshl:4gtv-4gtv068:TVBS 欢乐台"
        "liveabc:4gtv-live030:LiveABC 互動英語頻道"
        "arirang:4gtv-live202:阿里郎頻道"
    )

    other_chnls=(
        "disneyjr:迪士尼儿童频道(台湾)"
        "foxmovies:fox movies (台湾)"
        "amlh:澳门莲花"
    )

    providers=(
        "jiushi:就是 节目表"
        "niotv:niotv 节目表"
        "nowtv:nowtv 节目表"
        "icable:i-cable 节目表"
        "hbozw:hbo 中文 节目表"
        "hbous:hbo 美国 节目表"
        "ontvtonight:ontvtonight 节目表"
        "tvbhk:TVB 香港 节目表"
        "singteltv:singteltv 节目表"
        "cntv:cntv 节目表"
        "tvbs:tvbs 节目表"
        "astro:astro 节目表"
        "_4gtv:4gtv 节目表"
        "other:其它节目表"
    )

    if [ "${2:-}" == "4gtv" ] 
    then
        provider_id="_4gtv"
    elif [ "${2:-}" == "hbo" ] 
    then
        provider_id="hbozw"
    else
        provider_id=${2:-}
    fi

    if [ -n "${3:-}" ] 
    then
        # variable indirection
        var=("$provider_id"_chnls[@])
        if [[ -n ${!var:-} ]] 
        then
            provider_found=0
            for chnl in "${!var}"
            do
                chnl_id=${chnl%%@*}
                chnl_id=${chnl_id%%:*}
                if [ "$chnl_id" == "$3" ] 
                then
                    provider_found=1
                    unset "$provider_id"_chnls
                    IFS= read -r -a "$provider_id"_chnls <<< "$chnl"
                    break
                fi
            done
            [ "$provider_found" -eq 0 ] && Println "$error 没有找到频道\n" && exit 1
        fi
    fi

    user_agent="$USER_AGENT_BROWSER"

    case $provider_id in
        "jiushi")
            ScheduleJiushi
        ;;
        "niotv")
            ScheduleNiotv
        ;;
        "nowtv")
            ScheduleNowtv
        ;;
        "icable")
            ScheduleIcable
        ;;
        "hbo"|"hbozw")
            ScheduleHbozw
        ;;
        "hbous")
            ScheduleHbous "${4:-}"
        ;;
        "ontvtonight")
            ScheduleOntvtonight
        ;;
        "tvbhk")
            ScheduleTvbhk
        ;;
        "tvbhd")
            ScheduleTvbhd
        ;;
        "singteltv")
            ScheduleSingteltv
        ;;
        "cntv")
            ScheduleCntv
        ;;
        "tvbs")
            ScheduleTvbs
        ;;
        "astro")
            ScheduleAstro
        ;;
        "_4gtv")
            Schedule_4gtv
        ;;
        "other")
            ScheduleOther
        ;;
        "") 
            Println "节目表计划任务面板

  ${green}1.${normal} 查看频道
  ${green}2.${normal} 添加频道
  ${green}3.${normal} 删除频道
  ${green}4.${normal} 查看任务
  ${green}5.${normal} 执行任务
  ${green}6.${normal} 开启计划任务
  ${green}7.${normal} 关闭计划任务
  ${green}8.${normal} 备份任务
  ${green}9.${normal} 查看备份
 ${green}10.${normal} 修改备份
 ${green}11.${normal} 恢复备份
 ${green}12.${normal} 删除备份

"
            read -p "$i18n_default_cancel" cron_num
            [ -z "$cron_num" ] && Println "$i18n_canceled...\n" && exit 1

            case $cron_num in
                1) ScheduleView
                ;;
                2) ScheduleAdd
                ;;
                3) ScheduleDel
                ;;
                4) ScheduleViewCron
                ;;
                5) ScheduleExec
                ;;
                6) ScheduleEnableCron
                ;;
                7) ScheduleDisableCron
                ;;
                8) ScheduleBackup
                ;;
                9) ScheduleViewBackup
                ;;
                10) ScheduleEditBackup
                ;;
                11) ScheduleRestoreBackup
                ;;
                12) ScheduleDelBackup
                ;;
                *) Println "$i18n_canceled...\n" && exit 1
                ;;
            esac
        ;;
        "-")
            while IFS= read -r line 
            do
                if [[ $line == *"错误"* ]] 
                then
                    Println "错误: ${line#* }"
                fi
            done < <(ScheduleExec 2>> "$MONITOR_LOG")
        ;;
        *)
            for provider in "${providers[@]}"
            do
                provider_id=${provider%%:*}
                provider_name=${provider#*:}
                provider_chnls=("$provider_id"_chnls[@])
                schedule=""
                for provider_chnl in "${!provider_chnls}"
                do
                    if [ "$provider_id" == "ontvtonight" ] 
                    then
                        chnl_id=${provider_chnl%%@*}
                        chnl_name=${provider_chnl##@:}
                    else
                        chnl_id=${provider_chnl%%:*}
                        chnl_name=${provider_chnl##*:}
                    fi
                    if [ "$chnl_id" == "$2" ] 
                    then
                        unset "${provider_id}_chnls"
                        IFS="|" read -r -a "${provider_id}_chnls" <<< "${provider_chnl}|"
                        if [ "$provider_id" == "other" ] 
                        then
                            chnl_id_upper=$(tr '[:lower:]' '[:upper:]' <<< "${chnl_id:0:1}")"${chnl_id:1}"
                            Schedule"$chnl_id_upper" "${3:-}"
                        else
                            provider_id_upper=$(tr '[:lower:]' '[:upper:]' <<< "${provider_id:0:1}")"${provider_id:1}"
                            Schedule"$provider_id_upper" "${3:-}"
                        fi
                        break
                    fi
                done

                if [ -z "${schedule:-}" ] 
                then
                    Println "$error $provider_name 没有找到: $2"
                else
                    if [ -e "$IPTV_ROOT/vip.pid" ] 
                    then
                        printf '%s' "" > "$VIP_USERS_ROOT/epg.update"
                    fi
                    break
                fi
            done
        ;;
    esac
}

TsIsUnique()
{
    not_unique=$(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[unique_url]}?accounttype=${ts_array[acc_type_reg]}&username=$account" | $JQ_FILE '.ret')
    if [ "$not_unique" != 0 ] 
    then
        Println "$error 用户名已存在,请重新输入!"
    fi
}

TsImg()
{
    IMG_FILE="$IPTV_ROOT/ts_yzm.jpg"
    if [ -n "${ts_array[refresh_token_url]:-}" ] 
    then
        deviceno=$(< /proc/sys/kernel/random/uuid)
        str=$(printf '%s' "$deviceno" | md5sum)
        str=${str%% *}
        str=${str:7:1}
        deviceno="$deviceno$str"
        declare -A token_array
        while IFS="=" read -r key value
        do
            token_array[$key]="$value"
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" -X POST --data '{"role":"guest","deviceno":"'"$deviceno"'","deviceType":"yuj"}' "${ts_array[token_url]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

        if [ "${token_array[ret]}" -eq 0 ] 
        then
            declare -A refresh_token_array
            while IFS="=" read -r key value
            do
                refresh_token_array[$key]="$value"
            done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" -X POST --data '{"accessToken":"'"${token_array[accessToken]}"'","refreshToken":"'"${token_array[refreshToken]}"'"}' "${ts_array[refresh_token_url]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

            if [ "${refresh_token_array[ret]}" -eq 0 ] 
            then
                declare -A img_array
                while IFS="=" read -r key value
                do
                    img_array[$key]="$value"
                done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[img_url]}?accesstoken=${refresh_token_array[accessToken]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

                if [ "${img_array[ret]}" -eq 0 ] 
                then
                    picid=${img_array[picid]}
                    image=${img_array[image]}
                    refresh_img=0
                    base64 -d <<< "${image#*,}" > "$IMG_FILE"
                    /usr/local/bin/imgcat --half-height "$IMG_FILE"
                    rm -f "${IMG_FILE:-notfound}"
                    Println "$info 输入图片验证码: "
                    read -p "(默认: 刷新验证码): " pincode
                    [ -z "$pincode" ] && refresh_img=1
                    return 0
                fi
            fi
        fi
    else
        declare -A token_array
        while IFS="=" read -r key value
        do
            token_array[$key]="$value"
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" -X POST --data '{"usagescen":1}' "${ts_array[token_url]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

        if [ "${token_array[ret]}" -eq 0 ] 
        then
            declare -A img_array
            while IFS="=" read -r key value
            do
                img_array[$key]="$value"
            done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[img_url]}?accesstoken=${token_array[access_token]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

            if [ "${img_array[ret]}" -eq 0 ] 
            then
                picid=${img_array[picid]}
                image=${img_array[image]}
                refresh_img=0
                base64 -d <<< "${image#*,}" > "$IMG_FILE"
                /usr/local/bin/imgcat --half-height "$IMG_FILE"
                rm -f "${IMG_FILE:-notfound}"
                Println "$info 输入图片验证码: "
                read -p "(默认: 刷新验证码): " pincode
                [ -z "$pincode" ] && refresh_img=1
                return 0
            fi
        fi
    fi
}

InstallImgcat()
{
    echo
    AskIfContinue y "`gettext \"缺少 imgcat ,是否现在安装\"`"

    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    ReleaseCheck
    if [ "$release" == "rpm" ] 
    then
        yum -y install gcc gcc-c++ make ncurses-devel autoconf >/dev/null 2>&1
        echo -n "...50%..."
    else
        apt-get -y install debconf-utils libncurses5-dev autotools-dev autoconf >/dev/null 2>&1
        echo '* libraries/restart-without-asking boolean true' | debconf-set-selections
        apt-get -y install software-properties-common pkg-config build-essential >/dev/null 2>&1
        echo -n "...50%..."
    fi

    cd ~

    if [ ! -d ./imgcat-master ] 
    then
        wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/imgcat.zip" -qO imgcat.zip
        unzip imgcat.zip >/dev/null 2>&1
    fi

    cd ./imgcat-master
    rm -rf CImg
    wget --timeout=10 --tries=3 --no-check-certificate "$FFMPEG_MIRROR_LINK/CImg.zip" -qO CImg.zip
    unzip CImg.zip >/dev/null 2>&1
    mv CImg-master CImg
    ./configure >/dev/null 2>&1
    make >/dev/null 2>&1
    make install >/dev/null 2>&1
    kill $progress_pid
    trap - EXIT
    echo -n "...100%" && Println "$info imgcat 安装完成"
}

TsRegister()
{
    if [ ! -e "/usr/local/bin/imgcat" ] &&  [ -n "${ts_array[img_url]:-}" ]
    then
        InstallImgcat
    fi
    not_unique=1
    while [ "$not_unique" != 0 ] 
    do
        Println "$info 输入账号: "
        read -p "$i18n_default_cancel" account
        [ -z "$account" ] && Println "$i18n_canceled...\n" && exit 1
        if [ -z "${ts_array[unique_url]:-}" ] 
        then
            not_unique=0
        else
            TsIsUnique
        fi
    done

    Println "$info 输入密码: "
    read -p "$i18n_default_cancel" password
    [ -z "$password" ] && Println "$i18n_canceled...\n" && exit 1

    if [ -n "${ts_array[img_url]:-}" ] 
    then
        refresh_img=1
        while [ "$refresh_img" != 0 ] 
        do
            TsImg
            [ "$refresh_img" -eq 1 ] && continue

            if [ -n "${ts_array[sms_url]:-}" ] 
            then
                declare -A sms_array
                while IFS="=" read -r key value
                do
                    sms_array[$key]="$value"
                done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[sms_url]}?pincode=$pincode&picid=$picid&verifytype=3&account=$account&accounttype=1" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

                if [ "${sms_array[ret]}" -eq 0 ] 
                then
                    Println "$info 短信已发送!"
                    Println "$info 输入短信验证码: "
                    read -p "$i18n_default_cancel" smscode
                    [ -z "$smscode" ] && Println "$i18n_canceled...\n" && exit 1

                    declare -A verify_array
                    while IFS="=" read -r key value
                    do
                        verify_array[$key]="$value"
                    done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[verify_url]}?verifycode=$smscode&verifytype=3&username=$account&account=$account" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

                    if [ "${verify_array[ret]}" -eq 0 ] 
                    then
                        deviceno=$(< /proc/sys/kernel/random/uuid)
                        str=$(printf '%s' "$deviceno" | md5sum)
                        str=${str%% *}
                        str=${str:7:1}
                        deviceno="$deviceno$str"
                        devicetype="yuj"
                        md5_password=$(printf '%s' "$password" | md5sum)
                        md5_password=${md5_password%% *}
                        printf -v timestamp '%(%s)T' -1
                        timestamp=$((timestamp * 1000))
                        signature="$account|$md5_password|$deviceno|$devicetype|$timestamp"
                        signature=$(printf '%s' "$signature" | md5sum)
                        signature=${signature%% *}
                        declare -A reg_array
                        while IFS="=" read -r key value
                        do
                            reg_array[$key]="$value"
                        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" -X POST --data '{"account":"'"$account"'","deviceno":"'"$deviceno"'","devicetype":"'"$devicetype"'","code":"'"${verify_array[code]}"'","signature":"'"$signature"'","birthday":"1970-1-1","username":"'"$account"'","type":1,"timestamp":"'"$timestamp"'","pwd":"'"$md5_password"'","accounttype":"'"${ts_array[acc_type_reg]}"'"}' "${ts_array[reg_url]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

                        if [ "${reg_array[ret]}" -eq 0 ] 
                        then
                            echo
                            AskIfContinue n "`gettext \"注册成功 ,是否登录账号\"`"
                            TsLogin
                        else
                            Println "$error 注册失败!"
                            printf '%s\n' "${reg_array[@]}"
                        fi
                    fi

                else
                    if [ -z "${ts_array[unique_url]:-}" ] 
                    then
                        Println "$error 验证码或其它错误!请重新尝试!"
                    else
                        Println "$error 验证码错误!"
                    fi
                    #printf '%s\n' "${sms_array[@]}"
                    refresh_img=1
                fi
            fi
        done
    else
        md5_password=$(printf '%s' "$password" | md5sum)
        md5_password=${md5_password%% *}
        declare -A reg_array
        while IFS="=" read -r key value
        do
            reg_array[$key]="$value"
        done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[reg_url]}?username=$account&iconid=1&pwd=$md5_password&birthday=1970-1-1&type=1&accounttype=${ts_array[acc_type_reg]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

        if [ "${reg_array[ret]}" -eq 0 ] 
        then
            echo
            AskIfContinue n "`gettext \"注册成功 ,是否登录账号\"`"
            TsLogin
        else
            Println "$error 发生错误"
            printf '%s\n' "${sms_array[@]}"
        fi
    fi
}

TsLogin()
{
    if [ -z "${account:-}" ] 
    then
        Println "$info 输入账号: "
        read -p "$i18n_default_cancel" account
        [ -z "$account" ] && Println "$i18n_canceled...\n" && exit 1
    fi

    if [ -z "${password:-}" ] 
    then
        Println "$info 输入密码: "
        read -p "$i18n_default_cancel" password
        [ -z "$password" ] && Println "$i18n_canceled...\n" && exit 1
    fi

    deviceno=$(< /proc/sys/kernel/random/uuid)
    str=$(printf '%s' "$deviceno" | md5sum)
    str=${str%% *}
    str=${str:7:1}
    deviceno="$deviceno$str"
    md5_password=$(printf '%s' "$password" | md5sum)
    md5_password=${md5_password%% *}

    if [ -z "${ts_array[img_url]:-}" ] 
    then
        TOKEN_LINK="${ts_array[login_url]}?deviceno=$deviceno&devicetype=3&accounttype=${ts_array[acc_type_login]:-2}&accesstoken=(null)&account=$account&pwd=$md5_password&isforce=1&businessplatform=1"
        token=$(curl -s -Lm 10 -H "User-Agent: $user_agent" "$TOKEN_LINK")
    else
        printf -v timestamp '%(%s)T' -1
        timestamp=$((timestamp * 1000))
        signature="$deviceno|yuj|${ts_array[acc_type_login]}|$account|$timestamp"
        signature=$(printf '%s' "$signature" | md5sum)
        signature=${signature%% *}
        if [[ ${ts_array[extend_info]} == "{"*"}" ]] 
        then
            token=$(curl -X POST -s --data '{"account":"'"$account"'","deviceno":"'"$deviceno"'","pwd":"'"$md5_password"'","devicetype":"yuj","businessplatform":1,"signature":"'"$signature"'","isforce":1,"extendinfo":'"${ts_array[extend_info]}"',"timestamp":"'"$timestamp"'","accounttype":'"${ts_array[acc_type_login]}"'}' "${ts_array[login_url]}")
        else
            token=$(curl -X POST -s --data '{"account":"'"$account"'","deviceno":"'"$deviceno"'","pwd":"'"$md5_password"'","devicetype":"yuj","businessplatform":1,"signature":"'"$signature"'","isforce":1,"extendinfo":"'"${ts_array[extend_info]}"'","timestamp":"'"$timestamp"'","accounttype":'"${ts_array[acc_type_login]}"'}' "${ts_array[login_url]}")
        fi
    fi

    declare -A login_array
    while IFS="=" read -r key value
    do
        login_array[$key]="$value"
    done < <($JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]' <<< "$token")

    if [ -z "${login_array[access_token]:-}" ] 
    then
        Println "$error 账号错误"
        printf '%s\n' "${login_array[@]}"
        echo
        AskIfContinue n "`gettext \"是否注册账号\"`"
        TsRegister
    else
        while :; do
            Println "$info 输入需要转换的频道号码: "
            read -p "$i18n_default_cancel" programid
            [ -z "$programid" ] && Println "$i18n_canceled...\n" && exit 1
            [[ $programid =~ ^[0-9]{10}$ ]] || { Println "$error频道号码错误!"; continue; }
            break
        done

        if [ -n "${ts_array[auth_info_url]:-}" ] 
        then
            declare -A auth_info_array
            while IFS="=" read -r key value
            do
                auth_info_array[$key]="$value"
            done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[auth_info_url]}?accesstoken=${login_array[access_token]}&programid=$programid&playtype=live&protocol=hls&verifycode=${login_array[device_id]}" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

            if [ "${auth_info_array[ret]}" -eq 0 ] 
            then
                authtoken="ipanel123#%#&*(&(*#*&^*@#&*%()#*()$)#@&%(*@#()*%321ipanel${auth_info_array[auth_random_sn]}"
                authtoken=$(printf '%s' "$authtoken" | md5sum)
                authtoken=${authtoken%% *}
                playtoken=${auth_info_array[play_token]}

                declare -A auth_verify_array
                while IFS="=" read -r key value
                do
                    auth_verify_array[$key]="$value"
                done < <(curl -s -Lm 10 -H "User-Agent: $user_agent" "${ts_array[auth_verify_url]}?programid=$programid&playtype=live&protocol=hls&accesstoken=${login_array[access_token]}&verifycode=${login_array[device_id]}&authtoken=$authtoken" | $JQ_FILE -r 'to_entries | map("\(.key)=\(.value)") | .[]')

                if [ "${auth_verify_array[ret]}" -eq 0 ] 
                then
                    TS_LINK="${ts_array[play_url]}?playtype=live&protocol=http&accesstoken=${login_array[access_token]}&playtoken=$playtoken&verifycode=${login_array[device_id]}&rate=org&programid=$programid"
                else
                    Println "$error 发生错误"
                    printf '%s\n' "${auth_verify_array[@]}"
                    exit 1
                fi
            else
                Println "$error 发生错误"
                printf '%s\n' "${auth_info_array[@]}"
                exit 1
            fi
        else
            TS_LINK="${ts_array[play_url]}?playtype=live&protocol=http&accesstoken=${login_array[access_token]}&playtoken=ABCDEFGH&verifycode=${login_array[device_id]}&rate=org&programid=$programid"
        fi

        Println "$info ts链接: \n$TS_LINK"

        stream_link=$($JQ_FILE -r --arg a "programid=$programid" '[.channels[].stream_link] | map(select(test($a)))[0]' "$CHANNELS_FILE")
        if [ "${stream_link:-}" != null ]
        then
            echo
            AskIfContinue y "`gettext \"检测到此频道原有链接, 是否替换成新的ts链接\"`"

            JQ update "$CHANNELS_FILE" '(.channels[]|select(.stream_link=="'"$stream_link"'")|.stream_link)="'"$TS_LINK"'"'
            Println "$info 修改成功 !\n"
        fi
    fi
}

TsMenu()
{
    GetDefault

    user_agent="iPhone; CPU iPhone OS 13_6 like Mac OS X"
    echo
    inquirer list_input "是否使用默认频道文件: $DEFAULT_CHANNELS_LINK" yn_options use_default_channels_yn
    if [[ $use_default_channels_yn == "$i18n_yes" ]]
    then
        TS_CHANNELS_LINK=$DEFAULT_CHANNELS_LINK
    else
        if [ -n "$d_sync_file" ] && [[ -n $($JQ_FILE '.data[] | select(.reg_url != null)' "${d_sync_file%% *}") ]] 
        then
            echo
            inquirer list_input "是否使用本地频道文件? 本地路径: ${d_sync_file%% *}" yn_options use_local_channels_yn
            if [[ $use_local_channels_yn == [Yy] ]] 
            then
                TS_CHANNELS_FILE=${d_sync_file%% *}
            fi
        fi
        if [ -z "${TS_CHANNELS_FILE:-}" ]
        then
            Println "$info 请输入使用的频道文件链接或本地路径: \n"
            read -p "$i18n_default_cancel" TS_CHANNELS_LINK_OR_FILE
            [ -z "$TS_CHANNELS_LINK_OR_FILE" ] && Println "$i18n_canceled...\n" && exit 1
            if [[ $TS_CHANNELS_LINK_OR_FILE =~ ^https?:// ]] 
            then
                TS_CHANNELS_LINK=$TS_CHANNELS_LINK_OR_FILE
            else
                [ ! -e "$TS_CHANNELS_LINK_OR_FILE" ] && Println "文件不存在, $i18n_canceled...\n" && exit 1
                TS_CHANNELS_FILE=$TS_CHANNELS_LINK_OR_FILE
            fi
        fi
    fi

    if [ -z "${TS_CHANNELS_LINK:-}" ] 
    then
        ts_channels=$(< "$TS_CHANNELS_FILE")
    else
        ts_channels=$(curl -s -Lm 10 "$TS_CHANNELS_LINK")

        [ -z "$ts_channels" ] && Println "$error 无法连接文件地址, 请重试...\n" && exit 1
    fi

    ts_channels_desc=()
    while IFS='' read -r desc 
    do
        ts_channels_desc+=("$desc")
    done < <($JQ_FILE -r '.data[] | select(.reg_url != null) | .desc | @sh' <<< "$ts_channels")

    count=${#ts_channels_desc[@]}

    Println "$info 选择需要操作的直播源\n"
    for((i=0;i<count;i++));
    do
        desc=${ts_channels_desc[i]//\"/}
        desc=${desc//\'/}
        desc=${desc//\\/\'}
        echo -e "${green}$((i+1)).${normal}${indent_6}$desc"
    done

    while :; do
        echo && read -p "$i18n_default_cancel" channel_id
        [ -z "$channel_id" ] && Println "$i18n_canceled...\n" && exit 1
        [[ $channel_id =~ ^[0-9]+$ ]] || { Println "$error `gettext \"输入序号\"`!"; continue; }
        if ((channel_id >= 1 && channel_id <= count)); then
            ((channel_id--))
            declare -A ts_array
            while IFS="=" read -r key value
            do
                ts_array[$key]="$value"
            done < <($JQ_FILE -r '[.data[] | select(.reg_url != null)]['"$channel_id"'] | to_entries | map("\(.key)=\(.value)") | .[]' <<< "$ts_channels")

            if [ "${ts_array[name]}" == "jxtvnet" ] && ! nc -z -w 3 "access.jxtvnet.tv" 81 2> /dev/null
            then
                Println "$info 部分服务器无法连接此直播源, 但可以将ip写入 /etc/hosts 来连接, 请选择线路
  ${green}1.${normal} 电信
  ${green}2.${normal} 联通"
                read -p "$i18n_default_cancel" jxtvnet_lane
                case $jxtvnet_lane in
                    1) 
                        printf '%s\n' "59.63.205.33 access.jxtvnet.tv" >> "/etc/hosts"
                        printf '%s\n' "59.63.205.33 stream.slave.jxtvnet.tv" >> "/etc/hosts"
                        printf '%s\n' "59.63.205.33 slave.jxtvnet.tv" >> "/etc/hosts"
                    ;;
                    2) 
                        printf '%s\n' "110.52.240.146 access.jxtvnet.tv" >> "/etc/hosts"
                        printf '%s\n' "110.52.240.146 stream.slave.jxtvnet.tv" >> "/etc/hosts"
                        printf '%s\n' "110.52.240.146 slave.jxtvnet.tv" >> "/etc/hosts"
                    ;;
                    *) Println "$i18n_canceled...\n" && exit 1
                    ;;
                esac
            fi

            echo
            channel_act_options=( '登录以获取ts链接' '注册账号' )
            inquirer list_input "选择操作" channel_act_options channel_act
            if [[ $channel_act == "登录以获取ts链接" ]] 
            then
                TsLogin
            else
                TsRegister
            fi
            break
        else
            Println "$error序号错误, 请重新输入!"
        fi
    done
}

AntiDDoSSet()
{
    if [ -x "$(command -v ufw)" ] && [ -s "$nginx_prefix/logs/access.log" ] && ls -A $LIVE_ROOT/* > /dev/null 2>&1
    then
        sleep 1

        if ufw show added | grep -q "None" 
        then
            [ -x "$(command -v iptables)" ] && iptables -F
            Println "$info 添加常用 ufw 规则"
            ufw allow ssh > /dev/null 2>&1
            ufw allow http > /dev/null 2>&1
            ufw allow https > /dev/null 2>&1

            if ufw status | grep -q "inactive" 
            then
                current_port=${SSH_CLIENT##* }
                if [ "$current_port" != 22 ] 
                then
                    ufw allow "$current_port" > /dev/null 2>&1
                fi
                Println "$info 开启 ufw"
                ufw --force enable > /dev/null 2>&1
            fi
        fi

        GetDefault

        SetAntiDDosPort

        SetAntiDDosSynFlood

        SetAntiDDos

        if [ "$anti_ddos_syn_flood_yn" == "no" ] && [ "$anti_ddos_yn" == "no" ] 
        then
            if [ "$d_anti_ddos_syn_flood_yn" != "no" ] || [ "$d_anti_ddos_yn" != "no" ]
            then
                JQ update "$CHANNELS_FILE" '.default|=. * 
                {
                    anti_ddos_syn_flood: "no",
                    anti_ddos: "no"
                } // .'
            fi
            Println "不启动 AntiDDoS ...\n" && exit 0
        else
            anti_ddos_ports=${anti_ddos_port:-$d_anti_ddos_port}
            anti_ddos_ports=${anti_ddos_port%% *}
            JQ update "$CHANNELS_FILE" '.default|=. * 
            {
                anti_ddos_syn_flood: "'"${anti_ddos_syn_flood_yn:-$d_anti_ddos_syn_flood_yn}"'",
                anti_ddos_syn_flood_delay_seconds: '"${anti_ddos_syn_flood_delay_seconds:-$d_anti_ddos_syn_flood_delay_seconds}"',
                anti_ddos_syn_flood_seconds: '"${anti_ddos_syn_flood_seconds:-$d_anti_ddos_syn_flood_seconds}"',
                anti_ddos: "'"${anti_ddos_yn:-$d_anti_ddos_yn}"'",
                anti_ddos_port: "'"$anti_ddos_ports"'",
                anti_ddos_seconds: '"${anti_ddos_seconds:-$d_anti_ddos_seconds}"',
                anti_ddos_level: '"${anti_ddos_level:-$d_anti_ddos_level}"'
            } // .'
        fi
    else
        exit 0
    fi
}

AntiDDoS()
{
    trap '' HUP INT
    trap 'MonitorError $LINENO' ERR

    pid_file="$IPTV_ROOT/antiddos.pid"
    printf '%s' "$BASHPID" > "$pid_file"
    {
        flock -x 202
        {
            ips=()
            jail_time=()

            if [[ $d_anti_ddos_port == *","* ]] || [[ $d_anti_ddos_port =~ - ]] 
            then
                d_anti_ddos_port="$d_anti_ddos_port proto tcp"
            fi

            if [ -s "$IP_DENY" ]  
            then
                while IFS= read -r line
                do
                    if [[ $line == *:* ]] 
                    then
                        ip=${line%:*}
                        jail=${line#*:}
                        ips+=("$ip")
                        jail_time+=("$jail")
                    else
                        ip=$line
                        ufw delete deny from "$ip" to any port $d_anti_ddos_port > /dev/null 2>> "$IP_LOG"
                    fi
                done < "$IP_DENY"

                if [ -n "${ips:-}" ] 
                then
                    new_ips=()
                    new_jail_time=()
                    printf -v now '%(%s)T' -1

                    update=0
                    for((i=0;i<${#ips[@]};i++));
                    do
                        if [ "$now" -gt "${jail_time[i]}" ] 
                        then
                            ufw delete deny from "${ips[i]}" to any port $d_anti_ddos_port > /dev/null 2>> "$IP_LOG"
                            update=1
                        else
                            new_ips+=("${ips[i]}")
                            new_jail_time+=("${jail_time[i]}")
                        fi
                    done

                    if [ "$update" -eq 1 ] 
                    then
                        ips=("${new_ips[@]}")
                        jail_time=("${new_jail_time[@]}")

                        printf '%s' "" > "$IP_DENY"

                        for((i=0;i<${#ips[@]};i++));
                        do
                            printf '%s\n' "${ips[i]}:${jail_time[i]}" >> "$IP_DENY"
                        done
                    fi
                else
                    printf '%s' "" > "$IP_DENY"
                fi
            fi

            printf '%s\n' "$date_now AntiDDoS 启动成功 PID $BASHPID !" >> "$MONITOR_LOG"

            current_ip=${SSH_CLIENT%% *}
            [ -n "${anti_ddos_level:-}" ] && ((anti_ddos_level++))
            monitor=1
            while true
            do
                if [ "$anti_ddos_syn_flood_yn" == "yes" ] 
                then
                    anti_ddos_syn_flood_ips=()
                    while IFS= read -r anti_ddos_syn_flood_ip 
                    do
                        anti_ddos_syn_flood_ips+=("$anti_ddos_syn_flood_ip")
                    done < <(ss -taH|awk '{gsub(/.*:/, "", $4);gsub(/:.*/, "", $5); if ($1 == "SYN-RECV" && $5 != "'"$current_ip"'" && ('"$anti_ddos_ports_command$anti_ddos_ports_range_command"')) print $5}')

                    PrepTerm
                    sleep "$anti_ddos_syn_flood_delay_seconds" &
                    WaitTerm

                    printf -v now '%(%s)T' -1
                    jail=$((now + anti_ddos_syn_flood_seconds))

                    while IFS= read -r anti_ddos_syn_flood_ip 
                    do
                        to_ban=1
                        for banned_ip in ${ips[@]+"${ips[@]}"}
                        do
                            if [ "$banned_ip" == "$anti_ddos_syn_flood_ip/24" ] 
                            then
                                to_ban=0
                                break 1
                            fi
                        done

                        if [ "$to_ban" -eq 1 ] 
                        then
                            for ip in ${anti_ddos_syn_flood_ips[@]+"${anti_ddos_syn_flood_ips[@]}"}
                            do
                                if [ "$ip" == "$anti_ddos_syn_flood_ip" ] 
                                then
                                    ip="$ip/24"
                                    jail_time+=("$jail")
                                    printf '%s\n' "$ip:$jail" >> "$IP_DENY"
                                    ufw insert 1 deny from "$ip" to any port $anti_ddos_port > /dev/null 2>> "$IP_LOG"
                                    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                    printf '%s\n' "$date_now $ip 已被禁" >> "$IP_LOG"
                                    ips+=("$ip")
                                    break 1
                                fi
                            done
                        fi
                    done < <(ss -taH|awk '{gsub(/.*:/, "", $4);gsub(/:.*/, "", $5); if ($1 == "SYN-RECV" && $5 != "'"$current_ip"'" && ('"$anti_ddos_ports_command$anti_ddos_ports_range_command"')) print $5}')
                fi

                if [ "$anti_ddos_yn" == "yes" ] 
                then
                    chnls_count=0
                    chnls_output_dir_name=()
                    chnls_seg_length=()
                    chnls_seg_count=()
                    while IFS="=" read -r map_seg_length map_seg_count map_output_dir_name
                    do
                        chnls_count=$((chnls_count+1))
                        map_seg_length=${map_seg_length#\"}
                        map_output_dir_name=${map_output_dir_name%\"}

                        chnls_output_dir_name+=("$map_output_dir_name")
                        chnls_seg_length+=("$map_seg_length")
                        chnls_seg_count+=("$map_seg_count")
                    done < <($JQ_FILE '.channels[] | [.seg_length,.seg_count,.output_dir_name] | join("=")' "$CHANNELS_FILE")

                    output_dir_names=()
                    triggers=()
                    for output_dir_root in "$LIVE_ROOT"/*
                    do
                        output_dir_name=${output_dir_root#*$LIVE_ROOT/}

                        for((i=0;i<chnls_count;i++));
                        do
                            if [ "$output_dir_name" == "${chnls_output_dir_name[i]}" ] 
                            then
                                chnl_seg_count=${chnls_seg_count[i]}
                                if [ "$chnl_seg_count" != 0 ] 
                                then
                                    chnl_seg_length=${chnls_seg_length[i]}
                                    trigger=$(( 60 * anti_ddos_level / (chnl_seg_length * chnl_seg_count) ))
                                    if [ "$trigger" -eq 0 ] 
                                    then
                                        trigger=1
                                    fi
                                    output_dir_names+=("$output_dir_name")
                                    triggers+=("$trigger")
                                fi
                            fi
                        done
                    done

                    printf -v now '%(%s)T' -1
                    jail=$((now + anti_ddos_seconds))

                    while IFS=' ' read -r counts ip access_file
                    do
                        if [[ $access_file == *".ts" ]] 
                        then
                            seg_name=${access_file##*/}
                            access_file=${access_file%/*}
                            dir_name=${access_file##*/}
                            access_file=${access_file%/*}
                            to_ban=0

                            if [ -e "$LIVE_ROOT/$dir_name/$seg_name" ] 
                            then
                                output_dir_name=$dir_name
                                to_ban=1
                            elif [ -e "$LIVE_ROOT/${access_file##*/}/$dir_name/$seg_name" ] 
                            then
                                output_dir_name=${access_file##*/}
                                to_ban=1
                            fi

                            for banned_ip in ${ips[@]+"${ips[@]}"}
                            do
                                if [ "$banned_ip" == "$ip" ] 
                                then
                                    to_ban=0
                                    break 1
                                fi
                            done

                            if [ "$to_ban" -eq 1 ] 
                            then
                                for((i=0;i<${#output_dir_names[@]};i++));
                                do
                                    if [ "${output_dir_names[i]}" == "$output_dir_name" ] && [ "$counts" -gt "${triggers[i]}" ]
                                    then
                                        jail_time+=("$jail")
                                        printf '%s\n' "$ip:$jail" >> "$IP_DENY"
                                        ufw insert 1 deny from "$ip" to any port $anti_ddos_port > /dev/null 2>> "$IP_LOG"
                                        printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                        printf '%s\n' "$date_now $ip 已被禁" >> "$IP_LOG"
                                        ips+=("$ip")
                                        break 1
                                    fi
                                done
                            fi
                        fi
                    done < <(awk -v d1="$(printf '%(%d/%b/%Y:%H:%M:%S)T' $((now-60)))" '{gsub(/^[\[\t]+/, "", $4); if ( $4 > d1 ) print $1,$7;}' "$nginx_prefix"/logs/access.log | sort | uniq -c | sort -k1 -nr)
                    # date --date '-1 min' '+%d/%b/%Y:%T'
                    # awk -v d1="$(printf '%(%d/%b/%Y:%H:%M:%S)T' $((now-60)))" '{gsub(/^[\[\t]+/, "", $4); if ($7 ~ "'"$link"'" && $4 > d1 ) print $1;}' "$nginx_prefix"/logs/access.log | sort | uniq -c | sort -fr
                fi

                PrepTerm
                sleep 10 &
                WaitTerm

                if [ -n "${ips:-}" ] 
                then
                    new_ips=()
                    new_jail_time=()
                    printf -v now '%(%s)T' -1

                    update=0
                    for((i=0;i<${#ips[@]};i++));
                    do
                        if [ "$now" -gt "${jail_time[i]}" ] 
                        then
                            ufw delete deny from "${ips[i]}" to any port $anti_ddos_port > /dev/null 2>> "$IP_LOG"
                            update=1
                        else
                            new_ips+=("${ips[i]}")
                            new_jail_time+=("${jail_time[i]}")
                        fi
                    done

                    if [ "$update" -eq 1 ] 
                    then
                        ips=("${new_ips[@]}")
                        jail_time=("${new_jail_time[@]}")

                        printf '%s' "" > "$IP_DENY"

                        for((i=0;i<${#ips[@]};i++));
                        do
                            printf '%s\n' "${ips[i]}:${jail_time[i]}" >> "$IP_DENY"
                        done
                    fi
                fi
            done
        } 202>&-
    } 202<"$pid_file"
}

MonitorHlsRestartSuccess()
{
    if [ -n "${failed_restart_nums:-}" ] 
    then
        declare -a new_array
        for element in ${hls_failed[@]+"${hls_failed[@]}"}
        do
            [ "$element" != "$output_dir_name" ] && new_array+=("$element")
        done
        if [ -z "${new_array:-}" ] 
        then
            hls_failed=()
        else
            hls_failed=("${new_array[@]}")
        fi
        unset new_array

        declare -a new_array
        for element in ${hls_recheck_time[@]+"${hls_recheck_time[@]}"}
        do
            [ "$element" != "${hls_recheck_time[failed_i]}" ] && new_array+=("$element")
        done
        if [ -z "${new_array:-}" ] 
        then
            hls_recheck_time=()
        else
            hls_recheck_time=("${new_array[@]}")
        fi
        unset new_array
    fi
    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
    printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
}

MonitorHlsRestartFail()
{
    StopChannel
    printf -v now '%(%s)T' -1
    recheck_time=$((now+recheck_period))

    if [ -n "${failed_restart_nums:-}" ] 
    then
        hls_recheck_time[failed_i]=$recheck_time
    else
        hls_recheck_time+=("$recheck_time")
        hls_failed+=("$output_dir_name")
    fi

    declare -a new_array
    for element in "${monitor_dir_names_chosen[@]}"
    do
        [ "$element" != "$output_dir_name" ] && new_array+=("$element")
    done
    if [ -z "${new_array:-}" ] 
    then
        monitor_dir_names_chosen=()
    else
        monitor_dir_names_chosen=("${new_array[@]}")
    fi
    unset new_array

    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
    printf '%s\n' "$date_now $chnl_channel_name 重启失败" >> "$MONITOR_LOG"
}

MonitorHlsRestartChannel()
{
    XtreamCodesGetChnls
    domains_tried=()
    hls_restart_nums=${hls_restart_nums:-20}
    unset failed_restart_nums

    for((failed_i=0;failed_i<${#hls_failed[@]};failed_i++));
    do
        if [ "${hls_failed[failed_i]}" == "$output_dir_name" ] 
        then
            failed_restart_nums=3
            break
        fi
    done

    restart_nums=${failed_restart_nums:-$hls_restart_nums}

    IFS=" " read -ra chnl_stream_links_arr <<< "$chnl_stream_links"

    if [ "${#chnl_stream_links_arr[@]}" -gt $restart_nums ] 
    then
        restart_nums=${#chnl_stream_links_arr[@]}
    fi

    for((restart_i=0;restart_i<restart_nums;restart_i++))
    do
        if [ "$restart_i" -gt 0 ] && [[ $chnl_stream_links == *" "* ]] 
        then
            chnl_stream_links="${chnl_stream_links#* } $chnl_stream_link"
            chnl_stream_link=${chnl_stream_links%% *}
        fi

        chnl_mac=""
        if [[ ${chnl_stream_link##*|} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
        then
            chnl_domain=${chnl_stream_link%%|*}
            chnl_mac=${chnl_stream_link##*|}
            chnl_cmd=${chnl_stream_link%|*}
            chnl_cmd=${chnl_cmd##*|}

            chnl_cmd=${chnl_cmd%\_}
            chnl_cmd="http://localhost/ch/${chnl_cmd##*/}_"

            to_try=0
            for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
            do
                if [ "$xc_domain" == "$chnl_domain" ] 
                then
                    to_try=1
                    for domain in ${domains_tried[@]+"${domains_tried[@]}"}
                    do
                        if [ "$domain" == "$chnl_domain" ] 
                        then
                            to_try=0
                            break
                        fi
                    done
                    break
                fi
            done

            xc_chnl_found=0
            if [ "$to_try" -eq 1 ] 
            then
                for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                do
                    if [ "$xc_chnl_mac" == "$chnl_domain/$chnl_mac" ] 
                    then
                        xc_chnl_found=1
                        break
                    fi
                done
            fi

            if [ "$xc_chnl_found" -eq 1 ]
            then
                domains_tried+=("$chnl_domain")
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 1 ] 
                then
                    MonitorHlsRestartSuccess
                    break
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorHlsRestartFail
                    break
                else
                    continue
                fi
            fi

            if [ -n "${chnl_xc_proxy:-}" ] 
            then
                server=${chnl_xc_proxy%\/}
                xc_host_header=( -H "xc_host: $chnl_domain" )
            else
                server="http://$chnl_domain"
                xc_host_header=()
            fi

            access_token=""
            profile=""
            chnl_user_agent="$USER_AGENT_TV"
            mac=$(UrlencodeUpper "$chnl_mac")
            timezone=$(UrlencodeUpper "Europe/Amsterdam")
            chnl_cookies="mac=$mac; stb_lang=en; timezone=$timezone"
            token_url="$server/portal.php?type=stb&action=handshake"
            profile_url="$server/portal.php?type=stb&action=get_profile"
            genres_url="$server/portal.php?type=itv&action=get_genres"

            access_token=$(curl -s -Lm 10 -H "User-Agent: $chnl_user_agent" \
                ${xc_host_header[@]+"${xc_host_header[@]}"} \
                --cookie "$chnl_cookies" "$token_url" \
                | $JQ_FILE -r '.js.token') || true
            if [ -z "$access_token" ] 
            then
                if [ "$to_try" -eq 1 ] 
                then
                    domains_tried+=("$chnl_domain")
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 1 ] 
                    then
                        MonitorHlsRestartSuccess
                        break
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorHlsRestartFail
                        break
                    else
                        continue
                    fi
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorHlsRestartFail
                    break
                else
                    continue
                fi
            fi
            chnl_headers="Authorization: Bearer $access_token\r\n"
            printf -v chnl_headers_command '%b' "$chnl_headers"
            profile=$(curl -s -Lm 10 \
                -H "User-Agent: $chnl_user_agent" \
                ${xc_host_header[@]+"${xc_host_header[@]}"} \
                -H "${chnl_headers:0:-4}" \
                --cookie "$chnl_cookies" "$profile_url") || true
            if [ -z "$profile" ] 
            then
                if [ "$to_try" -eq 1 ] 
                then
                    domains_tried+=("$chnl_domain")
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 1 ] 
                    then
                        MonitorHlsRestartSuccess
                        break
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorHlsRestartFail
                        break
                    else
                        continue
                    fi
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorHlsRestartFail
                    break
                else
                    continue
                fi
            fi

            if [[ $($JQ_FILE -r '.js.id' <<< "$profile") == null ]] 
            then
                if [ "$to_try" -eq 1 ] 
                then
                    domains_tried+=("$chnl_domain")
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 1 ] 
                    then
                        MonitorHlsRestartSuccess
                        break
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorHlsRestartFail
                        break
                    else
                        continue
                    fi
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorHlsRestartFail
                    break
                else
                    continue
                fi
            else
                if [ -n "$chnl_xc_proxy" ] 
                then
                    server=${chnl_xc_proxy%\/}
                    chnl_stream_link=$(curl -k -s -o /dev/null -w '%{redirect_url}' "$server" \
                        ${xc_host_header[@]+"${xc_host_header[@]}"} \
                        -H "User-Agent: $chnl_user_agent" \
                        -H "${chnl_headers:0:-4}" \
                        -H "cmd: $chnl_cmd" \
                        --cookie "$chnl_cookies")
                    if [[ ! $chnl_stream_link =~ ([^/]+)//([^/]+)/(.+) ]] 
                    then
                        if [ "$to_try" -eq 1 ] 
                        then
                            domains_tried+=("$chnl_domain")
                            try_success=0
                            MonitorTryAccounts
                            if [ "$try_success" -eq 1 ] 
                            then
                                MonitorHlsRestartSuccess
                                break
                            elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                            then
                                MonitorHlsRestartFail
                                break
                            else
                                continue
                            fi
                        elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                        then
                            MonitorHlsRestartFail
                            break
                        else
                            continue
                        fi
                    fi
                else
                    create_link_url="$server/portal.php?type=itv&action=create_link&cmd=$chnl_cmd&series=&forced_storage=undefined&disable_ad=0&download=0"
                    cmd=$(curl -s -Lm 10 \
                        -H "User-Agent: $chnl_user_agent" \
                        ${xc_host_header[@]+"${xc_host_header[@]}"} \
                        -H "${chnl_headers:0:-4}" \
                        --cookie "$chnl_cookies" "$create_link_url" \
                        | $JQ_FILE -r '.js.cmd') || true

                    if [[ ${cmd#* } =~ ([^/]+)//([^/]+)/live/([^/]+)/([^/]+)/([^/]+) ]] 
                    then
                        chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/live/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                    elif [[ ${cmd#* } =~ ([^/]+)//([^/]+)/([^/]+)/([^/]+)/([^/]+) ]] 
                    then
                        chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                    else
                        if [ "$to_try" -eq 1 ] 
                        then
                            domains_tried+=("$chnl_domain")
                            try_success=0
                            MonitorTryAccounts
                            if [ "$try_success" -eq 1 ] 
                            then
                                MonitorHlsRestartSuccess
                                break
                            elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                            then
                                MonitorHlsRestartFail
                                break
                            else
                                continue
                            fi
                        elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                        then
                            MonitorHlsRestartFail
                            break
                        else
                            continue
                        fi
                    fi
                fi

                if [[ $chnl_stream_links == *" "* ]] 
                then
                    chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac ${chnl_stream_links#* }"
                else
                    chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac"
                fi
            fi
        else
            to_try=0
            if [[ $chnl_stream_link =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]] 
            then
                chnl_domain=${BASH_REMATCH[1]}

                for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
                do
                    if [ "$xc_domain" == "$chnl_domain" ] 
                    then
                        to_try=1
                        for domain in ${domains_tried[@]+"${domains_tried[@]}"}
                        do
                            if [ "$domain" == "$chnl_domain" ] 
                            then
                                to_try=0
                                break
                            fi
                        done
                        break
                    fi
                done
            fi

            xc_chnl_found=0
            if [ "$to_try" -eq 1 ] 
            then
                if [ "${BASH_REMATCH[2]}" == "live" ] && [[ $chnl_stream_link =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]]
                then
                    chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
                else
                    chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
                fi
                for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
                do
                    if [ "$xc_chnl" == "$chnl_domain/$chnl_account" ] 
                    then
                        xc_chnl_found=1
                        break
                    fi
                done
            fi

            if [ "$xc_chnl_found" -eq 1 ]
            then
                domains_tried+=("$chnl_domain")
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 1 ] 
                then
                    MonitorHlsRestartSuccess
                    break
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorHlsRestartFail
                    break
                else
                    continue
                fi
            fi
        fi

        action="skip"
        StopChannel
        if [ "$anti_leech_yn" == "yes" ] && [ "$anti_leech_restart_hls_changes_yn" == "yes" ] 
        then
            chnl_playlist_name=$(RandStr)
            chnl_seg_name=$chnl_playlist_name
            if [ "$chnl_encrypt_yn" == "yes" ] 
            then
                mkdir -p "$chnl_output_dir_root"
                chnl_key_name=$(RandStr)
                openssl rand 16 > "$chnl_output_dir_root/$chnl_key_name.key"
                if [ "$chnl_encrypt_session_yn" == "yes" ] 
                then
                    echo -e "/keys?key=$chnl_key_name&channel=$chnl_output_dir_name\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                else
                    echo -e "$chnl_key_name.key\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                fi
            fi
        fi

        StartChannel
        sleep $((15+chnl_seg_length))
        GetChannel

        if ls -A "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts > /dev/null 2>&1 
        then
            skip_check_stream=0
            if [ "$chnl_encrypt_yn" == "yes" ] 
            then
                if [ -e "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo" ] && \
                [ -e "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key" ] && \
                iv_hex=$(awk 'NR==3{print}' "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo") && \
                encrypt_key=$(hexdump -e '16/1 "%02x"' < "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key")
                then
                    encrypt_command="-key $encrypt_key -iv $iv_hex"
                else
                    skip_check_stream=1
                fi
                # xxd -p $KEY_FILE
            else
                encrypt_command=""
            fi

            if [ "$skip_check_stream" -eq 0 ] 
            then
                audio=0
                video=0
                video_bitrate=0
                bitrate_check=0

                f_count=1
                for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                do
                    ((f_count++))
                done

                f_num=$((f_count/2))
                f_count=1

                for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                do
                    if [ "$f_count" -lt "$f_num" ] 
                    then
                        ((f_count++))
                        continue
                    fi
                    [ -n "$encrypt_command" ] && f="crypto:$f"
                    while IFS= read -r line 
                    do
                        if [[ $line == *"codec_type=video"* ]] 
                        then
                            video=1
                        elif [ "$bitrate_check" -eq 0 ] && [ "$video" -eq 1 ] && [[ $line == *"bit_rate="* ]] 
                        then
                            line=${line#*bit_rate=}
                            video_bitrate=${line//N\/A/$hls_min_bitrates}
                            bitrate_check=1
                        elif [[ $line == *"codec_type=audio"* ]] 
                        then
                            audio=1
                        elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                        then
                            audio=0
                        fi
                    done < <($FFPROBE $encrypt_command -i "$f" -show_streams -loglevel quiet)
                    break
                done

                if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ] && [[ $video_bitrate -ge $hls_min_bitrates ]]
                then
                    MonitorHlsRestartSuccess
                    break
                fi
            fi
        fi

        if [ "$to_try" -eq 1 ] 
        then
            domains_tried+=("$chnl_domain")
            try_success=0
            MonitorTryAccounts
            if [ "$try_success" -eq 1 ] 
            then
                MonitorHlsRestartSuccess
                break
            fi
        fi

        if [[ $restart_i -eq $((restart_nums - 1)) ]] 
        then
            MonitorHlsRestartFail
            break
        fi
    done
}

MonitorFlvRestartSuccess()
{
    if [ -n "${failed_restart_nums:-}" ] 
    then
        declare -a new_array
        for element in ${flv_failed[@]+"${flv_failed[@]}"}
        do
            [ "$element" != "$flv_num" ] && new_array+=("$element")
        done
        if [ -z "${new_array:-}" ] 
        then
            flv_failed=()
        else
            flv_failed=("${new_array[@]}")
        fi
        unset new_array

        declare -a new_array
        for element in ${flv_recheck_time[@]+"${flv_recheck_time[@]}"}
        do
            [ "$element" != "${flv_recheck_time[failed_i]}" ] && new_array+=("$element")
        done
        if [ -z "${new_array:-}" ] 
        then
            flv_recheck_time=()
        else
            flv_recheck_time=("${new_array[@]}")
        fi
        unset new_array
    fi
    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
    printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
}

MonitorFlvRestartFail()
{
    StopChannel
    printf -v now '%(%s)T' -1
    recheck_time=$((now+recheck_period))

    if [ -n "${failed_restart_nums:-}" ] 
    then
        flv_recheck_time[failed_i]=$recheck_time
    else
        flv_recheck_time+=("$recheck_time")
        flv_failed+=("$flv_num")
    fi

    declare -a new_array
    for element in "${flv_nums_arr[@]}"
    do
        [ "$element" != "$flv_num" ] && new_array+=("$element")
    done
    if [ -z "${new_array:-}" ] 
    then
        flv_nums_arr=()
    else
        flv_nums_arr=("${new_array[@]}")
    fi
    unset new_array

    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
    printf '%s\n' "$date_now $chnl_channel_name FLV 重启超过${flv_restart_nums:-20}次关闭" >> "$MONITOR_LOG"
}

MonitorFlvRestartChannel()
{
    XtreamCodesGetChnls
    domains_tried=()
    flv_restart_nums=${flv_restart_nums:-20}
    unset failed_restart_nums

    for((failed_i=0;failed_i<${#flv_failed[@]};failed_i++));
    do
        if [ "${flv_failed[failed_i]}" == "$flv_num" ] 
        then
            failed_restart_nums=3
            break
        fi
    done

    restart_nums=${failed_restart_nums:-$flv_restart_nums}

    IFS=" " read -ra chnl_stream_links_arr <<< "$chnl_stream_links"

    if [ "${#chnl_stream_links_arr[@]}" -gt $restart_nums ] 
    then
        restart_nums=${#chnl_stream_links_arr[@]}
    fi

    for((restart_i=0;restart_i<restart_nums;restart_i++))
    do
        if [ "$restart_i" -gt 0 ] && [[ ${#chnl_stream_links_arr[@]} -gt 1 ]] 
        then
            chnl_stream_links="${chnl_stream_links#* } $chnl_stream_link"
            chnl_stream_link=${chnl_stream_links%% *}
        fi

        chnl_mac=""
        if [[ ${chnl_stream_link##*|} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
        then
            chnl_domain=${chnl_stream_link%%|*}
            chnl_mac=${chnl_stream_link##*|}
            chnl_cmd=${chnl_stream_link%|*}
            chnl_cmd=${chnl_cmd##*|}

            chnl_cmd=${chnl_cmd%\_}
            chnl_cmd="http://localhost/ch/${chnl_cmd##*/}_"

            to_try=0
            for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
            do
                if [ "$xc_domain" == "$chnl_domain" ] 
                then
                    to_try=1
                    for domain in ${domains_tried[@]+"${domains_tried[@]}"}
                    do
                        if [ "$domain" == "$chnl_domain" ] 
                        then
                            to_try=0
                            break
                        fi
                    done
                    break
                fi
            done

            xc_chnl_found=0
            if [ "$to_try" -eq 1 ] 
            then
                for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                do
                    if [ "$xc_chnl_mac" == "$chnl_domain/$chnl_mac" ] 
                    then
                        xc_chnl_found=1
                        break
                    fi
                done
            fi

            if [ "$xc_chnl_found" -eq 1 ] 
            then
                domains_tried+=("$chnl_domain")
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 1 ] 
                then
                    MonitorFlvRestartSuccess
                    break
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorFlvRestartFail
                    break
                else
                    continue
                fi
            fi

            if [ -n "${chnl_xc_proxy:-}" ] 
            then
                server=${chnl_xc_proxy%\/}
                xc_host_header=( -H "xc_host: $chnl_domain" )
            else
                server="http://$chnl_domain"
                xc_host_header=()
            fi

            access_token=""
            profile=""
            chnl_user_agent="$USER_AGENT_TV"
            mac=$(UrlencodeUpper "$chnl_mac")
            timezone=$(UrlencodeUpper "Europe/Amsterdam")
            chnl_cookies="mac=$mac; stb_lang=en; timezone=$timezone"
            token_url="$server/portal.php?type=stb&action=handshake"
            profile_url="$server/portal.php?type=stb&action=get_profile"
            genres_url="$server/portal.php?type=itv&action=get_genres"

            access_token=$(curl -s -Lm 10 \
                -H "User-Agent: $chnl_user_agent" \
                ${xc_host_header[@]+"${xc_host_header[@]}"} \
                --cookie "$chnl_cookies" "$token_url" \
                | $JQ_FILE -r '.js.token') || true
            if [ -z "$access_token" ] 
            then
                if [ "$to_try" -eq 1 ] 
                then
                    domains_tried+=("$chnl_domain")
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 1 ] 
                    then
                        MonitorFlvRestartSuccess
                        break
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorFlvRestartFail
                        break
                    else
                        continue
                    fi
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorFlvRestartFail
                    break
                else
                    continue
                fi
            fi
            chnl_headers="Authorization: Bearer $access_token\r\n"
            printf -v chnl_headers_command '%b' "$chnl_headers"
            profile=$(curl -s -Lm 10 \
                -H "User-Agent: $chnl_user_agent" \
                ${xc_host_header[@]+"${xc_host_header[@]}"} \
                -H "${chnl_headers:0:-4}" \
                --cookie "$chnl_cookies" "$profile_url") || true
            if [ -z "$profile" ] 
            then
                if [ "$to_try" -eq 1 ] 
                then
                    domains_tried+=("$chnl_domain")
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 1 ] 
                    then
                        MonitorFlvRestartSuccess
                        break
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorFlvRestartFail
                        break
                    else
                        continue
                    fi
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorFlvRestartFail
                    break
                else
                    continue
                fi
            fi

            if [[ $($JQ_FILE -r '.js.id' <<< "$profile") == null ]] 
            then
                if [ "$to_try" -eq 1 ] 
                then
                    domains_tried+=("$chnl_domain")
                    try_success=0
                    MonitorTryAccounts
                    if [ "$try_success" -eq 1 ] 
                    then
                        MonitorFlvRestartSuccess
                        break
                    elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                    then
                        MonitorFlvRestartFail
                        break
                    else
                        continue
                    fi
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorFlvRestartFail
                    break
                else
                    continue
                fi
            else
                if [ -n "$chnl_xc_proxy" ] 
                then
                    server=${chnl_xc_proxy%\/}
                    chnl_stream_link=$(curl -k -s -o /dev/null -w '%{redirect_url}' "$server" \
                        ${xc_host_header[@]+"${xc_host_header[@]}"} \
                        -H "User-Agent: $chnl_user_agent" \
                        -H "${chnl_headers:0:-4}" \
                        -H "cmd: $chnl_cmd" \
                        --cookie "$chnl_cookies")
                    if [[ ! $chnl_stream_link =~ ([^/]+)//([^/]+)/(.+) ]] 
                    then
                        if [ "$to_try" -eq 1 ] 
                        then
                            domains_tried+=("$chnl_domain")
                            try_success=0
                            MonitorTryAccounts
                            if [ "$try_success" -eq 1 ] 
                            then
                                MonitorFlvRestartSuccess
                                break
                            elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                            then
                                MonitorFlvRestartFail
                                break
                            else
                                continue
                            fi
                        elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                        then
                            MonitorFlvRestartFail
                            break
                        else
                            continue
                        fi
                    fi
                else
                    create_link_url="$server/portal.php?type=itv&action=create_link&cmd=$chnl_cmd&series=&forced_storage=undefined&disable_ad=0&download=0"
                    cmd=$(curl -s -Lm 10 \
                        -H "User-Agent: $chnl_user_agent" \
                        ${xc_host_header[@]+"${xc_host_header[@]}"} \
                        -H "${chnl_headers:0:-4}" \
                        --cookie "$chnl_cookies" "$create_link_url" \
                        | $JQ_FILE -r '.js.cmd') || true

                    if [[ ${cmd#* } =~ ([^/]+)//([^/]+)/live/([^/]+)/([^/]+)/([^/]+) ]] 
                    then
                        chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/live/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                    elif [[ ${cmd#* } =~ ([^/]+)//([^/]+)/([^/]+)/([^/]+)/([^/]+) ]] 
                    then
                        chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                    else
                        if [ "$to_try" -eq 1 ] 
                        then
                            domains_tried+=("$chnl_domain")
                            try_success=0
                            MonitorTryAccounts
                            if [ "$try_success" -eq 1 ] 
                            then
                                MonitorFlvRestartSuccess
                                break
                            elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                            then
                                MonitorFlvRestartFail
                                break
                            else
                                continue
                            fi
                        elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                        then
                            MonitorFlvRestartFail
                            break
                        else
                            continue
                        fi
                    fi
                fi

                if [[ $chnl_stream_links == *" "* ]] 
                then
                    chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac ${chnl_stream_links#* }"
                else
                    chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$chnl_mac"
                fi
            fi
        else
            to_try=0
            if [[ $chnl_stream_link =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]] 
            then
                chnl_domain=${BASH_REMATCH[1]}

                for xc_domain in ${xtream_codes_domains[@]+"${xtream_codes_domains[@]}"}
                do
                    if [ "$xc_domain" == "$chnl_domain" ] 
                    then
                        to_try=1
                        for domain in ${domains_tried[@]+"${domains_tried[@]}"}
                        do
                            if [ "$domain" == "$chnl_domain" ] 
                            then
                                to_try=0
                                break
                            fi
                        done
                        break
                    fi
                done
            fi

            xc_chnl_found=0
            if [ "$to_try" -eq 1 ] 
            then
                to_try=0
                if [ "${BASH_REMATCH[2]}" == "live" ] && [[ $chnl_stream_link =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]] 
                then
                    chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
                else
                    chnl_account="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
                fi
                for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
                do
                    if [ "$xc_chnl" == "$chnl_domain/$chnl_account" ] 
                    then
                        xc_chnl_found=1
                        break
                    fi
                done
            fi

            if [ "$xc_chnl_found" -eq 1 ]  
            then
                domains_tried+=("$chnl_domain")
                try_success=0
                MonitorTryAccounts
                if [ "$try_success" -eq 1 ] 
                then
                    MonitorFlvRestartSuccess
                    break
                elif [[ $restart_i -eq $((restart_nums-1)) ]] 
                then
                    MonitorFlvRestartFail
                    break
                else
                    continue
                fi
            fi
        fi

        action="skip"
        StopChannel
        if [ "$anti_leech_yn" == "yes" ] && [ "$anti_leech_restart_flv_changes_yn" == "yes" ] 
        then
            stream_name=${chnl_flv_push_link##*/}
            new_stream_name=$(RandStr)
            while [[ -n $($JQ_FILE '.channels[]|select(.flv_push_link=="'"${chnl_flv_push_link%/*}/$new_stream_name"'")' "$CHANNELS_FILE") ]] 
            do
                new_stream_name=$(RandStr)
            done
            chnl_flv_push_link="${chnl_flv_push_link%/*}/$new_stream_name"
            monitor_flv_push_links[i]=$chnl_flv_push_link
            if [ -n "$chnl_flv_pull_link" ] 
            then
                chnl_flv_pull_link=${chnl_flv_pull_link//stream=$stream_name/stream=$new_stream_name}
                monitor_flv_pull_links[i]=$chnl_flv_pull_link
            fi
        fi
        StartChannel
        sleep 15
        GetChannel

        if [ "$chnl_flv_status" == "on" ] 
        then
            audio=0
            video=0
            while IFS= read -r line 
            do
                if [[ $line == *"codec_type=audio"* ]] 
                then
                    audio=1
                elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                then
                    audio=0
                elif [[ $line == *"codec_type=video"* ]] 
                then
                    video=1
                fi
            done < <($FFPROBE -i "${chnl_flv_pull_link:-$chnl_flv_push_link}" -rw_timeout 10000000 -show_streams -loglevel quiet)
            if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ] 
            then
                MonitorFlvRestartSuccess
                break
            fi
        fi

        if [ "$to_try" -eq 1 ] 
        then
            domains_tried+=("$chnl_domain")
            try_success=0
            MonitorTryAccounts
            if [ "$try_success" -eq 1 ] 
            then
                MonitorFlvRestartSuccess
                break
            fi
        fi

        if [[ $restart_i -eq $((restart_nums - 1)) ]] 
        then
            MonitorFlvRestartFail
            break
        fi
    done
}

MonitorTryAccounts()
{
    accounts=()
    macs=()

    while IFS= read -r line 
    do
        if [[ $line == *"$chnl_domain"* ]] 
        then
            line=${line#* }
            account_line=${line#* }
            if [[ $account_line == *" "* ]] 
            then
                new_account_line=""
                while [[ $account_line == *" "* ]] 
                do
                    if [[ ${account_line%% *} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
                    then
                        macs+=("${account_line%% *}")
                        account_line=${account_line#* }
                        continue
                    fi
                    [ -n "$new_account_line" ] && new_account_line=" $new_account_line"
                    new_account_line="${account_line%% *}$new_account_line"
                    account_line=${account_line#* }
                done
            else
                if [[ $account_line =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
                then
                    macs+=("$account_line")
                fi
                new_account_line=$account_line
            fi

            IFS=" " read -ra accounts <<< "$new_account_line"
            break
        fi
    done < "$XTREAM_CODES"

    if [ -n "${chnl_mac:-}" ] 
    then
        if [ -n "${macs:-}" ] 
        then
            GetDefault

            if [ -n "${chnl_xc_proxy:-}" ] 
            then
                server=${chnl_xc_proxy%\/}
                xc_host_header=( -H "xc_host: $chnl_domain" )
            else
                server="http://$chnl_domain"
                xc_host_header=()
            fi

            chnl_user_agent="$USER_AGENT_TV"
            timezone=$(UrlencodeUpper "Europe/Amsterdam")
            token_url="$server/portal.php?type=stb&action=handshake"
            profile_url="$server/portal.php?type=stb&action=get_profile"
            genres_url="$server/portal.php?type=itv&action=get_genres"

            macs+=("$chnl_mac")
            macs_count=${#macs[@]}
            echo
            for((macs_i=0;macs_i<macs_count;macs_i++));
            do
                if [ -z "${monitor:-}" ] 
                then
                    printf '%b' "\r$macs_i/$macs_count 检测中..."
                fi
                mac_address=${macs[macs_i]}

                xc_chnl_found=0
                for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                do
                    if [ "$xc_chnl_mac" == "$chnl_domain/$mac_address" ] 
                    then
                        xc_chnl_found=1
                        break
                    fi
                done

                valid=0
                if [ "$xc_chnl_found" -eq 0 ] 
                then
                    access_token=""
                    profile=""
                    mac=$(UrlencodeUpper "$mac_address")
                    chnl_cookies="mac=$mac; stb_lang=en; timezone=$timezone"

                    access_token=$(curl -s -Lm 10 \
                        -H "User-Agent: $chnl_user_agent" \
                        ${xc_host_header[@]+"${xc_host_header[@]}"} \
                        --cookie "$chnl_cookies" "$token_url" \
                        | $JQ_FILE -r '.js.token') || true
                    if [ -z "$access_token" ] 
                    then
                        continue
                    fi

                    chnl_headers="Authorization: Bearer $access_token\r\n"
                    printf -v chnl_headers_command '%b' "$chnl_headers"
                    profile=$(curl -s -Lm 10 \
                        -H "User-Agent: $chnl_user_agent" \
                        ${xc_host_header[@]+"${xc_host_header[@]}"} \
                        -H "${chnl_headers:0:-4}" \
                        --cookie "$chnl_cookies" "$profile_url") || true
                    if [ -z "$profile" ] || [[ $($JQ_FILE -r '.js.id' <<< "$profile") == null ]]
                    then
                        continue
                    fi

                    if [ -n "$chnl_xc_proxy" ] 
                    then
                        server=${chnl_xc_proxy%\/}
                        chnl_stream_link=$(curl -k -s -o /dev/null -w '%{redirect_url}' "$server" \
                            ${xc_host_header[@]+"${xc_host_header[@]}"} \
                            -H "User-Agent: $chnl_user_agent" \
                            -H "${chnl_headers:0:-4}" \
                            -H "cmd: $chnl_cmd" \
                            --cookie "$chnl_cookies")
                        if [[ ! $chnl_stream_link =~ ([^/]+)//([^/]+)/(.+) ]] 
                        then
                            continue
                        fi
                    else
                        create_link_url="$server/portal.php?type=itv&action=create_link&cmd=$chnl_cmd&series=&forced_storage=undefined&disable_ad=0&download=0"
                        cmd=$(curl -s -Lm 10 \
                            -H "User-Agent: $chnl_user_agent" \
                            ${xc_host_header[@]+"${xc_host_header[@]}"} \
                            -H "${chnl_headers:0:-4}" \
                            --cookie "$chnl_cookies" "$create_link_url" \
                            | $JQ_FILE -r '.js.cmd') || true

                        if [[ ${cmd#* } =~ ([^/]+)//([^/]+)/live/([^/]+)/([^/]+)/([^/]+) ]] 
                        then
                            chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/live/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                        elif [[ ${cmd#* } =~ ([^/]+)//([^/]+)/([^/]+)/([^/]+)/([^/]+) ]] 
                        then
                            chnl_stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                        else
                            continue
                        fi
                    fi

                    audio=0
                    video=0
                    while IFS= read -r line 
                    do
                        if [[ $line == *"codec_type=audio"* ]] 
                        then
                            audio=1
                        elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                        then
                            audio=0
                        elif [[ $line == *"codec_type=video"* ]] 
                        then
                            video=1
                        fi
                    done < <($FFPROBE $chnl_proxy_command -user_agent "$chnl_user_agent" -headers "$chnl_headers_command" -cookies "$chnl_cookies" -i "$chnl_stream_link" -rw_timeout 10000000 -show_streams -loglevel quiet)

                    if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ]
                    then
                        valid=1
                    fi

                    if [ "$valid" -eq 1 ] 
                    then
                        action="skip"
                        StopChannel

                        if [[ $chnl_stream_links == *" "* ]] 
                        then
                            chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$mac_address ${chnl_stream_links#* }"
                        else
                            chnl_stream_links="$chnl_domain|$chnl_stream_link|$chnl_cmd|$mac_address"
                        fi

                        if [ -n "${monitor:-}" ] && [ "$anti_leech_yn" == "yes" ]
                        then
                            if [ -z "${kind:-}" ] && [ "$anti_leech_restart_hls_changes_yn" == "yes" ]
                            then
                                chnl_playlist_name=$(RandStr)
                                chnl_seg_name=$chnl_playlist_name
                                if [ "$chnl_encrypt_yn" == "yes" ] 
                                then
                                    mkdir -p "$chnl_output_dir_root"
                                    chnl_key_name=$(RandStr)
                                    openssl rand 16 > "$chnl_output_dir_root/$chnl_key_name.key"
                                    if [ "$chnl_encrypt_session_yn" == "yes" ] 
                                    then
                                        echo -e "/keys?key=$chnl_key_name&channel=$chnl_output_dir_name\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                                    else
                                        echo -e "$chnl_key_name.key\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                                    fi
                                fi
                            elif [ "${kind:-}" == "flv" ] && [ "$anti_leech_restart_flv_changes_yn" == "yes" ]
                            then
                                stream_name=${chnl_flv_push_link##*/}
                                new_stream_name=$(RandStr)
                                while [[ -n $($JQ_FILE '.channels[]|select(.flv_push_link=="'"${chnl_flv_push_link%/*}/$new_stream_name"'")' "$CHANNELS_FILE") ]] 
                                do
                                    new_stream_name=$(RandStr)
                                done
                                chnl_flv_push_link="${chnl_flv_push_link%/*}/$new_stream_name"
                                monitor_flv_push_links[i]=$chnl_flv_push_link
                                if [ -n "$chnl_flv_pull_link" ] 
                                then
                                    chnl_flv_pull_link=${chnl_flv_pull_link//stream=$stream_name/stream=$new_stream_name}
                                    monitor_flv_pull_links[i]=$chnl_flv_pull_link
                                fi
                            fi
                        fi

                        StartChannel
                        if [ -z "${monitor:-}" ] 
                        then
                            try_success=1
                            sleep 3
                            break
                        fi

                        if [ "${kind:-}" == "flv" ] 
                        then
                            sleep 15
                            GetChannel
                            audio=0
                            video=0
                            while IFS= read -r line 
                            do
                                if [[ $line == *"codec_type=audio"* ]] 
                                then
                                    audio=1
                                elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]]
                                then
                                    audio=0
                                elif [[ $line == *"codec_type=video"* ]] 
                                then
                                    video=1
                                fi
                            done < <($FFPROBE -i "${chnl_flv_pull_link:-$chnl_flv_push_link}" -rw_timeout 10000000 -show_streams -loglevel quiet)

                            if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ]
                            then
                                try_success=1
                                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
                                break
                            fi
                        else
                            sleep $((15+chnl_seg_length))
                            GetChannel
                            if ls -A "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts > /dev/null 2>&1 
                            then
                                if [ "$chnl_encrypt_yn" == "yes" ] 
                                then
                                    if [ -e "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo" ] && \
                                    [ -e "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key" ] && \
                                    iv_hex=$(awk 'NR==3{print}' "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo") && \
                                    encrypt_key=$(hexdump -e '16/1 "%02x"' < "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key")
                                    then
                                        encrypt_command="-key $encrypt_key -iv $iv_hex"
                                    else
                                        continue
                                    fi
                                else
                                    encrypt_command=""
                                fi

                                audio=0
                                video=0
                                video_bitrate=0
                                bitrate_check=0

                                f_count=1
                                for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                                do
                                    ((f_count++))
                                done

                                f_num=$((f_count/2))
                                f_count=1

                                for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                                do
                                    if [ "$f_count" -lt "$f_num" ] 
                                    then
                                        ((f_count++))
                                        continue
                                    fi
                                    [ -n "$encrypt_command" ] && f="crypto:$f"
                                    while IFS= read -r line 
                                    do
                                        if [[ $line == *"codec_type=video"* ]] 
                                        then
                                            video=1
                                        elif [ "$bitrate_check" -eq 0 ] && [ "$video" -eq 1 ] && [[ $line == *"bit_rate="* ]] 
                                        then
                                            line=${line#*bit_rate=}
                                            video_bitrate=${line//N\/A/$hls_min_bitrates}
                                            bitrate_check=1
                                        elif [[ $line == *"codec_type=audio"* ]] 
                                        then
                                            audio=1
                                        elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                                        then
                                            audio=0
                                        fi
                                    done < <($FFPROBE $encrypt_command -i "$f" -show_streams -loglevel quiet)
                                    break
                                done

                                if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ] && [[ $video_bitrate -ge $hls_min_bitrates ]]
                                then
                                    try_success=1
                                    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                    printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
                                    break
                                fi
                            fi
                        fi
                    fi
                fi
            done
            echo
        fi
    elif [ -n "${accounts:-}" ] 
    then
        accounts+=("$chnl_account")
        accounts_count=${#accounts[@]}
        echo
        for((accounts_i=0;accounts_i<accounts_count;accounts_i++));
        do
            if [ -z "${monitor:-}" ] 
            then
                printf '%b' "\r$accounts_i/$accounts_count 检测中..."
            fi
            account=${accounts[accounts_i]}

            xc_chnl_found=0
            for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
            do
                if [ "$xc_chnl" == "$chnl_domain/$account" ] 
                then
                    xc_chnl_found=1
                    break
                fi
            done

            valid=0
            if [ "$xc_chnl_found" -eq 0 ] 
            then
                if [[ $chnl_stream_link == *"/live/"* ]] 
                then
                    chnl_stream_link="http://$chnl_domain/live/${account//:/\/}/${chnl_stream_link##*/}"
                else
                    chnl_stream_link="http://$chnl_domain/${account//:/\/}/${chnl_stream_link##*/}"
                fi

                audio=0
                video=0
                while IFS= read -r line 
                do
                    if [[ $line == *"codec_type=audio"* ]] 
                    then
                        audio=1
                    elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                    then
                        audio=0
                    elif [[ $line == *"codec_type=video"* ]] 
                    then
                        video=1
                    fi
                done < <($FFPROBE $chnl_proxy_command -i "$chnl_stream_link" -rw_timeout 10000000 -show_streams -loglevel quiet)

                if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ]
                then
                    valid=1
                fi
            fi

            if [ "$valid" -eq 1 ] 
            then
                action="skip"
                StopChannel

                if [[ $chnl_stream_links == *" "* ]] 
                then
                    chnl_stream_links="$chnl_stream_link ${chnl_stream_links#* }"
                else
                    chnl_stream_links=$chnl_stream_link
                fi

                if [ -n "${monitor:-}" ] && [ "$anti_leech_yn" == "yes" ]
                then
                    if [ -z "${kind:-}" ] && [ "$anti_leech_restart_hls_changes_yn" == "yes" ]
                    then
                        chnl_playlist_name=$(RandStr)
                        chnl_seg_name=$chnl_playlist_name
                        if [ "$chnl_encrypt_yn" == "yes" ] 
                        then
                            mkdir -p "$chnl_output_dir_root"
                            chnl_key_name=$(RandStr)
                            openssl rand 16 > "$chnl_output_dir_root/$chnl_key_name.key"
                            if [ "$chnl_encrypt_session_yn" == "yes" ] 
                            then
                                echo -e "/keys?key=$chnl_key_name&channel=$chnl_output_dir_name\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                            else
                                echo -e "$chnl_key_name.key\n$chnl_output_dir_root/$chnl_key_name.key\n$(openssl rand -hex 16)" > "$chnl_output_dir_root/$chnl_keyinfo_name.keyinfo"
                            fi
                        fi
                    elif [ "${kind:-}" == "flv" ] && [ "$anti_leech_restart_flv_changes_yn" == "yes" ]
                    then
                        stream_name=${chnl_flv_push_link##*/}
                        new_stream_name=$(RandStr)
                        while [[ -n $($JQ_FILE '.channels[]|select(.flv_push_link=="'"${chnl_flv_push_link%/*}/$new_stream_name"'")' "$CHANNELS_FILE") ]] 
                        do
                            new_stream_name=$(RandStr)
                        done
                        chnl_flv_push_link="${chnl_flv_push_link%/*}/$new_stream_name"
                        monitor_flv_push_links[i]=$chnl_flv_push_link
                        if [ -n "$chnl_flv_pull_link" ] 
                        then
                            chnl_flv_pull_link=${chnl_flv_pull_link//stream=$stream_name/stream=$new_stream_name}
                            monitor_flv_pull_links[i]=$chnl_flv_pull_link
                        fi
                    fi
                fi

                StartChannel
                if [ -z "${monitor:-}" ] 
                then
                    try_success=1
                    sleep 3
                    break
                fi

                if [ "${kind:-}" == "flv" ] 
                then
                    sleep 15
                    GetChannel
                    audio=0
                    video=0
                    while IFS= read -r line 
                    do
                        if [[ $line == *"codec_type=audio"* ]] 
                        then
                            audio=1
                        elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]]
                        then
                            audio=0
                        elif [[ $line == *"codec_type=video"* ]] 
                        then
                            video=1
                        fi
                    done < <($FFPROBE -i "${chnl_flv_pull_link:-$chnl_flv_push_link}" -rw_timeout 10000000 -show_streams -loglevel quiet)

                    if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ]
                    then
                        try_success=1
                        printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                        printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
                        break
                    fi
                else
                    sleep $((15+chnl_seg_length))
                    GetChannel
                    if ls -A "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts > /dev/null 2>&1 
                    then
                        if [ "$chnl_encrypt_yn" == "yes" ] 
                        then
                            if [ -e "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo" ] && \
                            [ -e "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key" ] && \
                            iv_hex=$(awk 'NR==3{print}' "$LIVE_ROOT/$output_dir_name/$chnl_keyinfo_name.keyinfo") && \
                            encrypt_key=$(hexdump -e '16/1 "%02x"' < "$LIVE_ROOT/$output_dir_name/$chnl_key_name.key")
                            then
                                encrypt_command="-key $encrypt_key -iv $iv_hex"
                            else
                                continue
                            fi
                        else
                            encrypt_command=""
                        fi

                        audio=0
                        video=0
                        video_bitrate=0
                        bitrate_check=0

                        f_count=1
                        for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                        do
                            ((f_count++))
                        done

                        f_num=$((f_count/2))
                        f_count=1

                        for f in "$LIVE_ROOT/$output_dir_name/$chnl_seg_dir_name/"*.ts
                        do
                            if [ "$f_count" -lt "$f_num" ] 
                            then
                                ((f_count++))
                                continue
                            fi
                            [ -n "$encrypt_command" ] && f="crypto:$f"
                            while IFS= read -r line 
                            do
                                if [[ $line == *"codec_type=video"* ]] 
                                then
                                    video=1
                                elif [ "$bitrate_check" -eq 0 ] && [ "$video" -eq 1 ] && [[ $line == *"bit_rate="* ]] 
                                then
                                    line=${line#*bit_rate=}
                                    video_bitrate=${line//N\/A/$hls_min_bitrates}
                                    bitrate_check=1
                                elif [[ $line == *"codec_type=audio"* ]] 
                                then
                                    audio=1
                                elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                                then
                                    audio=0
                                fi
                            done < <($FFPROBE $encrypt_command -i "$f" -show_streams -loglevel quiet)
                            break
                        done

                        if [ "$audio" -eq 1 ] && [ "$video" -eq 1 ] && [[ $video_bitrate -ge $hls_min_bitrates ]]
                        then
                            try_success=1
                            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                            printf '%s\n' "$date_now $chnl_channel_name 重启成功" >> "$MONITOR_LOG"
                            break
                        fi
                    fi
                fi
            fi
        done
        echo
    fi
}

MonitorSet()
{
    flv_count=0
    monitor_channel_names=()
    monitor_stream_links=()
    monitor_flv_push_links=()
    monitor_flv_pull_links=()
    monitor_dir_names_chosen=()

    GetChannels
    for((i=0;i<chnls_count;i++));
    do
        if [ "${chnls_flv_status[i]}" == "on" ] && [ "${chnls_live[i]}" == "yes" ]
        then
            flv_count=$((flv_count+1))
            monitor_channel_names+=("${chnls_channel_name[i]}")
            monitor_stream_links+=("${chnls_stream_link[i]}")
            monitor_flv_push_links+=("${chnls_flv_push_link[i]}")
            monitor_flv_pull_links+=("${chnls_flv_pull_link[i]}")
        fi
    done

    if [ "$flv_count" -gt 0 ] 
    then
        GetDefault
        Println "请选择需要监控的 FLV 推流频道(多个频道用空格分隔 比如: 5 7 9-11)\n"

        result=""
        for((i=0;i<flv_count;i++));
        do
            flv_pull_link=${monitor_flv_pull_links[i]}
            result=$result"  ${green}$((i+1)).${normal}${indent_6}${monitor_channel_names[i]}\n${indent_6}源: ${monitor_stream_links[i]}\n${indent_6}pull: ${flv_pull_link:-无}\n\n"
        done

        Println "$result"
        Println "  ${green}$((flv_count+1)).${normal}${indent_6}全部"
        Println "  ${green}$((flv_count+2)).${normal}${indent_6}不设置\n"
        while read -p "(默认: 不设置): " flv_nums
        do
            if [ -z "$flv_nums" ] || [ "$flv_nums" == $((flv_count+2)) ] 
            then
                flv_nums=""
                break
            fi

            if [ "$flv_nums" == $((flv_count+1)) ] 
            then
                flv_nums=""
                for((i=1;i<=flv_count;i++));
                do
                    [ -n "$flv_nums" ] && flv_nums="$flv_nums "
                    flv_nums="$flv_nums$i"
                done
            fi

            IFS=" " read -ra flv_nums_arr <<< "$flv_nums"

            error_no=0
            for flv_num in "${flv_nums_arr[@]}"
            do
                case "$flv_num" in
                    *"-"*)
                        flv_num_start=${flv_num%-*}
                        flv_num_end=${flv_num#*-}
                        if [[ $flv_num_start == *[!0-9]* ]] || [[ $flv_num_end == *[!0-9]* ]] || [ "$flv_num_start" -eq 0 ] || [ "$flv_num_end" -eq 0 ] || [ "$flv_num_end" -gt "$flv_count" ] || [ "$flv_num_start" -ge "$flv_num_end" ]
                        then
                            error_no=3
                        fi
                    ;;
                    *[!0-9]*)
                        error_no=1
                    ;;
                    *)
                        if [ "$flv_num" -lt 1 ] || [ "$flv_num" -gt "$flv_count" ] 
                        then
                            error_no=2
                        fi
                    ;;
                esac
            done

            case "$error_no" in
                1|2|3)
                    Println "$error $i18n_input_correct_number\n"
                ;;
                *)
                    declare -a new_array
                    for element in "${flv_nums_arr[@]}"
                    do
                        if [[ $element =~ - ]] 
                        then
                            start=${element%-*}
                            end=${element#*-}
                            for((i=start;i<=end;i++));
                            do
                                new_array+=("$i")
                            done
                        else
                            new_array+=("$element")
                        fi
                    done
                    if [ -z "${new_array:-}" ] 
                    then
                        flv_nums_arr=()
                    else
                        flv_nums_arr=("${new_array[@]}")
                    fi
                    unset new_array

                    SetFlvDelaySeconds
                    break
                ;;
            esac
        done

        if [ -n "$flv_nums" ] 
        then
            SetFlvRestartNums
        fi
    fi

    if ! ls -A $LIVE_ROOT/* > /dev/null 2>&1
    then
        if [ "$flv_count" -eq 0 ] 
        then
            Println "$error 没有开启的频道!\n" && exit 1
        elif [ -z "${flv_delay_seconds:-}" ] 
        then
            Println "$i18n_canceled...\n" && exit 1
        else
            SetRecheckPeriod
            SetAntiLeech
            JQ update "$CHANNELS_FILE" '.default|=. * 
            {
                flv_delay_seconds: '"$flv_delay_seconds"',
                flv_restart_nums: '"$flv_restart_nums"',
                anti_leech: "'"$anti_leech_yn"'",
                anti_leech_restart_nums: '"$anti_leech_restart_nums"',
                anti_leech_restart_flv_changes: "'"$anti_leech_restart_flv_changes_yn"'",
                anti_leech_restart_hls_changes: "'"$anti_leech_restart_hls_changes_yn"'",
                recheck_period: '"$recheck_period"'
            } // .'
            return 0
        fi
    fi
    Println "请选择需要监控的 HLS 频道(多个频道用空格分隔 比如 5 7 9-11)\n"
    monitor_count=0
    monitor_dir_names=()
    exclude_paths=()
    GetDefault
    result=""
    for((i=0;i<chnls_count;i++));
    do
        if [ -e "$LIVE_ROOT/${chnls_output_dir_name[i]}" ] && [ "${chnls_live[i]}" == "yes" ] && [ "${chnls_seg_count[i]}" != 0 ]
        then
            monitor_count=$((monitor_count + 1))
            monitor_dir_names+=("${chnls_output_dir_name[i]}")
            result=$result"  ${green}$monitor_count.${normal}${indent_6}${chnls_channel_name[i]}\n\n"
        fi
    done

    Println "$result"
    Println "  ${green}$((monitor_count+1)).${normal}${indent_6}全部"
    Println "  ${green}$((monitor_count+2)).${normal}${indent_6}不设置\n"

    while read -p "(默认: 不设置): " hls_nums
    do
        if [ -z "$hls_nums" ] || [ "$hls_nums" == $((monitor_count+2)) ] 
        then
            hls_nums=""
            break
        fi
        IFS=" " read -ra hls_nums_arr <<< "$hls_nums"

        if [ "$hls_nums" == $((monitor_count+1)) ] 
        then
            monitor_dir_names_chosen=("${monitor_dir_names[@]}")

            SetHlsDelaySeconds
            break
        fi

        error_no=0
        for hls_num in ${hls_nums_arr[@]+"${hls_nums_arr[@]}"}
        do
            case "$hls_num" in
                *"-"*)
                    hls_num_start=${hls_num%-*}
                    hls_num_end=${hls_num#*-}
                    if [[ $hls_num_start == *[!0-9]* ]] || [[ $hls_num_end == *[!0-9]* ]] || [ "$hls_num_start" -eq 0 ] || [ "$hls_num_end" -eq 0 ] || [ "$hls_num_end" -gt "$monitor_count" ] || [ "$hls_num_start" -ge "$hls_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$hls_num" -lt 1 ] || [ "$hls_num" -gt "$monitor_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                declare -a new_array
                for element in "${hls_nums_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start;i<=end;i++));
                        do
                            new_array+=("$i")
                        done
                    else
                        new_array+=("$element")
                    fi
                done
                if [ -z "${new_array:-}" ] 
                then
                    hls_nums_arr=()
                else
                    hls_nums_arr=("${new_array[@]}")
                fi
                unset new_array

                for hls_num in "${hls_nums_arr[@]}"
                do
                    monitor_dir_names_chosen+=("${monitor_dir_names[((hls_num - 1))]}")
                done

                Println "设置超时多少秒自动重启频道"
                echo -e "$tip 必须大于 分片时长*分片数目"
                while read -p "(默认: $d_hls_delay_seconds 秒): " hls_delay_seconds
                do
                    case $hls_delay_seconds in
                        "") hls_delay_seconds=$d_hls_delay_seconds && break
                        ;;
                        *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                        ;;
                        *) 
                            if [ "$hls_delay_seconds" -gt 60 ]
                            then
                                break
                            else
                                Println "$error $i18n_input_correct_number [>60]\n"
                            fi
                        ;;
                    esac
                done

                break
            ;;
        esac
    done

    if [ -n "$hls_nums" ] 
    then
        SetHlsMinBitrates

        hls_min_bitrates=$((hls_min_bitrates * 1000))
    fi

    SetHlsMaxSegSize
    SetHlsRestartNums

    SetRecheckPeriod
    SetAntiLeech

    flv_delay_seconds=${flv_delay_seconds:-$d_flv_delay_seconds}
    flv_restart_nums=${flv_restart_nums:-$d_flv_restart_nums}
    hls_delay_seconds=${hls_delay_seconds:-$d_hls_delay_seconds}
    hls_min_bitrates=${hls_min_bitrates:-$d_hls_min_bitrates}
    hls_key_period=${hls_key_period:-$d_hls_key_period}
    JQ update "$CHANNELS_FILE" '.default|=. * 
    {
        flv_delay_seconds: '"$flv_delay_seconds"',
        flv_restart_nums: '"$flv_restart_nums"',
        hls_delay_seconds: '"$hls_delay_seconds"',
        hls_min_bitrates: '"$((hls_min_bitrates / 1000))"',
        hls_max_seg_size: '"$hls_max_seg_size"',
        hls_restart_nums: '"$hls_restart_nums"',
        hls_key_period: '"$hls_key_period"',
        anti_leech: "'"$anti_leech_yn"'",
        anti_leech_restart_nums: '"$anti_leech_restart_nums"',
        anti_leech_restart_flv_changes: "'"$anti_leech_restart_flv_changes_yn"'",
        anti_leech_restart_hls_changes: "'"$anti_leech_restart_hls_changes_yn"'",
        recheck_period: '"$recheck_period"'
    } // .'
}

Monitor()
{
    trap '' HUP INT
    trap 'MonitorError $LINENO' ERR

    pid_file="$IPTV_ROOT/monitor.pid"
    printf '%s' "$BASHPID" > "$pid_file"
    {
        flock -x 203
        {
            mkdir -p "$LIVE_ROOT"
            printf '%s\n' "$date_now 监控启动成功 PID $BASHPID !" >> "$MONITOR_LOG"

            FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
            FFPROBE="$FFMPEG_ROOT/ffprobe"
            XtreamCodesGetDomains
            monitor=1
            flv_failed=()
            flv_recheck_time=()
            hls_failed=()
            hls_recheck_time=()
            while true
            do
                printf -v now '%(%s)T' -1
                if [ "$recheck_period" -gt 0 ] 
                then
                    if [ -n "${flv_recheck_time:-}" ] 
                    then
                        for((i=0;i<${#flv_recheck_time[@]};i++));
                        do
                            if [ "$now" -ge "${flv_recheck_time[i]}" ] 
                            then
                                for flv_num in ${flv_nums_arr[@]+"${flv_nums_arr[@]}"}
                                do
                                    if [ "$flv_num" == "${flv_failed[i]}" ] 
                                    then
                                        continue 2
                                    fi
                                done
                                flv_nums_arr+=("${flv_failed[i]}")
                            fi
                        done
                    fi

                    if [ -n "${hls_recheck_time:-}" ] 
                    then
                        for((i=0;i<${#hls_recheck_time[@]};i++));
                        do
                            if [ "$now" -ge "${hls_recheck_time[i]}" ] 
                            then
                                for dir_name in ${monitor_dir_names_chosen[@]+"${monitor_dir_names_chosen[@]}"}
                                do
                                    if [ "$dir_name" == "${hls_failed[i]}" ] 
                                    then
                                        continue 2
                                    fi
                                done
                                monitor_dir_names_chosen+=("${hls_failed[i]}")
                            fi
                        done
                    fi
                fi

                if [ "$anti_leech_yn" == "yes" ] && [ "$anti_leech_restart_nums" -gt 0 ] && [ "${rand_restart_flv_done:-}" != 0 ] && [ "${rand_restart_hls_done:-}" != 0 ] 
                then
                    current_minute_old=${current_minute:-}
                    current_hour_old=${current_hour:-25}
                    printf -v current_time '%(%H:%M)T' -1
                    current_hour=${current_time%:*}
                    current_minute=${current_time#*:}

                    if [ "${current_hour:0:1}" -eq 0 ] 
                    then
                        current_hour=${current_hour:1}
                    fi
                    if [ "${current_minute:0:1}" -eq 0 ] 
                    then
                        current_minute=${current_minute:1}
                    fi

                    if [ "$current_hour" != "$current_hour_old" ] 
                    then
                        minutes=()
                        skip_hour=""
                    fi

                    if [ -n "${minutes:-}" ] && [ "$current_minute" -gt "$current_minute_old" ]
                    then
                        declare -a new_array
                        for minute in "${minutes[@]}"
                        do
                            if [ "$minute" -gt "$current_minute" ] 
                            then
                                new_array+=("$minute")
                            fi

                            if [ "$minute" -eq "$current_minute" ] 
                            then
                                rand_restart_flv_done=0
                                rand_restart_hls_done=0
                            fi
                        done
                        if [ -z "${new_array:-}" ] 
                        then
                            minutes=()
                        else
                            minutes=("${new_array[@]}")
                        fi
                        unset new_array
                        [ -z "${minutes:-}" ] && skip_hour=$current_hour
                    fi

                    if [ -z "${minutes:-}" ] && [ "$current_minute" -lt 59 ] && [ "$current_hour" != "${skip_hour:-}" ]
                    then
                        rand_restart_flv_done=""
                        rand_restart_hls_done=""
                        minutes_left=$((59 - current_minute))
                        restart_nums=$anti_leech_restart_nums
                        [ "$restart_nums" -gt "$minutes_left" ] && restart_nums=$minutes_left
                        minute_gap=$((minutes_left / anti_leech_restart_nums / 2))
                        [ "$minute_gap" -eq 0 ] && minute_gap=1
                        for((i=0;i<restart_nums;i++));
                        do
                            while true 
                            do
                                rand_minute=$((RANDOM % 60))
                                if [ "$rand_minute" -gt "$current_minute" ] 
                                then
                                    valid=1
                                    for minute in ${minutes[@]+"${minutes[@]}"}
                                    do
                                        if [ "$minute" -eq "$rand_minute" ] 
                                        then
                                            valid=0
                                            break
                                        elif [ "$minute" -gt "$rand_minute" ] && [ "$((minute-rand_minute))" -lt "$minute_gap" ]
                                        then
                                            valid=0
                                            break
                                        elif [ "$rand_minute" -gt "$minute" ] && [ "$((rand_minute-minute))" -lt "$minute_gap" ]
                                        then
                                            valid=0
                                            break
                                        fi
                                    done
                                    if [ "$valid" -eq 1 ] 
                                    then
                                        break
                                    fi
                                fi
                            done
                            minutes+=("$rand_minute")
                        done
                        printf '%s\n' "$current_time 计划重启时间 ${minutes[*]}" >> "$MONITOR_LOG"
                    fi
                fi

                if [ -n "${flv_nums:-}" ] 
                then
                    kind="flv"
                    rand_found=0
                    if [ -n "${rand_restart_flv_done:-}" ] && [ "$rand_restart_flv_done" -eq 0 ] && [ -z "${flv_nums_arr:-}" ]
                    then
                        rand_restart_flv_done=1
                        rand_found=1
                    fi
                    for flv_num in ${flv_nums_arr[@]+"${flv_nums_arr[@]}"}
                    do
                        chnl_flv_pull_link=${monitor_flv_pull_links[flv_num-1]}
                        chnl_flv_push_link=${monitor_flv_push_links[flv_num-1]}

                        audio=0
                        video=0
                        while IFS= read -r line 
                        do
                            if [[ $line == *"codec_type=audio"* ]] 
                            then
                                audio=1
                            elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                            then
                                audio=0
                            elif [[ $line == *"codec_type=video"* ]] 
                            then
                                video=1
                            fi
                        done < <($FFPROBE -i "${chnl_flv_pull_link:-$chnl_flv_push_link}" -rw_timeout 10000000 -show_streams -loglevel quiet)

                        if [ "$audio" -eq 0 ] || [ "$video" -eq 0 ]
                        then
                            GetChannel
                            if [ -n "${flv_first_fail:-}" ] 
                            then
                                printf -v flv_fail_time '%(%s)T' -1
                                if [ $((flv_fail_time - flv_first_fail)) -gt "$flv_delay_seconds" ] 
                                then
                                    flv_first_fail=""
                                    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                    printf '%s\n' "$date_now $chnl_channel_name FLV 超时重启" >> "$MONITOR_LOG"
                                    MonitorFlvRestartChannel
                                fi
                            else
                                if [ "$chnl_flv_status" == "off" ] 
                                then
                                    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                    printf '%s\n' "$date_now $chnl_channel_name FLV 恢复启动" >> "$MONITOR_LOG"
                                    MonitorFlvRestartChannel
                                else
                                    printf -v flv_first_fail '%(%s)T' -1
                                fi

                                new_array=("$flv_num")
                                for element in ${flv_nums_arr[@]+"${flv_nums_arr[@]}"}
                                do
                                    [ "$element" != "$flv_num" ] && new_array+=("$element")
                                done
                                if [ -z "${new_array:-}" ] 
                                then
                                    flv_nums_arr=()
                                else
                                    flv_nums_arr=("${new_array[@]}")
                                fi
                                unset new_array
                            fi
                            break 1
                        else
                            flv_first_fail=""

                            if [ -n "${rand_restart_flv_done:-}" ] && [ "$rand_restart_flv_done" -eq 0 ]
                            then
                                rand_found=1
                                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                                printf '%s\n' "$date_now $chnl_channel_name FLV 随机重启" >> "$MONITOR_LOG"
                                MonitorFlvRestartChannel
                            fi
                        fi
                    done
                    if [ "$rand_found" -eq 1 ] 
                    then
                        rand_restart_flv_done=1
                    fi
                else
                    rand_restart_flv_done=1
                fi

                kind=""

                if ls -A $LIVE_ROOT/* > /dev/null 2>&1
                then
                    exclude_command=""
                    for exclude_path in ${exclude_paths[@]+"${exclude_paths[@]}"}
                    do
                        exclude_command="$exclude_command -not \( -path $exclude_path -prune \)"
                    done

                    if [ -n "${hls_max_seg_size:-}" ] 
                    then
                        largest_file=$(find "$LIVE_ROOT" $exclude_command -type f -name "*.ts" -printf "%s %p\n" 2> /dev/null | sort -n | tail -1) || true
                        if [ -n "${largest_file:-}" ] 
                        then
                            largest_file_size=${largest_file%% *}
                            largest_file_path=${largest_file#* }
                            output_dir_name=${largest_file_path#*$LIVE_ROOT/}
                            output_dir_name=${output_dir_name%%/*}
                            if [ "$largest_file_size" -gt $(( hls_max_seg_size * 1000000)) ]
                            then
                                GetChannel
                                if [ -n "$chnl_live" ] 
                                then
                                    printf '%s\n' "$chnl_channel_name 文件过大重启" >> "$MONITOR_LOG"
                                    MonitorHlsRestartChannel
                                else
                                    exclude_paths+=("$LIVE_ROOT/$output_dir_name")
                                fi
                            fi
                        fi
                    fi
                fi

                if [ -n "${monitor_dir_names_chosen:-}" ] 
                then
                    rand_found=0
                    if [ -z "${loop:-}" ] || [ "$loop" -eq 10 ]
                    then
                        loop=1
                    else
                        ((loop++))
                    fi
                    while IFS= read -r old_file_path
                    do
                        output_dir_name=${old_file_path#*$LIVE_ROOT/}
                        output_dir_name=${output_dir_name%%/*}
                        for dir_name in "${monitor_dir_names_chosen[@]}"
                        do
                            if [ "$dir_name" == "$output_dir_name" ] 
                            then
                                GetChannel
                                if [ -n "$chnl_live" ] 
                                then
                                    printf '%s\n' "$chnl_channel_name 超时重启" >> "$MONITOR_LOG"
                                    MonitorHlsRestartChannel
                                    break 2
                                else
                                    exclude_paths+=("$LIVE_ROOT/$output_dir_name")
                                fi
                            fi
                        done
                    done < <(find "$LIVE_ROOT" -type f -name "*.ts" $exclude_command \! -newermt "-$hls_delay_seconds seconds" 2> /dev/null)

                    GetChannels

                    for output_dir_name in "${monitor_dir_names_chosen[@]}"
                    do
                        monitor_found=0
                        for((monitor_i=0;monitor_i<chnls_count;monitor_i++));
                        do
                            if [ "${chnls_output_dir_name[monitor_i]}" == "$output_dir_name" ] 
                            then
                                monitor_found=1

                                if [ "${chnls_status[monitor_i]}" == "off" ] 
                                then
                                    if [ "${chnls_stream_link[monitor_i]:0:23}" == "https://www.youtube.com" ] || [ "${chnls_stream_link[monitor_i]:0:19}" == "https://youtube.com" ]
                                    then
                                        sleep 10
                                    else
                                        sleep 5
                                    fi
                                    chnl_status=""
                                    GetChannel
                                    if [ -z "$chnl_status" ] 
                                    then
                                        declare -a new_array
                                        for element in "${monitor_dir_names_chosen[@]}"
                                        do
                                            [ "$element" != "$output_dir_name" ] && new_array+=("$element")
                                        done
                                        if [ -z "${new_array:-}" ] 
                                        then
                                            monitor_dir_names_chosen=()
                                        else
                                            monitor_dir_names_chosen=("${new_array[@]}")
                                        fi
                                        unset new_array
                                        break 2
                                    fi
                                    if [ "$chnl_status" == "off" ] 
                                    then
                                        printf '%s\n' "$chnl_channel_name 开启" >> "$MONITOR_LOG"
                                        MonitorHlsRestartChannel
                                        break 2
                                    fi
                                fi

                                if [ "${rand_restart_hls_done:-}" != 0 ] && [ "$anti_leech_yn" == "yes" ] && [ "${chnls_encrypt[monitor_i]}" == "yes" ] && [[ $((now-chnls_key_time[monitor_i])) -gt $hls_key_period ]] && ls -A "$LIVE_ROOT/$output_dir_name/"*.key > /dev/null 2>&1
                                then
                                    while IFS= read -r old_key 
                                    do
                                        old_key_name=${old_key##*/}
                                        old_key_name=${old_key_name%%.*}
                                        [ "$old_key_name" != "${chnls_key_name[monitor_i]}" ] && rm -f "$old_key"
                                    done < <(find "$LIVE_ROOT/$output_dir_name" -type f -name "*.key" \! -newermt "-$hls_key_expire_seconds seconds" 2> /dev/null)

                                    new_key_name=$(RandStr)
                                    if openssl rand 16 > "$LIVE_ROOT/$output_dir_name/$new_key_name.key" 
                                    then
                                        if [ "${chnls_encrypt_session[monitor_i]}" == "yes" ] 
                                        then
                                            if ! echo -e "/keys?key=$new_key_name&channel=$output_dir_name\n$LIVE_ROOT/$output_dir_name/$new_key_name.key\n$(openssl rand -hex 16)" > "$LIVE_ROOT/$output_dir_name/${chnls_keyinfo_name[monitor_i]}.keyinfo"
                                            then
                                                break 2
                                            fi
                                        else
                                            if ! echo -e "$new_key_name.key\n$LIVE_ROOT/$output_dir_name/$new_key_name.key\n$(openssl rand -hex 16)" > "$LIVE_ROOT/$output_dir_name/${chnls_keyinfo_name[monitor_i]}.keyinfo"
                                            then
                                                break 2
                                            fi
                                        fi
                                        JQ update "$CHANNELS_FILE" '.channels|=map(select(.pid=='"${chnls_pid[monitor_i]}"') * 
                                        {
                                            key_name: "'"$new_key_name"'",
                                            key_time: '"$now"'
                                        } // .)'
                                    else
                                        break 2
                                    fi
                                fi

                                if [ "$loop" -eq 1 ] && { [ "$anti_leech_yn" == "no" ] || [ "${chnls_encrypt[monitor_i]}" == "no" ]; }
                                then
                                    if [ "${chnls_encrypt[monitor_i]}" == "yes" ] 
                                    then
                                        if [ -e "$LIVE_ROOT/$output_dir_name/${chnls_keyinfo_name[monitor_i]}.keyinfo" ] && \
                                        [ -e "$LIVE_ROOT/$output_dir_name/${chnls_key_name[monitor_i]}.key" ] && \
                                        iv_hex=$(awk 'NR==3{print}' "$LIVE_ROOT/$output_dir_name/${chnls_keyinfo_name[monitor_i]}.keyinfo") && \
                                        encrypt_key=$(hexdump -e '16/1 "%02x"' < "$LIVE_ROOT/$output_dir_name/${chnls_key_name[monitor_i]}.key")
                                        then
                                            encrypt_command="-key $encrypt_key -iv $iv_hex"
                                        else
                                            printf '%s\n' "$chnl_channel_name 开启" >> "$MONITOR_LOG"
                                            MonitorHlsRestartChannel
                                            break 2
                                        fi
                                    else
                                        encrypt_command=""
                                    fi

                                    audio=0
                                    video=0
                                    video_bitrate=0
                                    bitrate_check=0
                                    f_count=1
                                    for f in "$LIVE_ROOT/$output_dir_name/${chnls_seg_dir_name[monitor_i]}/"*.ts
                                    do
                                        ((f_count++))
                                    done

                                    f_num=$((f_count/2))
                                    f_count=1

                                    for f in "$LIVE_ROOT/$output_dir_name/${chnls_seg_dir_name[monitor_i]}/"*.ts
                                    do
                                        if [ "$f_count" -lt "$f_num" ] 
                                        then
                                            ((f_count++))
                                            continue
                                        fi
                                        [ -n "$encrypt_command" ] && f="crypto:$f"
                                        while IFS= read -r line 
                                        do
                                            if [[ $line == *"codec_type=video"* ]] 
                                            then
                                                video=1
                                            elif [ "$bitrate_check" -eq 0 ] && [ "$video" -eq 1 ] && [[ $line == *"bit_rate="* ]] 
                                            then
                                                line=${line#*bit_rate=}
                                                video_bitrate=${line//N\/A/$hls_min_bitrates}
                                                bitrate_check=1
                                            elif [[ $line == *"codec_type=audio"* ]] 
                                            then
                                                audio=1
                                            elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                                            then
                                                audio=0
                                            fi
                                        done < <($FFPROBE $encrypt_command -i "$f" -show_streams -loglevel quiet)
                                        break
                                    done

                                    if [ "$audio" -eq 0 ] || [ "$video" -eq 0 ] || [[ $video_bitrate -lt $hls_min_bitrates ]]
                                    then
                                        [ -n "$encrypt_command" ] && f="crypto:$f"
                                        fail_count=1
                                        f_count=1
                                        for f in "$LIVE_ROOT/$output_dir_name/${chnls_seg_dir_name[monitor_i]}/"*.ts
                                        do
                                            if [ "$f_count" -lt "$f_num" ] 
                                            then
                                                ((f_count++))
                                                continue
                                            fi
                                            [ ! -e "$f" ] && continue
                                            audio=0
                                            video=0
                                            video_bitrate=0
                                            bitrate_check=0
                                            while IFS= read -r line 
                                            do
                                                if [[ $line == *"codec_type=video"* ]] 
                                                then
                                                    video=1
                                                elif [ "$bitrate_check" -eq 0 ] && [ "$video" -eq 1 ] && [[ $line == *"bit_rate="* ]] 
                                                then
                                                    line=${line#*bit_rate=}
                                                    video_bitrate=${line//N\/A/$hls_min_bitrates}
                                                    bitrate_check=1
                                                elif [[ $line == *"codec_type=audio"* ]] 
                                                then
                                                    audio=1
                                                elif [[ $line == *"sample_fmt=unknown"* ]] || [[ $line == *"sample_rate=0"* ]] || [[ $line == *"channels=0"* ]] 
                                                then
                                                    audio=0
                                                fi
                                            done < <($FFPROBE $encrypt_command -i "$f" -show_streams -loglevel quiet)

                                            if [ "$audio" -eq 0 ] || [ "$video" -eq 0 ] || [[ $video_bitrate -lt $hls_min_bitrates ]]
                                            then
                                                ((fail_count++))
                                            fi
                                            if [ "$fail_count" -gt 3 ] 
                                            then
                                                GetChannel
                                                printf '%s\n' "$chnl_channel_name 比特率过低重启" >> "$MONITOR_LOG"
                                                MonitorHlsRestartChannel
                                                break 2
                                            fi
                                        done
                                    fi
                                fi
                                break 1
                            fi
                        done

                        if [ "$monitor_found" -eq 0 ] 
                        then
                            declare -a new_array
                            for element in "${monitor_dir_names_chosen[@]}"
                            do
                                [ "$element" != "$output_dir_name" ] && new_array+=("$element")
                            done
                            if [ -z "${new_array:-}" ] 
                            then
                                monitor_dir_names_chosen=()
                            else
                                monitor_dir_names_chosen=("${new_array[@]}")
                            fi
                            unset new_array
                            break 1
                        elif [ -n "${rand_restart_hls_done:-}" ] && [ "$rand_restart_hls_done" -eq 0 ] 
                        then
                            rand_found=1
                            GetChannel
                            printf '%s\n' "$chnl_channel_name HLS 随机重启" >> "$MONITOR_LOG"
                            MonitorHlsRestartChannel
                        fi
                    done

                    if [ "$rand_found" -eq 1 ] 
                    then
                        rand_restart_hls_done=1
                    fi
                else
                    rand_restart_hls_done=1
                fi

                PrepTerm
                sleep 10 &
                WaitTerm
            done
        } 203>&-
    } 203<"$pid_file"
}

MonitorStop()
{
    printf -v date_now '%(%m-%d %H:%M:%S)T' -1

    # deprecated
    if ls -A "/tmp/monitor.lockdir/"* > /dev/null 2>&1
    then
        for PID in "/tmp/monitor.lockdir/"*
        do
            PID=${PID##*/}
            if kill -0 "$PID" 2> /dev/null
            then
                kill "$PID" 2> /dev/null
                printf '%s\n' "$date_now 关闭监控 PID $PID !" >> "$MONITOR_LOG"
            else
                rm -f "/tmp/monitor.lockdir/$PID"
            fi
        done

        Println "$info 关闭监控, 稍等..."

        until ! ls -A "/tmp/monitor.lockdir/"* > /dev/null 2>&1
        do
            sleep 1
        done

        rm -rf "/tmp/monitor.lockdir/"
        Println "$info 监控关闭成功 !\n"
    fi

    if [ -s "$IPTV_ROOT/monitor.pid" ]
    then
        PID=$(< "$IPTV_ROOT/monitor.pid")
        if kill -0 "$PID" 2> /dev/null 
        then
            Println "$info 关闭 HLS/FLV 监控, 稍等..."
            kill "$PID" 2> /dev/null

            i=0
            while ps -p $PID -o pid= >/dev/null
            do
                sleep 0.05
                i=$((i+1))
                [ "$i" == 200 ] && Println "$error HLS/FLV 监控关闭超时, 请重试\n" && exit 1
            done

            rm -f "$IPTV_ROOT/monitor.pid"
            Println "$info HLS/FLV 监控 关闭成功 !\n"
            printf '%s\n' "$date_now 关闭监控 PID $PID !" >> "$MONITOR_LOG"
        else
            rm -f "$IPTV_ROOT/monitor.pid"
            Println "$info HLS/FLV 监控 关闭成功 !\n"
        fi
    else
        [ -e "$IPTV_ROOT/monitor.pid" ] && rm -f "$IPTV_ROOT/monitor.pid"
        Println "$error HLS/FLV 监控 未开启\n"
    fi

    if [ -s "$IPTV_ROOT/antiddos.pid" ] 
    then
        PID=$(< "$IPTV_ROOT/antiddos.pid")
        if kill -0 "$PID" 2> /dev/null 
        then
            Println "$info 关闭 antiddos, 稍等..."
            kill "$PID" 2> /dev/null
            if flock -E 1 -w 20 -x "$IPTV_ROOT/antiddos.pid" rm -f "$IPTV_ROOT/antiddos.pid"
            then
                Println "$info AntiDDos 监控 关闭成功 !\n"
                printf '%s\n' "$date_now 关闭 antiddos PID $PID !" >> "$MONITOR_LOG"
            else
                Println "$error AntiDDos 监控关闭超时, 请重试\n"
                exit 1
            fi
        else
            rm -f "$IPTV_ROOT/antiddos.pid"
            Println "$info AntiDDos 监控 关闭成功 !\n"
        fi
    elif [ -e "$IPTV_ROOT/antiddos.pid" ]
    then
        rm -f "$IPTV_ROOT/antiddos.pid"
        Println "$error AntiDDos 监控 未开启\n"
    fi

    if [ -s "$IP_DENY" ] 
    then
        ips=()
        jail_time=()
        GetDefault
        if [[ $d_anti_ddos_port == *","* ]] || [[ $d_anti_ddos_port =~ - ]] 
        then
            d_anti_ddos_port="$d_anti_ddos_port proto tcp"
        fi
        while IFS= read -r line
        do
            if [[ $line == *:* ]] 
            then
                ip=${line%:*}
                jail=${line#*:}
                ips+=("$ip")
                jail_time+=("$jail")
            else
                ip=$line
                ufw delete deny from "$ip" to any port $d_anti_ddos_port
            fi
        done < "$IP_DENY"

        if [ -n "${ips:-}" ] 
        then
            new_ips=()
            new_jail_time=()
            printf -v now '%(%s)T' -1

            update=0
            for((i=0;i<${#ips[@]};i++));
            do
                if [ "$now" -gt "${jail_time[i]}" ] 
                then
                    ufw delete deny from "${ips[i]}" to any port $d_anti_ddos_port
                    update=1
                else
                    new_ips+=("${ips[i]}")
                    new_jail_time+=("${jail_time[i]}")
                fi
            done

            if [ "$update" -eq 1 ] 
            then
                ips=("${new_ips[@]}")
                jail_time=("${new_jail_time[@]}")

                printf '%s' "" > "$IP_DENY"

                for((i=0;i<${#ips[@]};i++));
                do
                    printf '%s\n' "${ips[i]}:${jail_time[i]}" >> "$IP_DENY"
                done
            fi
        else
            printf '%s' "" > "$IP_DENY"
        fi
    fi
}

MonitorError()
{
    printf -v date_now '%(%m-%d %H:%M:%S)T' -1
    printf '%s\n' "$date_now [ERROR: $1]" >> "$MONITOR_LOG"
}

XtreamCodesGetDomains()
{
    [ -n "${xtream_codes_domains:-}" ] && return 0

    if [ ! -s "$XTREAM_CODES" ] 
    then
        curl -s -L $XTREAM_CODES_LINK -o "$XTREAM_CODES"
    fi

    IFS="," read -ra xtream_codes_domains <<< $(awk -v ORS=, '$1 { gsub(/\|/, ",", $2); print $2 }' "$XTREAM_CODES")
}

XtreamCodesGetChnls()
{
    xc_chnls=()
    xc_chnls_mac=()
    if [ -n "${xtream_codes_domains:-}" ] 
    then
        GetChannels
        if [ "$chnls_count" -gt 0 ] 
        then
            for((xc_i=0;xc_i<chnls_count;xc_i++));
            do
                if { [ "${chnls_status[xc_i]}" == "on" ] && [ "${chnls_output_dir_name[xc_i]}" != "${chnl_output_dir_name:-}" ]; } || { [ "${chnls_flv_status[xc_i]}" == "on" ] && [ "${chnls_flv_push_link[xc_i]}" != "${chnl_flv_push_link:-}" ]; } 
                then
                    if [[ ${chnls_stream_link[xc_i]##*|} =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
                    then
                        f_domain=${chnls_stream_link[xc_i]%%|*}
                        for xc_domain in "${xtream_codes_domains[@]}"
                        do
                            if [ "$f_domain" == "$xc_domain" ] 
                            then
                                xc_chnls_mac+=("$f_domain/${BASH_REMATCH[0]}")
                                break
                            fi
                        done
                    elif [[ ${chnls_stream_link[xc_i]} =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]]
                    then
                        if [ "${BASH_REMATCH[2]}" != "live" ] || [[ ${chnls_stream_link[xc_i]} =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]]
                        then
                            f_domain=${BASH_REMATCH[1]}
                            for xc_domain in "${xtream_codes_domains[@]}"
                            do
                                if [ "$f_domain" == "$xc_domain" ] 
                                then
                                    xc_chnls+=("$f_domain/${BASH_REMATCH[2]}:${BASH_REMATCH[3]}")
                                    break
                                fi
                            done
                        fi
                    fi
                fi
            done
        fi
    fi
}

XtreamCodesAddAccount()
{
    echo && read -p "请输入账号(需包含服务器地址): " xtream_codes_input
    [ -z "$xtream_codes_input" ] && Println "$i18n_canceled...\n" && exit 1

    if [[ $xtream_codes_input == *"username="* ]] 
    then
        domain=${xtream_codes_input#*http://}
        domain=${domain%%/*}
        username=${xtream_codes_input#*username=}
        username=${username%%&*}
        password=${xtream_codes_input#*password=}
        password=${password%%&*}
        ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true
    elif [[ $xtream_codes_input =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]] 
    then
        if [ "${BASH_REMATCH[2]}" == "live" ] 
        then
            if [[ $line =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]] 
            then
                domain=${BASH_REMATCH[1]}
                username=${BASH_REMATCH[2]}
                password=${BASH_REMATCH[3]}
            else
                Println "$error 输入错误\n" && exit 1
            fi
        else
            domain=${BASH_REMATCH[1]}
            username=${BASH_REMATCH[2]}
            password=${BASH_REMATCH[3]}
        fi
        ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true
    else
        Println "$error 输入错误\n" && exit 1
    fi

    [ -z "${ip:-}" ] && Println "$error 无法解析域名 !\n" && exit 1
    printf '%s\n' "$ip $domain $username:$password" >> "$XTREAM_CODES_EXAM"

    Println "$info 账号添加成功 !\n"
}

VerifyXtreamCodesMac()
{
    trap '
        printf "%s" "" > "$XTREAM_CODES_EXAM"
        exit
    ' SIGINT

    if [ "${test_mac_domain:-}" != "$domain" ] 
    then
        Println "$info 验证 $domain ..."
        test_mac_domain=$domain

        server="http://$domain"
        xc_host_header=()
    fi

    to_continue=0
    if [ "${skip_domain:-}" == "$domain" ] 
    then
        to_continue=1
        return 0
    fi

    ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true
    if [ -z "$ip" ] 
    then
        to_continue=1
        skip_domain=$domain
        return 0
    fi

    if [ -n "${skip_mac_ip:-}" ] 
    then
        for((i=0;i<${#skip_mac_ip[@]};i++));
        do
            if [ "${skip_mac_ip[i]}" == "$ip" ] && [[ ${skip_mac_ip[i]} == *"${BASH_REMATCH[1]}"* ]] 
            then
                to_continue=1
                return 0
            fi
        done
    fi

    access_token=""
    profile=""
    mac=$(UrlencodeUpper "$mac_address")
    timezone=$(UrlencodeUpper "Europe/Amsterdam")
    token_url="$server/portal.php?type=stb&action=handshake"
    profile_url="$server/portal.php?type=stb&action=get_profile"

    access_token=$(curl -s -Lm 10 \
        -H "User-Agent: $USER_AGENT_TV" \
        ${xc_host_header[@]+"${xc_host_header[@]}"} \
        --cookie "mac=$mac; stb_lang=en; timezone=$timezone" "$token_url" \
        | $JQ_FILE -r '.js.token') || true
    if [ -z "$access_token" ] 
    then
        Println "$error $domain $mac_address"
        return 0
    fi

    profile=$(curl -s -Lm 10 \
        -H "User-Agent: $USER_AGENT_TV" \
        ${xc_host_header[@]+"${xc_host_header[@]}"} \
        -H "Authorization: Bearer $access_token" \
        --cookie "mac=$mac; stb_lang=en; timezone=$timezone" "$profile_url") || true
    if [ -z "$profile" ] 
    then
        Println "$error $domain $mac_address profile"
        return 0
    fi

    if [[ $($JQ_FILE -r '.js.id' <<< "$profile") == null ]] 
    then
        Println "$error $mac_address 地址错误!"
        return 0
    else
        account=$mac_address
    fi
}

XtreamCodesList()
{
    [ ! -s "$XTREAM_CODES" ] && Println "$error 没有账号 !\n" && exit 1

    ips=()
    new_domains=()
    new_accounts=()
    verify=${verify:-0}

    if [ "$verify" -eq 0 ] 
    then
        IFS=" " read -r m_ip m_domains m_accounts < <(awk '$1 {a=a $1",";b=b $2",";$1=$2="";c=c substr($0,3)","} END {print a,b,c}' "$XTREAM_CODES")
        IFS="," read -r -a ips <<< "$m_ip"
        IFS="," read -r -a new_domains <<< "$m_domains"
        IFS="," read -r -a new_accounts <<< "$m_accounts"
    fi

    if [ -s "$XTREAM_CODES_EXAM" ] 
    then
        while IFS= read -r line 
        do
            if [[ $line =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3} ]] 
            then
                if [[ $line =~ ([^ ]+)\ ([^ ]+)\ ([^ ]+) ]] 
                then
                    if [ "$verify" -eq 1 ] 
                    then
                        ip=${BASH_REMATCH[1]}
                        domain=${BASH_REMATCH[2]}
                        mac_address=${BASH_REMATCH[3]}
                        if [[ $mac_address =~ (([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})) ]] 
                        then
                            VerifyXtreamCodesMac 2> /dev/null
                            if [ "$to_continue" -eq 1 ] 
                            then
                                continue
                            fi
                        fi
                        account=$mac_address
                    else
                        ip=${BASH_REMATCH[1]}
                        domain=${BASH_REMATCH[2]}
                        account=${BASH_REMATCH[3]}
                    fi
                else
                    continue
                fi
            elif [[ $line == *"username="* ]] 
            then
                domain=${line#*http://}
                domain=${domain%%/*}
                username=${line#*username=}
                username=${username%%&*}
                password=${line#*password=}
                password=${password%%&*}
                ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true
                [ -z "$ip" ] && continue
                account="$username:$password"
            elif [[ $line =~ http://([^/]+)/([^/]+)/([^/]+)/ ]] 
            then
                if [ "${BASH_REMATCH[2]}" == "live" ] 
                then
                    if [[ $line =~ http://([^/]+)/live/([^/]+)/([^/]+)/ ]] 
                    then
                        domain=${BASH_REMATCH[1]}
                        username=${BASH_REMATCH[2]}
                        password=${BASH_REMATCH[3]}
                    else
                        continue
                    fi
                else
                    domain=${BASH_REMATCH[1]}
                    username=${BASH_REMATCH[2]}
                    password=${BASH_REMATCH[3]}
                fi

                ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true
                [ -z "$ip" ] && continue
                account="$username:$password"
            elif [[ $line =~ http://([^/]+)/ ]] 
            then
                stb_domain=${BASH_REMATCH[1]}

                if [[ ! $line =~ (([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})) ]] 
                then
                    continue
                fi

                domain=$stb_domain
                mac_address=${BASH_REMATCH[1]}
                VerifyXtreamCodesMac 2> /dev/null

                if [ "$to_continue" -eq 1 ] 
                then
                    continue
                fi

                account=$mac_address
            elif [ -n "${stb_domain:-}" ] && [[ $line =~ (([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})) ]] 
            then
                domain=$stb_domain
                mac_address=${BASH_REMATCH[1]}
                VerifyXtreamCodesMac 2> /dev/null
                if [ "$to_continue" -eq 1 ] 
                then
                    continue
                fi
                account=$mac_address
            else
                continue
            fi

            for((i=0;i<${#ips[@]};i++));
            do
                if [[ ${ips[i]} == *"$ip"* ]] 
                then
                    if ! [[ ${new_domains[i]} == *"$domain"* ]] 
                    then
                        new_domains[i]="${new_domains[i]}|$domain"
                    fi

                    if ! [[ ${new_accounts[i]} == *"$account"* ]] 
                    then
                        new_accounts[i]="${new_accounts[i]} $account"
                    fi
                    continue 2
                fi
            done

            for((i=0;i<${#new_domains[@]};i++));
            do
                if [[ ${new_domains[i]} == *"$domain"* ]] 
                then
                    if ! [[ ${ips[i]} == *"$ip"* ]] 
                    then
                        ips[i]="${ips[i]}|$ip"
                    fi

                    if ! [[ ${new_accounts[i]} == *"$account"* ]] 
                    then
                        new_accounts[i]="${new_accounts[i]} $account"
                    fi
                    continue 2
                fi
            done

            ips+=("$ip")
            new_domains+=("$domain")
            new_accounts+=("$account")
        done < <(awk '$1=$1' "$XTREAM_CODES_EXAM")
    fi

    if [ -n "${ips:-}" ] 
    then
        ips_count=${#ips[@]}
        print_list=""
        xtream_codes_list=""
        ips_acc_count=0
        ips_acc=()
        ips_mac_count=0
        ips_mac=()

        for((i=0;i<ips_count;i++));
        do
            print_list="$print_list${ips[i]} ${new_domains[i]} ${new_accounts[i]}\n"
            IFS=" " read -ra accounts <<< "${new_accounts[i]}"
            accounts_list=""
            macs_num=0
            accs_num=0
            for account in "${accounts[@]}"
            do
                if [ "${1:-}" == "mac" ] 
                then
                    if [[ $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
                    then
                        macs_num=$((macs_num+1))
                        accounts_list="$accounts_list${account}\n"
                    fi
                elif [[ ! $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
                then
                    accs_num=$((accs_num+1))
                    accounts_list="$accounts_list${account%:*}${indent_20}${account#*:}\n"
                fi
            done
            if [ -n "$accounts_list" ] 
            then
                if [ "${1:-}" == "mac" ] 
                then
                    ips_mac+=("$i")
                    ips_mac_count=$((ips_mac_count+1))
                    xtream_codes_list="$xtream_codes_list ${green}$ips_mac_count.${normal} IP: ${green}${ips[i]//|/, }${normal} 域名: ${green}${new_domains[i]//|/, }${normal} mac 地址个数: ${green}$macs_num${normal}\n\n"
                else
                    ips_acc+=("$i")
                    ips_acc_count=$((ips_acc_count+1))
                    xtream_codes_list="$xtream_codes_list ${green}$ips_acc_count.${normal} IP: ${green}${ips[i]//|/, }${normal} 域名: ${green}${new_domains[i]//|/, }${normal} 账号个数: ${green}$accs_num${normal}\n\n"
                fi
            fi
        done

        if [ -s "$XTREAM_CODES_EXAM" ] 
        then
            printf '%b' "$print_list" > "$XTREAM_CODES"
            printf '%s' "" > "$XTREAM_CODES_EXAM"
        fi

        if [ "${1:-}" == "mac" ] && [ "$ips_mac_count" -eq 0 ]
        then
            Println "$error 请先添加 mac 地址!\n" && exit 1
        else
            Println "$xtream_codes_list"
        fi
    else
        Println "$error 没有账号!\n" && exit 1
    fi
}

XtreamCodesListAcc()
{
    XtreamCodesList

    Println "请输入服务器的序号"
    while read -p "$i18n_default_cancel" server_num
    do
        case $server_num in
            "") Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$server_num" -gt 0 ] && [ "$server_num" -le "$ips_acc_count" ]
                then
                    ips_index=${ips_acc[server_num-1]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    domain=${new_domains[ips_index]}

    if [[ $domain == *"|"* ]] 
    then
        IFS="|" read -ra domains <<< "$domain"
        domains_list=""
        domains_count=${#domains[@]}
        for((i=0;i<domains_count;i++));
        do
            domains_list="$domains_list ${green}$((i+1)).${normal}${indent_6}${domains[i]}\n\n"
        done
        Println "$domains_list"

        Println "请选择域名"
        while read -p "$i18n_default_cancel" domains_num
        do
            case $domains_num in
                "") Println "$i18n_canceled...\n" && exit 1
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$domains_num" -gt 0 ] && [ "$domains_num" -le "$domains_count" ]
                    then
                        domain=${domains[domains_num-1]}
                        break
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done
    fi

    account=${new_accounts[ips_index]}
    IFS=" " read -ra accounts <<< "$account"

    accs=()
    for account in "${accounts[@]}"
    do
        if [[ ! $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
        then
            accs+=("$account")
        fi
    done

    XtreamCodesGetDomains
    XtreamCodesGetChnls

    accs_count=${#accs[@]}
    if [ "$accs_count" -gt 1 ] 
    then
        accs_list="账号: \n\n"
        for((i=0;i<accs_count;i++));
        do
            using=""
            for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
            do
                if [ "$xc_chnl" == "$domain/${accs[i]}" ] 
                then
                    using="${red}[使用中]${normal}"
                    break
                fi
            done
            accs_list="$accs_list ${green}$((i+1)).${normal}${indent_6}${accs[i]%:*}${indent_20}${accs[i]#*:} $using\n\n"
        done
        Println "$accs_list"
    else
        using=""
        for xc_chnl in ${xc_chnls[@]+"${xc_chnls[@]}"}
        do
            if [ "$xc_chnl" == "$domain/${accs[i]}" ] 
            then
                using="${red}[使用中]${normal}"
                break
            fi
        done
        Println "账号: \n\n${green}1.${normal} ${accs[0]%:*}${indent_20}${accs[0]#*:} $using\n"
    fi
}

XtreamCodesTestAcc()
{
    XtreamCodesList

    Println "请输入服务器的序号"
    while read -p "$i18n_default_cancel" server_num
    do
        case $server_num in
            "") Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$server_num" -gt 0 ] && [ "$server_num" -le "$ips_acc_count" ]
                then
                    ips_index=${ips_acc[server_num-1]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "请输入测试的频道ID"
    while read -p "$i18n_default_cancel" channel_id
    do
        case $channel_id in
            "") Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$channel_id" -gt 0 ]
                then
                    break
                else
                    Println "$error 请输入正确的频道ID(大于0)\n"
                fi
            ;;
        esac
    done

    chnls=()

    Println "比如 http://username:passsword@127.0.0.1:5555"
    inquirer text_input "输入 ffmpeg 代理: " proxy "不设置"

    if [ "$proxy" == "不设置" ] 
    then
        proxy_command=""
    else
        proxy_command="-http_proxy $proxy"
        Println "代理服务器如果有正在使用的账号需要排除, 输入代理服务器的 channels.json 链接或本地路径"
        read -p "(默认: 无): " proxy_channels_json
        if [ -n "$proxy_channels_json" ] 
        then
            if [ "${proxy_channels_json:0:1}" == "/" ] 
            then
                proxy_channels=$(< "$proxy_channels_json")
            else
                proxy_channels=$(curl -s -Lm 10 "$proxy_channels_json")
            fi
            while IFS= read -r line 
            do
                if [[ $line == *\"status\":* ]] 
                then
                    line=${line#*: \"}
                    status=${line%\",*}
                elif [[ $line == *\"stream_link\":* ]] && [[ $line == *http://*/*/*/* ]]
                then
                    line=${line#*: \"http://}
                    chnl_domain=${line%%/*}
                    line=${line#*/}
                    chnl_username=${line%%/*}
                    if [ "$chnl_username" == "live" ] 
                    then
                        line=${line#*/}
                        chnl_username=${line%%/*}
                    fi
                    line=${line#*/}
                    chnl_password=${line%%/*}
                elif [[ $line == *\"flv_status\":* ]] 
                then
                    line=${line#*: \"}
                    flv_status=${line%\",*}
                    if [ -n "${chnl_domain:-}" ] 
                    then
                        if [ "$status" == "on" ] || [ "$flv_status" == "on" ]
                        then
                            chnls+=("$chnl_domain/$chnl_username/$chnl_password")
                        fi
                    fi
                    chnl_domain=""
                fi
            done <<< "$proxy_channels"
        fi
    fi

    if [ -e "$CHANNELS_FILE" ] 
    then
        GetChannels
        if [ "$chnls_count" -gt 0 ] 
        then
            for((xc_i=0;xc_i<chnls_count;xc_i++));
            do
                if [ "${chnls_status[xc_i]}" == "on" ] || [ "${chnls_flv_status[xc_i]}" == "on" ]
                then
                    if [[ ${chnls_stream_link[xc_i]} =~ ^http://([^/]+)/([^/]+)/([^/]+)/ ]]
                    then
                        if [ "${BASH_REMATCH[2]}" != "live" ] || [[ ${chnls_stream_link[xc_i]} =~ ^http://([^/]+)/live/([^/]+)/([^/]+)/ ]]
                        then
                            chnls+=("${BASH_REMATCH[1]}/${BASH_REMATCH[2]}:${BASH_REMATCH[3]}")
                        fi
                    fi
                fi
            done
        fi
    fi

    IFS="|" read -ra domains <<< "${new_domains[ips_index]}"
    IFS=" " read -ra accounts <<< "${new_accounts[ips_index]}"
    Println "IP: ${green}${ips[ips_index]}${normal} 域名: ${green}${new_domains[ips_index]//|/ }${normal}"
    Println "${green}账号:${normal}"

    FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
    FFPROBE="$FFMPEG_ROOT/ffprobe"

    for account in "${accounts[@]}"
    do
        if [[ $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
        then
            continue
        fi
        username=${account%%:*}
        account=${account#*:}
        password=${account%%:*}

        for domain in "${domains[@]}"
        do
            for chnl in ${chnls[@]+"${chnls[@]}"}
            do
                if [ "$domain/$username/$password" == "$chnl" ] 
                then
                    # https://f-hauri.ch/vrac/diffU8test.sh
                    printf "${green}%s${normal}\r\033[12C%-21s%-21s\n" "[使用中]" "$username" "$password"
                    continue 2
                fi
            done

            # curl --output /dev/null -m 3 -s --fail -r 0-0
            if $FFPROBE $proxy_command -i "http://$domain/$username/$password/$channel_id" -rw_timeout 5000000 -show_streams -select_streams a -loglevel quiet > /dev/null
            then
                printf "${green}%s${normal}\r\033[12C%-21s%-21s${green}%s${normal}\n%s\n\n" "[成功]" "$username" "$password" "$domain" "http://$domain/$username/$password/$channel_id"
            elif $FFPROBE $proxy_command -i "http://$domain/live/$username/$password/$channel_id.ts" -rw_timeout 5000000 -show_streams -select_streams a -loglevel quiet > /dev/null 
            then
                printf "${green}%s${normal}\r\033[12C%-21s%-21s${green}%s${normal}\n%s\n\n" "[成功]" "$username" "$password" "$domain" "http://$domain/live/$username/$password/$channel_id.ts"
            else
                printf "${red}%s${normal}\r\033[12C%-21s%-21s${red}%s${normal}\n%s" "[失败]" "$username" "$password" "$domain"
            fi
        done
    done
    echo
}

XtreamCodesListMac()
{
    XtreamCodesList mac

    Println "请输入服务器的序号"
    while read -p "$i18n_default_cancel" server_num
    do
        case $server_num in
            "") Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$server_num" -gt 0 ] && [ "$server_num" -le "$ips_mac_count" ]
                then
                    ips_index=${ips_mac[server_num-1]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    domain=${new_domains[ips_index]}

    if [[ $domain == *"|"* ]] 
    then
        IFS="|" read -ra domains <<< "$domain"
        domains_list=""
        domains_count=${#domains[@]}
        for((i=0;i<domains_count;i++));
        do
            domains_list="$domains_list ${green}$((i+1)).${normal}${indent_6}${domains[i]}\n\n"
        done
        Println "$domains_list"

        Println "请选择域名"
        while read -p "$i18n_default_cancel" domains_num
        do
            case $domains_num in
                "") Println "$i18n_canceled...\n" && exit 1
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$domains_num" -gt 0 ] && [ "$domains_num" -le "$domains_count" ]
                    then
                        domain=${domains[domains_num-1]}
                        break
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done
    fi

    account=${new_accounts[ips_index]}
    IFS=" " read -ra accounts <<< "$account"

    macs=()
    for account in "${accounts[@]}"
    do
        if [[ $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
        then
            macs+=("$account")
        fi
    done

    XtreamCodesGetDomains
    XtreamCodesGetChnls

    macs_count=${#macs[@]}
    if [ "$macs_count" -gt 1 ] 
    then
        macs_list="mac 地址: \n\n"
        for((i=0;i<macs_count;i++));
        do
            using=""
            for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
            do
                if [ "$xc_chnl_mac" == "$domain/${macs[i]}" ] 
                then
                    using="${red}[使用中]${normal}"
                    break
                fi
            done
            macs_list="$macs_list ${green}$((i+1)).${normal}${indent_6}${macs[i]} $using\n\n"
        done
        Println "$macs_list"
    else
        using=""
        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
        do
            if [ "$xc_chnl_mac" == "$domain/${macs[i]}" ] 
            then
                using="${red}[使用中]${normal}"
                break
            fi
        done
        Println "mac 地址: \n\n${green}$((i+1)).${normal}${indent_6}${macs[0]} $using\n"
    fi
}

SearchXtreamCodesChnls()
{
    search_result=""

    for((i=1;i<=pages;i++));
    do
        if [ "$i" -gt 1 ] 
        then
            echo -en "\r$((i*100/pages))%"
        else
            Println "$info 搜索进度"
            echo -n "$((i*100/pages))%"
        fi
        sleep 1
        page_index=$((i-1))
        if [ -n "${ordered_list_pages[page_index]:-}" ] 
        then
            ordered_list_page=${ordered_list_pages[page_index]}
        else
            if [ "$i" -gt 1 ] 
            then
                ordered_list_url="$server/portal.php?type=itv&action=get_ordered_list&genre=${genres_id[genres_index]}&force_ch_link_check=&fav=0&sortby=number&hd=0&p=$i"
                ordered_list_page=$(curl -s -Lm 10 \
                    -H "User-Agent: $user_agent" \
                    -H "${headers:0:-4}" \
                    --cookie "$cookies" "$ordered_list_url")
            fi
            ordered_list_pages[page_index]=$ordered_list_page
        fi

        while IFS= read -r name
        do
            name=${name#\"}
            name=${name%\"}
            name_lower=$(tr '[:upper:]' '[:lower:]' <<< "$name")
            if [[ $name_lower == *"$search_phrase"* ]] 
            then
                search_result="$search_result页数: ${green}$i${normal} 频道名称: ${green}$name${normal}\n\n"
            fi
        done < <($JQ_FILE '.js.data[].name' <<< "$ordered_list_page")
    done
}

XtreamCodesListChnls()
{
    while true 
    do
        if [ -n "${xtream_codes_list:-}" ] 
        then
            Println "$xtream_codes_list"
        else
            XtreamCodesList mac
        fi

        Println "请输入服务器的序号"
        while read -p "$i18n_default_cancel" server_num
        do
            case $server_num in
                "") Println "$i18n_canceled...\n" && exit 1
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$server_num" -gt 0 ] && [ "$server_num" -le "$ips_mac_count" ]
                    then
                        ips_index=${ips_mac[server_num-1]}
                        break
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done

        domain=${new_domains[ips_index]}

        if [[ $domain == *"|"* ]] 
        then
            IFS="|" read -ra domains <<< "$domain"
            domains_list=""
            domains_count=${#domains[@]}
            for((i=0;i<domains_count;i++));
            do
                domains_list="$domains_list ${green}$((i+1)).${normal}${indent_6}${domains[i]}\n\n"
            done
            Println "$domains_list"

            Println "请选择域名"
            while read -p "(默认: 回到上级): " domains_num
            do
                case $domains_num in
                    ""|a) continue 2
                    ;;
                    *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                    ;;
                    *) 
                        if [ "$domains_num" -gt 0 ] && [ "$domains_num" -le "$domains_count" ]
                        then
                            domain=${domains[domains_num-1]}
                            break
                        else
                            Println "$error $i18n_input_correct_no\n"
                        fi
                    ;;
                esac
            done
        fi

        account=${new_accounts[ips_index]}
        IFS=" " read -ra accounts <<< "$account"

        macs=()
        for account in ${accounts[@]+"${accounts[@]}"}
        do
            if [[ $account =~ ^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$ ]] 
            then
                macs+=("$account")
            fi
        done

        XtreamCodesGetDomains
        XtreamCodesGetChnls

        macs_count=${#macs[@]}
        if [ "$macs_count" -gt 1 ] 
        then
            macs_list="mac 地址: \n\n"
            for((i=0;i<macs_count;i++));
            do
                using=""
                for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                do
                    if [ "$xc_chnl_mac" == "$domain/${macs[i]}" ] 
                    then
                        using="${red}[使用中]${normal}"
                        break
                    fi
                done
                macs_list="$macs_list ${green}$((i+1)).${normal}${indent_6}${macs[i]} $using\n\n"
            done
            Println "$macs_list"

            Println "请选择 mac"
            while read -p "(默认: 回到上级): " macs_num
            do
                case $macs_num in
                    ""|a) continue 2
                    ;;
                    *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                    ;;
                    *) 
                        if [ "$macs_num" -gt 0 ] && [ "$macs_num" -le "$macs_count" ]
                        then
                            mac_address=${macs[macs_num-1]}
                            for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                            do
                                if [ "$xc_chnl_mac" == "$domain/$mac_address" ] 
                                then
                                    Println "$error 此账号已经在使用!\n"
                                    continue 2
                                fi
                            done
                            break
                        else
                            Println "$error $i18n_input_correct_no\n"
                        fi
                    ;;
                esac
            done
        else
            mac_address=${macs[0]}
        fi

        user_agent="$USER_AGENT_TV"
        timezone=$(UrlencodeUpper "Europe/Amsterdam")
        mac_addresses_failed=()
        GetDefault

        if [ -n "${d_xc_proxy:-}" ] 
        then
            echo
            inquirer list_input "是否使用代理 $d_xc_proxy: " yn_options use_proxy_yn
            if [[ $use_proxy_yn == "$i18n_yes" ]]
            then
                server=${d_xc_proxy%\/}
                xc_host_header=( -H "xc_host: $domain" )
            else
                server="http://$domain"
                xc_host_header=()
            fi
        else
            server="http://$domain"
            xc_host_header=()
            use_proxy_yn="$i18n_no"
        fi

        token_url="$server/portal.php?type=stb&action=handshake"
        profile_url="$server/portal.php?type=stb&action=get_profile"
        genres_url="$server/portal.php?type=itv&action=get_genres"
        account_info_url="$server/portal.php?type=account_info&action=get_main_info"

        while true 
        do
            mac=$(UrlencodeUpper "$mac_address")
            cookies="mac=$mac; stb_lang=en; timezone=$timezone"

            access_token=$(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                ${xc_host_header[@]+"${xc_host_header[@]}"} \
                --cookie "$cookies" "$token_url" \
                | $JQ_FILE -r '.js.token') || true

            if [ -z "$access_token" ] 
            then
                Println "$error $domain $mac_address access\n"

                mac_addresses_failed+=("$mac_address")

                for mac in "${macs[@]}"
                do
                    if [ "$mac_address" != "$mac" ] 
                    then
                        for mac_address_failed in "${mac_addresses_failed[@]}"
                        do
                            if [ "$mac_address_failed" == "$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                        do
                            if [ "$xc_chnl_mac" == "$domain/$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        Println "$info 测试 $mac\n"
                        mac_address=$mac
                        continue 2
                    fi
                done
                exit 1
            fi

            headers="Authorization: Bearer $access_token\r\n"
            printf -v headers_command '%b' "$headers"

            profile=$(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                ${xc_host_header[@]+"${xc_host_header[@]}"} \
                -H "${headers:0:-4}" \
                --cookie "$cookies" "$profile_url") || true

            if [ -z "$profile" ] 
            then
                Println "$error $domain $mac_address profile\n"

                mac_addresses_failed+=("$mac_address")

                for mac in "${macs[@]}"
                do
                    if [ "$mac_address" != "$mac" ] 
                    then
                        for mac_address_failed in "${mac_addresses_failed[@]}"
                        do
                            if [ "$mac_address_failed" == "$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                        do
                            if [ "$xc_chnl_mac" == "$domain/$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        Println "$info 测试 $mac\n"
                        mac_address=$mac
                        continue 2
                    fi
                done
                exit 1
            fi

            if [[ $($JQ_FILE -r '.js.id' <<< "$profile") == null ]] 
            then
                Println "$error $domain $mac_address profile id\n"

                mac_addresses_failed+=("$mac_address")

                for mac in "${macs[@]}"
                do
                    if [ "$mac_address" != "$mac" ] 
                    then
                        for mac_address_failed in "${mac_addresses_failed[@]}"
                        do
                            if [ "$mac_address_failed" == "$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                        do
                            if [ "$xc_chnl_mac" == "$domain/$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        Println "$info 测试 $mac\n"
                        mac_address=$mac
                        continue 2
                    fi
                done
                exit 1
            fi

            exp_date=$(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                ${xc_host_header[@]+"${xc_host_header[@]}"} \
                -H "${headers:0:-4}" \
                --cookie "$cookies" "$account_info_url" | $JQ_FILE -r '.js.phone') || true

            if [ -z "$exp_date" ] 
            then
                Println "$error $domain $mac_address exp_date\n"

                mac_addresses_failed+=("$mac_address")

                for mac in "${macs[@]}"
                do
                    if [ "$mac_address" != "$mac" ] 
                    then
                        for mac_address_failed in "${mac_addresses_failed[@]}"
                        do
                            if [ "$mac_address_failed" == "$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                        do
                            if [ "$xc_chnl_mac" == "$domain/$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        Println "$info 测试 $mac\n"
                        mac_address=$mac
                        continue 2
                    fi
                done
                exit 1
            fi

            genres_list=""
            genres_count=0
            genres_id=()
            while IFS="=" read -r map_id map_title
            do
                map_id=${map_id#\"}
                map_title=${map_title%\"}
                genres_count=$((genres_count+1))
                genres_id+=("$map_id")
                genres_list="$genres_list ${green}$genres_count.${normal}${indent_6}$map_title\n\n"
            done < <(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                ${xc_host_header[@]+"${xc_host_header[@]}"} \
                -H "${headers:0:-4}" \
                --cookie "$cookies" "$genres_url" \
                | $JQ_FILE '.js[] | [.id,.title] | join("=")')

            if [ -n "$genres_list" ] 
            then
                genres_list_pages=()
                FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
                FFPROBE="$FFMPEG_ROOT/ffprobe"
                while true 
                do
                    Println "$genres_list\n\n${green}账号到期时间:${normal} $exp_date\n"

                    if [ "${return_err:-0}" -eq 1 ] 
                    then
                        return_err=0
                        Println "$error 返回错误, 请重试"
                    fi

                    Println "$tip 输入 a 返回上级页面, 输入 b 使用下个 mac 地址\n"
                    while read -p "输入分类序号(默认: 取消): " genres_num 
                    do
                        case "$genres_num" in
                            "")
                                Println "$i18n_canceled...\n" && exit
                            ;;
                            a)
                                continue 4
                            ;;
                            b)
                                mac_addresses_failed+=("$mac_address")

                                for mac in "${macs[@]}"
                                do
                                    if [ "$mac_address" != "$mac" ] 
                                    then
                                        for mac_address_failed in "${mac_addresses_failed[@]}"
                                        do
                                            if [ "$mac_address_failed" == "$mac" ] 
                                            then
                                                continue 2
                                            fi
                                        done
                                        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                                        do
                                            if [ "$xc_chnl_mac" == "$domain/$mac" ] 
                                            then
                                                continue 2
                                            fi
                                        done
                                        Println "$info 测试 $mac\n"
                                        mac_address=$mac
                                        continue 4
                                    fi
                                done
                                Println "$error 没有剩余 mac 地址\n"
                                exit 1
                            ;;
                            *[!0-9]*)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *)
                                if [ "$genres_num" -gt 0 ] && [ "$genres_num" -le "$genres_count" ]
                                then
                                    genres_index=$((genres_num-1))
                                    break
                                else
                                    Println "$error $i18n_input_correct_no\n"
                                fi
                            ;;
                        esac
                    done

                    if [ -n "${genres_list_pages[genres_index]:-}" ] 
                    then
                        ordered_list_page=${genres_list_pages[genres_index]}
                    else
                        ordered_list_url="$server/portal.php?type=itv&action=get_ordered_list&genre=${genres_id[genres_index]}&force_ch_link_check=&fav=0&sortby=number&hd=0&p=1"
                        ordered_list_page=$(curl -s -Lm 10 \
                            -H "User-Agent: $user_agent" \
                            ${xc_host_header[@]+"${xc_host_header[@]}"} \
                            -H "${headers:0:-4}" \
                            --cookie "$cookies" "$ordered_list_url")
                        [ -z "$ordered_list_page" ] && return_err=1 && continue 2
                        genres_list_pages[genres_index]="$ordered_list_page"
                    fi

                    exec 100< <($JQ_FILE -r '.js.total_items, .js.max_page_items' <<< "$ordered_list_page")
                    read total_items <&100
                    read max_page_items <&100
                    exec 100<&-

                    if [ "$total_items" == null ] || [ "${total_items:-0}" -eq 0 ] 
                    then
                        Println "$error 此分类没有频道!\n"
                        continue
                    fi

                    if [ "$total_items" -le "$max_page_items" ] 
                    then
                        pages=1
                    else
                        pages=$((total_items / max_page_items))
                        if [ "$total_items" -gt $((pages * max_page_items)) ] 
                        then
                            pages=$((pages+1))
                        fi
                    fi

                    page=1
                    ordered_list_pages=()

                    while true 
                    do
                        page_index=$((page-1))
                        if [ -n "${ordered_list_pages[page_index]:-}" ] 
                        then
                            ordered_list_page=${ordered_list_pages[page_index]}
                        else
                            if [ "$page" -gt 1 ] 
                            then
                                ordered_list_url="$server/portal.php?type=itv&action=get_ordered_list&genre=${genres_id[genres_index]}&force_ch_link_check=&fav=0&sortby=number&hd=0&p=$page"
                                ordered_list_page=$(curl -s -Lm 10 \
                                    -H "User-Agent: $user_agent" \
                                    ${xc_host_header[@]+"${xc_host_header[@]}"} \
                                    -H "${headers:0:-4}" \
                                    --cookie "$cookies" "$ordered_list_url")
                                [ -z "$ordered_list_page" ] && return_err=1 && continue 3
                            fi
                            ordered_list_pages[page_index]=$ordered_list_page
                        fi

                        xc_chnls_id=()
                        xc_chnls_name=()
                        xc_chnls_cmd=()
                        xc_chnls_list=""
                        xc_chnls_count=0
                        while IFS="^" read -r map_id map_cmd map_name
                        do
                            xc_chnls_count=$((xc_chnls_count+1))
                            map_id=${map_id#\"}
                            map_name=${map_name%\"}
                            map_cmd=${map_cmd#* }
                            map_cmd=${map_cmd%\_}
                            map_cmd="http://localhost/ch/${map_cmd##*/}_"
                            xc_chnls_id+=("$map_id")
                            xc_chnls_name+=("$map_name")
                            xc_chnls_cmd+=("$map_cmd")
                            xc_chnls_list="$xc_chnls_list# ${green}$xc_chnls_count${normal} $map_name\n\n"
                        done < <($JQ_FILE '.js.data[] | [.id,.cmd,.name] | join("^")' <<< "$ordered_list_page")

                        Println "$xc_chnls_list"
                        echo -e "$tip 输入 a 返回上级页面"
                        echo -e "$tip 输入 s 频道名称 搜索频道"
                        echo -e "$tip 输入 p 页数 跳转页面"
                        if [ "$pages" -gt 1 ] 
                        then
                            Println "当前第 $page 页, 共 $pages 页"
                            if [ "$page" -eq 1 ] 
                            then
                                echo -e "$tip 输入 x 转到下一页"
                            elif [ "$page" -eq "$pages" ] 
                            then
                                echo -e "$tip 输入 z 转到上一页"
                            else
                                echo -e "$tip 输入 z 转到上一页, 输入 x 转到下一页"
                            fi
                        fi

                        echo && while read -p "输入频道序号: " xc_chnls_num 
                        do
                            if [[ $xc_chnls_num =~ ^s\ * ]] 
                            then
                                search_phrase=${xc_chnls_num#*s }
                                lead=${search_phrase%%[^[:blank:]]*}
                                search_phrase=${search_phrase#${lead}}
                                if [ -z "$search_phrase" ] 
                                then
                                    Println "$error 搜索内容不能为空\n"
                                else
                                    SearchXtreamCodesChnls 2>> "$MONITOR_LOG"
                                fi

                                if [ -n "$search_result" ] 
                                then
                                    Println "搜索结果:\n\n$search_result"
                                else
                                    Println "$error 没有搜索结果\n"
                                fi
                                continue
                            elif [[ $xc_chnls_num =~ ^p\ [0-9]+ ]] 
                            then
                                if [ "${xc_chnls_num#* }" -le "$pages" ]
                                then
                                    page=${xc_chnls_num#* }
                                    continue 2
                                else
                                    Println "$error 页数错误\n"
                                    continue
                                fi
                            fi
                            case "$xc_chnls_num" in
                                a)
                                    continue 3
                                ;;
                                z)
                                    if [ "$page" -gt 1 ]
                                    then
                                        page=$((page-1))
                                        continue 2
                                    else
                                        Println "$error 没有上一页\n"
                                    fi
                                ;;
                                x)
                                    if [ "$page" -lt "$pages" ]
                                    then
                                        page=$((page+1))
                                        continue 2
                                    else
                                        Println "$error 没有下一页\n"
                                    fi
                                ;;
                                ""|*[!0-9]*)
                                    Println "$error $i18n_input_correct_no\n"
                                ;;
                                *)
                                    if [ "$xc_chnls_num" -gt 0 ] && [ "$xc_chnls_num" -le "$xc_chnls_count" ]
                                    then
                                        xc_chnls_index=$((xc_chnls_num-1))
                                        break
                                    else
                                        Println "$error $i18n_input_correct_no\n"
                                    fi
                                ;;
                            esac
                        done

                        if [ "$use_proxy_yn" == "$i18n_yes" ] 
                        then
                            server=${d_xc_proxy%\/}
                            stream_link=$(curl -k -s -o /dev/null -w '%{redirect_url}' "$server" \
                                ${xc_host_header[@]+"${xc_host_header[@]}"} \
                                -H "User-Agent: $user_agent" \
                                -H "${headers:0:-4}" \
                                -H "cmd: ${xc_chnls_cmd[xc_chnls_index]}" \
                                --cookie "$cookies")
                            if [[ ! $stream_link =~ ([^/]+)//([^/]+)/(.+) ]] 
                            then
                                Println "$error curl -k -s -o /dev/null -w '%{redirect_url}' '$server' -H 'xc_host: $domain' -H 'User-Agent: $user_agent' -H '${headers:0:-4}' -H 'cmd: ${xc_chnls_cmd[xc_chnls_index]}' --cookie '$cookies'"
                                Println "$error 返回错误[ stream_link: ${stream_link:-无} ], 请重试"
                                continue
                            fi
                            #curl -k -L -o - "$stream_link" \
                            #    -H "xc_host: ${BASH_REMATCH[2]}" \
                            #    -H "redirect: ${BASH_REMATCH[3]}" \
                            #    -H "User-Agent: $user_agent" \
                            #    -H "${headers:0:-4}" \
                            #    --cookie "$cookies"
                            Println "${green}${xc_chnls_name[xc_chnls_index]}:${normal} $stream_link\n"
                        else
                            create_link_url="$server/portal.php?type=itv&action=create_link&cmd=${xc_chnls_cmd[xc_chnls_index]}&series=&forced_storage=undefined&disable_ad=0&download=0"

                            cmd=$(curl -s -Lm 10 \
                                -H "User-Agent: $user_agent" \
                                -H "${headers:0:-4}" \
                                --cookie "$cookies" "$create_link_url" \
                                | $JQ_FILE -r '.js.cmd') || true

                            if [[ ${cmd#* } =~ ([^/]+)//([^/]+)/live/([^/]+)/([^/]+)/([^/]+) ]] 
                            then
                                stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/live/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                            elif [[ ${cmd#* } =~ ([^/]+)//([^/]+)/([^/]+)/([^/]+)/([^/]+) ]] 
                            then
                                stream_link="${BASH_REMATCH[1]}//${BASH_REMATCH[2]}/${BASH_REMATCH[3]}/${BASH_REMATCH[4]}/${cmd##*/}"
                            else
                                Println "$error 返回 cmd: ${cmd:-无} 错误, 请重试"
                                continue
                            fi
                            stream_link=${stream_link// /}
                            Println "${green}${xc_chnls_name[xc_chnls_index]}:${normal} $stream_link\n"
                        fi

                        if $FFPROBE -i "$stream_link" -user_agent "$user_agent" \
                            -headers "$headers_command" \
                            -cookies "$cookies" -hide_banner 
                        then
                            echo
                            inquirer list_input "是否添加此频道" ny_options add_channel_yn
                            if [[ $add_channel_yn == "$i18n_yes" ]] 
                            then
                                stream_links="$domain|$stream_link|${xc_chnls_cmd[xc_chnls_index]}|$mac_address"
                                echo
                                inquirer list_input "是否 添加/替换 现有频道直播源" yn_options append_channel_yn
                                if [[ $append_channel_yn == "$i18n_yes" ]] 
                                then
                                    ListChannels
                                    InputChannelsIndex
                                    i18nGetMsg list_channel
                                    for chnl_pid in "${chnls_pid_chosen[@]}"
                                    do
                                        GetChannel
                                        ListChannel
                                        change_options=( '添加' '替换' )
                                        echo
                                        inquirer list_input "如何修改频道 [ $chnl_channel_name ]" change_options change_option
                                        if [[ $change_option == "添加" ]] 
                                        then
                                            JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.stream_link)="'"$chnl_stream_links $stream_links"'"'
                                        else
                                            JQ update "$CHANNELS_FILE" '(.channels[]|select(.pid=='"$chnl_pid"')|.stream_link)="'"$stream_links"'"'
                                        fi
                                        Println "$info 频道 [ $chnl_channel_name ] 修改成功 !\n"
                                    done
                                else
                                    echo
                                    inquirer list_input "是否推流 flv" yn_options add_channel_flv_yn
                                    if [[ $add_channel_flv_yn == "$i18n_yes" ]] 
                                    then
                                        kind="flv"
                                    fi
                                    if [ "$use_proxy_yn" == "$i18n_yes" ] 
                                    then
                                        xtream_codes_proxy=$server
                                    fi
                                    xc=1
                                    AddChannel
                                fi
                            else
                                continue
                            fi
                        else
                            Println "$error 频道不可用或账号权限不够\n"
                            inquirer list_input "是否继续" yn_options continue_yn
                            if [[ $continue_yn == "$i18n_yes" ]] 
                            then
                                continue
                            else
                                Println "$i18n_canceled...\n"
                            fi
                        fi
                        break
                    done
                    break
                done
            else
                Println "$error $mac_address 错误, 找不到分类! 账号到期时间: $exp_date\n"

                mac_addresses_failed+=("$mac_address")

                for mac in "${macs[@]}"
                do
                    if [ "$mac_address" != "$mac" ] 
                    then
                        for mac_address_failed in "${mac_addresses_failed[@]}"
                        do
                            if [ "$mac_address_failed" == "$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        for xc_chnl_mac in ${xc_chnls_mac[@]+"${xc_chnls_mac[@]}"}
                        do
                            if [ "$xc_chnl_mac" == "$domain/$mac" ] 
                            then
                                continue 2
                            fi
                        done
                        Println "$info 测试 $mac\n"
                        mac_address=$mac
                        continue 2
                    fi
                done
                exit 1
            fi
            break
        done
        break
    done
}

XtreamCodesAddMac()
{
    echo && read -p "请输入服务器地址: " server
    [ -z "$server" ] && Println "$i18n_canceled...\n" && exit 1

    domain=${server#*http://}
    domain=${domain%%/*}
    ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || true

    [ -z "${ip:-}" ] && Println "$error 无法解析域名 !\n" && exit 1

    echo && read -p "请输入 mac 地址(多个地址空格分隔): " mac_address
    [ -z "$mac_address" ] && Println "$i18n_canceled...\n" && exit 1

    IFS=" " read -ra macs <<< "$mac_address"

    GetDefault

    if [ -n "${d_xc_proxy:-}" ] 
    then
        echo
        inquirer list_input "是否使用代理 $d_xc_proxy 验证: " yn_options use_proxy_yn
        if [[ $use_proxy_yn == "$i18n_yes" ]]
        then
            server=${d_xc_proxy%\/}
            xc_host_header=( -H "xc_host: $domain" )
        else
            server="http://$domain"
            xc_host_header=()
        fi
    else
        server="http://$domain"
        xc_host_header=()
    fi

    Println "$info 验证中..."

    add_mac_success=0
    for mac_address in "${macs[@]}"
    do
        access_token=""
        profile=""
        mac=$(UrlencodeUpper "$mac_address")
        timezone=$(UrlencodeUpper "Europe/Amsterdam")
        token_url="$server/portal.php?type=stb&action=handshake"
        profile_url="$server/portal.php?type=stb&action=get_profile"

        access_token=$(curl -s -Lm 10 \
            -H "User-Agent: $USER_AGENT_TV" \
            ${xc_host_header[@]+"${xc_host_header[@]}"} \
            --cookie "mac=$mac; stb_lang=en; timezone=$timezone" "$token_url" \
            | $JQ_FILE -r '.js.token') || true
        if [ -z "$access_token" ] 
        then
            if [ "$add_mac_success" -eq 0 ] 
            then
                Println "$error $domain $mac_address access_token\n" && exit 1
            else
                Println "$error $domain $mac_address access_token"
                continue
            fi
        fi
        profile=$(curl -s -Lm 10 \
            -H "User-Agent: $USER_AGENT_TV" \
            ${xc_host_header[@]+"${xc_host_header[@]}"} \
            -H "Authorization: Bearer $access_token" \
            --cookie "mac=$mac; stb_lang=en; timezone=$timezone" "$profile_url") || true
        if [ -z "$profile" ] 
        then
            if [ "$add_mac_success" -eq 0 ] 
            then
                Println "$error $domain $mac_address profile\n" && exit 1
            else
                Println "$error $domain $mac_address profile"
                continue
            fi
        fi

        if [[ $($JQ_FILE -r '.js.id' <<< "$profile") == null ]] 
        then
            Println "$error $domain $mac_address 地址错误!\n"
            continue
        fi

        add_mac_success=1
        printf '%s\n' "$ip $domain $mac_address" >> "$XTREAM_CODES_EXAM"
    done
}

NginxDomainInstallCert()
{
    local domain=$1

    if [ -e "/usr/local/nginx/conf/sites_crt/$domain.crt" ] && [ -d /usr/local/openresty/nginx/conf ] && [ ! -e "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt" ]
    then
        mkdir -p /usr/local/openresty/nginx/conf/sites_crt
        ln "/usr/local/nginx/conf/sites_crt/$domain.crt" "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt"
        ln "/usr/local/nginx/conf/sites_crt/$domain.key" "/usr/local/openresty/nginx/conf/sites_crt/$domain.key"
    elif [ -e "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt" ] && [ -d /usr/local/nginx/conf ] && [ ! -e "/usr/local/nginx/conf/sites_crt/$domain.crt" ] 
    then
        mkdir -p /usr/local/nginx/conf/sites_crt
        ln "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt" "/usr/local/nginx/conf/sites_crt/$domain.crt"
        ln "/usr/local/openresty/nginx/conf/sites_crt/$domain.key" "/usr/local/nginx/conf/sites_crt/$domain.key"
    fi

    if [ -e "$nginx_prefix/conf/sites_crt/$domain.crt" ] && [ -e "$nginx_prefix/conf/sites_crt/$domain.key" ]
    then
        echo
        inquirer list_input "检测到证书已存在, 是否重新安装证书" ny_options reinstall_crt_yn
        if [ "$reinstall_crt_yn" == "$i18n_no" ] 
        then
            return 0
        fi
    fi

    Println "$info 安装 $domain 证书..."

    NginxDomainUpdateCrt "$domain" 1

    Println "$info $domain 证书安装成功"
}

OpenrestyInstall()
{
    DepsCheck
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    if [ "$release" == "rpm" ] 
    then
        yum -y install gcc gcc-c++ make >/dev/null 2>&1
        timedatectl set-timezone Asia/Shanghai >/dev/null 2>&1
        systemctl restart crond >/dev/null 2>&1
        #if grep -q "Fedora" < "/etc/redhat-release"
        #then
        #    dnf install -y dnf-plugins-core >/dev/null 2>&1
        #    dnf config-manager --add-repo https://openresty.org/package/fedora/openresty.repo >/dev/null 2>&1
        #    dnf install -y openresty >/dev/null 2>&1 || true
        #    dnf install -y openresty-resty >/dev/null 2>&1
        #elif grep -q "Amazon" < "/etc/redhat-release"
        #then
        #    yum install -y yum-utils >/dev/null 2>&1
        #    yum-config-manager --add-repo https://openresty.org/package/amazon/openresty.repo >/dev/null 2>&1
        #    yum install -y openresty >/dev/null 2>&1 || true
        #    yum install -y openresty-resty >/dev/null 2>&1
        #elif grep -q "Red Hat" < "/etc/redhat-release"
        #then
        #    wget https://openresty.org/package/rhel/openresty.repo -qO /etc/yum.repos.d/openresty.repo >/dev/null 2>&1
        #    yum check-update >/dev/null 2>&1
        #    yum install -y openresty >/dev/null 2>&1 || true
        #    yum install -y openresty-resty >/dev/null 2>&1
        #else
        #    wget https://openresty.org/package/centos/openresty.repo -qO /etc/yum.repos.d/openresty.repo >/dev/null 2>&1
        #    yum check-update >/dev/null 2>&1
        #    yum install -y openresty >/dev/null 2>&1 || true
        #    yum install -y openresty-resty >/dev/null 2>&1
        #fi
    #elif [ "$release" == "ubu" ] 
    #then
        #apt-get -y install ca-certificates >/dev/null 2>&1
        #if ! wget -qO - https://openresty.org/package/pubkey.gpg | apt-key add - > /dev/null 2>&1
        #then
        #    apt-get -y install gnupg >/dev/null 2>&1
        #    wget -qO - https://openresty.org/package/pubkey.gpg | apt-key add - > /dev/null
        #fi
        #echo "deb http://openresty.org/package/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/openresty.list
        #apt-get update >/dev/null 2>&1
        #apt-get -y install openresty >/dev/null 2>&1 || true
    else
        timedatectl set-timezone Asia/Shanghai >/dev/null 2>&1
        systemctl restart cron >/dev/null 2>&1
        apt-get -y install debconf-utils >/dev/null 2>&1
        echo '* libraries/restart-without-asking boolean true' | debconf-set-selections
        apt-get -y install perl software-properties-common pkg-config libssl-dev libghc-zlib-dev libcurl4-gnutls-dev libexpat1-dev unzip gettext build-essential >/dev/null 2>&1
        #apt-get -y install ca-certificates software-properties-common >/dev/null 2>&1
        #if ! wget -qO - https://openresty.org/package/pubkey.gpg | apt-key add - > /dev/null 2>&1
        #then
        #    apt-get -y install gnupg >/dev/null 2>&1
        #    wget -qO - https://openresty.org/package/pubkey.gpg | apt-key add - > /dev/null
        #fi
        #codename=$(grep -Po 'VERSION="[0-9]+ \(\K[^)]+' /etc/os-release)
        #echo "deb http://openresty.org/package/debian $codename openresty" > /etc/apt/sources.list.d/openresty.list
        #apt-get update >/dev/null 2>&1
        #apt-get -y install openresty >/dev/null 2>&1 || true
    fi

    echo -n "...40%..."

    cd ~
    if [ ! -d "./pcre-8.44" ] 
    then
        curl -s -L "https://ftp.pcre.org/pub/pcre/pcre-8.44.tar.gz" -o "pcre-8.44.tar.gz"
        tar xzf "pcre-8.44.tar.gz"
    fi

    if [ ! -d "./zlib-1.2.11" ] 
    then
        curl -s -L "https://www.zlib.net/zlib-1.2.11.tar.gz" -o "zlib-1.2.11.tar.gz"
        tar xzf "zlib-1.2.11.tar.gz"
    fi

    if [ ! -d "./openssl-1.1.1f-patched" ] || [ ! -s "./openssl-1.1.1f-patched/openssl-1.1.1f-sess_set_get_cb_yield.patch" ]
    then
        rm -rf openssl-1.1.1f
        rm -rf openssl-1.1.1f-patched
        curl -s -L "https://www.openssl.org/source/openssl-1.1.1f.tar.gz" -o "openssl-1.1.1f.tar.gz"
        tar xzf "openssl-1.1.1f.tar.gz"
        mv openssl-1.1.1f openssl-1.1.1f-patched
        cd openssl-1.1.1f-patched
        curl -s -L "$FFMPEG_MIRROR_LINK/openssl-1.1.1f-sess_set_get_cb_yield.patch" -o "openssl-1.1.1f-sess_set_get_cb_yield.patch"
        patch -p1 < openssl-1.1.1f-sess_set_get_cb_yield.patch >/dev/null 2>&1
        cd ~
    fi

    rm -rf nginx-http-flv-module-master
    curl -s -L "$FFMPEG_MIRROR_LINK/nginx-http-flv-module.zip" -o "nginx-http-flv-module.zip"
    unzip "nginx-http-flv-module.zip" >/dev/null 2>&1

    cd nginx-http-flv-module-master
    curl -s -L "$FFMPEG_MIRROR_LINK/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch" -o "Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch"
    patch -p1 < Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch >/dev/null 2>&1
    cd ~

    latest_release=0
    while IFS= read -r line
    do
        if [[ $line == *"Lastest release"* ]] 
        then
            latest_release=1
        elif [ "$latest_release" -eq 1 ] && [[ $line == *"<a "* ]]
        then
            openresty_package_name=${line#*/download/}
            openresty_package_name=${openresty_package_name%%.tar.gz*}
            break
        fi
    done < <(curl -s -L -H "User-Agent: $USER_AGENT_BROWSER" "https://openresty.org/en/download.html" 2> /dev/null)

    if [ ! -d "./$openresty_package_name" ] 
    then
        curl -s -L "https://openresty.org/download/$openresty_package_name.tar.gz" -o "$openresty_package_name.tar.gz"
        tar xzf "$openresty_package_name.tar.gz"
    fi

    echo -n "...60%..."

    cd "$openresty_package_name/bundle/ngx_lua-"*

    curl -s -L "$FFMPEG_MIRROR_LINK/fix_ngx_lua_resp_get_headers_key_whitespace.patch" -o "fix_ngx_lua_resp_get_headers_key_whitespace.patch"
    patch -p1 < fix_ngx_lua_resp_get_headers_key_whitespace.patch >/dev/null 2>&1

    cd ../..

    ./configure --add-module=../nginx-http-flv-module-master \
        --with-pcre=../pcre-8.44 --with-pcre-jit \
        --with-zlib=../zlib-1.2.11 --with-openssl=../openssl-1.1.1f-patched \
        --with-http_ssl_module --with-http_v2_module \
        --without-mail_pop3_module --without-mail_imap_module \
        --without-mail_smtp_module --with-http_stub_status_module \
        --with-http_realip_module --with-debug --with-http_addition_module \
        --with-http_auth_request_module --with-http_secure_link_module \
        --with-http_random_index_module --with-http_gzip_static_module \
        --with-http_sub_module --with-http_dav_module --with-http_flv_module \
        --with-http_mp4_module --with-http_gunzip_module --with-stream --with-stream_ssl_preread_module \
        --with-stream_ssl_module --with-stream_realip_module --with-threads >/dev/null 2>&1

    echo -n "...80%..."

    nproc="-j$(nproc 2> /dev/null)" || nproc="-j1"
    make $nproc >/dev/null 2>&1
    make install >/dev/null 2>&1

    kill $progress_pid
    trap - EXIT
    echo -n "...100%" && echo

    if ! grep -q "$nginx_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser "$nginx_name" --system --group --no-create-home > /dev/null
        else
            adduser "$nginx_name" --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin "$nginx_name"
    fi

    sed -i "s/#user  nobody;/user $nginx_name $nginx_name;/" "$nginx_prefix/conf/nginx.conf"
    sed -i "s/worker_processes .*/worker_processes  ${nproc:2};/" "$nginx_prefix/conf/nginx.conf"
    sed -i "s/worker_connections  1024;/worker_connections  51200;/" "$nginx_prefix/conf/nginx.conf"

    mkdir -p "$nginx_prefix/conf/sites_crt/"
    mkdir -p "$nginx_prefix/conf/sites_available/"
    mkdir -p "$nginx_prefix/conf/sites_enabled/"
    mkdir -p "$nginx_prefix/html/localhost/"

    if [[ ! -x $(command -v crossplane) ]] 
    then
        Println "$info 安装 crossplane ..."
        CrossplaneInstall
    fi
}

NginxInstall()
{
    DepsCheck
    JQInstall >/dev/null
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    if [ "$release" == "rpm" ] 
    then
        yum -y install gcc gcc-c++ make >/dev/null 2>&1
        # yum groupinstall 'Development Tools'
        timedatectl set-timezone Asia/Shanghai >/dev/null 2>&1
        systemctl restart crond >/dev/null 2>&1
    else
        timedatectl set-timezone Asia/Shanghai >/dev/null 2>&1
        systemctl restart cron >/dev/null 2>&1
        apt-get -y install debconf-utils >/dev/null 2>&1
        echo '* libraries/restart-without-asking boolean true' | debconf-set-selections
        apt-get -y install software-properties-common pkg-config libssl-dev libghc-zlib-dev libcurl4-gnutls-dev libexpat1-dev unzip build-essential gettext >/dev/null 2>&1
    fi

    echo -n "...40%..."

    cd ~
    if [ ! -d "./pcre-8.44" ] 
    then
        curl -s -L "https://ftp.pcre.org/pub/pcre/pcre-8.44.tar.gz" -o "pcre-8.44.tar.gz"
        tar xzf "pcre-8.44.tar.gz"
    fi

    if [ ! -d "./zlib-1.2.11" ] 
    then
        curl -s -L "https://www.zlib.net/zlib-1.2.11.tar.gz" -o "zlib-1.2.11.tar.gz"
        tar xzf "zlib-1.2.11.tar.gz"
    fi

    while IFS= read -r line
    do
        if [[ $line == *"openssl-1."* ]] 
        then
            openssl_name=${line#*<a href=\"}
            openssl_name=${openssl_name%%.tar.gz*}
            break
        fi
    done < <(curl -s -L -H "User-Agent: $USER_AGENT_BROWSER" "https://www.openssl.org/source/" 2> /dev/null)

    if [ ! -d "./$openssl_name" ] 
    then
        curl -s -L "https://www.openssl.org/source/$openssl_name.tar.gz" -o "$openssl_name.tar.gz"
        tar xzf "$openssl_name.tar.gz"
    fi

    rm -rf nginx-http-flv-module-master
    curl -s -L "$FFMPEG_MIRROR_LINK/nginx-http-flv-module.zip" -o "nginx-http-flv-module.zip"
    unzip "nginx-http-flv-module.zip" >/dev/null 2>&1

    cd nginx-http-flv-module-master
    curl -s -L "$FFMPEG_MIRROR_LINK/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch" -o "Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch"
    patch -p1 < Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch >/dev/null 2>&1
    cd ~

    while IFS= read -r line
    do
        if [[ $line == *"/download/"* ]] 
        then
            nginx_package_name=${line#*/download/}
            nginx_package_name=${nginx_package_name%%.tar.gz*}
            break
        fi
    done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" "https://nginx.org/en/download.html" 2> /dev/null)

    if [ ! -d "./$nginx_package_name" ] 
    then
        curl -s -L "https://nginx.org/download/$nginx_package_name.tar.gz" -o "$nginx_package_name.tar.gz"
        tar xzf "$nginx_package_name.tar.gz"
    fi

    echo -n "...60%..."

    cd "$nginx_package_name/"
    ./configure --add-module=../nginx-http-flv-module-master \
        --with-pcre=../pcre-8.44 --with-pcre-jit --with-zlib=../zlib-1.2.11 \
        --with-openssl=../$openssl_name --with-openssl-opt=no-nextprotoneg \
        --with-http_stub_status_module --with-http_ssl_module --with-http_v2_module \
        --with-http_realip_module --with-threads --with-stream --with-stream_ssl_preread_module \
        --with-stream_ssl_module --with-stream_realip_module --with-debug >/dev/null 2>&1

    echo -n "...80%..."

    nproc="-j$(nproc 2> /dev/null)" || nproc="-j1"
    make $nproc >/dev/null 2>&1
    make install >/dev/null 2>&1

    kill $progress_pid
    trap - EXIT
    ln -sf /usr/local/nginx/sbin/nginx /usr/local/bin/
    echo -n "...100%" && echo

    if ! grep -q "$nginx_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser "$nginx_name" --system --group --no-create-home > /dev/null
        else
            adduser "$nginx_name" --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin "$nginx_name"
    fi

    sed -i "s/#user  nobody;/user $nginx_name $nginx_name;/" "$nginx_prefix/conf/nginx.conf"
    sed -i "s/worker_processes .*/worker_processes  ${nproc:2};/" "$nginx_prefix/conf/nginx.conf"
    sed -i "s/worker_connections  1024;/worker_connections  51200;/" "$nginx_prefix/conf/nginx.conf"

    mkdir -p "$nginx_prefix/conf/sites_crt/"
    mkdir -p "$nginx_prefix/conf/sites_available/"
    mkdir -p "$nginx_prefix/conf/sites_enabled/"
    mkdir -p "$nginx_prefix/html/localhost/"

    if [[ ! -x $(command -v crossplane) ]] 
    then
        Println "$info 安装 crossplane ..."
        CrossplaneInstall
    fi
}

NginxUninstall()
{
    if [ ! -d "$nginx_prefix" ] 
    then
        Println "$error $nginx_name 未安装 !\n"
        exit 1
    fi

    echo
    AskIfContinue n "`eval_gettext \"确定删除 \\\$nginx_name 包括所有配置文件, 操作不可恢复\"`"

    systemctl stop $nginx_name || true

    if [ "$nginx_ctl" == "or" ] 
    then
        rm -rf "${nginx_prefix%/*}"
    else
        rm -rf "$nginx_prefix"
    fi

    Println "$info $nginx_name 卸载完成\n"
}

NginxUpdate()
{
    if [ ! -d "$nginx_prefix" ] 
    then
        Println "$error $nginx_name 未安装 !\n"
        exit 1
    fi

    ShFileUpdate "$nginx_name"

    echo
    AskIfContinue n "`eval_gettext \"是否重新编译 \\\$nginx_name\"`"

    nginx_name_upper=$(tr '[:lower:]' '[:upper:]' <<< "${nginx_name:0:1}")"${nginx_name:1}"
    "$nginx_name_upper"Install
    Println "$info $nginx_name 升级完成\n"
}

NginxViewStatus()
{
    if [ ! -d "$nginx_prefix" ] 
    then
        Println "$error $nginx_name 未安装 !\n"
    else
        systemctl status $nginx_name.service --no-pager
    fi
}

NginxToggle()
{
    echo
    if [[ $(systemctl is-active $nginx_name) == "active" ]] 
    then
        AskIfContinue y "`eval_gettext \"\\\$nginx_name 正在运行, 是否关闭\"`"

        systemctl stop $nginx_name
        Println "$info $nginx_name 已关闭\n"
    else
        AskIfContinue y "`eval_gettext \"\\\$nginx_name 未运行, 是否开启\"`"

        systemctl start $nginx_name
        Println "$info $nginx_name 已开启\n"
    fi
}

NginxRestart()
{
    systemctl restart $nginx_name
    Println "$info $nginx_name 重启成功\n"
}

NginxParseConfig()
{
    if [[ ! -x $(command -v crossplane) ]] 
    then
        Println "$info 安装 crossplane ..."
        CrossplaneInstall
    fi

    if TMP_FILE=$(mktemp -q)
    then
        chmod +r "$TMP_FILE"
    else
        exit $?
    fi

    trap '
        rm -f "$TMP_FILE"
    ' EXIT

    if [ -z "${1:-}" ] 
    then
        parse_file="$nginx_prefix/conf/nginx.conf"
        parse_in=$(< $parse_file)
        parse_domain=0
    else
        parse_file="$nginx_prefix/conf/sites_available/$1.conf"
        parse_in="http {$(< $parse_file)}"
        parse_domain=1
    fi

    echo "$parse_in" > "$TMP_FILE"

    parse_out=$(crossplane parse "$TMP_FILE" --single-file)

    rm -f "$TMP_FILE"

    trap - EXIT

    jq_path='["config",0,"file"]'
    JQs update parse_out "$parse_file"
}

NginxGetConfig()
{
    delimiters=( $'\001' $'\002' $'\003' $'\004' $'\005' $'\006' )
    IFS=$'\007\t' read -r status error_message level_1_directive level_1_args \
    level_2_directive level_2_args level_3_directive level_3_args \
    level_4_directive level_4_args level_5_directive level_5_args < <(
    JQs flat_c "$parse_out" '' \
    '(.config.parsed|if . == "" then {} else . end) as $level_1 |
    ($level_1.block|if . == "" then {} else . end) as $level_2 |
    ($level_2.block|if . == "" then {} else . end) as $level_3 |
    ($level_3.block|if . == "" then {} else . end) as $level_4 |
    ($level_4.block|if . == "" then {} else . end) as $level_5 |
    [.status + "\u0007",
    (.errors|if . == "" then {} else . end).error + "\u0007",
    ($level_1.directive|if . != null then (. + $d2) else . end) + "\u0007",
    ($level_1.args|if . != null then (. + $d2) else . end) + "\u0007",
    ($level_2.directive|if . != null then (. + $d3) else . end) + "\u0007",
    ($level_2.args|if . != null then (. + $d3) else . end) + "\u0007",
    ($level_3.directive|if . != null then (. + $d4) else . end) + "\u0007",
    ($level_3.args|if . != null then (. + $d4) else . end) + "\u0007",
    ($level_4.directive|if . != null then (. + $d5) else . end) + "\u0007",
    ($level_4.args|if . != null then (. + $d5) else . end) + "\u0007",
    ($level_5.directive|if . != null then (. + $d6) else . end) + "\u0007",
    ($level_5.args|if . != null then (. + $d6) else . end) + "\u0007"
    ]|@tsv' "${delimiters[@]}")

    if [ "$status" == "failed" ] 
    then
        Println "$error ${error_message//$'\002'/$'\n'}\n"
        exit 1
    fi

    # level 1 - stream,http...
    # level 2 - map,upstream,server...
    # level 3 - location...
    # level 4 - proxy_pass,root,index...
    # level 5 - return...

    level_1_count=0
    level_2_d1_count=0
    level_3_d1_count=0
    level_4_d1_count=0
    level_5_d1_count=0

    if [ -z "$level_1_directive" ]
    then
        return 0
    fi

    IFS="${delimiters[1]}" read -r -a level_1_directive_arr <<< "$level_1_directive"
    IFS="${delimiters[1]}" read -r -a level_1_args_arr <<< "$level_1_args"

    level_1_count=${#level_1_directive_arr[@]}

    if [ -z "$level_2_directive" ]
    then
        return 0
    fi

    IFS="${delimiters[2]}" read -r -a level_2_directive_arr <<< "$level_2_directive"
    IFS="${delimiters[2]}" read -r -a level_2_args_arr <<< "$level_2_args"

    level_2_d1_count=${#level_2_directive_arr[@]}

    if [ -z "$level_3_directive" ]
    then
        return 0
    fi

    IFS="${delimiters[3]}" read -r -a level_3_directive_arr <<< "$level_3_directive"
    IFS="${delimiters[3]}" read -r -a level_3_args_arr <<< "$level_3_args"

    level_3_d1_count=${#level_3_directive_arr[@]}

    if [ -z "$level_4_directive" ]
    then
        return 0
    fi

    IFS="${delimiters[4]}" read -r -a level_4_directive_arr <<< "$level_4_directive"
    IFS="${delimiters[4]}" read -r -a level_4_args_arr <<< "$level_4_args"

    level_4_d1_count=${#level_4_directive_arr[@]}

    if [ -z "$level_5_directive" ]
    then
        return 0
    fi

    IFS="${delimiters[5]}" read -r -a level_5_directive_arr <<< "$level_5_directive"
    IFS="${delimiters[5]}" read -r -a level_5_args_arr <<< "$level_5_args"

    level_5_d1_count=${#level_5_directive_arr[@]}
}

NginxListDomains()
{
    if [ ! -d "$nginx_prefix" ] 
    then
        Println "$error $nginx_name 未安装 ! 输入 $nginx_ctl 安装 $nginx_name\n"
        exit 1
    fi

    nginx_domains_list=""
    nginx_domains_count=0
    nginx_domains=()
    nginx_domains_status=()

    if ls -A "$nginx_prefix/conf/sites_available/"* > /dev/null 2>&1
    then
        for f in "$nginx_prefix/conf/sites_available/"*
        do
            nginx_domains_count=$((nginx_domains_count+1))
            domain=${f##*/}
            domain=${domain%.conf}
            if [ -e "$nginx_prefix/conf/sites_enabled/$domain.conf" ] 
            then
                domain_status=1
                domain_status_text="${green} [开启] ${normal}"
            else
                domain_status=0
                domain_status_text="${red} [关闭] ${normal}"
            fi
            nginx_domains_list="$nginx_domains_list ${green}$nginx_domains_count.${normal}${indent_6}$domain $domain_status_text\n\n"
            nginx_domains+=("$domain")
            nginx_domains_status+=("$domain_status")
        done
    fi

    if [ "$nginx_domains_count" -gt 0 ] 
    then
        Println "${green}域名列表:${normal}\n\n$nginx_domains_list"
    fi
}

NginxSelectDomain()
{
    echo "选择域名"
    while read -p "$i18n_default_cancel" nginx_domains_index
    do
        case "$nginx_domains_index" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$nginx_domains_index" -gt 0 ] && [ "$nginx_domains_index" -le "$nginx_domains_count" ]
                then
                    nginx_domains_index=$((nginx_domains_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

NginxListDomain()
{
    level_1_add_indices=( 0 )

    NginxListDomains

    if [ "$nginx_domains_count" -eq 0 ] 
    then
        Println "$error 没有域名\n"
        exit 1
    fi

    NginxSelectDomain
    NginxParseConfig ${nginx_domains[nginx_domains_index]}
    NginxGetConfig

    if [ "$level_3_d1_count" -eq 0 ] 
    then
        Println "$error 请先添加 ${nginx_domains[nginx_domains_index]} 配置\n"
        exit 1
    fi

    nginx_domain_servers_list=""
    nginx_domain_servers_count=0
    nginx_domain_servers_indices=()
    nginx_domain_servers_name=()
    nginx_domain_servers_root=()

    level_1_index=0

    level_2_directive_d1=${level_2_directive_arr[level_1_index]}
    level_3_directive_d1=${level_3_directive_arr[level_1_index]}
    level_3_args_d1=${level_3_args_arr[level_1_index]}

    IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "$level_2_directive_d1${delimiters[1]}"
    IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "$level_3_directive_d1${delimiters[2]}"
    IFS="${delimiters[2]}" read -r -a level_3_args_d1_arr <<< "$level_3_args_d1${delimiters[2]}"

    if [ "$level_4_d1_count" -gt 0 ] 
    then
        level_4_directive_d1=${level_4_directive_arr[level_1_index]}
        level_4_args_d1=${level_4_args_arr[level_1_index]}
        IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "$level_4_directive_d1${delimiters[3]}"
        IFS="${delimiters[3]}" read -r -a level_4_args_d1_arr <<< "$level_4_args_d1${delimiters[3]}"
    fi

    for((level_2_index=0;level_2_index<${#level_2_directive_d1_arr[@]};level_2_index++));
    do
        if [ "${level_2_directive_d1_arr[level_2_index]}" == "server" ] 
        then
            level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}
            level_3_args_d2=${level_3_args_d1_arr[level_2_index]}

            IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "$level_3_directive_d2${delimiters[1]}"
            IFS="${delimiters[1]}" read -r -a level_3_args_d2_arr <<< "$level_3_args_d2${delimiters[1]}"

            if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ]
            then
                level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                level_4_args_d2=${level_4_args_d1_arr[level_2_index]}
                IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "$level_4_directive_d2${delimiters[2]}"
                IFS="${delimiters[2]}" read -r -a level_4_args_d2_arr <<< "$level_4_args_d2${delimiters[2]}"
            fi

            nginx_domain_servers_count=$((nginx_domain_servers_count+1))
            nginx_domain_servers_indices+=("$level_2_index")
            nginx_domain_server_listen_list=""
            nginx_domain_server_name_list=""
            nginx_domain_server_flv_status="${red}未配置${normal}"
            nginx_domain_server_nodejs_status="${red}未配置${normal}"
            skip_find_nodejs=0
            server_root=""

            for((level_3_index=0;level_3_index<${#level_3_directive_d2_arr[@]};level_3_index++));
            do
                level_3_directive=${level_3_directive_d2_arr[level_3_index]}
                level_3_args=${level_3_args_d2_arr[level_3_index]}

                if [ "$level_3_directive" == "listen" ] 
                then
                    [ -n "$nginx_domain_server_listen_list" ] && nginx_domain_server_listen_list="$nginx_domain_server_listen_list, "
                    nginx_domain_server_listen_list="$nginx_domain_server_listen_list${level_3_args//${delimiters[0]}/ }"
                elif [ "$level_3_directive" == "server_name" ] 
                then
                    [ -n "$nginx_domain_server_name_list" ] && nginx_domain_server_name_list="$nginx_domain_server_name_list, "
                    nginx_domain_server_name_list="$nginx_domain_server_name_list${level_3_args//${delimiters[0]}/ }"
                elif [ "$level_3_directive" == "location" ] 
                then
                    if [ "${level_3_args}" == "/flv" ] 
                    then
                        nginx_domain_server_flv_status="${green}已配置${normal}"
                    elif [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ] && [ -n "${level_4_directive_d2_arr[level_3_index]}" ]
                    then
                        level_4_directive_d3=${level_4_directive_d2_arr[level_3_index]}
                        level_4_args_d3=${level_4_args_d2_arr[level_3_index]}
                        IFS="${delimiters[1]}" read -r -a level_4_directive_d3_arr <<< "$level_4_directive_d3${delimiters[1]}"
                        IFS="${delimiters[1]}" read -r -a level_4_args_d3_arr <<< "$level_4_args_d3${delimiters[1]}"

                        if [ "${level_3_args}" == "=${delimiters[0]}/" ] && [ "$skip_find_nodejs" -eq 0 ] 
                        then
                            for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                            do
                                if [ "${level_4_directive_d3_arr[level_4_index]}" == "proxy_pass" ] 
                                then
                                    if [[ ${level_4_args_d3_arr[level_4_index]} =~ ^http://nodejs ]] 
                                    then
                                        nginx_domain_server_nodejs_status="${green}已配置${normal}"
                                        skip_find_nodejs=1
                                    fi
                                    break
                                fi
                            done
                        elif [ "${level_3_args}" == "/" ] 
                        then
                            for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                            do
                                if [ "${level_4_directive_d3_arr[level_4_index]}" == "root" ] 
                                then
                                    if [ "${level_4_args_d3_arr[level_4_index]:0:1}" == "/" ] 
                                    then
                                        server_root=${level_4_args_d3_arr[level_4_index]}
                                    else
                                        server_root="$nginx_prefix/${level_4_args_d3_arr[level_4_index]}"
                                    fi
                                    break
                                fi
                            done
                        fi
                    fi
                elif [ "$level_3_directive" == "root" ] 
                then
                    if [ "${level_3_args_d2_arr[level_3_index]:0:1}" == "/" ] 
                    then
                        server_root=${level_3_args_d2_arr[level_3_index]}
                    else
                        server_root="$nginx_prefix/${level_3_args_d2_arr[level_3_index]}"
                    fi
                fi
            done

            nginx_domain_servers_name+=("${nginx_domain_server_name_list//, /,}")
            nginx_domain_servers_root+=("$server_root")
            nginx_domain_servers_list="$nginx_domain_servers_list $nginx_domain_servers_count.${indent_6}域名: ${green}${nginx_domain_server_name_list:-未设置}${normal}\n${indent_6}端口: ${green}${nginx_domain_server_listen_list:-未设置}${normal}\n${indent_6}flv: $nginx_domain_server_flv_status\n${indent_6}nodejs: $nginx_domain_server_nodejs_status\n\n"
        fi
    done

    if [ "$nginx_domain_servers_count" -eq 0 ] 
    then
        Println "$error 请先添加 ${nginx_domains[nginx_domains_index]} 配置\n"
        exit 1
    fi

    Println "域名 ${green}${nginx_domains[nginx_domains_index]}${normal} 配置:\n\n$nginx_domain_servers_list"
}

NginxSelectDomainServer()
{
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" nginx_domain_servers_num
    do
        case "$nginx_domain_servers_num" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$nginx_domain_servers_num" -gt 0 ] && [ "$nginx_domain_servers_num" -le "$nginx_domain_servers_count" ]
                then
                    nginx_domain_servers_index=$((nginx_domain_servers_num-1))
                    level_2_add_indices=( "${nginx_domain_servers_indices[nginx_domain_servers_index]}" )
                    server_root=${nginx_domain_servers_root[nginx_domain_servers_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

NginxConfigDomain()
{
    NginxListDomain

    NginxSelectDomainServer

    echo
    domain_server_options=( '修改指令' '更新证书' '添加 flv 设置' '添加 nodejs 设置' )
    inquirer list_input_index "选择操作" domain_server_options domain_server_options_index

    if [ "$domain_server_options_index" -eq 0 ] 
    then
        NginxConfigDirective level_2
    elif [ "$domain_server_options_index" -eq 1 ] 
    then
        NginxDomainServerUpdateCrt
    elif [ "$domain_server_options_index" -eq 2 ] 
    then
        updated=0
        NginxAddFlv
        if [ "$updated" -eq 1 ] 
        then
            NginxBuildConf parse_out
        fi
        Println "$info flv 配置添加成功\n"
    else
        updated=0
        NginxAddNodejs
        if [ "$updated" -eq 1 ] 
        then
            NginxBuildConf parse_out
        fi
        Println "$info nodejs 配置添加成功\n"
    fi
}

NginxListLocalhost()
{
    NginxCheckLocalhost

    nginx_localhost_list=""
    nginx_localhost_server_count=0
    nginx_localhost_server_indices=()
    nginx_localhost_server_root=()

    for((level_1_index=0;level_1_index<level_1_count;level_1_index++));
    do
        if [ "${level_1_directive_arr[level_1_index]}" == "http" ] 
        then
            if [ -z "${level_3_directive_arr[level_1_index]}" ] 
            then
                break
            fi

            level_1_add_indices=( "$level_1_index" )

            level_2_directive_d1=${level_2_directive_arr[level_1_index]}
            level_3_directive_d1=${level_3_directive_arr[level_1_index]}
            level_3_args_d1=${level_3_args_arr[level_1_index]}

            IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "$level_2_directive_d1${delimiters[1]}"
            IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "$level_3_directive_d1${delimiters[2]}"
            IFS="${delimiters[2]}" read -r -a level_3_args_d1_arr <<< "$level_3_args_d1${delimiters[2]}"

            if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_arr[level_1_index]}" ]
            then
                level_4_directive_d1=${level_4_directive_arr[level_1_index]}
                level_4_args_d1=${level_4_args_arr[level_1_index]}
                IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "$level_4_directive_d1${delimiters[3]}"
                IFS="${delimiters[3]}" read -r -a level_4_args_d1_arr <<< "$level_4_args_d1${delimiters[3]}"
            fi

            for((level_2_index=0;level_2_index<${#level_2_directive_d1_arr[@]};level_2_index++));
            do
                if [ "${level_2_directive_d1_arr[level_2_index]}" == "server" ] 
                then
                    level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}
                    level_3_args_d2=${level_3_args_d1_arr[level_2_index]}

                    IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "$level_3_directive_d2${delimiters[1]}"
                    IFS="${delimiters[1]}" read -r -a level_3_args_d2_arr <<< "$level_3_args_d2${delimiters[1]}"

                    if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_arr[level_1_index]}" ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ]
                    then
                        level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                        level_4_args_d2=${level_4_args_d1_arr[level_2_index]}
                        IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "$level_4_directive_d2${delimiters[2]}"
                        IFS="${delimiters[2]}" read -r -a level_4_args_d2_arr <<< "$level_4_args_d2${delimiters[2]}"
                    fi

                    nginx_localhost_server_count=$((nginx_localhost_server_count+1))
                    nginx_localhost_server_indices+=("$level_2_index")
                    nginx_localhost_listen=""
                    nginx_localhost_flv_status="${red}未配置${normal}"
                    nginx_localhost_nodejs_status="${red}未配置${normal}"
                    skip_find_nodejs=0
                    server_root=""

                    for((level_3_index=0;level_3_index<${#level_3_directive_d2_arr[@]};level_3_index++));
                    do
                        level_3_directive=${level_3_directive_d2_arr[level_3_index]}
                        level_3_args=${level_3_args_d2_arr[level_3_index]}

                        if [ "$level_3_directive" == "listen" ] 
                        then
                            [ -n "$nginx_localhost_listen" ] && nginx_localhost_listen="$nginx_localhost_listen, "
                            nginx_localhost_listen="$nginx_localhost_listen${level_3_args//${delimiters[0]}/ }"
                        elif [ "$level_3_directive" == "location" ] 
                        then
                            if [ "${level_3_args}" == "/flv" ] 
                            then
                                nginx_localhost_flv_status="${green}已配置${normal}"
                            elif [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_arr[level_1_index]}" ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ] && [ -n "${level_4_directive_d2_arr[level_3_index]}" ] 
                            then
                                level_4_directive_d3=${level_4_directive_d2_arr[level_3_index]}
                                level_4_args_d3=${level_4_args_d2_arr[level_3_index]}
                                IFS="${delimiters[1]}" read -r -a level_4_directive_d3_arr <<< "$level_4_directive_d3${delimiters[1]}"
                                IFS="${delimiters[1]}" read -r -a level_4_args_d3_arr <<< "$level_4_args_d3${delimiters[1]}"

                                if [ "${level_3_args}" == "=${delimiters[0]}/" ] && [ "$skip_find_nodejs" -eq 0 ] 
                                then
                                    for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                                    do
                                        if [ "${level_4_directive_d3_arr[level_4_index]}" == "proxy_pass" ] 
                                        then
                                            if [[ ${level_4_args_d3_arr[level_4_index]} =~ ^http://nodejs ]] 
                                            then
                                                nginx_localhost_nodejs_status="${green}已配置${normal}"
                                                skip_find_nodejs=1
                                            fi
                                            break
                                        fi
                                    done
                                elif [ "${level_3_args}" == "/" ] 
                                then
                                    for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                                    do
                                        if [ "${level_4_directive_d3_arr[level_4_index]}" == "root" ] 
                                        then
                                            if [ "${level_4_args_d3_arr[level_4_index]:0:1}" == "/" ] 
                                            then
                                                server_root=${level_4_args_d3_arr[level_4_index]}
                                            else
                                                server_root="$nginx_prefix/${level_4_args_d3_arr[level_4_index]}"
                                            fi
                                            break
                                        fi
                                    done
                                fi
                            fi
                        elif [ "$level_3_directive" == "root" ] 
                        then
                            if [ "${level_3_args_d2_arr[level_3_index]:0:1}" == "/" ] 
                            then
                                server_root=${level_3_args_d2_arr[level_3_index]}
                            else
                                server_root="$nginx_prefix/${level_3_args_d2_arr[level_3_index]}"
                            fi
                        fi
                    done

                    nginx_localhost_server_root+=("$server_root")
                    nginx_localhost_list="$nginx_localhost_list $nginx_localhost_server_count.${indent_6}端口: ${green}${nginx_localhost_listen:-未设置}${normal}\n${indent_6}flv: $nginx_localhost_flv_status\n${indent_6}nodejs: $nginx_localhost_nodejs_status\n\n"
                fi
            done
            break
        fi
    done

    if [ "$nginx_localhost_server_count" -eq 0 ] 
    then
        Println "$error 请先添加本地配置\n"
        exit 1
    fi

    Println "本地配置:\n\n$nginx_localhost_list"
}

NginxSelectLocalhostServer()
{
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" nginx_localhost_server_num
    do
        case "$nginx_localhost_server_num" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$nginx_localhost_server_num" -gt 0 ] && [ "$nginx_localhost_server_num" -le "$nginx_localhost_server_count" ]
                then
                    nginx_localhost_server_index=$((nginx_localhost_server_num-1))
                    level_2_add_indices=( "${nginx_localhost_server_indices[nginx_localhost_server_index]}" )
                    server_root=${nginx_localhost_server_root[nginx_localhost_server_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

NginxIsBlockDirective()
{
    local level=("level_${1}_block_directives"[@])
    local block_directives=("${!level}")
    for block_directive in "${block_directives[@]}"
    do
        if [ "$block_directive" == "$2" ] 
        then
            return 0
        fi
    done
    return 1
}

NginxInputArgs()
{
    new_args=""
    while true 
    do
        [ -n "$new_args" ] && new_args="$new_args,"
        Println "$tip 如果有空字符需包在 \"\" 中"
        inquirer text_input "输入单个指令值: " args "不设置"
        if [ "$args" == "不设置" ] 
        then
            args=""
            break
        elif [[ $args =~ ^\"(.*)\"$ ]] 
        then
            new_args="$new_args$args"
        else
            new_args="$new_args\"$args\""
        fi
        echo
        inquirer list_input "继续添加指令值" ny_options yn_option
        if [ "$yn_option" == "$i18n_no" ] 
        then
            break
        fi
    done
}

NginxAddDirective()
{
    case $1 in
        1) 
            local level_1_index
            new_directive=""
            add_count=0
            level_1_add_indices=()

            for((directive_i=0;directive_i<${#directives[@]};directive_i++));
            do
                if [ "${check_directives[directive_i]:-1}" -eq 1 ] 
                then
                    for((level_1_index=0;level_1_index<level_1_count;level_1_index++));
                    do
                        if [ "${level_1_directive_arr[level_1_index]}" == "${directives[directive_i]}" ] 
                        then
                            if [ -n "${check_args[directive_i]:-}" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"args"]'
                                JQs get parse_out args
                                if [ "$args" == "${check_args[directive_i]}" ] 
                                then
                                    level_1_add_indices+=("$level_1_index")
                                    continue 2
                                fi
                            else
                                level_1_add_indices+=("$level_1_index")
                                continue 2
                            fi
                        fi
                    done
                fi

                level_1_add_indices+=("$((level_1_count+add_count))")
                add_count=$((add_count+1))
                jq_path='["config",0,"parsed"]'
                new_directive="directive_${directives_val[directive_i]:-${directives[directive_i]}}"
                JQs add parse_out "${!new_directive}"
            done

            if [ -n "$new_directive" ] 
            then
                NginxGetConfig
                updated=1
            fi
        ;;
        2) 
            local level_1_index level_2_index
            new_directive=""
            add_count=0
            level_2_add_indices=()

            for((directive_i=0;directive_i<${#directives[@]};directive_i++));
            do
                level_1_index=${level_1_add_indices[directive_i]:-${level_1_add_indices[0]}}

                level_2_directive_d1=${level_2_directive_arr[level_1_index]}

                level_2_directive_d1_arr_count=0

                if [ -n "$level_2_directive_d1" ] 
                then
                    IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "$level_2_directive_d1${delimiters[1]}"
                    level_2_directive_d1_arr_count=${#level_2_directive_d1_arr[@]}
                fi

                if [ "${check_directives[directive_i]:-1}" -eq 1 ] 
                then
                    for((level_2_index=0;level_2_index<level_2_directive_d1_arr_count;level_2_index++));
                    do
                        if [ "${level_2_directive_d1_arr[level_2_index]}" == "${directives[directive_i]}" ] 
                        then
                            if [ -n "${check_args[directive_i]:-}" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"args"]'
                                JQs get parse_out args
                                if [ "$args" == "${check_args[directive_i]}" ] 
                                then
                                    level_2_add_indices+=("$level_2_index")
                                    continue 2
                                fi
                            else
                                level_2_add_indices+=("$level_2_index")
                                continue 2
                            fi
                        fi
                    done
                fi

                level_2_add_indices+=("$((level_2_directive_d1_arr_count+add_count))")
                add_count=$((add_count+1))
                jq_path='["config",0,"parsed",'"$level_1_index"',"block"]'
                new_directive="directive_${directives_val[directive_i]:-${directives[directive_i]}}"
                JQs add parse_out "${!new_directive}"
            done

            if [ -n "$new_directive" ] 
            then
                NginxGetConfig
                updated=1
            fi
        ;;
        3) 
            local level_1_index level_2_index level_3_index
            new_directive=""
            add_count=0
            level_3_add_indices=()

            for((directive_i=0;directive_i<${#directives[@]};directive_i++));
            do
                level_1_index=${level_1_add_indices[directive_i]:-${level_1_add_indices[0]}}
                level_2_index=${level_2_add_indices[directive_i]:-${level_2_add_indices[0]}}

                level_3_directive_d1=${level_3_directive_arr[level_1_index]}
                IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "$level_3_directive_d1${delimiters[2]}"

                level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}

                level_3_directive_d2_arr_count=0

                if [ -n "$level_3_directive_d2" ] 
                then
                    IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "$level_3_directive_d2${delimiters[1]}"
                    level_3_directive_d2_arr_count=${#level_3_directive_d2_arr[@]}
                fi

                if [ "${check_directives[directive_i]:-1}" -eq 1 ] 
                then
                    for((level_3_index=0;level_3_index<level_3_directive_d2_arr_count;level_3_index++));
                    do
                        if [ "${level_3_directive_d2_arr[level_3_index]}" == "${directives[directive_i]}" ] 
                        then
                            if [ -n "${check_args[directive_i]:-}" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"args"]'
                                JQs get parse_out args
                                if [ "$args" == "${check_args[directive_i]}" ] 
                                then
                                    level_3_add_indices+=("$level_3_index")
                                    continue 2
                                fi
                            else
                                level_3_add_indices+=("$level_3_index")
                                continue 2
                            fi
                        fi
                    done
                fi

                level_3_add_indices+=("$((level_3_directive_d2_arr_count+add_count))")
                add_count=$((add_count+1))
                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block"]'
                new_directive="directive_${directives_val[directive_i]:-${directives[directive_i]}}"
                JQs add parse_out "${!new_directive}"
            done

            if [ -n "$new_directive" ] 
            then
                NginxGetConfig
                updated=1
            fi
        ;;
        4) 
            local level_1_index level_2_index level_3_index level_4_index
            new_directive=""
            add_count=0
            level_4_add_indices=()

            for((directive_i=0;directive_i<${#directives[@]};directive_i++));
            do
                level_1_index=${level_1_add_indices[directive_i]:-${level_1_add_indices[0]}}
                level_2_index=${level_2_add_indices[directive_i]:-${level_2_add_indices[0]}}
                level_3_index=${level_3_add_indices[directive_i]:-${level_3_add_indices[0]}}

                level_4_directive_d1=${level_4_directive_arr[level_1_index]}
                IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "$level_4_directive_d1${delimiters[3]}"

                level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "$level_4_directive_d2${delimiters[2]}"

                level_4_directive_d3=${level_4_directive_d2_arr[level_3_index]}

                level_4_directive_d3_arr_count=0

                if [ -n "$level_4_directive_d3" ] 
                then
                    IFS="${delimiters[1]}" read -r -a level_4_directive_d3_arr <<< "$level_4_directive_d3${delimiters[1]}"
                    level_4_directive_d3_arr_count=${#level_4_directive_d3_arr[@]}
                fi

                if [ "${check_directives[directive_i]:-1}" -eq 1 ] 
                then
                    for((level_4_index=0;level_4_index<level_4_directive_d3_arr_count;level_4_index++));
                    do
                        if [ "${level_4_directive_d3_arr[level_4_index]}" == "${directives[directive_i]}" ] 
                        then
                            if [ -n "${check_args[directive_i]:-}" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"args"]'
                                JQs get parse_out args
                                if [ "$args" == "${check_args[directive_i]}" ] 
                                then
                                    level_4_add_indices+=("$level_4_index")
                                    continue 2
                                fi
                            else
                                level_4_add_indices+=("$level_4_index")
                                continue 2
                            fi
                        fi
                    done
                fi

                level_4_add_indices+=("$((level_4_directive_d3_arr_count+add_count))")
                add_count=$((add_count+1))
                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block"]'
                new_directive="directive_${directives_val[directive_i]:-${directives[directive_i]}}"
                JQs add parse_out "${!new_directive}"
            done

            if [ -n "$new_directive" ] 
            then
                NginxGetConfig
                updated=1
            fi
        ;;
        5) 
            local level_1_index level_2_index level_3_index level_4_index level_5_index
            new_directive=""
            add_count=0
            level_5_add_indices=()

            for((directive_i=0;directive_i<${#directives[@]};directive_i++));
            do
                level_1_index=${level_1_add_indices[directive_i]:-${level_1_add_indices[0]}}
                level_2_index=${level_2_add_indices[directive_i]:-${level_2_add_indices[0]}}
                level_3_index=${level_3_add_indices[directive_i]:-${level_3_add_indices[0]}}
                level_4_index=${level_4_add_indices[directive_i]:-${level_4_add_indices[0]}}

                level_5_directive_d1=${level_5_directive_arr[level_1_index]}
                IFS="${delimiters[4]}" read -r -a level_5_directive_d1_arr <<< "$level_5_directive_d1${delimiters[4]}"

                level_5_directive_d2=${level_5_directive_d1_arr[level_2_index]}
                IFS="${delimiters[3]}" read -r -a level_5_directive_d2_arr <<< "$level_5_directive_d2${delimiters[3]}"

                level_5_directive_d3=${level_5_directive_d2_arr[level_3_index]}
                IFS="${delimiters[2]}" read -r -a level_5_directive_d3_arr <<< "$level_5_directive_d3${delimiters[2]}"

                level_5_directive_d4=${level_5_directive_d3_arr[level_4_index]}

                level_5_directive_d4_arr_count=0

                if [ -n "$level_5_directive_d4" ] 
                then
                    IFS="${delimiters[1]}" read -r -a level_5_directive_d4_arr <<< "$level_5_directive_d4${delimiters[1]}"
                    level_5_directive_d4_arr_count=${#level_5_directive_d4_arr[@]}
                fi

                if [ "${check_directives[directive_i]:-1}" -eq 1 ] 
                then
                    for((level_5_index=0;level_5_index<level_5_directive_d4_arr_count;level_5_index++));
                    do
                        if [ "${level_5_directive_d4_arr_count[level_5_index]}" == "${directives[directive_i]}" ] 
                        then
                            if [ -n "${check_args[directive_i]:-}" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"block",'"$level_5_index"',"args"]'
                                JQs get parse_out args
                                if [ "$args" == "${check_args[directive_i]}" ] 
                                then
                                    level_5_add_indices+=("$level_5_index")
                                    continue 2
                                fi
                            else
                                level_5_add_indices+=("$level_5_index")
                                continue 2
                            fi
                        fi
                    done
                fi

                level_5_add_indices+=("$((level_5_directive_d4_arr_count+add_count))")
                add_count=$((add_count+1))
                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"block"]'
                new_directive="directive_${directives_val[directive_i]:-${directives[directive_i]}}"
                JQs add parse_out "${!new_directive}"
            done

            if [ -n "$new_directive" ] 
            then
                NginxGetConfig
                updated=1
            fi
        ;;
        level_1|level_2|level_3|level_4|level_5) 
            level_id=${1#*_}

            zh=( "" "一" "二" "三" "四" "五" )

            Println "$tip 如果有空字符需包在 \"\" 中"
            inquirer text_input "输入${zh[level_id]}级指令: " new_directive "$i18n_cancel"

            if [ "$new_directive" == "$i18n_cancel" ] 
            then
                return 0
            fi

            if [[ $new_directive =~ ^\"(.*)\"$ ]] 
            then
                new_directive=${BASH_REMATCH[1]}
            fi

            NginxInputArgs

            is_block_directive=0

            if [ "$level_id" -ne 5 ] 
            then
                Println "$tip 如果需要添加下级指令请选择 是"
                inquirer list_input "是否是 块 指令" ny_options yn_option

                if [ "$yn_option" == "$i18n_yes" ] 
                then
                    is_block_directive=1
                fi
            fi

            if [ "$is_block_directive" -eq 1 ]
            then
                directive=$(
                    $JQ_FILE -n --arg directive "$new_directive" --argjson args "[$new_args]" \
                    '{
                        "directive": $directive,
                        "args": $args,
                        "block":[]
                    }'
                )
            else
                directive=$(
                    $JQ_FILE -n --arg directive "$new_directive" --argjson args "[$new_args]" \
                    '{
                        "directive": $directive,
                        "args": $args
                    }'
                )
            fi

            jq_path='"config",0,"parsed"'

            for((level_i=1;level_i<level_id;level_i++));
            do
                index_name="level_${level_i}_index"
                jq_path="$jq_path,${!index_name},\"block\""
            done

            jq_path="[$jq_path]"
            JQs add parse_out "$directive"

            NginxBuildConf parse_out
            NginxGetConfig

            Println "$info 指令 $new_directive 添加成功\n"
        ;;
    esac
}

NginxAddUser()
{
    directive_user='{"directive":"user","args":["'"$nginx_name"'","'"$nginx_name"'"]}'
    directives=( user )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 1
}

NginxAddHttp()
{
    directive_http='
    {"directive":"http","args":[],"block":[
        {"directive":"include","args":["mime.types"]},
        {"directive":"default_type","args":["application/octet-stream"]},
        {"directive":"sendfile","args":["on"]},
        {"directive":"keepalive_timeout","args":["65"]},
        {"directive":"server","args":[],"block":[
            {"directive":"listen","args":["80"]},
            {"directive":"server_name","args":["localhost"]},
            {"directive":"access_log","args":["logs/localhost-access.log"]},
            {"directive":"error_log","args":["logs/localhost-error.log"]},
            {"directive":"location","args":["/"],"block":[
                {"directive":"root","args":["html/localhost"]},
                {"directive":"index","args":["index.html","index.htm"]}
            ]},
            {"directive":"error_page","args":["500","502","503","504","/50x.html"]},
            {"directive":"location","args":["/50x.html"],"block":[
                {"directive":"root","args":["html/localhost"]}
            ]}
        ]}
    ]}'

    directives=( http )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 1
}

NginxAddRtmp()
{
    directive_rtmp_auto_push='{"directive":"rtmp_auto_push","args":["on"]}'
    directive_rtmp_auto_push_reconnect='{"directive":"rtmp_auto_push_reconnect","args":["1s"]}'
    directive_rtmp_socket_dir='{"directive":"rtmp_socket_dir","args":["/tmp"]}'
    directive_rtmp='
    {"directive":"rtmp","args":[],"block":[
        {"directive":"out_queue","args":["4096"]},
        {"directive":"out_cork","args":["8"]},
        {"directive":"max_streams","args":["128"]},
        {"directive":"timeout","args":["15s"]},
        {"directive":"drop_idle_publisher","args":["10s"]},
        {"directive":"log_interval","args":["120s"]},
        {"directive":"log_size","args":["1m"]},
        {"directive":"server","args":[],"block":[
            {"directive":"listen","args":["1935"]},
            {"directive":"server_name","args":["localhost"]},
            {"directive":"access_log","args":["logs/flv.log"]},
            {"directive":"application","args":["flv"],"block":[
                {"directive":"live","args":["on"]},
                {"directive":"gop_cache","args":["on"]}
            ]}
        ]}
    ]}'

    directives=( rtmp_auto_push rtmp_auto_push_reconnect rtmp_socket_dir rtmp )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 1
}

NginxAddSitesEnabled()
{
    directive_include='{"directive":"include","args":["sites_enabled/*.conf"]}'
    directives=( include )
    directives_val=()
    check_directives=()
    check_args=( '["sites_enabled/*.conf"]' )

    NginxAddDirective 2
}

NginxAddSsl()
{
    directive_ssl_session_cache='{"directive":"ssl_session_cache","args":["shared:SSL:20m"]}'
    directive_ssl_session_timeout='{"directive":"ssl_session_timeout","args":["2h"]}'
    directive_ssl_prefer_server_ciphers='{"directive":"ssl_prefer_server_ciphers","args":["on"]}'
    directive_ssl_protocols='{"directive":"ssl_protocols","args":["TLSv1.2","TLSv1.3"]}'
    directive_ssl_ciphers='{"directive":"ssl_ciphers","args":["HIGH:!aNULL:!MD5"]}'
    directive_ssl_stapling='{"directive":"ssl_stapling","args":["on"]}'
    directive_ssl_stapling_verify='{"directive":"ssl_stapling_verify","args":["on"]}'
    directive_resolver='{"directive":"resolver","args":["8.8.8.8"]}'

    directives=( ssl_session_cache ssl_session_timeout ssl_prefer_server_ciphers ssl_protocols 
        ssl_ciphers ssl_stapling ssl_stapling_verify resolver )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 2
}

NginxAddLocalhost()
{
    directive_server='
    {"directive":"server","args":[],"block":[
        {"directive":"listen","args":["80"]},
        {"directive":"server_name","args":["localhost"]},
        {"directive":"access_log","args":["logs/localhost-access.log"]},
        {"directive":"error_log","args":["logs/localhost-error.log"]},
        {"directive":"location","args":["/"],"block":[
            {"directive":"root","args":["html/localhost"]},
            {"directive":"index","args":["index.html","index.htm"]}
        ]},
        {"directive":"error_page","args":["500","502","503","504","/50x.html"]},
        {"directive":"location","args":["/50x.html"],"block":[
            {"directive":"root","args":["html/localhost"]}
        ]}
    ]}'

    directives=( server )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 2
}

NginxAddNodejs()
{
    server_ip=${server_ip:-$(GetServerIp)}

    directive_location_1='
    {"directive":"location","args":["=","/"],"block":[
        {"directive":"proxy_redirect","args":["off"]},
        {"directive":"proxy_pass","args":["http://nodejs"]},
        {"directive":"proxy_cache_bypass","args":["1"]},
        {"directive":"proxy_no_cache","args":["1"]},
        {"directive":"proxy_cookie_path","args":["/","/$samesite_none"]},
        {"directive":"proxy_cookie_domain","args":["localhost","'"$server_ip"'"]}
    ]}'

    directive_location_2='
    {"directive":"location","args":["=","/channels"],"block":[
        {"directive":"proxy_redirect","args":["off"]},
        {"directive":"proxy_pass","args":["http://nodejs"]},
        {"directive":"proxy_cache_bypass","args":["1"]},
        {"directive":"proxy_no_cache","args":["1"]}
    ]}'

    directive_location_3='
    {"directive":"location","args":["=","/channels.json"],"block":[
        {"directive":"return","args":["302","/channels"]}
    ]}'

    directive_location_4='
    {"directive":"location","args":["=","/remote"],"block":[
        {"directive":"proxy_redirect","args":["off"]},
        {"directive":"proxy_pass","args":["http://nodejs"]},
        {"directive":"proxy_cache_bypass","args":["1"]},
        {"directive":"proxy_no_cache","args":["1"]},
        {"directive":"proxy_cookie_path","args":["/","/$samesite_none"]},
        {"directive":"proxy_cookie_domain","args":["localhost","'"$server_ip"'"]}
    ]}'

    directive_location_5='
    {"directive":"location","args":["=","/remote.json"],"block":[
        {"directive":"return","args":["302","/remote"]}
    ]}'

    directive_location_6='
    {"directive":"location","args":["=","/keys"],"block":[
        {"directive":"proxy_redirect","args":["off"]},
        {"directive":"proxy_pass","args":["http://nodejs"]},
        {"directive":"proxy_cache_bypass","args":["1"]},
        {"directive":"proxy_no_cache","args":["1"]}
    ]}'

    directive_location_7='
    {"directive":"location","args":["~","\\.(keyinfo|key)$"],"block":[
        {"directive":"return","args":["403"]}
    ]}'

    directive_add_header_1='{"directive":"add_header","args":["Access-Control-Allow-Origin","$cors_host"]}'
    directive_add_header_2='{"directive":"add_header","args":["Vary","Origin"]}'
    directive_add_header_3='{"directive":"add_header","args":["X-Frame-Options","SAMEORIGIN"]}'
    directive_add_header_4='{"directive":"add_header","args":["Access-Control-Allow-Credentials","true"]}'
    directive_add_header_5='{"directive":"add_header","args":["Cache-Control","no-cache"]}'

    directives=( location location location location location location location 
        add_header add_header add_header add_header add_header location )
    directives_val=( location_1 location_2 location_3 location_4 location_5 location_6 location_7 
        add_header_1 add_header_2 add_header_3 add_header_4 add_header_5 )

    check_directives=()
    check_args=( '["=","/"]' '["=","/channels"]' '["=","/channels.json"]' '["=","/remote"]' 
        '["=","/remote.json"]' '["=","/keys"]' '["~","\\.(keyinfo|key)$"]' '["Access-Control-Allow-Origin","$cors_host"]' 
        '["Vary","Origin"]' '["X-Frame-Options","SAMEORIGIN"]' '["Access-Control-Allow-Credentials","true"]' 
        '["Cache-Control","no-cache"]' )

    NginxAddDirective 3
}

NginxAddCorsHost()
{
    Println "$info 配置 cors..."

    cors_domains=()

    if ls -A "$nginx_prefix/conf/sites_available/"* > /dev/null 2>&1
    then
        for f in "$nginx_prefix/conf/sites_available/"*
        do
            domain=${f##*/}
            domain=${domain%.conf}
            if [[ $domain =~ ^([a-zA-Z0-9](([a-zA-Z0-9-]){0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$ ]] 
            then
                cors_domains+=("$domain")
            fi
        done
    fi

    directive_map='{"directive":"map","args":["$http_origin","$cors_host"],"block":[]}'
    directives=( map )
    directives_val=()

    check_directives=()
    check_args=( '["$http_origin","$cors_host"]' )

    NginxAddDirective 2

    server_ip=$(GetServerIp)

    directive_default='{"directive":"default","args":["*"]}'

    read -r directive_server_ip_http < <(
        $JQ_FILE -c -n --arg directive "~http://$server_ip" --argjson args "[\"~http://$server_ip\"]" \
        '{
            "directive":$directive,
            "args":$args
        }'
    )

    read -r directive_server_ip_https < <(
        $JQ_FILE -c -n --arg directive "~https://$server_ip" --argjson args "[\"~https://$server_ip\"]" \
        '{
            "directive":$directive,
            "args":$args
        }'
    )

    directives=( default "~http://$server_ip" "~https://$server_ip" )
    directives_val=( default server_ip_http server_ip_https )

    if [ -n "${cors_domains:-}" ]
    then
        for((cors_i=0;cors_i<${#cors_domains[@]};cors_i++));
        do
            read -r directive_cors_domain_${cors_i}_http < <(
                $JQ_FILE -c -n --arg directive "~http://${cors_domains[cors_i]}" --argjson args "[\"~http://${cors_domains[cors_i]}\"]" \
                '{
                    "directive":$directive,
                    "args":$args
                }'
            )
            read -r directive_cors_domain_${cors_i}_https < <(
                $JQ_FILE -c -n --arg directive "~https://${cors_domains[cors_i]}" --argjson args "[\"~https://${cors_domains[cors_i]}\"]" \
                '{
                    "directive":$directive,
                    "args":$args
                }'
            )
            directives+=( "~http://${cors_domains[cors_i]}" "~https://${cors_domains[cors_i]}" )
            directives_val+=( cors_domain_${cors_i}_http cors_domain_${cors_i}_https )
        done
    fi

    check_directives=()
    check_args=()

    NginxAddDirective 3

    if ! grep -q "$nginx_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser "$nginx_name" --system --group --no-create-home > /dev/null
        else
            adduser "$nginx_name" --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin "$nginx_name"
    fi

    sed -i "s/#user  nobody;/user $nginx_name $nginx_name;/" "$nginx_prefix/conf/nginx.conf"
}

NginxAddUpstreamNodejs()
{
    directive_upstream='{"directive":"upstream","args":["nodejs"],"block":[]}'

    directives=( upstream )
    directives_val=()
    check_directives=()
    check_args=( '["nodejs"]' )

    NginxAddDirective 2

    directive_server='{"directive":"server","args":["127.0.0.1:'"$nodejs_port"'"]}'

    directives=( server )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 3
}

NginxAddFlv()
{
    directive_location='{"directive":"location","args":["/flv"],"block":[]}'

    directives=( location )
    directives_val=()
    check_directives=()
    check_args=( '["/flv"]' )

    NginxAddDirective 3

    directive_flv_live='{"directive":"flv_live","args":["on"]}'
    directive_chunked_transfer_encoding='{"directive":"chunked_transfer_encoding","args":["on"]}'

    directives=( flv_live chunked_transfer_encoding )
    directives_val=()
    check_directives=()
    check_args=()

    NginxAddDirective 4
}

NginxAddSameSiteNone()
{
    directive_map='{"directive":"map","args":["$http_user_agent","$samesite_none"],"block":[]}'

    directives=( map )
    directives_val=()
    check_directives=()
    check_args=( '["$http_user_agent","$samesite_none"]' )

    NginxAddDirective 2

    directive_default='{"directive":"default","args":["; Secure"]}'
    directive_chrome='{"directive":"~Chrom[^ \\/]+\\/8[\\d][\\.\\d]*","args":["; Secure; SameSite=None"]}'

    directives=( default '~Chrom[^ \\/]+\\/8[\\d][\\.\\d]*' )
    directives_val=( default chrome )
    check_directives=()
    check_args=( '["; Secure"]' )

    NginxAddDirective 3
}

NginxBuildConf()
{
    if TMP_FILE=$(mktemp -q)
    then
        chmod +r "$TMP_FILE"
    else
        exit $?
    fi

    trap '
        rm -f "$TMP_FILE"
    ' EXIT

    if [ "$parse_domain" -eq 1 ] 
    then
        parse_out_domain=${!1}
        jq_path='["config",0,"parsed",0,"block"]'
        JQs get parse_out_domain domain_conf
        jq_path='["config",0,"parsed"]'
        JQs replace parse_out_domain "$domain_conf"
        echo "$parse_out_domain" > "$TMP_FILE"
    else
        echo "${!1}" > "$TMP_FILE"
    fi

    crossplane build -f --no-headers "$TMP_FILE"

    rm -f "$TMP_FILE"

    trap - EXIT
}

NginxCheckLocalhost()
{
    if [ ! -d "$nginx_prefix" ] 
    then
        Println "$error $nginx_name 未安装 !\n"
        exit 1
    fi

    mkdir -p "$nginx_prefix/conf/sites_crt/"
    mkdir -p "$nginx_prefix/conf/sites_available/"
    mkdir -p "$nginx_prefix/conf/sites_enabled/"

    NginxParseConfig
    NginxGetConfig

    updated=0

    NginxAddUser

    NginxAddHttp

    NginxAddSitesEnabled

    NginxAddSsl

    server_offset=0

    if [ "$level_2_d1_count" -gt 0 ] 
    then
        for((level_1_index=0;level_1_index<level_1_count;level_1_index++));
        do
            if [ "${level_1_directive_arr[level_1_index]}" == "http" ] 
            then
                if [ -z "${level_2_directive_arr[level_1_index]}" ] 
                then
                    break
                fi

                level_2_directive_d1=${level_2_directive_arr[level_1_index]}
                level_2_args_d1=${level_2_args_arr[level_1_index]}
                IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "$level_2_directive_d1${delimiters[1]}"
                IFS="${delimiters[1]}" read -r -a level_2_args_d1_arr <<< "$level_2_args_d1${delimiters[1]}"

                if [ "$level_3_d1_count" -gt 0 ] && [ -n "${level_3_directive_arr[level_1_index]}" ]
                then
                    level_3_directive_d1=${level_3_directive_arr[level_1_index]}
                    level_3_args_d1=${level_3_args_arr[level_1_index]}
                    IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "$level_3_directive_d1${delimiters[2]}"
                    IFS="${delimiters[2]}" read -r -a level_3_args_d1_arr <<< "$level_3_args_d1${delimiters[2]}"
                fi

                for((level_2_index=0;level_2_index<${#level_2_directive_d1_arr[@]};level_2_index++));
                do
                    if [ "${level_2_directive_d1_arr[level_2_index]}" == "server" ] && [ "$level_3_d1_count" -gt 0 ] && [ -n "${level_3_directive_arr[level_1_index]}" ] && [ -n "${level_3_directive_d1_arr[level_2_index]}" ]
                    then
                        level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}
                        level_3_args_d2=${level_3_args_d1_arr[level_2_index]}
                        IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "$level_3_directive_d2${delimiters[1]}"
                        IFS="${delimiters[1]}" read -r -a level_3_args_d2_arr <<< "$level_3_args_d2${delimiters[1]}"

                        for((level_3_index=0;level_3_index<${#level_3_directive_d2_arr[@]};level_3_index++));
                        do
                            if [ "${level_3_directive_d2_arr[level_3_index]}" == "server_name" ] 
                            then
                                if [ "${level_3_args_d2_arr[level_3_index]}" == "localhost" ] 
                                then
                                    continue 2
                                fi
                                updated=1
                                IFS="${delimiters[0]}" read -r -a domains <<< "${level_3_args_d2_arr[level_3_index]}${delimiters[0]}"
                                new_conf='{"status":"ok","errors":[],"config":[]}'
                                localhost_found=0
                                for((l=0;l<${#domains[@]};l++));
                                do
                                    if [ "${domains[l]}" == "localhost" ] 
                                    then
                                        localhost_found=1
                                        continue
                                    fi
                                    jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"']'
                                    JQs get parse_out new_server
                                    jq_path='["block",'"$level_3_index"',"args"]'
                                    JQs replace new_server '["'${domains[l]}'"]'
                                    jq_path='["config"]'
                                    JQs add new_conf '{"file":"'"$nginx_prefix/conf/sites_available/${domains[l]}.conf"'","status":"ok","errors":[],"parsed":['"$new_server"']}'
                                    ln -sf "$nginx_prefix/conf/sites_available/${domains[l]}.conf" "$nginx_prefix/conf/sites_enabled/"
                                done
                                NginxBuildConf new_conf
                                if [ "$localhost_found" -eq 0 ] 
                                then
                                    jq_path='["config",0,"parsed",'"$level_1_index"',"block"]'
                                    JQs delete parse_out "$((j-server_offset))"
                                    server_offset=$((server_offset+1))
                                else
                                    jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"args"]'
                                    JQs replace parse_out '["localhost"]'
                                fi
                            elif [ "${level_3_directive_d2_arr[level_3_index]}" == "add_header" ] && [ "${level_3_args_d2_arr[level_3_index]}" == 'Access-Control-Allow-Origin'"${delimiters[0]}"'$corsHost' ]
                            then
                                updated=1
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"args"]'
                                JQs replace parse_out '["Access-Control-Allow-Origin","$cors_host"]'
                            fi
                        done
                    elif [ "${level_2_directive_d1_arr[level_2_index]}" == "map" ] && [ "${level_2_args_d1_arr[level_2_index]}" == '$http_origin'"${delimiters[0]}"'$corsHost' ]
                    then
                        updated=1
                        jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"args"]'
                        JQs replace parse_out '["$http_origin","$cors_host"]'
                    fi
                done
                break
            fi
        done
    fi

    if [ "$server_offset" -gt 0 ] 
    then
        NginxGetConfig
    fi

    NginxAddLocalhost

    NginxAddRtmp

    if [ "$updated" -eq 1 ] 
    then
        NginxBuildConf parse_out

        if ls -A "$nginx_prefix/conf/sites_available/"* > /dev/null 2>&1 
        then
            for f in "$nginx_prefix/conf/sites_available/"*
            do
                sed -i 's/$corsHost/$cors_host/g' "$f"
            done
        fi

        sed -i 's/$corsHost/$cors_host/g' "$nginx_prefix/conf/nginx.conf"
    fi
}

NginxConfigDirective()
{
    case $1 in
        level_1) 
            while true 
            do
                level_1_options=()

                for((level_1_index=0;level_1_index<level_1_count;level_1_index++));
                do
                    level_1_option=${level_1_directive_arr[level_1_index]:-\"\"}

                    if [ -n "${level_1_args_arr[level_1_index]}" ] 
                    then
                        IFS="${delimiters[0]}" read -r -a args <<< "${level_1_args_arr[level_1_index]}${delimiters[0]}"
                        for arg in "${args[@]}"
                        do
                            if [[ $arg == *" "* ]] 
                            then
                                arg="\"$arg\""
                            fi
                            level_1_option="$level_1_option ${arg:-\"\"}"
                        done
                    fi

                    if [ "$level_2_d1_count" -gt 0 ] && [ -n "${level_2_directive_arr[level_1_index]}" ]
                    then
                        level_1_option="$level_1_option {...}"
                    fi

                    level_1_options+=("$level_1_option")
                done

                level_1_options+=("添加指令" "$i18n_cancel")
                level_1_options_count=${#level_1_options[@]}

                while true 
                do
                    echo
                    inquirer list_input_index "选择指令" level_1_options level_1_index

                    if [ "$level_1_index" -eq "$((level_1_options_count-1))" ] 
                    then
                        Println "$i18n_canceled...\n"
                        break
                    elif [ "$level_1_index" -eq "$((level_1_options_count-2))" ] 
                    then
                        NginxAddDirective level_1
                        continue 2
                    else
                        level_1_actions=("修改二级指令" "修改指令" "删除指令" "返回选择")

                        echo
                        inquirer list_input "选择操作" level_1_actions level_1_action

                        if [ "$level_1_action" == "修改二级指令" ] 
                        then
                            from_level_1=1
                            NginxConfigDirective level_2
                            unset from_level_1
                        elif [ "$level_1_action" == "修改指令" ]
                        then
                            NginxInputArgs
                            jq_path='["config",0,"parsed",'"$level_1_index"',"args"]'
                            JQs replace parse_out "[$new_args]"
                            NginxBuildConf parse_out
                            NginxGetConfig
                            Println "$info ${level_1_directive_arr[level_1_index]} 指令修改成功\n"
                            continue 2
                        elif [ "$level_1_action" == "删除指令" ] 
                        then
                            echo
                            inquirer list_input "确认删除, 此操作不可恢复" ny_options yn_option
                            if [ "$yn_option" == "$i18n_yes" ] 
                            then
                                jq_path='["config",0,"parsed"]'
                                JQs delete parse_out "$level_1_index"
                                NginxBuildConf parse_out
                                NginxGetConfig
                                Println "$info 已删除指令 ${level_1_directive_arr[level_1_index]}\n"
                                continue 2
                            fi
                        fi
                    fi
                done
                break
            done
        ;;
        level_2) 
            while true 
            do
                level_2_options=()

                if [ "$level_2_d1_count" -gt 0 ] 
                then
                    level_2_directive_d1=${level_2_directive_arr[level_1_index]}
                    level_2_args_d1=${level_2_args_arr[level_1_index]}

                    IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "${level_2_directive_d1}${delimiters[1]}"
                    IFS="${delimiters[1]}" read -r -a level_2_args_d1_arr <<< "${level_2_args_d1}${delimiters[1]}"

                    if [ "$level_3_d1_count" -gt 0 ] && [ -n "${level_3_directive_arr[level_1_index]}" ]
                    then
                        level_3_directive_d1=${level_3_directive_arr[level_1_index]}
                        IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "${level_3_directive_d1}${delimiters[2]}"
                    fi

                    for((level_2_index=0;level_2_index<${#level_2_directive_d1_arr[@]};level_2_index++));
                    do
                        level_2_option=${level_2_directive_d1_arr[level_2_index]:-\"\"}

                        if [ -n "${level_2_args_d1_arr[level_2_index]}" ] 
                        then
                            IFS="${delimiters[0]}" read -r -a args <<< "${level_2_args_d1_arr[level_2_index]}${delimiters[0]}"
                            for arg in "${args[@]}"
                            do
                                if [[ $arg == *" "* ]] 
                                then
                                    arg="\"$arg\""
                                fi
                                level_2_option="$level_2_option ${arg:-\"\"}"
                            done
                        fi

                        if [ "$level_3_d1_count" -gt 0 ] && [ -n "${level_3_directive_arr[level_1_index]}" ] && [ -n "${level_3_directive_d1_arr[level_2_index]}" ]
                        then
                            level_2_option="$level_2_option {...}"
                        fi

                        level_2_options+=("$level_2_option")
                    done
                fi

                level_2_options+=("添加指令")

                if [ "${from_level_1:-0}" -eq 1 ] 
                then
                    level_2_options+=("返回一级指令")
                else
                    level_2_options+=("$i18n_cancel")
                fi

                level_2_options_count=${#level_2_options[@]}

                while true 
                do
                    echo
                    inquirer list_input_index "选择指令" level_2_options level_2_index

                    if [ "$level_2_index" -eq "$((level_2_options_count-1))" ] 
                    then
                        if [ "${from_level_1:-0}" -eq 0 ] 
                        then
                            Println "$i18n_canceled...\n"
                        fi
                        break
                    elif [ "$level_2_index" -eq "$((level_2_options_count-2))" ] 
                    then
                        NginxAddDirective level_2
                        continue 2
                    else
                        level_2_actions=("修改三级指令" "修改指令" "删除指令" "返回选择")

                        echo
                        inquirer list_input "选择操作" level_2_actions level_2_action

                        if [ "$level_2_action" == "修改三级指令" ] 
                        then
                            from_level_2=1
                            NginxConfigDirective level_3
                            unset from_level_2
                        elif [ "$level_2_action" == "修改指令" ]
                        then
                            NginxInputArgs
                            jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"args"]'
                            JQs replace parse_out "[$new_args]"
                            NginxBuildConf parse_out
                            NginxGetConfig
                            Println "$info ${level_2_directive_d1_arr[level_2_index]} 指令修改成功\n"
                            continue 2
                        elif [ "$level_2_action" == "删除指令" ] 
                        then
                            echo
                            inquirer list_input "确认删除, 此操作不可恢复" ny_options yn_option
                            if [ "$yn_option" == "$i18n_yes" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block"]'
                                JQs delete parse_out "$level_2_index"
                                NginxBuildConf parse_out
                                NginxGetConfig
                                Println "$info 已删除指令 ${level_2_directive_d1_arr[level_2_index]}\n"
                                continue 2
                            fi
                        fi
                    fi
                done
                break
            done
        ;;
        level_3) 
            while true 
            do
                level_3_options=()

                if [ "$level_3_d1_count" -gt 0 ] 
                then
                    level_3_directive_d1=${level_3_directive_arr[level_1_index]}
                    level_3_args_d1=${level_3_args_arr[level_1_index]}

                    IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "${level_3_directive_d1}${delimiters[2]}"
                    IFS="${delimiters[2]}" read -r -a level_3_args_d1_arr <<< "${level_3_args_d1}${delimiters[2]}"

                    if [ -n "${level_3_directive_d1_arr[level_2_index]}" ] 
                    then
                        level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}
                        level_3_args_d2=${level_3_args_d1_arr[level_2_index]}

                        IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "${level_3_directive_d2}${delimiters[1]}"
                        IFS="${delimiters[1]}" read -r -a level_3_args_d2_arr <<< "${level_3_args_d2}${delimiters[1]}"

                        if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_arr[level_1_index]}" ]
                        then
                            level_4_directive_d1=${level_4_directive_arr[level_1_index]}
                            IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "${level_4_directive_d1}${delimiters[3]}"
                            if [ -n "${level_4_directive_d1_arr[level_2_index]}" ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ]
                            then
                                level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                                IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "${level_4_directive_d2}${delimiters[2]}"
                            fi
                        fi

                        for((level_3_index=0;level_3_index<${#level_3_directive_d2_arr[@]};level_3_index++));
                        do
                            level_3_option=${level_3_directive_d2_arr[level_3_index]:-\"\"}

                            if [ -n "${level_3_args_d2_arr[level_3_index]}" ] 
                            then
                                IFS="${delimiters[0]}" read -r -a args <<< "${level_3_args_d2_arr[level_3_index]}${delimiters[0]}"
                                for arg in "${args[@]}"
                                do
                                    if [[ $arg == *" "* ]] 
                                    then
                                        arg="\"$arg\""
                                    fi
                                    level_3_option="$level_3_option ${arg:-\"\"}"
                                done
                            fi

                            if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_arr[level_1_index]}" ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ] && [ -n "${level_4_directive_d2_arr[level_3_index]}" ]
                            then
                                level_3_option="$level_3_option {...}"
                            fi

                            level_3_options+=("$level_3_option")
                        done
                    fi
                fi

                level_3_options+=("添加指令")

                if [ "${from_level_2:-0}" -eq 1 ] 
                then
                    level_3_options+=("返回二级指令")
                else
                    level_3_options+=("$i18n_cancel")
                fi

                level_3_options_count=${#level_3_options[@]}

                while true 
                do
                    echo
                    inquirer list_input_index "选择指令" level_3_options level_3_index

                    if [ "$level_3_index" -eq "$((level_3_options_count-1))" ] 
                    then
                        if [ "${from_level_2:-0}" -eq 0 ] 
                        then
                            Println "$i18n_canceled...\n"
                        fi
                        break
                    elif [ "$level_3_index" -eq "$((level_3_options_count-2))" ] 
                    then
                        NginxAddDirective level_3
                        continue 2
                    else
                        level_3_actions=("修改四级指令" "修改指令" "删除指令" "返回选择")

                        echo
                        inquirer list_input "选择操作" level_3_actions level_3_action

                        if [ "$level_3_action" == "修改四级指令" ] 
                        then
                            from_level_3=1
                            NginxConfigDirective level_4
                            unset from_level_3
                        elif [ "$level_3_action" == "修改指令" ]
                        then
                            NginxInputArgs
                            jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"args"]'
                            JQs replace parse_out "[$new_args]"
                            NginxBuildConf parse_out
                            NginxGetConfig
                            Println "$info ${level_3_directive_d2_arr[level_3_index]} 指令修改成功\n"
                            continue 2
                        elif [ "$level_3_action" == "删除指令" ] 
                        then
                            echo
                            inquirer list_input "确认删除, 此操作不可恢复" ny_options yn_option
                            if [ "$yn_option" == "$i18n_yes" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block"]'
                                JQs delete parse_out "$level_3_index"
                                NginxBuildConf parse_out
                                NginxGetConfig
                                Println "$info 已删除指令 ${level_3_directive_d2_arr[level_3_index]}\n"
                                continue 2
                            fi
                        fi
                    fi
                done
                break
            done
        ;;
        level_4) 
            while true 
            do
                level_4_options=()

                if [ "$level_4_d1_count" -gt 0 ] 
                then
                    level_4_directive_d1=${level_4_directive_arr[level_1_index]}
                    level_4_args_d1=${level_4_args_arr[level_1_index]}

                    IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "${level_4_directive_d1}${delimiters[3]}"
                    IFS="${delimiters[3]}" read -r -a level_4_args_d1_arr <<< "${level_4_args_d1}${delimiters[3]}"

                    level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                    level_4_args_d2=${level_4_args_d1_arr[level_2_index]}

                    IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "${level_4_directive_d2}${delimiters[2]}"
                    IFS="${delimiters[2]}" read -r -a level_4_args_d2_arr <<< "${level_4_args_d2}${delimiters[2]}"

                    if [ -n "${level_4_directive_d2_arr[level_3_index]}" ]
                    then
                        level_4_directive_d3=${level_4_directive_d2_arr[level_3_index]}
                        level_4_args_d3=${level_4_args_d2_arr[level_3_index]}

                        IFS="${delimiters[1]}" read -r -a level_4_directive_d3_arr <<< "${level_4_directive_d3}${delimiters[1]}"
                        IFS="${delimiters[1]}" read -r -a level_4_args_d3_arr <<< "${level_4_args_d3}${delimiters[1]}"

                        if [ "$level_5_d1_count" -gt 0 ] && [ -n "${level_5_directive_arr[level_1_index]}" ]
                        then
                            level_5_directive_d1=${level_5_directive_arr[level_1_index]}
                            IFS="${delimiters[4]}" read -r -a level_5_directive_d1_arr <<< "${level_5_directive_d1}${delimiters[4]}"
                            if [ -n "${level_5_directive_d1_arr[level_2_index]}" ] 
                            then
                                level_5_directive_d2=${level_5_directive_d1_arr[level_2_index]}
                                IFS="${delimiters[3]}" read -r -a level_5_directive_d2_arr <<< "${level_5_directive_d2}${delimiters[3]}"
                                if [ -n "${level_5_directive_d2_arr[level_3_index]}" ] 
                                then
                                    level_5_directive_d3=${level_5_directive_d2_arr[level_3_index]}
                                    IFS="${delimiters[2]}" read -r -a level_5_directive_d3_arr <<< "${level_5_directive_d3}${delimiters[2]}"
                                fi
                            fi
                        fi

                        for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                        do
                            level_4_option=${level_4_directive_d3_arr[level_4_index]:-\"\"}

                            if [ -n "${level_4_args_d3_arr[level_4_index]}" ] 
                            then
                                IFS="${delimiters[0]}" read -r -a args <<< "${level_4_args_d3_arr[level_4_index]}${delimiters[0]}"
                                for arg in "${args[@]}"
                                do
                                    if [[ $arg == *" "* ]] 
                                    then
                                        arg="\"$arg\""
                                    fi
                                    level_4_option="$level_4_option ${arg:-\"\"}"
                                done
                            fi

                            if [ "$level_5_d1_count" -gt 0 ] && [ -n "${level_5_directive_arr[level_1_index]}" ] && [ -n "${level_5_directive_d1_arr[level_2_index]}" ] && [ -n "${level_5_directive_d2_arr[level_3_index]}" ] && [ -n "${level_5_directive_d3_arr[level_4_index]}" ]
                            then
                                level_4_option="$level_4_option {...}"
                            fi

                            level_4_options+=("$level_4_option")
                        done
                    fi
                fi

                level_4_options+=("添加指令")

                if [ "${from_level_3:-0}" -eq 1 ] 
                then
                    level_4_options+=("返回三级指令")
                else
                    level_4_options+=("$i18n_cancel")
                fi

                level_4_options_count=${#level_4_options[@]}

                while true 
                do
                    echo
                    inquirer list_input_index "选择指令" level_4_options level_4_index

                    if [ "$level_4_index" -eq "$((level_4_options_count-1))" ] 
                    then
                        if [ "${from_level_3:-0}" -eq 0 ] 
                        then
                            Println "$i18n_canceled...\n"
                        fi
                        break
                    elif [ "$level_4_index" -eq "$((level_4_options_count-2))" ] 
                    then
                        NginxAddDirective level_4
                        continue 2
                    else
                        level_4_actions=("修改五级指令" "修改指令" "删除指令" "返回选择")

                        echo
                        inquirer list_input "选择操作" level_4_actions level_4_action

                        if [ "$level_4_action" == "修改五级指令" ] 
                        then
                            from_level_4=1
                            NginxConfigDirective level_5
                            unset from_level_4
                        elif [ "$level_4_action" == "修改指令" ]
                        then
                            NginxInputArgs
                            jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"args"]'
                            JQs replace parse_out "[$new_args]"
                            NginxBuildConf parse_out
                            NginxGetConfig
                            Println "$info ${level_4_directive_d3_arr[level_4_index]} 指令修改成功\n"
                            continue 2
                        elif [ "$level_4_action" == "删除指令" ] 
                        then
                            echo
                            inquirer list_input "确认删除, 此操作不可恢复" ny_options yn_option
                            if [ "$yn_option" == "$i18n_yes" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block"]'
                                JQs delete parse_out "$level_4_index"
                                NginxBuildConf parse_out
                                NginxGetConfig
                                Println "$info 已删除指令 ${level_4_directive_d3_arr[level_4_index]}\n"
                                continue 2
                            fi
                        fi
                    fi
                done
                break
            done
        ;;
        level_5) 
            while true 
            do
                level_5_options=()

                if [ "$level_5_d1_count" -gt 0 ] 
                then
                    level_5_directive_d1=${level_5_directive_arr[level_1_index]}
                    level_5_args_d1=${level_5_args_arr[level_1_index]}

                    IFS="${delimiters[4]}" read -r -a level_5_directive_d1_arr <<< "${level_5_directive_d1}${delimiters[4]}"
                    IFS="${delimiters[4]}" read -r -a level_5_args_d1_arr <<< "${level_5_args_d1}${delimiters[4]}"

                    level_5_directive_d2=${level_5_directive_d1_arr[level_2_index]}
                    level_5_args_d2=${level_5_args_arr[level_2_index]}

                    IFS="${delimiters[3]}" read -r -a level_5_directive_d2_arr <<< "${level_5_directive_d2}${delimiters[3]}"
                    IFS="${delimiters[3]}" read -r -a level_5_args_d2_arr <<< "${level_5_args_d2}${delimiters[3]}"

                    level_5_directive_d3=${level_5_directive_d2_arr[level_3_index]}
                    level_5_args_d3=${level_5_args_d2_arr[level_3_index]}

                    IFS="${delimiters[2]}" read -r -a level_5_directive_d3_arr <<< "${level_5_directive_d3}${delimiters[2]}"
                    IFS="${delimiters[2]}" read -r -a level_5_args_d3_arr <<< "${level_5_args_d3}${delimiters[2]}"

                    if [ -n "${level_5_directive_d3_arr[level_4_index]}" ]
                    then
                        level_5_directive_d4=${level_5_directive_d3_arr[level_4_index]}
                        level_5_args_d4=${level_5_args_d3_arr[level_4_index]}

                        IFS="${delimiters[1]}" read -r -a level_5_directive_d4_arr <<< "${level_5_directive_d4}${delimiters[1]}"
                        IFS="${delimiters[1]}" read -r -a level_5_args_d4_arr <<< "${level_5_args_d4}${delimiters[1]}"

                        for((level_5_index=0;level_5_index<${#level_5_directive_d4_arr[@]};level_5_index++));
                        do
                            level_5_option=${level_5_directive_d4_arr[level_5_index]:-\"\"}

                            if [ -n "${level_5_args_d4_arr[level_5_index]}" ] 
                            then
                                IFS="${delimiters[0]}" read -r -a args <<< "${level_5_args_d4_arr[level_5_index]}${delimiters[0]}"
                                for arg in "${args[@]}"
                                do
                                    if [[ $arg == *" "* ]] 
                                    then
                                        arg="\"$arg\""
                                    fi
                                    level_5_option="$level_5_option ${arg:-\"\"}"
                                done
                            fi

                            level_5_options+=("$level_5_option")
                        done
                    fi
                fi

                level_5_options+=("添加指令")

                if [ "${from_level_4:-0}" -eq 1 ] 
                then
                    level_5_options+=("返回四级指令")
                else
                    level_5_options+=("$i18n_cancel")
                fi

                level_5_options_count=${#level_5_options[@]}

                while true 
                do
                    echo
                    inquirer list_input_index "选择指令" level_5_options level_5_index

                    if [ "$level_5_index" -eq "$((level_5_options_count-1))" ] 
                    then
                        if [ "${from_level_4:-0}" -eq 0 ] 
                        then
                            Println "$i18n_canceled...\n"
                        fi
                        break
                    elif [ "$level_5_index" -eq "$((level_5_options_count-2))" ] 
                    then
                        NginxAddDirective level_5
                        continue 2
                    else
                        level_5_actions=("修改指令" "删除指令" "返回选择")

                        echo
                        inquirer list_input "选择操作" level_5_actions level_5_action

                        if [ "$level_5_action" == "修改指令" ]
                        then
                            NginxInputArgs
                            jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"block",'"$level_5_index"',"args"]'
                            JQs replace parse_out "[$new_args]"
                            NginxBuildConf parse_out
                            NginxGetConfig
                            Println "$info ${level_5_directive_d4_arr[level_5_index]} 指令修改成功\n"
                            continue 2
                        elif [ "$level_5_action" == "删除指令" ] 
                        then
                            echo
                            inquirer list_input "确认删除, 此操作不可恢复" ny_options yn_option
                            if [ "$yn_option" == "$i18n_yes" ] 
                            then
                                jq_path='["config",0,"parsed",'"$level_1_index"',"block",'"$level_2_index"',"block",'"$level_3_index"',"block",'"$level_4_index"',"block"]'
                                JQs delete parse_out "$level_5_index"
                                NginxBuildConf parse_out
                                NginxGetConfig
                                Println "$info 已删除指令 ${level_5_directive_d4_arr[level_5_index]}\n"
                                continue 2
                            fi
                        fi
                    fi
                done
                break
            done
        ;;
    esac
}

NginxConfigLocalhost()
{
    NginxCheckLocalhost

    NginxConfigDirective level_1
}

NginxConfigServerHttpPort()
{
    echo
    inquirer text_input "输入 http 端口: " server_http_port 80
}

NginxConfigServerHttpsPort()
{
    echo
    inquirer text_input "输入 https 端口: " server_https_port 443
}

NginxConfigServerRoot()
{
    Println "设置公开的根目录"
    while read -p "(默认: $nginx_prefix/html): " server_root 
    do
        if [ -z "$server_root" ] 
        then
            server_root="$nginx_prefix/html"
            break
        elif [ "${server_root:0:1}" != "/" ] 
        then
            Println "$error 输入错误\n"
        else
            if [ "${server_root: -1}" == "/" ] 
            then
                server_root=${server_root:0:-1}
            fi

            mkdir -p "$server_root"
            break
        fi
    done
}

NginxConfigServerLiveRoot()
{
    Println "设置公开目录下的(live目录 - HLS输出目录)位置"
    while read -p "(默认: $server_root/): " server_live_root 
    do
        if [ -z "$server_live_root" ] 
        then
            server_live_root=$server_root
            ln -sf "$LIVE_ROOT" "$server_live_root/"
            break
        elif [ "${server_live_root:0:1}" != "/" ] 
        then
            Println "$error 输入错误\n"
        else
            if [ "${server_live_root: -1}" == "/" ] 
            then
                server_live_root=${server_live_root:0:-1}
            fi

            mkdir -p "$server_live_root"
            ln -sf "$LIVE_ROOT" "$server_live_root/"
            break
        fi
    done
}

NginxConfigBlockAliyun()
{
    echo
    inquirer list_input "是否屏蔽所有阿里云ip段" ny_options block_aliyun_yn
    if [[ $block_aliyun_yn == "$i18n_yes" ]] 
    then
        Println "输入本机IP"
        echo -e "$tip 多个IP用空格分隔\n"

        while read -p "(默认: 自动检测): " server_ip
        do
            server_ip=${server_ip:-$(GetServerIp)}
            if [ -z "$server_ip" ]
            then
                Println "$error 无法获取本机IP, 请手动输入\n"
            else
                Println "$info      本机IP: $server_ip\n"
                break
            fi
        done

        start=0
        deny_aliyun="
            location ${server_live_root#*$server_root}/${LIVE_ROOT##*/} {"

        IFS=" " read -ra server_ips <<< "$server_ip"
        for ip in "${server_ips[@]}"
        do
            deny_aliyun="$deny_aliyun
                allow $ip;"
        done

        while IFS= read -r line 
        do
            if [[ $line == *"ipTabContent"* ]] 
            then
                start=1
            elif [ "$start" -eq 1 ] && [[ $line == *"AS45102"* ]] 
            then
                line=${line#*AS45102\/}
                ip=${line%\"*}
                deny_aliyun="$deny_aliyun
                deny $ip;"
            elif [ "$start" -eq 1 ] && [[ $line == *"</tbody>"* ]] 
            then
                break
            fi
        done < <(curl -s -Lm 10 -H "User-Agent: $USER_AGENT_BROWSER" https://ipinfo.io/AS45102)
        deny_aliyun="$deny_aliyun
                allow all;"
        deny_aliyun="$deny_aliyun
            }

"
    fi
}

NginxDomainUpdateCrt()
{
    local domain=$1 quiet=${2:-0}

    [ "$quiet" -eq 0 ] && Println "$info 更新 $domain 证书..."

    if [ ! -f "$HOME/.acme.sh/acme.sh" ] 
    then
        DepInstall socat
        bash <(curl -s -m 20 https://get.acme.sh) > /dev/null
    fi

    if [ -f /etc/systemd/system/mmproxy-acme.service ] 
    then
        if [ -z "${tls_port:-}" ] 
        then
            tls_port=$(grep ^ExecStart= < /etc/systemd/system/mmproxy-acme.service)
            if [[ $tls_port =~ -4\ 127.0.0.1:([^ ]+) ]] 
            then
                tls_port=${BASH_REMATCH[1]}
            else
                tls_port=${tls_port#*-4 }
                tls_port=${tls_port#*:}
                tls_port=${tls_port%% *}
            fi
        fi

        ~/.acme.sh/acme.sh --force --issue --alpn --tlsport "$tls_port" -d "$domain" --standalone -k ec-256 > /dev/null
        ~/.acme.sh/acme.sh --force --installcert -d "$domain" --fullchainpath "$nginx_prefix/conf/sites_crt/$domain.crt" --keypath "$nginx_prefix/conf/sites_crt/$domain.key" --ecc > /dev/null
    else
        stopped=0

        if [[ $(systemctl is-active $nginx_name) == "active" ]]
        then
            systemctl stop $nginx_name
            stopped=1
        fi

        sleep 1

        ~/.acme.sh/acme.sh --force --issue -d "$domain" --standalone -k ec-256 > /dev/null
        ~/.acme.sh/acme.sh --force --installcert -d "$domain" --fullchainpath "$nginx_prefix/conf/sites_crt/$domain.crt" --keypath "$nginx_prefix/conf/sites_crt/$domain.key" --ecc > /dev/null

        [ "$stopped" -eq 1 ] && systemctl start $nginx_name
    fi

    [ "$quiet" -eq 0 ] && Println "$info $domain 证书更新成功\n"

    return 0
}

NginxDomainServerUpdateCrt()
{
    nginx_domain_server_name=${nginx_domain_servers_name[nginx_domain_servers_index]}

    if [[ $nginx_domain_server_name =~ , ]] 
    then
        IFS="," read -r -a domains <<< "$nginx_domain_server_name"

        echo
        set +u
        inquirer checkbox_input "选择域名: " domains domains_selected
        set -u

        for domain in "${domains_selected[@]}"
        do
            NginxDomainUpdateCrt "$domain"
        done

        return 0
    fi

    NginxDomainUpdateCrt "$nginx_domain_server_name"
}

NginxToggleDomain()
{
    NginxListDomains

    [ "$nginx_domains_count" -eq 0 ] && Println "$error 没有域名\n" && exit 1

    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" nginx_domains_index
    do
        case "$nginx_domains_index" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$nginx_domains_index" -gt 0 ] && [ "$nginx_domains_index" -le "$nginx_domains_count" ]
                then
                    nginx_domains_index=$((nginx_domains_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    server_domain=${nginx_domains[nginx_domains_index]}
    if [ "${nginx_domains_status[nginx_domains_index]}" -eq 1 ] 
    then
        NginxDisableDomain
        Println "$info $server_domain 关闭成功\n"
    else
        NginxEnableDomain
        Println "$info $server_domain 开启成功\n"
    fi
}

NginxDeleteDomain()
{
    NginxListDomains

    [ "$nginx_domains_count" -eq 0 ] && Println "$error 没有域名\n" && exit 1

    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" nginx_domains_index
    do
        case "$nginx_domains_index" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$nginx_domains_index" -gt 0 ] && [ "$nginx_domains_index" -le "$nginx_domains_count" ]
                then
                    nginx_domains_index=$((nginx_domains_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    server_domain=${nginx_domains[nginx_domains_index]}
    if [ "${nginx_domains_status[nginx_domains_index]}" -eq 1 ] 
    then
        NginxDisableDomain
    fi
    rm -f "$nginx_prefix/conf/sites_available/$server_domain.conf"
    Println "$info $server_domain 删除成功\n"
}

NginxLogRotate()
{
    if [ ! -d "$IPTV_ROOT" ] 
    then
        Println "$error 请先安装脚本 !\n" && exit 1
    fi

    if ! ls -A $nginx_prefix/logs/*.log > /dev/null 2>&1
    then
        Println "$error 没有日志 !\n" && exit 1
    fi

    if [ -d "$nginx_prefix" ] 
    then
        chown $nginx_name:root $nginx_prefix/logs/*.log
        chmod 660 $nginx_prefix/logs/*.log
    fi

    if crontab -l | grep -q "$LOGROTATE_CONFIG" 2> /dev/null
    then
        if grep -q "$nginx_prefix" < "$LOGROTATE_CONFIG"
        then
            Println "$error 日志切割定时任务已存在 !\n"
        else
            logrotate='
'"$nginx_prefix"'/logs/*.log {
  daily
  missingok
  rotate 14
  compress
  delaycompress
  notifempty
  create 660 nginx root
  sharedscripts
  postrotate
    [ ! -f '"$nginx_prefix"'/logs/nginx.pid ] || /bin/kill -USR1 `cat '"$nginx_prefix"'/logs/nginx.pid`
  endscript
}
'
            printf '%s\n' "$logrotate" >> "$LOGROTATE_CONFIG"
            Println "$error 日志切割定时任务设置成功 !\n"
        fi
    else
        LOGROTATE_FILE=$(command -v logrotate)

        if [ ! -x "$LOGROTATE_FILE" ] 
        then
            Println "$error 请先安装 logrotate !\n" && exit 1
        fi

        logrotate=""

        if [ -d "$nginx_prefix" ] 
        then
            logrotate='
'"$nginx_prefix"'/logs/*.log {
  daily
  missingok
  rotate 14
  compress
  delaycompress
  notifempty
  create 660 nginx root
  sharedscripts
  postrotate
    [ ! -f '"$nginx_prefix"'/logs/nginx.pid ] || /bin/kill -USR1 `cat '"$nginx_prefix"'/logs/nginx.pid`
  endscript
}
'
    fi

    logrotate="$logrotate
$IPTV_ROOT/*.log {
  monthly
  missingok
  rotate 3
  compress
  nodelaycompress
  notifempty
  sharedscripts
}
"
        printf '%s' "$logrotate" > "$LOGROTATE_CONFIG"

        crontab -l > "$IPTV_ROOT/cron_tmp" 2> /dev/null || true
        printf '%s\n' "0 0 * * * $LOGROTATE_FILE $LOGROTATE_CONFIG" >> "$IPTV_ROOT/cron_tmp"
        crontab "$IPTV_ROOT/cron_tmp" > /dev/null
        rm -f "$IPTV_ROOT/cron_tmp"
        Println "$info 日志切割定时任务开启成功 !\n"
    fi
}

NginxUpdateCFIBMip()
{
    if [ ! -f $nginx_prefix/conf/nginx.conf ] 
    then
        Println "$error 请先安装 $nginx_name\n"
        exit 1
    fi

    if ! grep -q "include cloudflare_ip.conf;" < $nginx_prefix/conf/nginx.conf
    then
        sed -i '/http {/a\    include cloudflare_ip.conf;' $nginx_prefix/conf/nginx.conf
    else
        Println "$error $nginx_name 配置已经存在\n"
    fi

    Println "$info 更新 ip ..."
    printf '%s' "#!/bin/bash
echo '#Cloudflare' > $nginx_prefix/conf/cloudflare_ip.conf;
ibm_ips=(
  50.22.0.0/16
  50.23.0.0/16
  66.228.118.0/23
  67.228.66.0/24
  75.126.0.0/16
  108.168.157.0/24
  173.192.0.0/16
  174.35.17.0/24
  184.172.0.0/16
  192.255.0.0/16
  198.23.0.0/16
  208.43.15.0/24
  169.45.0.0/16
  169.46.0.0/16
  169.47.0.0/16
  169.48.0.0/16
  169.61.0.0/16
  169.62.0.0/16
)
for i in \"\${ibm_ips[@]}\"; do
        echo \"set_real_ip_from \$i;\" >> $nginx_prefix/conf/cloudflare_ip.conf;
done
for i in \$(curl https://www.cloudflare.com/ips-v4); do
        echo \"set_real_ip_from \$i;\" >> $nginx_prefix/conf/cloudflare_ip.conf;
done
for i in \$(curl https://www.cloudflare.com/ips-v6); do
        echo \"set_real_ip_from \$i;\" >> $nginx_prefix/conf/cloudflare_ip.conf;
done
echo >> $nginx_prefix/conf/cloudflare_ip.conf;
echo '# use any of the following two' >> $nginx_prefix/conf/cloudflare_ip.conf;
echo 'real_ip_header CF-Connecting-IP;' >> $nginx_prefix/conf/cloudflare_ip.conf;
echo '#real_ip_header X-Forwarded-For;' >> $nginx_prefix/conf/cloudflare_ip.conf;
" > ~/update_cf_ibm_ip.sh
    bash ~/update_cf_ibm_ip.sh
    Println "$info IP 更新成功\n"
}

NginxEnableDomain()
{
    ln -sf "$nginx_prefix/conf/sites_available/$server_domain.conf" "$nginx_prefix/conf/sites_enabled/$server_domain.conf"
    systemctl restart $nginx_name
}

NginxDisableDomain()
{
    rm -f "$nginx_prefix/conf/sites_enabled/$server_domain.conf"
    systemctl restart $nginx_name
}

NginxAppendHttpConf()
{
    printf '%s' "    server {
        listen      $server_http_port;
        server_name $server_domain;

        access_log logs/access.log;

        add_header Access-Control-Allow-Origin \$cors_host;
        add_header Vary Origin;
        add_header X-Frame-Options SAMEORIGIN;
        add_header Access-Control-Allow-Credentials true;
        add_header Cache-Control no-cache;

        location / {${deny_aliyun:-}
            root   ${server_root#*$nginx_prefix/};
            index  index.html index.htm;
        }
    }

" >> "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpRedirectConf()
{
    echo && read -p "输入网址: " http_redirect_address
    printf '%s' "    server {
        listen      $server_http_port;
        server_name $server_domain;

        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header Connection \"\";

        location / {
            return 301 $http_redirect_address\$request_uri;
        }
    }

" >> "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpRedirectToHttpsConf()
{
    printf '%s' "    server {
        listen      $server_http_port;
        server_name $server_domain;

        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header Connection \"\";

        location / {
            return 301 https://$server_domain\$request_uri;
        }
    }

" > "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpsConf()
{
    printf '%s' "    server {
        listen      $server_https_port ssl;
        server_name $server_domain;

        access_log logs/access.log;

        ssl_certificate      $nginx_prefix/conf/sites_crt/$server_domain.crt;
        ssl_certificate_key  $nginx_prefix/conf/sites_crt/$server_domain.key;

        add_header Access-Control-Allow-Origin \$cors_host;
        add_header Vary Origin;
        add_header X-Frame-Options SAMEORIGIN;
        add_header Access-Control-Allow-Credentials true;
        add_header Cache-Control no-cache;

        location / {${deny_aliyun:-}
            root   ${server_root#*$nginx_prefix/};
            index  index.html index.htm;
        }
    }

" >> "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpsRedirectConf()
{
    echo && read -p "输入网址: " https_redirect_address
    printf '%s' "    server {
        listen      $server_https_port;
        server_name $server_domain;

        access_log off;

        ssl_certificate      $nginx_prefix/conf/sites_crt/$server_domain.crt;
        ssl_certificate_key  $nginx_prefix/conf/sites_crt/$server_domain.key;

        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header Connection \"\";

        location / {
            return 301 $https_redirect_address\$request_uri;
        }
    }

" >> "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpHttpsRedirectConf()
{
    echo && read -p "输入网址: " http_https_redirect_address
    printf '%s' "    server {
        listen      $server_http_port;
        listen      $server_https_port;
        server_name $server_domain;

        access_log off;

        ssl_certificate      $nginx_prefix/conf/sites_crt/$server_domain.crt;
        ssl_certificate_key  $nginx_prefix/conf/sites_crt/$server_domain.key;

        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header Connection \"\";

        location / {
            return 301 $http_https_redirect_address\$request_uri;
        }
    }

" >> "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAppendHttpHttpsConf()
{
    printf '%s' "    server {
        listen      $server_http_port;
        listen      $server_https_port ssl;
        server_name $server_domain;

        access_log logs/access.log;

        ssl_certificate      $nginx_prefix/conf/sites_crt/$server_domain.crt;
        ssl_certificate_key  $nginx_prefix/conf/sites_crt/$server_domain.key;

        add_header Access-Control-Allow-Origin \$cors_host;
        add_header Vary Origin;
        add_header X-Frame-Options SAMEORIGIN;
        add_header Access-Control-Allow-Credentials true;
        add_header Cache-Control no-cache;

        location / {${deny_aliyun:-}
            root   ${server_root#*$nginx_prefix/};
            index  index.html index.htm;
        }
    }

" > "$nginx_prefix/conf/sites_available/$server_domain.conf"
}

NginxAddDomain()
{
    NginxListDomains

    Println "$tip 多个域名用空格分隔"
    read -p "输入指向本机的IP或域名: " domains

    if [ -n "$domains" ] 
    then
        NginxCheckLocalhost
        NginxAddHttp

        IFS=" " read -ra new_domains <<< "$domains"
        for server_domain in "${new_domains[@]}"
        do
            if [ -e "$nginx_prefix/conf/sites_available/$server_domain.conf" ] 
            then
                Println "$error $server_domain 已存在"
                continue
            fi

            if [[ $server_domain =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]] || [[ ! $server_domain =~ ^([a-zA-Z0-9](([a-zA-Z0-9-]){0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$ ]]
            then
                server_num=1
            else
                Println "选择网站类型

  ${green}1.${normal} http
  ${green}2.${normal} http => https
  ${green}3.${normal} http +  https
 \n"
                read -p "`gettext \"输入序号\"` [1-3]: " server_num
            fi

            case $server_num in
                1) 
                    NginxConfigServerHttpPort
                    echo
                    inquirer list_input "是否设置跳转到其它网址" ny_options http_redirect_yn

                    if [[ $http_redirect_yn == "$i18n_yes" ]] 
                    then
                        NginxAppendHttpRedirectConf
                    else
                        NginxConfigServerRoot
                        NginxConfigServerLiveRoot
                        NginxAppendHttpConf
                    fi

                    updated=0
                    NginxAddCorsHost
                    [ "$updated" -eq 1 ] && NginxBuildConf parse_out

                    NginxEnableDomain
                    Println "$info $server_domain 配置成功\n"
                ;;
                2) 
                    NginxDomainInstallCert "$server_domain"
                    echo
                    inquirer list_input "是否设置 http 跳转 https" yn_options http_to_https_yn

                    if [[ $http_to_https_yn == "$i18n_yes" ]] 
                    then
                        Println "$info 设置 $server_domain http 配置"
                        NginxConfigServerHttpPort
                        NginxAppendHttpRedirectToHttpsConf
                    fi

                    NginxConfigServerHttpsPort
                    echo
                    inquirer list_input "是否设置 https 跳转到其它网址" ny_options https_redirect_yn

                    if [[ $https_redirect_yn == "$i18n_yes" ]] 
                    then
                        NginxAppendHttpsRedirectConf
                    else
                        NginxConfigServerRoot
                        NginxConfigServerLiveRoot
                        NginxAppendHttpsConf
                    fi

                    updated=0
                    NginxAddCorsHost
                    [ "$updated" -eq 1 ] && NginxBuildConf parse_out

                    NginxEnableDomain
                    Println "$info $server_domain 配置成功\n"
                ;;
                3) 
                    NginxDomainInstallCert "$server_domain"
                    echo
                    inquirer list_input "http 和 https 是否使用相同的目录" yn_options http_https_same_dir_yn

                    if [[ $http_https_same_dir_yn == "$i18n_yes" ]] 
                    then
                        NginxConfigServerHttpPort
                        NginxConfigServerHttpsPort
                        echo
                        inquirer list_input "是否设置跳转到其它网址" ny_options http_https_redirect_yn
                        if [[ $http_https_redirect_yn == "$i18n_yes" ]] 
                        then
                            NginxAppendHttpHttpsRedirectConf
                        else
                            NginxConfigServerRoot
                            NginxConfigServerLiveRoot
                            NginxAppendHttpHttpsConf
                        fi
                    else
                        NginxConfigServerHttpPort
                        echo
                        inquirer list_input "是否设置 http 跳转到其它网址" ny_options http_redirect_yn
                        if [[ $http_redirect_yn == "$i18n_yes" ]] 
                        then
                            NginxAppendHttpRedirectConf
                            NginxConfigServerHttpsPort

                            echo
                            inquirer list_input "是否设置 https 跳转到其它网址" yn_options https_redirect_yn

                            if [[ $https_redirect_yn == "$i18n_yes" ]] 
                            then
                                NginxAppendHttpsRedirectConf
                            else
                                NginxConfigServerRoot
                                NginxConfigServerLiveRoot
                                NginxAppendHttpsConf
                            fi
                        else
                            NginxConfigServerRoot
                            NginxConfigServerLiveRoot

                            server_http_root=$server_root
                            server_http_live_root=$server_live_root
                            server_http_deny=$deny_aliyun

                            NginxConfigServerHttpsPort

                            echo
                            inquirer list_input "是否设置 https 跳转到其它网址" yn_options https_redirect_yn

                            if [[ $https_redirect_yn == "$i18n_yes" ]] 
                            then
                                NginxAppendHttpConf
                                NginxAppendHttpsRedirectConf
                            else
                                server_root=""
                                server_live_root=""
                                deny_aliyun=""
                                NginxConfigServerRoot
                                NginxConfigServerLiveRoot

                                server_https_root=$server_root
                                server_https_live_root=$server_live_root
                                server_https_deny=$deny_aliyun

                                if [ "$server_http_root" == "$server_https_root" ] && [ "$server_http_live_root" == "$server_https_live_root" ] && [ "$server_http_deny" == "$server_https_deny" ]
                                then
                                    NginxAppendHttpHttpsConf
                                else
                                    NginxAppendHttpConf
                                    NginxAppendHttpsConf
                                fi
                            fi
                        fi
                    fi

                    updated=0
                    NginxAddCorsHost
                    [ "$updated" -eq 1 ] && NginxBuildConf parse_out

                    NginxEnableDomain
                    Println "$info $server_domain 配置成功\n"
                ;;
                *) Println "$i18n_canceled...\n" && exit 1
                ;;
            esac
        done
    else
        Println "$i18n_canceled...\n" && exit 1
    fi
}

NodejsInstall()
{
    DepsCheck
    Progress &
    progress_pid=$!
    trap '
        kill $progress_pid 2> /dev/null
    ' EXIT
    if [ "$release" == "rpm" ] 
    then
        yum -y install gcc-c++ make >/dev/null 2>&1
        # yum groupinstall 'Development Tools'
        if bash <(curl -sL https://rpm.nodesource.com/setup_10.x) > /dev/null
        then
            yum -y install nodejs >/dev/null 2>&1
        fi
    else
        if bash <(curl -sL https://deb.nodesource.com/setup_10.x) > /dev/null 
        then
            apt-get install -y nodejs >/dev/null 2>&1
        fi
    fi

    kill $progress_pid
    trap - EXIT
    echo -n "...100%" && Println "$info nodejs 安装完成"
}

NodejsInstallMongodb()
{
    Println "$info 安装 mongodb, 请等待(国内可能无法安装)..."
    limits=(
        "root soft nofile 65535"
        "root hard nofile 65535"
        "root soft nproc 65535"
        "root hard nproc 65535"
        "* soft nofile 64000"
        "* hard nofile 64000"
        "mongod soft fsize unlimited"
        "mongod hard fsize unlimited"
        "mongod soft cpu unlimited"
        "mongod hard cpu unlimited"
        "mongod soft as unlimited"
        "mongod hard as unlimited"
        "mongod soft memlock unlimited"
        "mongod hard memlock unlimited"
        "mongod soft nproc 64000"
        "mongod hard nproc 64000"
    )

    limits_append=""
    for limit in "${limits[@]}"
    do
        if ! grep -q "${limit% *}" < "/etc/security/limits.conf" 
        then
            limits_append="$limits_append$limit\n"
        fi
    done

    if [ -n "$limits_append" ] 
    then
        echo -e "$limits_append" >> "/etc/security/limits.conf"
    fi

    ulimit -f unlimited
    ulimit -t unlimited
    ulimit -v unlimited
    ulimit -n 64000
    ulimit -m unlimited
    ulimit -u 32000

    ReleaseCheck
    if [ "$release" == "rpm" ] 
    then
        printf '%s' "
[mongodb-org-4.4]
name=MongoDB Repository
baseurl=https://repo.mongodb.org/yum/redhat/\$releasever/mongodb-org/4.4/x86_64/
gpgcheck=1
enabled=1
gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc
" > "/etc/yum.repos.d/mongodb-org-4.4.repo"
        yum install -y mongodb-org >/dev/null 2>&1
    else 
        if ! wget -qO - https://www.mongodb.org/static/pgp/server-4.4.asc | apt-key add - > /dev/null 2>&1
        then
            apt-get -y install gnupg >/dev/null 2>&1
            wget -qO - https://www.mongodb.org/static/pgp/server-4.4.asc | apt-key add - > /dev/null
        fi

        if [ "$release" == "ubu" ] 
        then
            if grep -q "xenial" < "/etc/apt/sources.list"
            then
                echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/4.4 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.4.list
            elif grep -q "bionic" < "/etc/apt/sources.list" 
            then
                echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.4 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.4.list
            else
                echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/4.4 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.4.list
            fi
        else
            if grep -q "stretch" < "/etc/apt/sources.list"
            then
                echo "deb http://repo.mongodb.org/apt/debian stretch/mongodb-org/4.4 main" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.4.list
            else
                echo "deb http://repo.mongodb.org/apt/debian buster/mongodb-org/4.4 main" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.4.list
            fi
        fi

        AptUpdate
        apt-get install -y mongodb-org >/dev/null 2>&1
    fi

    if [[ $(ps --no-headers -o comm 1) == "systemd" ]] 
    then
        if ! systemctl start mongod > /dev/null 2>&1
        then
            systemctl daemon-reload
            systemctl start mongod > /dev/null 2>&1
        fi
        systemctl enable mongod
    else
        service mongod start
    fi
    sleep 3
    Println "$info mongodb 安装成功"
}

InstallGit()
{
    ReleaseCheck
    if [ "$release" == "rpm" ] 
    then
        yum -y install git > /dev/null
    elif [ "$release" == "ubu" ] 
    then
        add-apt-repository ppa:git-core/ppa -y > /dev/null 
        AptUpdate
        apt-get -y install git > /dev/null
    else
        apt-get -y install git > /dev/null
    fi
    Println "$info git 安装成功...\n"
}

NodejsConfig()
{
    nodejs_options=( '域名' '本地' )
    echo
    inquirer list_input "选择使用 nodejs 的对象" nodejs_options nodejs_option

    if [ "$nodejs_option" == "域名" ] 
    then
        NginxListDomain
        NginxSelectDomainServer
    else
        NginxListLocalhost
        NginxSelectLocalhostServer
    fi

    NginxConfigServerLiveRoot

    updated=0

    NginxAddFlv

    NginxAddNodejs

    if [ "$updated" -eq 1 ] 
    then
        NginxBuildConf parse_out
        Println "$info nodejs 配置添加成功"
    fi

    if [ "$nodejs_option" == "域名" ] 
    then
        NginxCheckLocalhost
        NginxAddHttp
    fi

    updated=0

    NginxAddCorsHost

    NginxAddSameSiteNone

    nodejs_port=$(GetFreePort)

    NginxAddUpstreamNodejs

    if [ "$updated" -eq 1 ] 
    then
        NginxBuildConf parse_out
    fi

    username=$(RandStr)
    password=$(RandStr)

    if [[ ! -x $(command -v mongo) ]] 
    then
        NodejsInstallMongodb
    fi

    if [[ $(ps --no-headers -o comm 1) == "systemd" ]] 
    then
        mongo admin --eval "db.getSiblingDB('admin').createUser({user: '${username}', pwd: '${password}', roles: ['root']})"
        systemctl restart mongod
    else
        mongo admin --eval "db.getSiblingDB('admin').createUser({user: '${username}', pwd: '${password}', roles: ['root']})"
        service mongod restart
    fi

    mkdir -p "$NODE_ROOT"
    echo "
const express = require('express');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);

const store = new MongoDBStore({
    uri: 'mongodb://$username:$password@127.0.0.1/admin',
    databaseName: 'encrypt',
    collection: 'sessions'
});

const app = express();
const port = $nodejs_port;

app.set('trust proxy', 1);
app.use(session({name: '$(RandStr)', resave: false, saveUninitialized: true, secret: '$(RandStr)', store: store, cookie: { domain: 'localhost', maxAge: 60 * 60 * 2000, httpOnly: true }}));

app.get('/', function(req, res){
    sessionData = req.session || {};
    sessionData.websiteUser = true;
    res.sendFile('$server_root/index.html');
});

app.get('/remote', function(req, res){
    sessionData = req.session || {};
    sessionData.websiteUser = true;
    res.sendFile('$server_root/channels.json');
});

app.get('/channels', function(req, res){
    sessionData = req.session;
    if (!sessionData.websiteUser){
        res.send('error');
        return;
    }
    res.sendFile('$server_root/channels.json');
});

app.get('/keys', function(req, res){
    sessionData = req.session;
    if (!sessionData.websiteUser){
        res.send('error');
        return;
    }
    let keyName = req.query.key;
    let channelDirName = req.query.channel;
    if (keyName && channelDirName){
        res.sendFile('$server_live_root/${LIVE_ROOT##*/}/' + channelDirName + '/' + keyName + '.key');
    }
});

app.listen(port, () => console.log(\`App listening on port \${port}!\`))

" > "$NODE_ROOT/index.js"

    $JQ_FILE -n \
'{
  "name": "node",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node index.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "connect-mongodb-session": "^2.3.1",
    "express": "^4.17.1",
    "express-session": "^1.17.0"
  }
}' > "$NODE_ROOT/package.json"

    if [[ ! -x $(command -v git) ]] 
    then
        Spinner "安装 git" InstallGit
    fi

    cd "$NODE_ROOT"
    npm install
    npm install -g pm2
    pm2 start "$NODE_ROOT/index.js"
    pm2 startup
    Println "$info nodejs 配置完成"
}

GetFreeTag()
{
    while true 
    do
        free_tag=$(RandStr)
        if ! grep -q '"tag": "'"$free_tag"'"' < "$V2_CONFIG"
        then
            echo "$free_tag"
            break
        fi
    done
}

V2rayInstall()
{
    if [ -s "$V2_CONFIG" ] 
    then
        Println "$error $v2ray_name 已存在...\n"
        AskIfContinue n "`gettext \"是否覆盖原安装\"`"
    fi

    DepsCheck
    JQInstall

    if ! grep -q "$v2ray_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser $v2ray_name --system --group --no-create-home > /dev/null
        else
            adduser $v2ray_name --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin $v2ray_name
    fi

    Println "$info 安装 $v2ray_name..."

    if [ "$v2ray_name" == "v2ray" ] 
    then
        { curl -s -m 10 "$V2_LINK" || curl -s -m 30 "$V2_LINK_BACKUP"; } \
        | sed "s+nobody+$v2ray_name+g" \
        | sed "s+ 'sha1'++g" \
        | sed "s+ 'sha256'++g" \
        | sed "s+ 'sha512'++g" \
        | sed "s+https://api.github.com/repos/v2fly/v2ray-core/releases/latest+$FFMPEG_MIRROR_LINK/$v2ray_name.json+g" \
        | sed "s+https://github.com/v2fly/v2ray-core/releases/download+$FFMPEG_MIRROR_LINK/$v2ray_name+g" | bash
    else
        { curl -s -m 10 "$V2_LINK" || curl -s -m 30 "$V2_LINK_BACKUP"; } \
        | sed "s+nobody+$v2ray_name+g" \
        | sed "s+ 'sha1'++g" \
        | sed "s+ 'sha256'++g" \
        | sed "s+ 'sha512'++g" \
        | sed "s+https://api.github.com/repos/XTLS/Xray-core/releases/latest+$FFMPEG_MIRROR_LINK/$v2ray_name.json+g" \
        | sed "s+https://github.com/XTLS/Xray-core/releases/download+$FFMPEG_MIRROR_LINK/$v2ray_name+g" | bash
    fi

    sed -i "s+nobody+$v2ray_name+g" "/etc/systemd/system/$v2ray_name.service"
    sed -i "s+nobody+$v2ray_name+g" "/etc/systemd/system/$v2ray_name@.service"

    mkdir -p /var/log/$v2ray_name/
    [ ! -e "/var/log/$v2ray_name/error.log" ] && printf '%s' "" > /var/log/$v2ray_name/error.log
    chown -R $v2ray_name:$v2ray_name /var/log/$v2ray_name/
    chown -R $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/

    V2rayConfigUpdate

    systemctl daemon-reload
    systemctl enable $v2ray_name
    systemctl start $v2ray_name

    Println "$info $v2ray_name 安装完成\n"
}

V2rayUpdate()
{
    DepsCheck
    JQInstall
    ShFileUpdate $v2ray_name

    if ! grep -q "$v2ray_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser $v2ray_name --system --group --no-create-home > /dev/null
        else
            adduser $v2ray_name --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin $v2ray_name
    fi

    if [ "$v2ray_name" == "v2ray" ] 
    then
        { curl -s -m 10 "$V2_LINK" || curl -s -m 30 "$V2_LINK_BACKUP"; } \
        | sed "s+nobody+$v2ray_name+g" \
        | sed "s+ 'sha1'++g" \
        | sed "s+ 'sha256'++g" \
        | sed "s+ 'sha512'++g" \
        | sed "s+https://api.github.com/repos/v2fly/v2ray-core/releases/latest+$FFMPEG_MIRROR_LINK/$v2ray_name.json+g" \
        | sed "s+https://github.com/v2fly/v2ray-core/releases/download+$FFMPEG_MIRROR_LINK/$v2ray_name+g" | bash
    else
        { curl -s -m 10 "$V2_LINK" || curl -s -m 30 "$V2_LINK_BACKUP"; } \
        | sed "s+nobody+$v2ray_name+g" \
        | sed "s+ 'sha1'++g" \
        | sed "s+ 'sha256'++g" \
        | sed "s+ 'sha512'++g" \
        | sed "s+https://api.github.com/repos/XTLS/Xray-core/releases/latest+$FFMPEG_MIRROR_LINK/$v2ray_name.json+g" \
        | sed "s+https://github.com/XTLS/Xray-core/releases/download+$FFMPEG_MIRROR_LINK/$v2ray_name+g" | bash
    fi

    sed -i "s+nobody+$v2ray_name+g" "/etc/systemd/system/$v2ray_name.service"
    sed -i "s+nobody+$v2ray_name+g" "/etc/systemd/system/$v2ray_name@.service"

    mkdir -p /var/log/$v2ray_name/
    [ ! -e "/var/log/$v2ray_name/error.log" ] && printf '%s' "" > /var/log/$v2ray_name/error.log
    chown -R $v2ray_name:$v2ray_name /var/log/$v2ray_name/
    chown -R $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/

    V2rayConfigUpdate

    systemctl daemon-reload
    systemctl restart $v2ray_name

    Println "$info $v2ray_name 升级完成\n"
}

V2rayConfigUpdate()
{
    if [ ! -e "$V2_CONFIG" ] 
    then
        Println "$error $v2ray_name 未安装...\n"
        exit 1
    fi

    if ! outbounds=$($JQ_FILE '.outbounds' "$V2_CONFIG" 2> /dev/null) || [ "$outbounds" == "null" ]
    then
        if grep -q '"path": "' < "$V2_CONFIG" 
        then
            while IFS= read -r line 
            do
                if [[ $line == *"path"* ]] 
                then
                    path=${line#*: \"}
                    path=${path%\"*}
                    break
                fi
            done < "$V2_CONFIG"
        fi

        printf -v update_date '%(%m-%d)T' -1
        cp -f "$V2_CONFIG" "${V2_CONFIG}_$update_date"
        while IFS= read -r line 
        do
            if [[ $line == *"port"* ]] 
            then
                port=${line#*: }
                port=${port%,*}
            elif [[ $line == *"id"* ]] 
            then
                id=${line#*: \"}
                id=${id%\"*}
                break
            fi
        done < "$V2_CONFIG"

        $JQ_FILE -n --arg port "${port:-$(GetFreePort)}" --arg id "${id:-$($V2CTL_FILE uuid)}" --arg path "${path:-/$(RandStr)}" \
        --arg error "/var/log/$v2ray_name/error.log" \
        '{
            "log": {
                "access": "none",
                "error": $error,
                "loglevel": "error"
            },
            "inbounds": [
                {
                    "listen": "127.0.0.1",
                    "port": $port | tonumber,
                    "protocol": "vmess",
                    "settings": {
                        "clients": [
                            {
                                "id": $id,
                                "level": 0,
                                "alterId": 64,
                                "email": "name@localhost"
                            }
                        ]
                    },
                    "streamSettings": {
                        "network": "ws",
                        "wsSettings": {
                            "path": $path
                        }
                    },
                    "tag": "nginx-1"
                }
            ],
            "outbounds": [
                {
                    "protocol": "freedom",
                    "tag": "direct"
                },
                {
                    "protocol": "blackhole",
                    "tag": "block"
                }
            ],
            "policy": {
                "levels": {
                    "0": {
                        "handshake": 4,
                        "connIdle": 300,
                        "uplinkOnly": 2,
                        "downlinkOnly": 5,
                        "statsUserUplink": false,
                        "statsUserDownlink": false,
                        "bufferSize": 512
                    }
                },
                "system": {
                    "statsInboundUplink": false,
                    "statsInboundDownlink": false,
                    "statsOutboundUplink": false,
                    "statsOutboundDownlink": false
                }
            }
        }' > "$V2_CONFIG"

        Println "$info $v2ray_name 配置文件已更新\n"
    fi
}

V2rayStatus()
{
    systemctl status $v2ray_name --no-pager
}

V2raySetListen()
{
    echo
    inquirer text_input "输入监听地址: " listen "0.0.0.0"
}

V2raySetFollowRedirect()
{
    Println "$tip 如果选 是, 安全起见需要你自己设置透明代理的防火墙 详见: https://www.v2fly.org/config/protocols/dokodemo.html"
    inquirer list_input "识别出由 iptables 转发而来的数据, 并转发到相应的目标地址" ny_options follow_redirect
    if [ "$follow_redirect" == "$i18n_no" ] 
    then
        follow_redirect="false"
    else
        follow_redirect="true"
    fi
}

V2raySetAddress()
{
    echo
    inquirer text_input "输入目标服务器地址(ip或域名): " address "$i18n_cancel"
    ExitOnCancel address
}

V2raySetDnsAddress()
{
    Println "$tip 当不指定时, 保持来源中指定的地址不变"
    inquirer text_input "修改 DNS 服务器地址: " dns_address "不指定"
    if [ "$dns_address" == "不指定" ] 
    then
        dns_address=""
    fi
}

V2raySetLocalPort()
{
    Println "请输入端口, 可以是 整型数值, 环境变量, 端口范围"
    while read -p "(默认: 随机生成): " port
    do
        case "$port" in
            "")
                port=$(GetFreePort)
                break
            ;;
            *[!0-9]*)
                if [[ $port =~ ^([0-9]+)-([0-9]+)$ ]] 
                then
                    break
                else
                    Println "$error 输入错误\n"
                fi
            ;;
            *)
                if [ "$port" -ge 1 ] && [ "$port" -le 65535 ]
                then
                    if ( echo -n "" >/dev/tcp/127.0.0.1/"$port" ) >/dev/null 2>&1
                    then
                        Println "$error 端口已被其他程序占用!请重新输入! \n"
                    else
                        break
                    fi
                else
                    Println "$error $i18n_input_correct_number [1-65535]\n"
                fi
            ;;
        esac
    done
    Println "  端口: ${green} $port ${normal}"
}

V2raySetAddressPort()
{
    Println "请输入端口"
    while read -p "$i18n_default_cancel" address_port
    do
        case "$address_port" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                if [ "$address_port" -gt 0 ] && [ "$address_port" -le 65535 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done
    Println "  端口: ${green} $address_port ${normal}"
}

V2raySetDnsPort()
{
    Println "$tip 当不指定时, 保持来源中指定的端口不变"
    inquirer text_input "修改 DNS 服务器端口: " dns_port "不指定"
    if [ "$dns_port" == "不指定" ] 
    then
        dns_port=""
    fi
}

V2raySetSettingsNetwork()
{
    Println "$tip 比如当指定为 tcp 时, 仅会接收 TCP 流量"
    settings_network_options=( 'tcp' 'udp' 'tcp,udp' )
    inquirer list_input "可接收的网络协议类型" settings_network_options settings_network
}

V2raySetDnsNetwork()
{
    Println "$tip 当不指定时, 保持来源的传输方式不变"
    dns_network_options=( 'tcp' 'udp' '不指定' )
    inquirer list_input "DNS 流量的传输层协议" dns_network_options dns_network
    if [ "$dns_network" == "不指定" ] 
    then
        dns_network=""
    fi
}

V2raySetInboundProtocol()
{
    echo
    protocol_options=( 'vmess' 'vless' 'http' 'socks' 'shadowsocks' 'dokodemo-door' 'trojan' )
    inquirer list_input "选择传输协议" protocol_options protocol
}

V2raySetOutboundProtocol()
{
    echo
    protocol_options=( 'vmess' 'vless' 'http' 'socks' 'shadowsocks' 'trojan' 'blackhole' 'dns' 'freedom' )
    inquirer list_input "选择传输协议" protocol_options protocol
}

V2raySetInboundNetwork()
{
    echo
    network_options=( 'ws' 'tcp' 'kcp' 'http/2' 'quic' 'domainsocket' )
    inquirer list_input "选择传输方式" network_options network
    if [ "$network" == "http/2" ] 
    then
        network="http"
    fi
}

V2raySetOutboundNetwork()
{
    echo
    network_options=( 'ws' 'tcp' 'kcp' 'http/2' 'quic' )
    inquirer list_input "选择传输方式" network_options network
    if [ "$network" == "http/2" ] 
    then
        network="http"
    fi
}

V2raySetSecurity()
{
    echo
    if [ "$v2ray_name" == "xray" ] && { [ "$protocol" == "vless" ] || [ "$protocol" == "trojan" ]; }
    then
        security_options=( 'none' 'tls' 'xtls' )
    else
        security_options=( 'none' 'tls' )
    fi
    inquirer list_input "选择传输加密" security_options security
}

V2raySetServerName()
{
    Println "$tip 在连接由 IP 建立时有用"
    inquirer text_input "指定服务器端证书的域名" server_name "不设置"
    if [ "$server_name" == "不设置" ] 
    then
        server_name=""
    fi
}

V2raySetAllowInsecure()
{
    Println "$tip 在自定义证书的情况开可以选 否"
    inquirer list_input "是否检测证书有效性" yn_options allow_insecure
    if [[ $allow_insecure == "$i18n_yes" ]]
    then
        allow_insecure="false"
    else
        allow_insecure="true"
    fi
}

V2raySetAlpn()
{
    if [ -n "${new_inbound:-}" ] && { [ "$protocol" == "vless" ] || [ "$protocol" == "trojan" ]; } && [ "$network" == "tcp" ]
    then
        Println "$tip 多个 ALPN 值用空格分隔, 如果要设置 $protocol 协议回落这里至少需要 http/1.1"
    else
        Println "$tip 多个 ALPN 值用空格分隔"
    fi
    inquirer text_input "指定 ALPN 值" alpn "h2 http/1.1"
    IFS=" " read -r -a alpns <<< "$alpn"
    printf -v alpn ',"%s"' "${alpns[@]}"
    alpn=${alpn:1}
}

V2raySetDisableSystemRoot()
{
    Println "$tip 不禁用时只会使用操作系统自带的 CA 证书进行 $tls_name 握手"
    if [ -n "${new_inbound:-}" ] 
    then
        inquirer list_input "是否禁用操作系统自带的 CA 证书" yn_options disable_system_root
    else
        inquirer list_input "是否禁用操作系统自带的 CA 证书" ny_options disable_system_root
    fi

    if [ "$disable_system_root" == "$i18n_no" ] 
    then
        disable_system_root="false"
    else
        disable_system_root="true"
    fi
}

V2raySetCertificateFile()
{
    Println "$tip 如使用 OpenSSL 生成, 后缀名为 .crt, 文件必须存在"
    inquirer text_input "输入证书文件路径: " certificate_file

    if [ -s "$certificate_file" ] 
    then
        cp -f "$certificate_file" /usr/local/share/$v2ray_name/
        certificate_file="/usr/local/share/$v2ray_name/${certificate_file##*/}"
        chown $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/*
        Println "$info 已复制证书到 $certificate_file 并赋予 $v2ray_name:$v2ray_name 权限"
    else
        Println "$error 证书不存在, 请稍后手动添加证书并赋予 $v2ray_name 权限(chown $v2ray_name:$v2ray_name $certificate_file)"
    fi
}

V2raySetKeyFile()
{
    Println "$tip 如使用 OpenSSL 生成, 后缀名为 .key, 密钥必须存在"
    inquirer text_input "输入证书密钥路径: " key_file

    if [ -s "$key_file" ] 
    then
        cp -f "$key_file" /usr/local/share/$v2ray_name/
        key_file="/usr/local/share/$v2ray_name/${key_file##*/}"
        chown $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/*
        Println "$info 已复制密钥到 $key_file 并赋予 $v2ray_name:$v2ray_name 权限"
    else
        Println "$error 密钥不存在, 请稍后手动添加密钥并赋予 $v2ray_name 权限(chown $v2ray_name:$v2ray_name $key_file)"
    fi
}

V2raySetCertificates()
{
    echo
    usage_options=( "$tls_name 认证和加密" "验证远端 $tls_name 的证书" "签发其它证书" )
    inquirer list_input "选择证书用途" usage_options usage
    if [ "$usage" == "$tls_name 认证和加密" ] 
    then
        usage="encipherment"
    elif [ "$usage" == "验证远端 $tls_name 的证书" ] 
    then
        usage="verify"
    else
        usage="issue"
    fi

    echo
    add_crt_options=( '自签名 / CA证书' '选择现有证书/请求真实域名证书' '输入证书地址' )
    inquirer list_input "选择添加证书方式" add_crt_options add_crt_option

    if [ "$add_crt_option" == "自签名 / CA证书" ] 
    then
        if [ "$v2ray_name" == "xray" ] 
        then
            crt=$($V2CTL_FILE tls cert)
        elif [ "$usage" == "encipherment" ] 
        then
            echo
            inquirer list_input "是否是 CA 证书" yn_options ca_yn
            if [ "$ca_yn" == "$i18n_yes" ] 
            then
                crt=$($V2CTL_FILE cert -ca)
            else
                crt=$($V2CTL_FILE cert)
            fi
        else
            crt=$($V2CTL_FILE cert -ca)
        fi
        certificate=$($JQ_FILE "{\"usage\":\"$usage\"} * ." <<< "$crt")
    elif [ "$add_crt_option" == "选择现有证书/请求真实域名证书" ] 
    then
        if ls -A /usr/local/share/$v2ray_name/*.crt > /dev/null 2>&1 
        then
            crt_options=()
            for f in /usr/local/share/$v2ray_name/*.crt
            do
                domain=${f##*/}
                domain=${domain%.*}
                crt_options+=("$domain")
            done
            crt_options+=("添加域名")
            echo
            inquirer list_input "选择证书" crt_options crt_option
        else
            crt_option="添加域名"
        fi
        if [ "$crt_option" == "添加域名" ] 
        then
            Println "$tip 如果证书不存在需请求新 CA 证书, 请确保没有程序占用 80 端口"
            inquirer text_input "输入域名: " domain "$i18n_cancel"
            ExitOnCancel domain
            if [ ! -s "/usr/local/share/$v2ray_name/$domain.crt" ] 
            then
                if [ -s "/usr/local/nginx/conf/sites_crt/$domain.crt" ] 
                then
                    cp -f "/usr/local/nginx/conf/sites_crt/$domain.crt" "/usr/local/share/$v2ray_name/$domain.crt"
                    cp -f "/usr/local/nginx/conf/sites_crt/$domain.key" "/usr/local/share/$v2ray_name/$domain.key"
                elif [ -s "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt" ] 
                then
                    cp -f "/usr/local/openresty/nginx/conf/sites_crt/$domain.crt" "/usr/local/share/$v2ray_name/$domain.crt"
                    cp -f "/usr/local/openresty/nginx/conf/sites_crt/$domain.key" "/usr/local/share/$v2ray_name/$domain.key"
                else
                    Println "$info 安装证书..."

                    V2rayDomainUpdateCrt "$domain" 1

                    Println "$info 证书安装成功"
                fi
            fi
            chown $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/*
            certificate=$(
            $JQ_FILE -n --arg usage "$usage" --arg certificateFile "/usr/local/share/$v2ray_name/$domain.crt" \
                --arg keyFile "/usr/local/share/$v2ray_name/$domain.key" \
            '{
                "usage": $usage,
                "certificateFile": $certificateFile,
                "keyFile": $keyFile
            }')
        else
            certificate=$(
            $JQ_FILE -n --arg usage "$usage" --arg certificateFile "/usr/local/share/$v2ray_name/$crt_option.crt" \
                --arg keyFile "/usr/local/share/$v2ray_name/$crt_option.key" \
            '{
                "usage": $usage,
                "certificateFile": $certificateFile,
                "keyFile": $keyFile
            }')
        fi
    else
        V2raySetCertificateFile

        if [ "$usage" == "verify" ] 
        then
            echo
            inquirer list_input "是否继续添加证书密钥" ny_options continue_yn
            if [ "$continue_yn" == "$i18n_no" ] 
            then
                certificate=$(
                $JQ_FILE -n --arg usage "$usage" --arg certificateFile "$certificate_file" \
                '{
                    "usage": $usage,
                    "certificateFile": $certificateFile
                }')
                return 0
            fi
        fi

        V2raySetKeyFile

        certificate=$(
        $JQ_FILE -n --arg usage "$usage" --arg certificateFile "$certificate_file" \
            --arg keyFile "$key_file" \
        '{
            "usage": $usage,
            "certificateFile": $certificateFile,
            "keyFile": $keyFile
        }')
    fi
    Println "$info 证书添加成功"
}

V2raySetTproxy()
{
    echo
    tproxy_options=( 'off' 'redirect' 'tproxy' )
    inquirer list_input "设置透明代理模式" tproxy_options tproxy
}

V2raySetPath()
{
    echo
    inquirer text_input "输入路径: " path "随机"
    if [ "$path" == "随机" ]
    then
        path="/$(RandStr)"
        Println "  路径: ${green} $path ${normal}"
    fi
}

V2raySetHeaders()
{
    headers=""
    while true 
    do
        echo
        inquirer text_input "输入自定义 HTTP 头的名称: " header_name "不设置"
        if [ "$header_name" == "不设置" ] 
        then
            break
        fi
        echo
        inquirer text_input "输入自定义 HTTP 头 $header_name 的值: " header_value "不设置"
        if [ "$header_value" == "不设置" ] 
        then
            break
        fi
        [ -n "$headers" ] && headers="$headers, "
        headers="$headers\"$header_name\":\"$header_value\""
        inquirer list_input "是否继续添加" ny_options continue_yn
        if [ "$continue_yn" == "$i18n_no" ] 
        then
            break
        fi
    done
}

V2raySetId()
{
    echo
    inquirer text_input "输入 id: " id "随机"
    if [ "$id" == "随机" ] 
    then
        id=$($V2CTL_FILE uuid)
        Println "  id: ${green} $id ${normal}"
    fi
}

V2raySetInboundFlow()
{
    echo
    flow_options=( 'xtls-rprx-direct' 'xtls-rprx-origin' )
    inquirer list_input "选择模式" flow_options flow
}

V2raySetOutboundFlow()
{
    echo
    flow_options=( 'xtls-rprx-direct' 'xtls-rprx-direct-udp443' 'xtls-rprx-splice' 'xtls-rprx-splice-udp443' 'xtls-rprx-origin' 'xtls-rprx-origin-udp443' )
    inquirer list_input "选择模式" flow_options flow
}

V2raySetAlterId()
{
    Println "请输入 alterId"
    while read -p "(默认: 0): " alter_id
    do
        case "$alter_id" in
            "")
                alter_id=0
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [0-65535]\n"
            ;;
            *)
                if [ "$alter_id" -ge 0 ] && [ "$alter_id" -le 65535 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [0-65535]\n"
                fi
            ;;
        esac
    done
    Println "  alterId: ${green} $alter_id ${normal}"
}

V2raySetEmail()
{
    echo
    inquirer text_input "输入邮箱: " email "随机"
    if [ "$email" == "随机" ] 
    then
        email="$(RandStr)@localhost"
        Println "  邮箱: ${green} $email ${normal}"
    fi
}

V2raySetPassword()
{
    echo
    inquirer text_input "输入密码: " password "随机"
    if [ "$password" == "随机" ] 
    then
        password=$(RandStr)
        Println "  密码: ${green} $password ${normal}"
    fi
}

V2raySetTimeout()
{
    Println "入站数据的时间限制(秒)"
    while read -p "(默认: 300): " timeout
    do
        case "$timeout" in
            "")
                timeout=300
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>0]\n"
            ;;
            *)
                if [ "$timeout" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
    Println "  时间限制: ${green} $timeout ${normal}"
}

V2raySetAllowTransparent()
{
    echo
    inquirer list_input "转发所有 HTTP 请求, 而非只是代理请求, 若配置不当, 开启此选项会导致死循环" ny_options allow_transparent_yn
    if [[ $allow_transparent_yn == "$i18n_yes" ]]
    then
        allow_transparent="true"
    else
        allow_transparent="false"
    fi
    Println "  allowTransparent: ${green} $allow_transparent ${normal}"
}

V2raySetLevel()
{
    V2rayListPolicy

    echo -e "选择等级"
    while read -p "(默认: 1): " level
    do
        case "$level" in
            "")
                level=0
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$level" -gt 0 ] && [ "$level" -le $((policy_levels_count+1)) ]
                then
                    level=$((level-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
    Println "  等级: ${green} $level ${normal}\n"
}

V2raySetHttpAccount()
{
    echo
    inquirer text_input "输入用户名: " user "随机"
    if [ "$user" == "随机" ] 
    then
        user=$(RandStr)
        Println "  用户名: ${green} $user ${normal}"
    fi
    echo
    inquirer text_input "输入密码: " pass "随机"
    if [ "$pass" == "随机" ] 
    then
        pass=$(RandStr)
        Println "  密码: ${green} $pass ${normal}"
    fi
}

V2raySetTag()
{
    echo
    inquirer text_input "输入标签: " tag "随机"
    if [ "$tag" == "随机" ] 
    then
        tag=$(GetFreeTag)
        tag=${tag//nginx-/}
        Println "  标签: ${green} $tag ${normal}"
    fi
}

V2raySetNginxTag()
{
    i=0
    while true 
    do
        i=$((i+1))
        tag="nginx-$i"
        if ! grep -q '"tag": "'"$tag"'"' < "$V2_CONFIG"
        then
            break
        fi
    done
    Println "  标签: ${green} $tag ${normal}\n"
}

V2raySetAcceptProxyProtocol()
{
    Println "$tip PROXY 协议专用于传递请求的真实来源 IP 和端口, 如果前端 nginx 发送 PROXY Protocol 必须选是"
    inquirer list_input "是否接收 PROXY 协议" ny_options accept_proxy_protocol
    if [[ $accept_proxy_protocol == "$i18n_yes" ]] 
    then
        accept_proxy_protocol="true"
    else
        accept_proxy_protocol="false"
    fi
}

V2raySetVmessSecurity()
{
    echo
    vmess_security_options=( 'auto' 'aes-128-gcm' 'chacha20-poly1305' 'none' )
    inquirer list_input "选择加密方式" vmess_security_options vmess_security
}

V2raySetQuicSecurity()
{
    echo
    quic_security_options=( 'none' 'aes-128-gcm' 'chacha20-poly1305' )
    inquirer list_input "设置 QUIC 加密方式" quic_security_options quic_security
}

V2raySetQuicKey()
{
    if [ "$quic_security" == "none" ] 
    then
        quic_key=""
    else
        echo
        inquirer text_input "输入 QUIC 加密密钥: " quic_key "随机"
        if [[ $quic_key == "随机" ]] 
        then
            quic_key=$(RandStr)
        fi
    fi
}

V2raySetDsPath()
{
    Println "$tip 在运行 $v2ray_name 之前, 这个文件必须不存在"
    inquirer text_input "输入 domainsocket 文件路径: " ds_path "$i18n_cancel"
    ExitOnCancel ds_path
    Println "  domainsocket 文件路径: ${green} $ds_path ${normal}"
}

V2raySetDsAbstract()
{
    echo
    inquirer list_input "是否为 abstract domain socket" ny_options ds_abstract
    if [[ $ds_abstract == "$i18n_no" ]] 
    then
        ds_abstract="false"
    else
        ds_abstract="true"
    fi
}

V2raySetDsPadding()
{
    echo
    inquirer list_input "abstract domain socket 是否带 padding" ny_options ds_padding
    if [[ $ds_padding == "$i18n_no" ]] 
    then
        ds_padding="false"
    else
        ds_padding="true"
    fi
}

V2raySetDetourTo()
{
    Println "$tip 指定的入站协议必须是 VMess"
    inquirer text_input "使用另一个入站的出站(输入指定的另一个入站的标签): " detour_to "不设置"
    Println "  指定的另一个入站: ${green} $detour_to ${normal}"
}

V2raySetDetourDefault()
{
    V2raySetLevel
    V2raySetAlterId
}

V2raySetDisableInsecureEncryption()
{
    Println "$tip 当客户端使用 none / aes-128-cfb 加密方式时, 服务器会主动断开连接"
    inquirer list_input "是否禁止客户端使用不安全的加密方式" yn_options disable_insecure_encryption
    if [[ $disable_insecure_encryption == "$i18n_yes" ]] 
    then
        disable_insecure_encryption="true"
    else
        disable_insecure_encryption="false"
    fi
}

V2raySetHeaderType()
{
    echo
    if [ "$network" == "tcp" ] 
    then
        header_type_options=( 'none' 'http' )
        header_http_request='{}'
        header_http_response='{}'
    else
        header_type_options=( 'none' 'srtp' 'utp' 'wechat-video' 'dtls' 'wireguard' )
    fi
    inquirer list_input "设置数据包头部伪装" header_type_options header_type

    if [ "$header_type" == "http" ] 
    then
        echo
        inquirer text_input "输入 HTTP 请求版本: " http_request_version "1.1"

        echo
        inquirer text_input "输入 HTTP 请求方法: " http_request_method "GET"

        Println "$tip 多个路径用空格分隔, 当有多个值时, 每次请求随机选择一个值"
        inquirer text_input "输入 HTTP 请求路径: " http_request_path "/"
        IFS=" " read -r -a request_path <<< "$http_request_path"
        printf -v http_request_path ',"%s"' "${request_path[@]}"
        http_request_path=${http_request_path:1}

        http_request_headers='{}'
        while true 
        do
            echo
            inquirer text_input "输入自定义 HTTP 请求头的名称: " header_name "不设置"
            if [ "$header_name" == "不设置" ] 
            then
                break
            fi

            Println "$tip 多个值用 | 分隔"
            inquirer text_input "输入自定义 HTTP 请求头 $header_name 的值: " header_value "不设置"
            if [ "$header_value" == "不设置" ] 
            then
                break
            fi

            if [[ $header_value =~ | ]] 
            then
                IFS="|" read -r -a header_values <<< "$header_value"
                printf -v header_value ',"%s"' "${header_values[@]}"
                header_value="${header_value:1}"
                http_request_headers=$(
                $JQ_FILE --arg key "$header_name" --argjson value "[$header_value]" \
                '. * 
                {
                    ($key): $value
                }' <<< "$http_request_headers")
            else
                http_request_headers=$(
                $JQ_FILE --arg key "$header_name" --arg value "$header_value" \
                '. * 
                {
                    ($key): $value
                }' <<< "$http_request_headers")
            fi

            echo
            inquirer list_input "是否继续添加" ny_options continue_yn
            if [ "$continue_yn" == "$i18n_no" ] 
            then
                break
            fi
        done

        header_http_request=$(
        $JQ_FILE -n --arg version "$http_request_version" --arg method "$http_request_method" \
        --argjson path "[$http_request_path]" --argjson headers "$http_request_headers" \
        '{
            "version": $version,
            "method": $method,
            "path": $path,
            "headers": $headers,
        }')

        echo
        inquirer text_input "输入 HTTP 响应版本: " http_response_version "1.1"

        echo
        inquirer text_input "输入 HTTP 响应状态: " http_response_status "200"

        echo
        inquirer text_input "输入 HTTP 响应说明: " http_response_reason "OK"

        http_response_headers='{}'
        while true 
        do
            echo
            inquirer text_input "输入自定义 HTTP 响应头的名称: " header_name "不设置"
            if [ "$header_name" == "不设置" ] 
            then
                break
            fi

            Println "$tip 多个值用|分隔"
            inquirer text_input "输入自定义 HTTP 响应头 $header_name 的值: " header_value "不设置"
            if [ "$header_value" == "不设置" ] 
            then
                break
            fi

            if [[ $header_value =~ | ]] 
            then
                IFS="|" read -r -a header_values <<< "$header_value"
                printf -v header_value ',"%s"' "${header_values[@]}"
                header_value="${header_value:1}"
                http_response_headers=$(
                $JQ_FILE --arg key "$header_name" --argjson value "[$header_value]" \
                '. * 
                {
                    ($key): $value
                }' <<< "$http_response_headers")
            else
                http_response_headers=$(
                $JQ_FILE --arg key "$header_name" --arg value "$header_value" \
                '. * 
                {
                    ($key): $value
                }' <<< "$http_response_headers")
            fi

            echo
            inquirer list_input "是否继续添加" ny_options continue_yn
            if [ "$continue_yn" == "$i18n_no" ] 
            then
                break
            fi
        done

        header_http_response=$(
        $JQ_FILE -n --arg version "$http_response_version" --arg status "$http_response_status" \
        --arg reason "$http_response_reason" --argjson headers "$http_response_headers" \
        '{
            "version": $version,
            "status": $status,
            "reason": $reason,
            "headers": $headers,
        }')
    fi
}

V2raySetHost()
{
    Println "$tip 多个域名用空格分隔, 客户端会随机从列表中选出一个域名进行通信, 服务器会验证域名是否在列表中"
    inquirer text_input "输入通信域名: " host "v2ray.com"
    IFS=" " read -r -a hosts <<< "$host"
    printf -v host ',"%s"' "${hosts[@]}"
    host=${host:1}
}

V2raySetSniffingEnabled()
{
    echo
    inquirer list_input "是否开启流量探测" ny_options sniffing_enabled
    if [[ $sniffing_enabled == "$i18n_no" ]] 
    then
        sniffing_enabled="false"
    else
        sniffing_enabled="true"
    fi
}

V2raySetSniffingDestOverride()
{
    Println "$tip 客户端已经设置过的流量类型这里可以不设置"
    dest_override_options=( 'tls' 'http' )
    set +u
    inquirer checkbox_input "指定流量类型: " dest_override_options dest_override_selected
    set -u
    dest_override=""
    if [ -n "${dest_override_selected:-}" ] 
    then
        printf -v dest_override ',"%s"' "${dest_override_selected[@]}"
        dest_override=${dest_override:1}
    fi
}

V2raySetSniffingDomainsExcluded()
{
    Println "$tip 多个域名用空格分隔"
    inquirer text_input "输入排除流量探测的域名: " domains_excluded "不设置"
    if [ "$domains_excluded" == "不设置" ] 
    then
        domains_excluded=""
    else
        IFS=" " read -r -a domains <<< "$domains_excluded"
        printf -v domains_excluded ',"%s"' "${domains[@]}"
        domains_excluded=${domains_excluded:1}
    fi
}

SetV2rayAllocateStrategy()
{
    echo
    allocate_strategy_options=( 'always' 'random' )
    inquirer list_input "端口分配策略" allocate_strategy_options allocate_strategy
}

SetV2rayAllocateRefresh()
{
    Println "随机端口刷新间隔(分钟)"
    while read -p "(默认: 5): " allocate_refresh
    do
        case "$allocate_refresh" in
            "")
                allocate_refresh=5
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>1]\n"
            ;;
            *)
                if [ "$allocate_refresh" -ge 2 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>1]\n"
                fi
            ;;
        esac
    done
    Println "  刷新间隔: ${green} $allocate_refresh ${normal}"
}

SetV2rayAllocateConcurrency()
{
    Println "随机端口数量, 最大值为端口范围的三分之一"
    while read -p "(默认: 3): " allocate_concurrency
    do
        case "$allocate_concurrency" in
            "")
                allocate_concurrency=3
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>0]\n"
            ;;
            *)
                if [ "$allocate_concurrency" -ge 1 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
    Println "  随机端口数量: ${green} $allocate_concurrency ${normal}"
}

V2raySetSendThrough()
{
    Println "$tip 当主机有多个 IP 地址时有效"
    inquirer text_input "用于发送数据的 IP 地址: " send_through "0.0.0.0"
}

V2raySetProxy()
{
    Println "$tip 如果指定另一个出站协议, 当前协议发出的数据, 将从指定的出站协议发出"
    inquirer text_input "输入指定的另一个出站协议的标签: " proxy_tag "不设置"
    if [ "$proxy_tag" == "不设置" ] 
    then
        proxy_tag=""
    fi
}

V2raySetMuxEnabled()
{
    Println "$info Mux 功能是在一条 TCP 连接上分发多个 TCP 连接的数据, 是为了减少 TCP 的握手延迟而设计, 而非提高连接的吞吐量"
    inquirer list_input "是否启用 Mux 转发请求" ny_options mux_enabled
    if [ "$mux_enabled" == "$i18n_no" ] 
    then
        mux_enabled="false"
    else
        mux_enabled="true"
    fi
}

V2raySetMuxConcurrency()
{
    Println "$tip 最小值 1, 最大值 1024, 填负数, 比如 -1, 则不加载 mux 模块"
    inquirer text_input "最大并发连接数: " mux_concurrency 8
}

V2raySetResponseType()
{
    Println "$tip none 时直接关闭, http 时返回 403 并关闭"
    response_type_options=( 'none' 'http' )
    inquirer list_input "选择黑洞的响应方式" response_type
}

V2raySetFreedomDomainStrategy()
{
    Println "$tip AsIs - 直接向此域名发出连接, 其余将域名用内建的 dns 解析为 IP 之后再建立连接"
    freedom_domain_strategy_options=( 'AsIs' 'UseIP' 'UseIPv4' 'UseIPv6' )
    inquirer list_input "域名策略" freedom_domain_strategy_options freedom_domain_strategy
}

V2raySetFreedomRedirect()
{
    Println "例如 127.0.0.1:80, :1234 - 不改变原先的目标地址, v2ray.com:0 - 不改变原先的端口"
    inquirer text_input "强制将所有数据发送到指定地址: " freedom_redirect "不设置"
    if [ "$freedom_redirect" == "不设置" ] 
    then
        freedom_redirect=""
    fi
}

V2raySetFallbacks()
{
    echo
    inquirer list_input "是否配置协议回落" ny_options v2ray_fallbacks_yn
    if [ "$v2ray_fallbacks_yn" == "$i18n_yes" ] 
    then
        if [ "$v2ray_name" == "xray" ] 
        then
            v2ray_fallbacks=$(
            $JQ_FILE -n --arg name "" --arg alpn "" \
            --arg path "" --arg dest 80 --arg xver 0 \
            '[{
                "name": $name,
                "alpn": $alpn,
                "path": $path,
                "dest": $dest | tonumber,
                "xver": $xver | tonumber
            }]')
        else
            v2ray_fallbacks=$(
            $JQ_FILE -n --arg alpn "" --arg path "" \
            --arg dest 80 --arg xver 0 \
            '[{
                "alpn": $alpn,
                "path": $path,
                "dest": $dest | tonumber,
                "xver": $xver | tonumber
            }]')
        fi
        while true 
        do
            if [ "$v2ray_name" == "xray" ] 
            then
                Println "$tip 一般不用设置"
                inquirer text_input "输入 SNI 分流匹配值: " v2ray_fallback_name "不设置"
                if [ "$v2ray_fallback_name" == "不设置" ] 
                then
                    v2ray_fallback_name=""
                fi
            else
                v2ray_fallback_name=""
            fi
            Println "$tip 请输入单个, 比如 http/1.1 或 h2"
            inquirer text_input "输入尝试匹配 $tls_name ALPN 协商结果: " v2ray_fallback_alpn "不设置"
            if [ "$v2ray_fallback_alpn" == "不设置" ] 
            then
                v2ray_fallback_alpn=""
            elif [ "$v2ray_fallback_alpn" == "h2" ] && [[ ! $alpn =~ h2 ]]
            then
                Println "$error 协议回落存在 h2 时, $tls_name 需设置 h2 http/1.1\n"
                exit 1
            fi
            Println "$tip 非空则必须以 / 开头, 不支持 h2c"
            inquirer text_input "输入尝试匹配首包 HTTP PATH: " v2ray_fallback_path "任意"
            if [ "$v2ray_fallback_path" == "任意" ] 
            then
                v2ray_fallback_path=""
            fi
            Println "$tip 格式为 addr:port 或 /dev/shm/domain.socket, 若填写域名, 也将直接发起 TCP 连接(而不走内置的 DNS)"
            inquirer text_input "输入 $tls_name 解密后 TCP 流量的去向: " v2ray_fallback_dest
            if [ -z "$v2ray_fallback_dest" ] 
            then
                Println "$error $i18n_canceled...\n"
                exit 1
            fi
            Println "$tip 如果配置 nginx 的 PROXY protocol 记得设置 set_real_ip_from"
            v2ray_fallback_proxy_protocol_options=( '不发送' '版本1' '版本2' )
            inquirer list_input "选择 PROXY protocol" v2ray_fallback_proxy_protocol_options v2ray_fallback_proxy_protocol
            if [ "$v2ray_fallback_proxy_protocol" == "不发送" ] 
            then
                v2ray_fallback_proxy_protocol=0
            elif [ "$v2ray_fallback_proxy_protocol" == "版本1" ] 
            then
                v2ray_fallback_proxy_protocol=1
            else
                v2ray_fallback_proxy_protocol=2
            fi
            if [[ $v2ray_fallback_dest =~ ^[0-9]+$ ]] 
            then
                v2ray_fallback=$(
                $JQ_FILE -n --arg alpn "$v2ray_fallback_alpn" --arg path "$v2ray_fallback_path" \
                --arg dest "$v2ray_fallback_dest" --arg xver "$v2ray_fallback_proxy_protocol" \
                '{
                    "alpn": $alpn,
                    "path": $path,
                    "dest": $dest | tonumber,
                    "xver": $xver | tonumber
                }')
            else
                v2ray_fallback=$(
                $JQ_FILE -n --arg alpn "$v2ray_fallback_alpn" --arg path "$v2ray_fallback_path" \
                --arg dest "$v2ray_fallback_dest" --arg xver "$v2ray_fallback_proxy_protocol" \
                '{
                    "alpn": $alpn,
                    "path": $path,
                    "dest": $dest,
                    "xver": $xver | tonumber
                }')
            fi
            if [ -n "${v2ray_fallback_name:-}" ] 
            then
                v2ray_fallback=$(
                $JQ_FILE --arg name "$v2ray_fallback_name" \
                '{
                    "name": $name
                } * .' <<< "$v2ray_fallback")
            fi
            v2ray_fallbacks=$(
            $JQ_FILE --arg name "$v2ray_fallback_name" --argjson fallback "[$v2ray_fallback]" \
            '. + $fallback' <<< "$v2ray_fallbacks")
            echo
            inquirer list_input "回落添加成功, 是否继续添加新的回落" ny_options v2ray_fallbacks_yn
            if [ "$v2ray_fallbacks_yn" == "$i18n_no" ] 
            then
                break
            fi
        done
    else
        v2ray_fallbacks="[]"
    fi
}

V2raySetAuth()
{
    echo
    auth_options=( '匿名' '用户密码' )
    inquirer list_input "选择认证方式" auth_options auth_option
    if [ "$auth_option" == "匿名" ] 
    then
        auth="noauth"
    else
        auth="password"
    fi
}

V2raySetUdp()
{
    echo
    inquirer list_input "是否支持 udp" ny_options udp_yn
    if [ "$udp_yn" == "$i18n_no" ] 
    then
        udp="false"
    else
        udp="true"
    fi
}

V2raySetIp()
{
    echo
    inquirer text_input "输入用于 udp 的本机 IP: " ip "127.0.0.1"
}

V2raySetMethod()
{
    echo
    method_options=( 'aes-256-gcm' 'aes-128-gcm' 'chacha20-poly1305' 'none' )
    inquirer list_input "选择加密方式" method_options method
}

V2rayAddInbound()
{
    V2raySetInboundProtocol
    V2raySetInboundNetwork
    V2raySetTproxy

    V2raySetSniffingEnabled
    if [ "$sniffing_enabled" == "true" ] 
    then
        V2raySetSniffingDestOverride
    else
        dest_override=""
    fi

    if [ "$v2ray_name" == "xray" ] && [ -n "$dest_override" ] 
    then
        V2raySetSniffingDomainsExcluded
    fi

    if [ "$self" == "ibm" ] || [ "$self" == "ibm.sh" ] 
    then
        V2raySetSecurity
        V2raySetTag
        V2raySetListen
    else
        echo
        inquirer list_input "是否通过此脚本配置的 nginx 连接" ny_options nginx_proxy_yn

        if [[ $nginx_proxy_yn == "$i18n_yes" ]]
        then
            if [ "$protocol" == "vless" ] || [ "$protocol" == "trojan" ]
            then
                V2raySetSecurity
            else
                security="none"
            fi
            V2raySetNginxTag
            listen="127.0.0.1"
        else
            V2raySetSecurity
            V2raySetTag
            V2raySetListen
        fi
    fi

    if [ "$network" == "domainsocket" ] 
    then
        port=$(GetFreePort)
    else
        V2raySetLocalPort
    fi

    new_inbound=$(
    $JQ_FILE -n --arg listen "$listen" --arg port "$port" \
        --arg protocol "$protocol" --arg network "$network" \
        --arg security "$security" --arg tproxy "$tproxy" \
        --arg enabled "$sniffing_enabled" --argjson destOverride "[$dest_override]" \
        --arg tag "$tag" \
    '{
        "listen": $listen,
        "port": $port | tonumber,
        "protocol": $protocol,
        "streamSettings": {
            "network": $network,
            "security": $security,
            "sockopt": {
                "tproxy": $tproxy
            }
        },
        "sniffing": {
            "enabled": $enabled | test("true"),
            "destOverride": $destOverride
        },
        "tag": $tag
    }')

    if [ "$v2ray_name" == "xray" ] && [ -n "${domains_excluded:-}" ] 
    then
        new_inbound=$(
        $JQ_FILE --argjson domainsExcluded "[$domains_excluded]" \
        '. * 
        {
            "sniffing": {
                "domainsExcluded": $domainsExcluded
            }
        }' <<< "$new_inbound")
    fi

    if [[ ! "$port" =~ ^[0-9]+$ ]] 
    then
        SetV2rayAllocateStrategy
        if [ "$allocate_strategy" == "random" ] 
        then
            SetV2rayAllocateRefresh
            SetV2rayAllocateConcurrency
            new_inbound=$(
            $JQ_FILE --arg strategy "$allocate_strategy" --arg refresh "$allocate_refresh" \
            --arg concurrency "$allocate_concurrency" \
            '. * 
            {
                "allocate": {
                    "strategy": $strategy,
                    "refresh": $refresh | tonumber,
                    "concurrency": $concurrency | tonumber
                }
            }' <<< "$new_inbound")
        fi
    fi

    if [ "$security" == "tls" ] 
    then
        V2raySetServerName
        if [ -n "$server_name" ] 
        then
            new_inbound=$(
            $JQ_FILE --arg serverName "$server_name" \
            '. * 
            {
                "streamSettings": {
                    "tlsSettings": {
                        "serverName": $serverName
                    }
                }
            }' <<< "$new_inbound")
        fi
        V2raySetAlpn
        V2raySetDisableSystemRoot
        new_inbound=$(
        $JQ_FILE --argjson alpn "[$alpn]" --arg disableSystemRoot "$disable_system_root" \
        '. * 
        {
            "streamSettings": {
                "tlsSettings": {
                    "alpn": $alpn,
                    "disableSystemRoot": $disableSystemRoot | test("true"),
                }
            }
        }' <<< "$new_inbound")
        while true 
        do
            if [ "$disable_system_root" == "false" ] 
            then
                echo
                inquirer list_input "是否继续添加证书" ny_options continue_yn
                if [ "$continue_yn" == "$i18n_no" ] 
                then
                    break
                fi
            fi
            Println "$info 设置证书"
            V2raySetCertificates
            merge=$(
            $JQ_FILE -n --argjson certificates "[$certificate]" \
            '{
                "streamSettings": {
                    "tlsSettings": {
                        "certificates": $certificates
                    }
                }
            }')
            JQs merge new_inbound "$merge"
            if [ "$disable_system_root" == "true" ] 
            then
                echo
                inquirer list_input "是否继续添加证书" ny_options continue_yn
                if [ "$continue_yn" == "$i18n_no" ] 
                then
                    break
                fi
            fi
        done
    elif [ "$security" == "xtls" ] 
    then
        V2raySetServerName
        if [ -n "$server_name" ] 
        then
            new_inbound=$(
            $JQ_FILE --arg serverName "$server_name" \
            '. * 
            {
                "streamSettings": {
                    "xtlsSettings": {
                        "serverName": $serverName
                    }
                }
            }' <<< "$new_inbound")
        fi
        V2raySetAlpn
        V2raySetDisableSystemRoot
        new_inbound=$(
        $JQ_FILE --argjson alpn "[$alpn]" --arg disableSystemRoot "$disable_system_root" \
        '. * 
        {
            "streamSettings": {
                "xtlsSettings": {
                    "alpn": $alpn,
                    "disableSystemRoot": $disableSystemRoot | test("true"),
                }
            }
        }' <<< "$new_inbound")
        while true 
        do
            if [ "$disable_system_root" == "false" ] 
            then
                echo
                inquirer list_input "是否继续添加证书" ny_options continue_yn
                if [ "$continue_yn" == "$i18n_no" ] 
                then
                    break
                fi
            fi
            Println "$info 设置证书"
            V2raySetCertificates
            merge=$(
            $JQ_FILE -n --argjson certificates "[$certificate]" \
            '{
                "streamSettings": {
                    "xtlsSettings": {
                        "certificates": $certificates
                    }
                }
            }')
            JQs merge new_inbound "$merge"
            if [ "$disable_system_root" == "true" ] 
            then
                echo
                inquirer list_input "是否继续添加证书" ny_options continue_yn
                if [ "$continue_yn" == "$i18n_no" ] 
                then
                    break
                fi
            fi
        done
    fi

    if [ "$protocol" == "vmess" ] 
    then
        V2raySetDisableInsecureEncryption
        new_inbound=$(
        $JQ_FILE --arg disableInsecureEncryption "$disable_insecure_encryption" \
        '. * 
        {
            "settings": {
                "clients": [],
                "disableInsecureEncryption":$disableInsecureEncryption | test("true")
            }
        }' <<< "$new_inbound")

        V2raySetDetourTo
        if [ "$detour_to" != "不设置" ] 
        then
            V2raySetDetourDefault
            new_inbound=$(
            $JQ_FILE --arg level "$level" --arg alterId "$alter_id" --arg to "$detour_to" \
            '. * 
            {
                "settings": {
                    "default": {
                        "level": $level | tonumber,
                        "alterId": $alterId | tonumber
                    },
                    "detour": {
                        "to": $to
                    }
                }
            }' <<< "$new_inbound")
        fi
    elif [ "$protocol" == "vless" ] || [ "$protocol" == "trojan" ]
    then
        new_inbound=$(
        $JQ_FILE \
        '. * 
        {
            "settings": {
                "clients": []
            }
        }' <<< "$new_inbound")
        if [ "$protocol" == "vless" ] 
        then
            new_inbound=$(
            $JQ_FILE \
            '. * 
            {
                "settings": {
                    "decryption":"none"
                }
            }' <<< "$new_inbound")
        fi
        if { [ "$security" == "tls" ] || [ "$security" == "xtls" ]; } && [ "$network" == "tcp" ] && [[ $alpn == *"http/1.1"* ]]
        then
            V2raySetFallbacks
            if [ "$v2ray_fallbacks" != "[]" ] 
            then
                new_inbound=$(
                $JQ_FILE --argjson fallbacks "$v2ray_fallbacks" \
                '. * 
                {
                    "settings": {
                        "fallbacks":$fallbacks
                    }
                }' <<< "$new_inbound")
            fi
        fi
    elif [ "$protocol" == "http" ] 
    then
        V2raySetTimeout
        V2raySetAllowTransparent
        V2raySetLevel

        new_inbound=$(
        $JQ_FILE --arg timeout "$timeout" --arg allowTransparent "$allow_transparent" \
        --arg userLevel "$level" \
        '. * 
        {
            "settings": {
                "timeout": $timeout | tonumber,
                "accounts": [],
                "allowTransparent": $allowTransparent | test("true"),
                "userLevel": $userLevel | tonumber
            }
        }' <<< "$new_inbound")
    elif [ "$protocol" == "socks" ] 
    then
        V2raySetLevel
        V2raySetAuth
        V2raySetUdp
        new_inbound=$(
        $JQ_FILE --arg auth "$auth" --arg udp "$udp" \
        --arg userLevel "$level" \
        '. * 
        {
            "settings": {
                "auth": $auth,
                "udp": $udp | test("true"),
                "userLevel": $userLevel | tonumber
            }
        }' <<< "$new_inbound")
        if [ "$udp" == "true" ] 
        then
            V2raySetIp
            new_inbound=$(
            $JQ_FILE --arg ip "$ip" \
            '. * 
            {
                "settings": {
                    "ip": $ip
                }
            }' <<< "$new_inbound")
        fi
    elif [ "$protocol" == "shadowsocks" ] 
    then
        if [ "$v2ray_name" == "xray" ] && [[ $($V2CTL_FILE version | head -1 | cut -d' ' -f2) =~ ([^.]+).([^.]+).([^.]+) ]] && \
        [ "${BASH_REMATCH[1]}" -ge 1 ] && [ "${BASH_REMATCH[2]}" -ge 2 ] && [ "${BASH_REMATCH[3]}" -ge 3 ]
        then
            V2raySetSettingsNetwork
            new_inbound=$(
            $JQ_FILE --arg network "$settings_network" \
            '. * 
            {
                "settings": {
                    "clients": [],
                    "network": $network
                }
            }' <<< "$new_inbound")
        else
            V2raySetEmail
            V2raySetMethod
            V2raySetPassword
            V2raySetLevel
            V2raySetSettingsNetwork
            new_inbound=$(
            $JQ_FILE --arg email "$email" --arg method "$method" \
            --arg password "$password" --arg level "$level" \
            --arg network "$settings_network" \
            '. * 
            {
                "settings": {
                    "email": $email,
                    "method": $method,
                    "password": $password,
                    "level": $level | tonumber,
                    "network": $network
                }
            }' <<< "$new_inbound")
        fi
    elif [ "$protocol" == "dokodemo-door" ] 
    then
        echo
        inquirer list_input "是否用于 api 查询" ny_options yn_option
        if [ "$yn_option" == "$i18n_yes" ] 
        then
            new_inbound=$(
            $JQ_FILE \
            '. * 
            {
                "settings": {
                    "address": "127.0.0.1",
                }
            }' <<< "$new_inbound")
        else
            V2raySetSettingsNetwork
            V2raySetTimeout
            V2raySetLevel
            V2raySetFollowRedirect
            if [ "$follow_redirect" == "true" ] 
            then
                new_inbound=$(
                $JQ_FILE --arg network "$settings_network" --arg timeout "$timeout" \
                --arg followRedirect "$follow_redirect" --arg userLevel "$level" \
                '. * 
                {
                    "settings": {
                        "network": $network,
                        "timeout": $timeout | tonumber,
                        "followRedirect": $followRedirect | test("true"),
                        "userLevel": $userLevel | tonumber
                    }
                }' <<< "$new_inbound")
            else
                V2raySetAddress
                V2raySetAddressPort
                new_inbound=$(
                $JQ_FILE --arg address "$address" --arg port "$address_port" \
                --arg network "$settings_network" --arg timeout "$timeout" \
                --arg followRedirect "$follow_redirect" --arg userLevel "$level" \
                '. * 
                {
                    "settings": {
                        "address": $address,
                        "port": $port | tonumber,
                        "network": $network,
                        "timeout": $timeout | tonumber,
                        "followRedirect": $followRedirect | test("true"),
                        "userLevel": $userLevel | tonumber
                    }
                }' <<< "$new_inbound")
            fi
        fi
    fi

    if [ "$network" == "ws" ] 
    then
        V2raySetAcceptProxyProtocol
        V2raySetPath
        V2raySetHeaders
        new_inbound=$(
        $JQ_FILE --arg acceptProxyProtocol "$accept_proxy_protocol" \
            --arg path "$path" --argjson headers "{$headers}" \
        '. * 
        {
            "streamSettings": {
                "wsSettings": {
                    "acceptProxyProtocol": $acceptProxyProtocol | test("true"),
                    "path": $path,
                    "headers": $headers
                }
            }
        }' <<< "$new_inbound")
    elif [ "$network" == "tcp" ] 
    then
        V2raySetAcceptProxyProtocol
        V2raySetHeaderType
        new_inbound=$(
        $JQ_FILE --arg acceptProxyProtocol "$accept_proxy_protocol" \
            --arg header_type "$header_type" --argjson request "$header_http_request" \
            --argjson response "$header_http_response" \
        '. * 
        {
            "streamSettings": {
                "tcpSettings": {
                    "acceptProxyProtocol": $acceptProxyProtocol | test("true"),
                    "header": {
                        "type": $header_type,
                        "request": $request,
                        "response": $response
                    }
                }
            }
        }' <<< "$new_inbound")
    elif [ "$network" == "kcp" ] 
    then
        V2raySetHeaderType
        new_inbound=$(
        $JQ_FILE --arg header_type "$header_type" \
        '. * 
        {
            "streamSettings": {
                "kcpSettings": {
                    "header": {
                        "type": $header_type
                    }
                }
            }
        }' <<< "$new_inbound")
    elif [ "$network" == "http" ] 
    then
        V2raySetHost
        V2raySetPath
        new_inbound=$(
        $JQ_FILE --argjson host "[$host]" \
            --arg path "$path" \
        '. * 
        {
            "streamSettings": {
                "httpSettings": {
                    "host": $host,
                    "path": $path
                }
            }
        }' <<< "$new_inbound")
    elif [ "$network" == "quic" ] 
    then
        V2raySetQuicSecurity
        V2raySetQuicKey
        V2raySetHeaderType
        new_inbound=$(
        $JQ_FILE --arg security "$quic_security" \
            --arg key "$quic_key" --arg header_type "$header_type" \
        '. * 
        {
            "streamSettings": {
                "quicSettings": {
                    "security": $security,
                    "key": $key,
                    "header": {
                        "type": $header_type
                    }
                }
            }
        }' <<< "$new_inbound")
    else
        V2raySetDsPath
        V2raySetDsAbstract
        V2raySetDsPadding
        new_inbound=$(
        $JQ_FILE --arg path "$ds_path" \
            --arg abstract "$ds_abstract" --arg padding "$ds_padding" \
        '. * 
        {
            "streamSettings": {
                "dsSettings": {
                    "path": $ds_path,
                    "abstract": $abstract | test("true"),
                    "padding": $padding | test("true")
                }
            }
        }' <<< "$new_inbound")
    fi

    JQ add "$V2_CONFIG" inbounds "[$new_inbound]"

    Println "$info 入站 $tag 添加成功\n"
}

V2rayGetInbounds()
{
    IFS=$'`\t' read -r map_listen map_port map_protocol map_settings_disable_insecure_encryption \
    map_settings_decryption map_settings_timeout map_settings_allow_transparent map_settings_user_level \
    map_settings_address map_settings_port map_settings_network map_settings_follow_redirect \
    map_settings_default_level map_settings_default_alter_id map_settings_detour_to map_settings_auth \
    map_settings_udp map_settings_ip map_settings_email map_settings_method map_settings_password \
    map_stream_network map_stream_security map_stream_tls_server_name map_stream_tls_alpn \
    map_stream_tls_certificates_usage map_stream_tls_certificates_certificate_file \
    map_stream_tls_certificates_key_file map_stream_tls_certificates_certificate \
    map_stream_tls_certificates_key map_stream_tls_disable_system_root map_stream_http_host \
    map_stream_path map_stream_accept_proxy_protocol map_stream_ws_headers map_stream_header_type \
    map_stream_header_request map_stream_header_response map_stream_quic_security map_stream_quic_key \
    map_stream_ds_abstract map_stream_ds_padding map_stream_tproxy map_sniffing_enabled \
    map_sniffing_dest_override map_sniffing_domains_excluded map_allocate_strategy map_allocate_refresh \
    map_allocate_concurrency map_tag < <($JQ_FILE -c -r '[
    ([.inbounds[]|.listen|if . == "" // . == null then "0.0.0.0" else . end|. + "^"]|join("") + "`"),
    ([.inbounds[]|.port|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.protocol|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.disableInsecureEncryption // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.decryption // "none"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.timeout // 300|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.allowTransparent // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.userLevel // .settings.level // ""|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.address|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.port // ""|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.network // "tcp"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.follow_redirect // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.default.level // 0|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.default.alterId // 0|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.detour.to|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.auth // "noauth"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.udp // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.ip // "127.0.0.1"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.email|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.method // "none"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.settings.password|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.network|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.security // "none"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.serverName // .streamSettings.xtlsSettings.serverName|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.alpn // .streamSettings.xtlsSettings.alpn // []|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].usage|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].certificateFile|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].keyFile|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].certificate // []|join(" ")]|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].key // []|join(" ")]|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tlsSettings.disableSystemRoot // .streamSettings.xtlsSettings.disableSystemRoot // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.httpSettings.host // []|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.wsSettings.path // .streamSettings.httpSettings.path|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tcpSettings.acceptProxyProtocol // .streamSettings.wsSettings.acceptProxyProtocol // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.wsSettings.headers // {}|to_entries|map("\(.key)=\(.value)")|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tcpSettings.header.type // .streamSettings.kcpSettings.header.type // .streamSettings.quicSettings.header.type // "none"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tcpSettings.header.request // {}|to_entries|
    map("\(.key)=\(.value|(. | type) as $type|if ($type == "array") then (.|join("~")) 
    elif ($type == "object") then (.|to_entries|map("\(.key)=\(
        (.value|(. | type) as $type2|if ($type2 == "array") then (.|join("~")) else . end))")|join("!"))
    else . end)")|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.tcpSettings.header.response // {}|to_entries|
    map("\(.key)=\(.value|(. | type) as $type|if ($type == "object") then (.|to_entries|map("\(.key)=\(
        (.value|(. | type) as $type2|if ($type2 == "array") then (.|join("~")) else . end))")|join("!"))
    else . end)")|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.quicSettings.security // "none"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.quicSettings.key|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.dsSettings.abstract // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.dsSettings.padding // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.streamSettings.sockopt.tproxy // "off"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.sniffing.enabled // false|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.sniffing.destOverride // []|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.sniffing.domainsExcluded // []|join("|")|. + "^"]|join("") + "`"),
    ([.inbounds[]|.allocate.strategy // "always"|. + "^"]|join("") + "`"),
    ([.inbounds[]|.allocate.refresh // 5|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.allocate.concurrency // 3|tostring|. + "^"]|join("") + "`"),
    ([.inbounds[]|.tag|. + "^"]|join("") + "`")
    ]|@tsv' "$V2_CONFIG")

    if [ -z "$map_protocol" ] 
    then
        inbounds_count=0
        return 0
    fi

    IFS="^" read -r -a inbounds_protocol <<< "$map_protocol"
    inbounds_count=${#inbounds_protocol[@]}
    if_null=""

    for((inbounds_i=0;inbounds_i<inbounds_count;inbounds_i++));
    do
        if_null="$if_null^"
    done

    IFS="^" read -r -a inbounds_listen <<< "${map_listen:-$if_null}"
    IFS="^" read -r -a inbounds_port <<< "${map_port:-$if_null}"
    IFS="^" read -r -a inbounds_settings_disable_insecure_encryption <<< "${map_settings_disable_insecure_encryption:-$if_null}"
    IFS="^" read -r -a inbounds_settings_decryption <<< "${map_settings_decryption:-$if_null}"
    IFS="^" read -r -a inbounds_settings_timeout <<< "${map_settings_timeout:-$if_null}"
    IFS="^" read -r -a inbounds_settings_allow_transparent <<< "${map_settings_allow_transparent:-$if_null}"
    IFS="^" read -r -a inbounds_settings_user_level <<< "${map_settings_user_level:-$if_null}"
    IFS="^" read -r -a inbounds_settings_address <<< "${map_settings_address:-$if_null}"
    IFS="^" read -r -a inbounds_settings_port <<< "${map_settings_port:-$if_null}"
    IFS="^" read -r -a inbounds_settings_network <<< "${map_settings_network:-$if_null}"
    IFS="^" read -r -a inbounds_settings_follow_redirect <<< "${map_settings_follow_redirect:-$if_null}"
    IFS="^" read -r -a inbounds_settings_default_level <<< "${map_settings_default_level:-$if_null}"
    IFS="^" read -r -a inbounds_setttings_default_alter_id <<< "${map_settings_default_alter_id:-$if_null}"
    IFS="^" read -r -a inbounds_settings_detour_to <<< "${map_settings_detour_to:-$if_null}"
    IFS="^" read -r -a inbounds_settings_auth <<< "${map_settings_auth:-$if_null}"
    IFS="^" read -r -a inbounds_settings_udp <<< "${map_settings_udp:-$if_null}"
    IFS="^" read -r -a inbounds_settings_ip <<< "${map_settings_ip:-$if_null}"
    IFS="^" read -r -a inbounds_settings_email <<< "${map_settings_email:-$if_null}"
    IFS="^" read -r -a inbounds_settings_method <<< "${map_settings_method:-$if_null}"
    IFS="^" read -r -a inbounds_settings_password <<< "${map_settings_password:-$if_null}"
    IFS="^" read -r -a inbounds_stream_network <<< "${map_stream_network:-$if_null}"
    IFS="^" read -r -a inbounds_stream_security <<< "${map_stream_security:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_server_name <<< "${map_stream_tls_server_name:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_alpn <<< "${map_stream_tls_alpn:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_certificates_usage <<< "${map_stream_tls_certificates_usage:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_certificates_certificate_file <<< "${map_stream_tls_certificates_certificate_file:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_certificates_key_file <<< "${map_stream_tls_certificates_key_file:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_certificates_certificate <<< "${map_stream_tls_certificates_certificate:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_certificates_key <<< "${map_stream_tls_certificates_key:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tls_disable_system_root <<< "${map_stream_tls_disable_system_root:-$if_null}"
    IFS="^" read -r -a inbounds_stream_http_host <<< "${map_stream_http_host:-$if_null}"
    IFS="^" read -r -a inbounds_stream_path <<< "${map_stream_path:-$if_null}"
    IFS="^" read -r -a inbounds_stream_accept_proxy_protocol <<< "${map_stream_accept_proxy_protocol:-$if_null}"
    IFS="^" read -r -a inbounds_stream_ws_headers <<< "${map_stream_ws_headers:-$if_null}"
    IFS="^" read -r -a inbounds_stream_header_type <<< "${map_stream_header_type:-$if_null}"
    IFS="^" read -r -a inbounds_stream_header_request <<< "${map_stream_header_request:-$if_null}"
    IFS="^" read -r -a inbounds_stream_header_response <<< "${map_stream_header_response:-$if_null}"
    IFS="^" read -r -a inbounds_stream_quic_security <<< "${map_stream_quic_security:-$if_null}"
    IFS="^" read -r -a inbounds_stream_quic_key <<< "${map_stream_quic_key:-$if_null}"
    IFS="^" read -r -a inbounds_stream_ds_abstract <<< "${map_stream_ds_abstract:-$if_null}"
    IFS="^" read -r -a inbounds_stream_ds_padding <<< "${map_stream_ds_padding:-$if_null}"
    IFS="^" read -r -a inbounds_stream_tproxy <<< "${map_stream_tproxy:-$if_null}"
    IFS="^" read -r -a inbounds_sniffing_enabled <<< "${map_sniffing_enabled:-$if_null}"
    IFS="^" read -r -a inbounds_sniffing_dest_override <<< "${map_sniffing_dest_override:-$if_null}"
    IFS="^" read -r -a inbounds_sniffing_domains_excluded <<< "${map_sniffing_domains_excluded:-$if_null}"
    IFS="^" read -r -a inbounds_allocate_strategy <<< "${map_allocate_strategy:-$if_null}"
    IFS="^" read -r -a inbounds_allocate_refresh <<< "${map_allocate_refresh:-$if_null}"
    IFS="^" read -r -a inbounds_allocate_concurrency <<< "${map_allocate_concurrency:-$if_null}"
    IFS="^" read -r -a inbounds_tag <<< "${map_tag:-$if_null}"

    inbounds_nginx_count=0
    inbounds_nginx_index=()
    inbounds_other_count=0
    inbounds_other_index=()

    for((inbounds_i=0;inbounds_i<inbounds_count;inbounds_i++));
    do
        if [ "${inbounds_tag[inbounds_i]:0:6}" == "nginx-" ]
        then
            inbounds_nginx_count=$((inbounds_nginx_count+1))
            inbounds_nginx_index+=("$inbounds_i")
        else
            inbounds_other_count=$((inbounds_other_count+1))
            inbounds_other_index+=("$inbounds_i")
        fi
    done
}

V2rayListInbounds()
{
    V2rayGetInbounds

    list_inbounds_options=( '全部入站' '本地 nginx 入站' "直连 $v2ray_name 入站" )

    if [ "${1:-}" == "nginx" ] 
    then
        list_inbounds_options_index=1
        count=$inbounds_nginx_count
    elif [ "${1:-}" == "direct" ] 
    then
        list_inbounds_options_index=2
        count=$((inbounds_count-inbounds_nginx_count))
    else
        echo
        inquirer list_input_index "选择显示的范围" list_inbounds_options list_inbounds_options_index

        if [ "$list_inbounds_options_index" -eq 0 ] 
        then
            count=$inbounds_count
        elif [ "$list_inbounds_options_index" -eq 1 ] 
        then
            count=$inbounds_nginx_count
        else
            count=$((inbounds_count-inbounds_nginx_count))
        fi
    fi

    if [ "$count" -eq 0 ] 
    then
        if [ "$list_inbounds_options_index" -eq 0 ] 
        then
            Println "$error 请先添加入站\n"
        else
            Println "$error 请先添加 ${list_inbounds_options[list_inbounds_options_index]}\n"
        fi

        exit 1
    fi

    Println "\n=== ${list_inbounds_options[list_inbounds_options_index]}数 ${green} $count ${normal}"

    inbounds_list=""

    for((i=0;i<count;i++));
    do
        if [ "$list_inbounds_options_index" -eq 0 ] 
        then
            inbounds_index=$i
        elif [ "$list_inbounds_options_index" -eq 1 ] 
        then
            inbounds_index=${inbounds_nginx_index[i]}
        else
            inbounds_index=${inbounds_other_index[i]}
        fi
        if [ "${inbounds_stream_network[inbounds_index]}" != "domainsocket" ] 
        then
            protocol_settings_list="监听地址: ${green}${inbounds_listen[inbounds_index]}${normal} 监听端口: ${green}${inbounds_port[inbounds_index]}${normal}\n${indent_6}传输协议: ${green}${inbounds_protocol[inbounds_index]}${normal}\n${indent_6}"
        else
            protocol_settings_list="传输协议: ${green}${inbounds_protocol[inbounds_index]}${normal}\n${indent_6}"
        fi
        if [ "${inbounds_sniffing_enabled[inbounds_index]}" == "true" ] 
        then
            protocol_settings_list="$protocol_settings_list流量探测: ${green}开启${normal} 指定流量类型: ${green}${inbounds_sniffing_dest_override[inbounds_index]//|/,}${normal}\n${indent_6}"
            if [ -n "${inbounds_sniffing_domains_excluded[inbounds_index]}" ] 
            then
                IFS="|" read -r -a domains <<< "${inbounds_sniffing_domains_excluded[inbounds_index]}"
                domains_list=""
                for domain in "${domains[@]}"
                do
                    domains_list="$domains_list${green}$domain${normal}\n${indent_6}"
                done
                protocol_settings_list="$protocol_settings_list排除域名:\n${indent_6}$domains_list"
            fi
        fi
        if [ "${inbounds_allocate_strategy[inbounds_index]}" == "random" ] 
        then
            protocol_settings_list="$protocol_settings_list随机端口: ${green}开启${normal} 刷新间隔: ${green}${inbounds_allocate_refresh[inbounds_index]} 分钟${normal} 随机端口数量: ${green}${inbounds_allocate_concurrency[inbounds_index]}${normal}\n${indent_6}"
        fi
        if [ "${inbounds_protocol[inbounds_index]}" == "vmess" ] 
        then
            if [ "${inbounds_settings_disable_insecure_encryption[inbounds_index]}" == "false" ] 
            then
                protocol_settings_list="$protocol_settings_list禁止不安全加密: ${red}否${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list禁止不安全加密: ${green}是${normal}\n${indent_6}"
            fi
            if [ -n "${inbounds_settings_detour_to[inbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list指定的另一个入站: ${green}${inbounds_settings_detour_to[inbounds_index]}${normal} 默认等级: ${green}${inbounds_settings_default_level[inbounds_index]}${normal} 默认 alterId: ${green}${inbounds_setttings_default_alter_id[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "vless" ] 
        then
            if [ "${inbounds_settings_decryption[inbounds_index]}" == "none" ] 
            then
                protocol_settings_list="$protocol_settings_list解密协议: ${red}否${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list解密协议: ${green}${inbounds_settings_decryption[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "http" ] 
        then
            protocol_settings_list="$protocol_settings_list入站数据时间限制: ${green}${inbounds_settings_timeout[inbounds_index]}${normal}\n${indent_6}"
            if [ -n "${inbounds_settings_user_level[inbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list连接使用等级: ${green}${inbounds_settings_user_level[inbounds_index]}${normal}\n${indent_6}"
            fi
            if [ "${inbounds_settings_allow_transparent[inbounds_index]}" == "false" ] 
            then
                protocol_settings_list="$protocol_settings_list转发所有请求: ${red}否${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list转发所有请求: ${green}是${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "socks" ] 
        then
            if [ "${inbounds_settings_auth[inbounds_index]}" == "noauth" ] 
            then
                protocol_settings_list="$protocol_settings_list认证方式: ${green}匿名${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list认证方式: ${green}用户密码${normal}\n${indent_6}"
            fi
            if [ "${inbounds_settings_udp[inbounds_index]}" == "false" ] 
            then
                protocol_settings_list="$protocol_settings_list支持 UDP 协议: ${red}否${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list支持 UDP 协议: ${green}是${normal}\n${indent_6}本机 IP 地址: ${green}${inbounds_settings_ip[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] 
        then
            protocol_settings_list="$protocol_settings_list可接收的网络协议类型: ${green}${inbounds_settings_network[inbounds_index]}${normal}\n${indent_6}"
            if [ -n "${inbounds_settings_method[inbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list加密方式: ${green}${inbounds_settings_method[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "dokodemo-door" ] 
        then
            protocol_settings_list="$protocol_settings_list可接收的网络协议类型: ${green}${inbounds_settings_network[inbounds_index]}${normal}\n${indent_6}入站数据时间限制: ${green}${inbounds_settings_timeout[inbounds_index]}${normal}\n${indent_6}"
            if [ -n "${inbounds_settings_user_level[inbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list连接使用等级: ${green}${inbounds_settings_user_level[inbounds_index]}${normal}\n${indent_6}"
            fi
            if [ "${inbounds_settings_follow_redirect[inbounds_index]}" == "false" ] 
            then
                protocol_settings_list="$protocol_settings_list转发防火墙: ${red}否${normal}\n${indent_6}目标地址: ${green}${inbounds_settings_address[inbounds_index]}${normal} 目标端口: ${green}${inbounds_settings_port[inbounds_index]}${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list转发防火墙: ${green}是${normal}\n${indent_6}"
            fi
        fi
        if [ "${inbounds_stream_network[inbounds_index]}" == "http" ] 
        then
            stream_settings_list="传输方式: ${green}http/2${normal}\n${indent_6}"
        else
            stream_settings_list="传输方式: ${green}${inbounds_stream_network[inbounds_index]}${normal}\n${indent_6}"
        fi
        if [ "${inbounds_stream_security[inbounds_index]}" == "none" ] 
        then
            stream_settings_list="${stream_settings_list}$tls_name 加密: ${red}否${normal}\n${indent_6}"
        else
            stream_settings_list="${stream_settings_list}$tls_name 加密: ${green}是${normal}\n${indent_6}"
            if [ -n "${inbounds_stream_tls_server_name[inbounds_index]}" ] 
            then
                stream_settings_list="${stream_settings_list}指定证书域名: ${green}${inbounds_stream_tls_server_name[inbounds_index]}${normal}\n${indent_6}"
            else
                stream_settings_list="${stream_settings_list}指定证书域名: ${red}否${normal}\n${indent_6}"
            fi
            if [ "${inbounds_stream_tls_disable_system_root[inbounds_index]}" == "false" ] 
            then
                stream_settings_list="${stream_settings_list}禁用操作系统自带 CA 证书: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="${stream_settings_list}禁用操作系统自带 CA 证书: ${green}是${normal}\n${indent_6}"
            fi
            if [ -n "${inbounds_stream_tls_alpn[inbounds_index]}" ] 
            then
                stream_settings_list="${stream_settings_list}$tls_name 握手 ALPN: ${green}${inbounds_stream_tls_alpn[inbounds_index]//|/,}${normal}\n${indent_6}"
            else
                stream_settings_list="${stream_settings_list}$tls_name 握手 ALPN: ${green}h2,http/1.1${normal}\n${indent_6}"
            fi
            if [ -n "${inbounds_stream_tls_certificates_usage[inbounds_index]}" ] 
            then
                certificates_list="${green}证书:${normal}\n${indent_6}"
                IFS="|" read -r -a usages <<< "${inbounds_stream_tls_certificates_usage[inbounds_index]}"
                IFS="|" read -r -a certificate_files <<< "${inbounds_stream_tls_certificates_certificate_file[inbounds_index]}"
                IFS="|" read -r -a key_files <<< "${inbounds_stream_tls_certificates_key_file[inbounds_index]}"
                IFS="|" read -r -a certificates <<< "${inbounds_stream_tls_certificates_certificate[inbounds_index]}"
                for((certificate_i=0;certificate_i<${#usages[@]};certificate_i++));
                do
                    if [ "${usages[certificate_i]}" == "encipherment" ] 
                    then
                        certificate_usage="$tls_name 认证和加密"
                    elif [ "${usages[certificate_i]}" == "verify" ] 
                    then
                        certificate_usage="验证远端 $tls_name"
                    else
                        certificate_usage="签发其它证书"
                    fi
                    if [ -n "${certificates:-}" ] && [ -n "${certificates[certificate_i]}" ] 
                    then
                        certificates_list="$certificates_list$((certificate_i+1)). 用途: ${green}$certificate_usage [自签名]${normal}\n${indent_6}"
                    else
                        certificates_list="$certificates_list$((certificate_i+1)). 用途: ${green}$certificate_usage${normal}\n${indent_6}"
                    fi
                    if [ -n "${certificate_files[certificate_i]}" ] 
                    then
                        certificates_list="$certificates_list证书路径: ${green}${certificate_files[certificate_i]}${normal}\n${indent_6}"
                    fi
                    if [ -n "${key_files[certificate_i]}" ] 
                    then
                        certificates_list="$certificates_list密钥路径: ${green}${key_files[certificate_i]}${normal}\n${indent_6}"
                    fi
                done
                stream_settings_list="$stream_settings_list\n${indent_6}$certificates_list\n${indent_6}"
            fi
        fi
        if [ "${inbounds_stream_tproxy[inbounds_index]}" == "off" ] 
        then
            stream_settings_list="$stream_settings_list透明代理: ${red}否${normal}\n${indent_6}"
        else
            stream_settings_list="$stream_settings_list透明代理: ${green}${inbounds_stream_tproxy[inbounds_index]}${normal}\n${indent_6}"
        fi
        if [ "${inbounds_stream_network[inbounds_index]}" == "ws" ] 
        then
            stream_settings_list="$stream_settings_list路径: ${green}${inbounds_stream_path[inbounds_index]}${normal}\n${indent_6}"
            if [ "${inbounds_stream_accept_proxy_protocol[inbounds_index]}" == "false" ] 
            then
                stream_settings_list="$stream_settings_list接收 PROXY 协议: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list接收 PROXY 协议: ${green}是${normal}\n${indent_6}"
            fi
            if [ -n "${inbounds_stream_ws_headers[inbounds_index]}" ] 
            then
                IFS="|" read -r -a headers <<< "${inbounds_stream_ws_headers[inbounds_index]}"
                headers_list=""
                for header in "${headers[@]}"
                do
                    headers_list="$headers_list${green}${header%%=*}${normal}: ${green}${header#*=}${normal}\n${indent_6}"
                done
                [ -n "$headers_list" ] && stream_settings_list="$stream_settings_list自定义 HTTP 头:\n${indent_6}$headers_list"
            fi
        elif [ "${inbounds_stream_network[inbounds_index]}" == "tcp" ] 
        then
            if [ "${inbounds_stream_accept_proxy_protocol[inbounds_index]}" == "false" ] 
            then
                stream_settings_list="$stream_settings_list接收 PROXY 协议: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list接收 PROXY 协议: ${green}是${normal}\n${indent_6}"
            fi
            if [ "${inbounds_stream_header_type[inbounds_index]}" == "none" ] 
            then
                stream_settings_list="$stream_settings_list数据包头部伪装: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list数据包头部伪装: ${green}${inbounds_stream_header_type[inbounds_index]}${normal}\n${indent_6}"
                if [ -n "${inbounds_stream_header_request[inbounds_index]}" ] 
                then
                    IFS="|" read -r -a header_request <<< "${inbounds_stream_header_request[inbounds_index]}"
                    header_request_list=""
                    for request in "${header_request[@]}"
                    do
                        request_key=${request%%=*}
                        request_value=${request#*=}
                        if [ "$request_key" == "headers" ] 
                        then
                            IFS="!" read -r -a headers <<< "$request_value"
                            if [ -n "${headers:-}" ] 
                            then
                                header_request_list="$header_request_list${green}headers${normal}:\n\033[8C"
                                for header in "${headers[@]}"
                                do
                                    header_key=${header%%=*}
                                    header_request_list="$header_request_list${green}$header_key => ${normal}\n\033[8C"
                                    header_value=${header#*=}
                                    IFS="~" read -r -a header_values <<< "$header_value"
                                    if [ -z "${header_values:-}" ] 
                                    then
                                        continue
                                    fi
                                    for header_value in "${header_values[@]}"
                                    do
                                        header_request_list="$header_request_list  ${green}$header_value${normal}\n\033[8C"
                                    done
                                done
                            fi
                        else
                            header_request_list="$header_request_list${green}$request_key${normal}: ${green}${request_value//~/, }${normal}\n${indent_6}"
                        fi
                    done
                    [ -n "$header_request_list" ] && stream_settings_list="$stream_settings_list自定义 HTTP 头:\n${indent_6}$header_request_list"
                fi
            fi
        elif [ "${inbounds_stream_network[inbounds_index]}" == "kcp" ] 
        then
            if [ "${inbounds_stream_header_type[inbounds_index]}" == "none" ] 
            then
                stream_settings_list="$stream_settings_list数据包头部伪装: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list数据包头部伪装: ${green}${inbounds_stream_header_type[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_stream_network[inbounds_index]}" == "http" ] 
        then
            stream_settings_list="$stream_settings_list路径: ${green}${inbounds_stream_path[inbounds_index]}${normal}\n${indent_6}"
            if [ -n "${inbounds_stream_http_host[inbounds_index]}" ] 
            then
                stream_settings_list="$stream_settings_list通信域名: ${green}${inbounds_stream_http_host[inbounds_index]//|/, }${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_stream_network[inbounds_index]}" == "quic" ] 
        then
            if [ "${inbounds_stream_quic_security[inbounds_index]}" == "none" ] 
            then
                stream_settings_list="$stream_settings_list数据包加密方式: ${green}不加密${normal} 密钥: ${green}${inbounds_stream_quic_key[inbounds_index]}${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list数据包加密方式: ${green}${inbounds_stream_quic_security[inbounds_index]}${normal} 密钥: ${green}${inbounds_stream_quic_key[inbounds_index]}${normal}\n${indent_6}"
            fi
            if [ "${inbounds_stream_header_type[inbounds_index]}" == "none" ] 
            then
                stream_settings_list="$stream_settings_list数据包头部伪装: ${red}否${normal}\n${indent_6}"
            else
                stream_settings_list="$stream_settings_list数据包头部伪装: ${green}${inbounds_stream_header_type[inbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${inbounds_stream_network[inbounds_index]}" == "domainsocket" ] 
        then
            stream_settings_list="$stream_settings_list文件路径: ${green}${inbounds_stream_path[inbounds_index]}${normal} abstract: ${green}${inbounds_stream_ds_abstract[inbounds_index]}${normal} padding: ${green}${inbounds_stream_ds_padding[inbounds_index]}${normal}\n${indent_6}"
        fi
        inbounds_list=$inbounds_list"# ${green}$((i+1))${normal}${indent_6}标签: ${green}${inbounds_tag[inbounds_index]:-无}${normal}\n${indent_6}$protocol_settings_list$stream_settings_list\n\n"
    done

    Println "$inbounds_list\n"
}

V2raySelectInbound()
{
    echo "选择入站"
    while read -p "$i18n_default_cancel" inbound_num
    do
        case "$inbound_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$inbound_num" -gt 0 ] && [ "$inbound_num" -le $count ]
                then
                    inbound_num=$((inbound_num-1))
                    if [ "$list_inbounds_options_index" -eq 0 ] 
                    then
                        inbounds_index=$inbound_num
                    elif [ "$list_inbounds_options_index" -eq 1 ] 
                    then
                        inbounds_index=${inbounds_nginx_index[inbound_num]}
                    else
                        inbounds_index=${inbounds_other_index[inbound_num]}
                    fi
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2raySelectAccount()
{
    echo "选择账号"
    while read -p "$i18n_default_cancel" account_num
    do
        case "$account_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$account_num" -gt 0 ] && [ "$account_num" -le $accounts_count ]
                then
                    accounts_index=$((account_num-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2rayDeleteInbound()
{
    V2rayListInbounds
    V2raySelectInbound
    jq_path='["inbounds"]'
    JQ delete "$V2_CONFIG" "$inbounds_index"
    Println "$info 入站 ${inbounds_tag[inbounds_index]} 删除成功\n"
}

V2rayAddInboundAccount()
{
    V2rayListInbounds
    V2raySelectInbound

    if [ "${inbounds_protocol[inbounds_index]}" == "vmess" ] 
    then
        V2raySetId
        V2raySetLevel
        V2raySetAlterId
        V2raySetEmail
        jq_path='["inbounds",'"$inbounds_index"',"settings","clients"]'
        new_account=$(
        $JQ_FILE -n --arg id "$id" --arg level "$level" \
            --arg alterId "$alter_id" --arg email "$email" \
        '{
            "id": $id,
            "level": $level | tonumber,
            "alterId": $alterId | tonumber,
            "email": $email
        }')
    elif [ "${inbounds_protocol[inbounds_index]}" == "vless" ] 
    then
        V2raySetId
        V2raySetLevel
        V2raySetEmail
        jq_path='["inbounds",'"$inbounds_index"',"settings","clients"]'
        if [ "$v2ray_name" == "xray" ] 
        then
            V2raySetInboundFlow
            new_account=$(
            $JQ_FILE -n --arg id "$id" --arg flow "$flow" \
                --arg level "$level" --arg email "$email" \
            '{
                "id": $id,
                "flow": $flow,
                "level": $level | tonumber,
                "email": $email
            }')
        else
            new_account=$(
            $JQ_FILE -n --arg id "$id" --arg level "$level" \
                --arg email "$email" \
            '{
                "id": $id,
                "level": $level | tonumber,
                "email": $email
            }')
        fi
    elif [ "${inbounds_protocol[inbounds_index]}" == "http" ] || [ "${inbounds_protocol[inbounds_index]}" == "socks" ]
    then
        V2raySetHttpAccount
        jq_path='["inbounds",'"$inbounds_index"',"settings","accounts"]'
        new_account=$(
        $JQ_FILE -n --arg user "$user" --arg pass "$pass" \
        '{
            "user": $user,
            "pass": $pass
        }')
    elif [ "${inbounds_protocol[inbounds_index]}" == "trojan" ] 
    then
        V2raySetPassword
        V2raySetLevel
        V2raySetEmail
        jq_path='["inbounds",'"$inbounds_index"',"settings","clients"]'
        if [ "$v2ray_name" == "xray" ] 
        then
            V2raySetInboundFlow
            new_account=$(
            $JQ_FILE -n --arg password "$password" --arg flow "$flow" \
                --arg email "$email" --arg level "$level" \
            '{
                "password": $password,
                "flow": $flow,
                "email": $email,
                "level": $level | tonumber
            }')
        else
            new_account=$(
            $JQ_FILE -n --arg password "$password" --arg email "$email" \
                --arg level "$level" \
            '{
                "password": $password,
                "email": $email,
                "level": $level | tonumber
            }')
        fi
    elif [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] 
    then
        if [ "$v2ray_name" == "xray" ] 
        then
            if [[ $($V2CTL_FILE version | head -1 | cut -d' ' -f2) =~ ([^.]+).([^.]+).([^.]+) ]] && \
            [ "${BASH_REMATCH[1]}" -ge 1 ] && [ "${BASH_REMATCH[2]}" -ge 2 ] && [ "${BASH_REMATCH[3]}" -ge 3 ]
            then
                if [ -n "${inbounds_settings_email[inbounds_index]}" ] 
                then
                    Println "$error 请重新添加 shadowsocks 协议入站\n"
                    exit 1
                fi
                V2raySetEmail
                V2raySetMethod
                V2raySetPassword
                V2raySetLevel
                jq_path='["inbounds",'"$inbounds_index"',"settings","clients"]'
                new_account=$(
                $JQ_FILE -n --arg email "$email" --arg method "$method" \
                    --arg password "$password" --arg level "$level" \
                '{
                    "email": $email,
                    "method": $method,
                    "password": $password,
                    "level": $level | tonumber
                }')
            else
                Println "$error 请更新 xray\n"
                exit 1
            fi
        else
            Println "$error shadowsocks 协议不支持多账号\n"
            exit 1
        fi
    elif [ "${inbounds_protocol[inbounds_index]}" == "dokodemo-door" ] 
    then
        Println "$error 无法添加账号到任意门协议\n"
        exit 1
    fi

    JQ add "$V2_CONFIG" "$new_account"
    Println "$info 入站账号添加成功\n"
}

V2rayListInboundAccounts()
{
    V2rayListInbounds
    V2raySelectInbound

    if [ "${inbounds_protocol[inbounds_index]}" == "dokodemo-door" ] 
    then
        Println "$error 任意门协议没有账号\n"
        exit 1
    fi

    if [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] && [ -n "${inbounds_settings_email[inbounds_index]}" ]
    then
        Println "邮箱: ${green}${inbounds_settings_email[inbounds_index]}${normal}\n密码: ${green}${inbounds_settings_password[inbounds_index]}${normal}\n等级: ${green}${inbounds_settings_user_level[inbounds_index]}${normal}\n"
        return 0
    fi

    accounts_count=0
    accounts_id=()
    accounts_level=()
    accounts_alter_id=()
    accounts_email=()
    accounts_list=""
    while IFS="^" read -r map_id map_flow map_level map_alter_id map_email map_user map_pass map_method
    do
        accounts_count=$((accounts_count+1))
        accounts_id+=("$map_id")
        accounts_level+=("$map_level")
        accounts_alter_id+=("$map_alter_id")
        accounts_email+=("$map_email")
        if [ "${inbounds_protocol[inbounds_index]}" == "http" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}HTTP${normal} 用户名: ${green}$map_user${normal} 密码: ${green}$map_pass${normal}\n\n"
        elif [ "${inbounds_protocol[inbounds_index]}" == "socks" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}Socks${normal} 用户名: ${green}$map_user${normal} 密码: ${green}$map_pass${normal} 等级: ${green}$map_level${normal}\n\n"
        elif [ "${inbounds_protocol[inbounds_index]}" == "trojan" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}Trojan${normal} 密码: ${green}$map_pass${normal} 邮箱: ${green}$map_email${normal} 等级: ${green}$map_level${normal}\n\n"
        elif [ "${inbounds_protocol[inbounds_index]}" == "vless" ] 
        then
            if [ "$v2ray_name" == "xray" ] 
            then
                accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VLESS${normal} ID: ${green}$map_id${normal} 模式: ${green}$map_flow${normal} 等级: ${green}$map_level${normal} 邮箱: ${green}$map_email${normal}\n\n"
            else
                accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VLESS${normal} ID: ${green}$map_id${normal} 等级: ${green}$map_level${normal} 邮箱: ${green}$map_email${normal}\n\n"
            fi
        elif [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}Shadowsocks${normal} 邮箱: ${green}$map_email${normal} 加密方式: ${green}$map_method${normal} 密码: ${green}$map_pass${normal} 等级: ${green}$map_level${normal}\n\n"
        else
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VMESS${normal} ID: ${green}$map_id${normal} 等级: ${green}$map_level${normal} alterId: ${green}$map_alter_id${normal} 邮箱: ${green}$map_email${normal}\n\n"
        fi
    done < <($JQ_FILE -r '.inbounds['"$inbounds_index"'].settings | (.clients // .accounts)[] | [.id,.flow,.level,.alterId,.email,.user,(.pass // .password),.method] | join("^")' "$V2_CONFIG")

    if [ "${inbounds_tag[inbounds_index]:0:6}" == "nginx-" ] 
    then
        V2rayListInboundDomains
    fi

    if [ -n "$accounts_list" ] 
    then
        echo "可用账号:"
        Println "$accounts_list\n"
    else
        Println "$error 此入站没有账号\n"
        exit 1
    fi
}

V2rayListInboundAccountLink()
{
    if [ "${inbounds_protocol[inbounds_index]}" == "vmess" ] && [ "${inbounds_listen[inbounds_index]}" != "127.0.0.1" ]
    then
        V2raySelectAccount
        if [ "${inbounds_listen[inbounds_index]}" == "0.0.0.0" ] 
        then
            server_ip=$(GetServerIp)
        else
            server_ip=${inbounds_listen[inbounds_index]}
        fi
        vmess_link=$(
        $JQ_FILE -n --arg ps "${inbounds_tag[inbounds_index]}" --arg add "$server_ip" \
        --arg port "${inbounds_port[inbounds_index]}" --arg id "${accounts_id[accounts_index]}" \
        --arg aid "${accounts_alter_id[accounts_index]}" --arg net "${inbounds_stream_network[inbounds_index]}" \
        --arg header_type "${inbounds_stream_header_type[inbounds_index]}" --arg host "${inbounds_stream_http_host[inbounds_index]}" \
        --arg path "${inbounds_stream_path[inbounds_index]}" --arg tls "${inbounds_stream_security[inbounds_index]}" \
        '{
            "v": "2",
            "ps": $ps,
            "add": $add,
            "port": $port,
            "id": $id,
            "aid": $aid,
            "net": $net,
            "type": $header_type,
            "host": $host,
            "path": $path,
            "tls": $tls
        }' | base64 -w 0)
        Println "分享链接: ${green}vmess://$vmess_link${normal}\n"
        echo
        AskIfContinue y "`gettext \"打印二维码\"`"
        ReleaseCheck
        if [ ! -e "/usr/local/bin/imgcat" ] 
        then
            InstallImgcat
        fi
        if [[ ! -x $(command -v convert) ]] 
        then
            Println "$info 安装 ImageMagick"
            ImageMagickInstall
        fi
        if [[ ! -x $(command -v qrencode) ]] 
        then
            DepInstall qrencode
        fi
        qrencode -s 1 -o "$HOME/vmess_link.png" "vmess://$vmess_link"
        /usr/local/bin/imgcat --half-height "$HOME/vmess_link.png"
    fi
}

V2rayDeleteInboundAccount()
{
    V2rayListInboundAccounts

    if [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] 
    then
        Println "$error 请直接删除此入站\n"
        exit 1
    fi

    echo -e "# ${green}$((accounts_count+1))${normal}${indent_6}删除所有账号\n\n"
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" accounts_index
    do
        case "$accounts_index" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$accounts_index" -gt 0 ] && [ "$accounts_index" -le $((accounts_count+1)) ]
                then
                    accounts_index=$((accounts_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ "${inbounds_protocol[inbounds_index]}" == "http" ] 
    then
        group_name="accounts"
    else
        group_name="clients"
    fi

    if [ "$accounts_index" == "$accounts_count" ] 
    then
        jq_path='["inbounds",'"$inbounds_index"',"settings","'"$group_name"'"]'
        JQ replace "$V2_CONFIG" "[]"
    else
        jq_path='["inbounds",'"$inbounds_index"',"settings","'"$group_name"'"]'
        JQ delete "$V2_CONFIG" "$accounts_index"
    fi
    Println "$info 入站账号删除成功\n"
}

V2rayAddOutbound()
{
    V2raySetOutboundProtocol
    V2raySetTag

    new_outbound=$(
    $JQ_FILE -n --arg protocol "$protocol" --arg tag "$tag" \
    '{
        "protocol": $protocol,
        "tag": $tag
    }')

    if [ "$protocol" != "blackhole" ]
    then
        V2raySetSendThrough
        new_outbound=$(
        $JQ_FILE --arg sendThrough "$send_through" \
        '. * 
        {
            "sendThrough": $sendThrough,
        }' <<< "$new_outbound")
    fi

    if [ "$protocol" != "blackhole" ] && [ "$protocol" != "dns" ]
    then
        V2raySetMuxEnabled
        V2raySetMuxConcurrency
        new_outbound=$(
        $JQ_FILE --arg enabled "$mux_enabled" --arg concurrency "$mux_concurrency" \
        '. * 
        {
            "mux": {
                "enabled": $enabled | test("true"),
                "concurrency": $concurrency | tonumber
            }
        }' <<< "$new_outbound")
    fi

    if [ "$protocol" == "vmess" ] || [ "$protocol" == "vless" ]
    then
        V2raySetAddress
        V2raySetAddressPort
        new_outbound=$(
        $JQ_FILE --arg address "$address" --arg port "$address_port" \
        '. * 
        {
            "settings": { 
                "vnext" : [
                    {
                        "address": $address,
                        "port": $port | tonumber,
                        "users": []
                    }
                ]
            }
        }' <<< "$new_outbound")
    elif [ "$protocol" == "http" ] || [ "$protocol" == "socks" ]
    then
        V2raySetAddress
        V2raySetAddressPort
        new_outbound=$(
        $JQ_FILE --arg address "$address" --arg port "$address_port" \
        '. * 
        {
            "settings": { 
                "servers" : [
                    {
                        "address": $address,
                        "port": $port | tonumber,
                        "users": []
                    }
                ]
            }
        }' <<< "$new_outbound")
    elif [ "$protocol" == "shadowsocks" ] 
    then
        V2raySetEmail
        V2raySetAddress
        V2raySetAddressPort
        V2raySetMethod
        V2raySetPassword
        V2raySetLevel
        new_outbound=$(
        $JQ_FILE --arg email "$email" --arg address "$address" \
        --arg port "$address_port" --arg method "$method" \
        --arg password "$password" --arg level "$level" \
        '. * 
        {
            "settings": {
                "email": $email,
                "address": $address,
                "port": $port | tonumber,
                "method": $method,
                "password": $password,
                "level": $level | tonumber
            }
        }' <<< "$new_outbound")
    elif [ "$protocol" == "trojan" ] 
    then
        new_outbound=$(
        $JQ_FILE \
        '. * 
        {
            "settings": { 
                "servers" : []
            }
        }' <<< "$new_outbound")
    elif [ "$protocol" == "blackhole" ] 
    then
        V2raySetResponseType
        new_outbound=$(
        $JQ_FILE --arg response_type "$response_type" \
        '. * 
        {
            "settings": {
                "type": $response_type
            }
        }' <<< "$new_outbound")
    elif [ "$protocol" == "dns" ] 
    then
        V2raySetDnsNetwork
        V2raySetDnsAddress
        V2raySetDnsPort
        if [ -n "$dns_network" ] 
        then
            new_outbound=$(
            $JQ_FILE --arg network "$dns_network" \
            '. * 
            {
                "settings": {
                    "network": $network
                }
            }' <<< "$new_outbound")
        fi
        if [ -n "$dns_address" ] 
        then
            new_outbound=$(
            $JQ_FILE --arg address "$dns_address" \
            '. * 
            {
                "settings": {
                    "address": $address
                }
            }' <<< "$new_outbound")
        fi
        if [ -n "$dns_port" ] 
        then
            new_outbound=$(
            $JQ_FILE --arg port "$dns_port" \
            '. * 
            {
                "settings": {
                    "port": $port | tonumber
                }
            }' <<< "$new_outbound")
        fi
    elif [ "$protocol" == "freedom" ] 
    then
        V2raySetFreedomDomainStrategy
        V2raySetFreedomRedirect
        V2raySetLevel
        new_outbound=$(
        $JQ_FILE --arg domainStrategy "$freedom_domain_strategy" --arg userLevel "$level" \
        '. * 
        {
            "settings": {
                "domainStrategy": $domainStrategy,
                "userLevel": $userLevel | tonumber
            }
        }' <<< "$new_outbound")
        if [ -n "$freedom_redirect" ] 
        then
            new_outbound=$(
            $JQ_FILE --arg redirect "$freedom_redirect" \
            '. * 
            {
                "settings": {
                    "redirect": ${red}irect
                }
            }' <<< "$new_outbound")
        fi
    fi

    V2raySetProxy
    if [ -n "$proxy_tag" ] 
    then
        new_outbound=$(
        $JQ_FILE --arg tag "$proxy_tag" \
        '. * 
        {
            "proxySettings": {
                "tag": $tag
            }
        }' <<< "$new_outbound")
    fi

    if [ -z "$proxy_tag" ] && [ "$protocol" != "blackhole" ] && [ "$protocol" != "dns" ] && [ "$protocol" != "freedom" ]
    then
        V2raySetOutboundNetwork

        new_outbound=$(
        $JQ_FILE --arg network "$network" --arg security "$security" \
        '. * 
        {
            "streamSettings": {
                "network": $network,
                "security": $security
            }
        }' <<< "$new_outbound")

        if [ "$network" == "ws" ] 
        then
            V2raySetPath
            V2raySetHeaders
            new_outbound=$(
            $JQ_FILE --arg path "$path" --argjson headers "{$headers}" \
            '. * 
            {
                "streamSettings": {
                    "wsSettings": {
                        "path": $path,
                        "headers": $headers
                    }
                }
            }' <<< "$new_outbound")
        elif [ "$network" == "tcp" ] 
        then
            V2raySetHeaderType
            new_outbound=$(
            $JQ_FILE --arg header_type "$header_type" --argjson request "$header_http_request" \
            --argjson response "$header_http_response" \
            '. * 
            {
                "streamSettings": {
                    "tcpSettings": {
                        "header": {
                            "type": $header_type,
                            "request": $request,
                            "response": $response
                        }
                    }
                }
            }' <<< "$new_outbound")
        elif [ "$network" == "kcp" ] 
        then
            V2raySetHeaderType
            new_outbound=$(
            $JQ_FILE --arg header_type "$header_type" \
            '. * 
            {
                "streamSettings": {
                    "kcpSettings": {
                        "header": {
                            "type": $header_type
                        }
                    }
                }
            }' <<< "$new_outbound")
        elif [ "$network" == "http" ] 
        then
            V2raySetHost
            V2raySetPath
            new_outbound=$(
            $JQ_FILE --argjson host "[$host]" \
                --arg path "$path" \
            '. * 
            {
                "streamSettings": {
                    "httpSettings": {
                        "host": $host,
                        "path": $path
                    }
                }
            }' <<< "$new_outbound")
        elif [ "$network" == "quic" ] 
        then
            V2raySetQuicSecurity
            V2raySetQuicKey
            V2raySetHeaderType
            new_outbound=$(
            $JQ_FILE --arg security "$quic_security" \
                --arg key "$quic_key" --arg header_type "$header_type" \
            '. * 
            {
                "streamSettings": {
                    "quicSettings": {
                        "security": $security,
                        "key": $key,
                        "header": {
                            "type": $header_type
                        }
                    }
                }
            }' <<< "$new_outbound")
        fi

        V2raySetSecurity

        if [ "$security" == "tls" ] 
        then
            V2raySetServerName
            if [ -n "$server_name" ] 
            then
                new_outbound=$(
                $JQ_FILE --arg serverName "$server_name" \
                '. * 
                {
                    "streamSettings": {
                        "tlsSettings": {
                            "serverName": $serverName
                        }
                    }
                }' <<< "$new_outbound")
            fi
            V2raySetAllowInsecure
            V2raySetAlpn
            V2raySetDisableSystemRoot
            new_outbound=$(
            $JQ_FILE --arg allowInsecure "$allow_insecure" \
            --argjson alpn "[$alpn]" --arg disableSystemRoot "$disable_system_root" \
            '. * 
            {
                "streamSettings": {
                    "tlsSettings": {
                        "allowInsecure": $allowInsecure | test("true"),
                        "alpn": $alpn,
                        "disableSystemRoot": $disableSystemRoot | test("true"),
                    }
                }
            }' <<< "$new_outbound")
            while true 
            do
                if [ "$disable_system_root" == "false" ] 
                then
                    echo
                    inquirer list_input "是否继续添加证书" ny_options continue_yn
                    if [ "$continue_yn" == "$i18n_no" ] 
                    then
                        break
                    fi
                fi
                Println "$info 设置证书"
                V2raySetCertificates
                merge=$(
                $JQ_FILE -n --argjson certificates "[$certificate]" \
                '{
                    "streamSettings": {
                        "tlsSettings": {
                            "certificates": $certificates
                        }
                    }
                }')
                JQs merge new_outbound "$merge"
                if [ "$disable_system_root" == "true" ] 
                then
                    echo
                    inquirer list_input "是否继续添加证书" ny_options continue_yn
                    if [ "$continue_yn" == "$i18n_no" ] 
                    then
                        break
                    fi
                fi
            done
        elif [ "$security" == "xtls" ] 
        then
            V2raySetServerName
            if [ -n "$server_name" ] 
            then
                new_outbound=$(
                $JQ_FILE --arg serverName "$server_name" \
                '. * 
                {
                    "streamSettings": {
                        "xtlsSettings": {
                            "serverName": $serverName
                        }
                    }
                }' <<< "$new_outbound")
            fi
            V2raySetAllowInsecure
            V2raySetAlpn
            V2raySetDisableSystemRoot
            new_outbound=$(
            $JQ_FILE --arg allowInsecure "$allow_insecure" \
            --argjson alpn "[$alpn]" --arg disableSystemRoot "$disable_system_root" \
            '. * 
            {
                "streamSettings": {
                    "xtlsSettings": {
                        "allowInsecure": $allowInsecure | test("true"),
                        "alpn": $alpn,
                        "disableSystemRoot": $disableSystemRoot | test("true"),
                    }
                }
            }' <<< "$new_outbound")
            while true 
            do
                if [ "$disable_system_root" == "false" ] 
                then
                    echo
                    inquirer list_input "是否继续添加证书" ny_options continue_yn
                    if [ "$continue_yn" == "$i18n_no" ] 
                    then
                        break
                    fi
                fi
                Println "$info 设置证书"
                V2raySetCertificates
                merge=$(
                $JQ_FILE -n --argjson certificates "[$certificate]" \
                '{
                    "streamSettings": {
                        "xtlsSettings": {
                            "certificates": $certificates
                        }
                    }
                }')
                JQs merge new_outbound "$merge"
                if [ "$disable_system_root" == "true" ] 
                then
                    echo
                    inquirer list_input "是否继续添加证书" ny_options continue_yn
                    if [ "$continue_yn" == "$i18n_no" ] 
                    then
                        break
                    fi
                fi
            done
        fi
    fi

    JQ add "$V2_CONFIG" outbounds "[$new_outbound]"

    Println "$info 出站 $tag 添加成功\n"
}

V2rayGetOutbounds()
{
    IFS=$'`\t' read -r map_send_through map_protocol map_settings_user_level \
    map_settings_address map_settings_port map_settings_network map_settings_response_type \
    map_settings_domain_strategy map_settings_redirect map_settings_email map_settings_method \
    map_settings_password map_stream_network map_stream_security map_stream_tls_server_name \
    map_stream_tls_allow_insecure map_stream_tls_alpn map_stream_tls_certificates_usage \
    map_stream_tls_certificates_certificate_file map_stream_tls_certificates_key_file \
    map_stream_tls_certificates_certificate map_stream_tls_certificates_key \
    map_stream_tls_disable_system_root map_stream_http_host map_stream_path map_stream_ws_headers \
    map_stream_header_type map_stream_header_request map_stream_header_response map_stream_quic_security \
    map_stream_quic_key map_proxy_tag map_mux_enabled map_mux_concurrency map_tag < <($JQ_FILE -c -r '[
    ([.outbounds[]|.sendThrough|if . == "" // . == null then "0.0.0.0" else . end|. + "^"]|join("") + "`"),
    ([.outbounds[]|.protocol|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.userLevel // .settings.servers[0].level // ""|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.address // .settings.vnext[0].address // .settings.servers[0].address|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.port // .settings.vnext[0].port // .settings.servers[0].port // ""|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.network|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.response.type // "none"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.domainStrategy // "AsIs"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.redirect|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.servers[0].email|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.servers[0].method // "none"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.settings.servers[0].password|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.network|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.security // "none"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.serverName // .streamSettings.xtlsSettings.serverName|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.allowInsecure // .streamSettings.xtlsSettings.allowInsecure // false|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.alpn // .streamSettings.xtlsSettings.alpn // []|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].usage|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].certificateFile|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].keyFile|. + "|"]|join("")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].certificate // []|join(" ")]|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.certificates // .streamSettings.xtlsSettings.certificates // []|[.[].key // []|join(" ")]|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tlsSettings.disableSystemRoot // .streamSettings.xtlsSettings.disableSystemRoot // false|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.httpSettings.host // []|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.wsSettings.path // .streamSettings.httpSettings.path|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.wsSettings.headers // {}|to_entries|map("\(.key)=\(.value)")|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tcpSettings.header.type // .streamSettings.kcpSettings.header.type // .streamSettings.quicSettings.header.type // "none"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tcpSettings.header.request // {}|to_entries|
    map("\(.key)=\(.value|(. | type) as $type|if ($type == "array") then (.|join("~")) 
    elif ($type == "object") then (.|to_entries|map("\(.key)=\(
        (.value|(. | type) as $type2|if ($type2 == "array") then (.|join("~")) else . end))")|join("!"))
    else . end)")|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.tcpSettings.header.response // {}|to_entries|
    map("\(.key)=\(.value|(. | type) as $type|if ($type == "object") then (.|to_entries|map("\(.key)=\(
        (.value|(. | type) as $type2|if ($type2 == "array") then (.|join("~")) else . end))")|join("!"))
    else . end)")|join("|")|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.quicSettings.security // "none"|. + "^"]|join("") + "`"),
    ([.outbounds[]|.streamSettings.quicSettings.key|. + "^"]|join("") + "`"),
    ([.outbounds[]|.proxySettings.tag|. + "^"]|join("") + "`"),
    ([.outbounds[]|.mux.enabled // false|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.mux.concurrency // 8|tostring|. + "^"]|join("") + "`"),
    ([.outbounds[]|.tag|. + "^"]|join("") + "`")
    ]|@tsv' "$V2_CONFIG")

    if [ -z "$map_protocol" ] 
    then
        outbounds_count=0
        return 0
    fi

    IFS="^" read -r -a outbounds_protocol <<< "$map_protocol"
    outbounds_count=${#outbounds_protocol[@]}
    if_null=""

    for((outbounds_i=0;outbounds_i<outbounds_count;outbounds_i++));
    do
        if_null="$if_null^"
    done

    IFS="^" read -r -a outbounds_send_through <<< "${map_send_through:-$if_null}"
    IFS="^" read -r -a outbounds_settings_user_level <<< "${map_settings_user_level:-$if_null}"
    IFS="^" read -r -a outbounds_settings_address <<< "${map_settings_address:-$if_null}"
    IFS="^" read -r -a outbounds_settings_port <<< "${map_settings_port:-$if_null}"
    IFS="^" read -r -a outbounds_settings_network <<< "${map_settings_network:-$if_null}"
    IFS="^" read -r -a outbounds_settings_response_type <<< "${map_settings_response_type:-$if_null}"
    IFS="^" read -r -a outbounds_settings_domain_strategy <<< "${map_settings_domain_strategy:-$if_null}"
    IFS="^" read -r -a outbounds_settings_redirect <<< "${map_settings_redirect:-$if_null}"
    IFS="^" read -r -a outbounds_settings_email <<< "${map_settings_email:-$if_null}"
    IFS="^" read -r -a outbounds_settings_method <<< "${map_settings_method:-$if_null}"
    IFS="^" read -r -a outbounds_settings_password <<< "${map_settings_password:-$if_null}"
    IFS="^" read -r -a outbounds_stream_network <<< "${map_stream_network:-$if_null}"
    IFS="^" read -r -a outbounds_stream_security <<< "${map_stream_security:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_server_name <<< "${map_stream_tls_server_name:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_allow_insecure <<< "${map_stream_tls_allow_insecure:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_alpn <<< "${map_stream_tls_alpn:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_certificates_usage <<< "${map_stream_tls_certificates_usage:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_certificates_certificate_file <<< "${map_stream_tls_certificates_certificate_file:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_certificates_key_file <<< "${map_stream_tls_certificates_key_file:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_certificates_certificate <<< "${map_stream_tls_certificates_certificate:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_certificates_key <<< "${map_stream_tls_certificates_key:-$if_null}"
    IFS="^" read -r -a outbounds_stream_tls_disable_system_root <<< "${map_stream_tls_disable_system_root:-$if_null}"
    IFS="^" read -r -a outbounds_stream_http_host <<< "${map_stream_http_host:-$if_null}"
    IFS="^" read -r -a outbounds_stream_path <<< "${map_stream_path:-$if_null}"
    IFS="^" read -r -a outbounds_stream_ws_headers <<< "${map_stream_ws_headers:-$if_null}"
    IFS="^" read -r -a outbounds_stream_header_type <<< "${map_stream_header_type:-$if_null}"
    IFS="^" read -r -a outbounds_stream_header_request <<< "${map_stream_header_request:-$if_null}"
    IFS="^" read -r -a outbounds_stream_header_response <<< "${map_stream_header_response:-$if_null}"
    IFS="^" read -r -a outbounds_stream_quic_security <<< "${map_stream_quic_security:-$if_null}"
    IFS="^" read -r -a outbounds_stream_quic_key <<< "${map_stream_quic_key:-$if_null}"
    IFS="^" read -r -a outbounds_proxy_tag <<< "${map_proxy_tag:-$if_null}"
    IFS="^" read -r -a outbounds_mux_enabled <<< "${map_mux_enabled:-$if_null}"
    IFS="^" read -r -a outbounds_mux_concurrency <<< "${map_mux_concurrency:-$if_null}"
    IFS="^" read -r -a outbounds_tag <<< "${map_tag:-$if_null}"
}

V2rayListOutbounds()
{
    V2rayGetOutbounds

    [ "$outbounds_count" -eq 0 ] && Println "$error 没有出站\n" && exit 1

    Println "\n=== 出站数 ${green} $outbounds_count ${normal}"

    outbounds_list=""

    for((outbounds_index=0;outbounds_index<outbounds_count;outbounds_index++));
    do
        protocol_settings_list="传输协议: ${green}${outbounds_protocol[outbounds_index]}${normal}\n${indent_6}"
        if [ "${outbounds_send_through[outbounds_index]}" != "0.0.0.0" ] 
        then
            protocol_settings_list="$protocol_settings_list发送数据的 IP 地址: ${green}${outbounds_send_through[outbounds_index]}${normal}\n${indent_6}"
        fi
        if [ -n "${outbounds_settings_address[outbounds_index]}" ] 
        then
            protocol_settings_list="$protocol_settings_list目标地址: ${green}${outbounds_settings_address[outbounds_index]}${normal} 目标端口: ${green}${outbounds_settings_port[outbounds_index]}${normal}\n${indent_6}"
        fi
        if [ "${outbounds_protocol[outbounds_index]}" == "blackhole" ] 
        then
            if [ "${outbounds_settings_response_type[outbounds_index]}" == "none" ] 
            then
                protocol_settings_list="$protocol_settings_list黑洞的响应方式: ${green}直接关闭${normal}\n${indent_6}"
            else
                protocol_settings_list="$protocol_settings_list黑洞的响应方式: ${green}返回403并关闭${normal}\n${indent_6}"
            fi
        elif [ "${outbounds_protocol[outbounds_index]}" == "dns" ] 
        then
            protocol_settings_list="${protocol_settings_list}传输层协议: ${green}${outbounds_settings_network[outbounds_index]:-不变}${normal} 服务器地址: ${green}${outbounds_settings_address[outbounds_index]:-不变}${normal} 服务器端口: ${green}${outbounds_settings_port[outbounds_index]:-不变}${normal}\n${indent_6}"
        elif [ "${outbounds_protocol[outbounds_index]}" == "freedom" ] 
        then
            if [ -n "${outbounds_settings_domain_strategy[outbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list域名策略: ${green}${outbounds_settings_domain_strategy[outbounds_index]}${normal}\n${indent_6}"
            fi
            if [ -n "${outbounds_settings_redirect[outbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list发送到指定地址: ${green}${outbounds_settings_redirect[outbounds_index]}${normal}\n${indent_6}"
            fi
            if [ -n "${outbounds_settings_user_level[outbounds_index]}" ] 
            then
                protocol_settings_list="$protocol_settings_list使用用户等级: ${green}${outbounds_settings_user_level[outbounds_index]}${normal}\n${indent_6}"
            fi
        elif [ "${outbounds_protocol[outbounds_index]}" == "shadowsocks" ] 
        then
            protocol_settings_list="$protocol_settings_list加密方式: ${green}${outbounds_settings_method[outbounds_index]}${normal}\n${indent_6}"
        fi
        if [ -n "${outbounds_proxy_tag[outbounds_index]}" ] 
        then
            stream_settings_list="指定的出站代理标签: ${outbounds_proxy_tag[outbounds_index]}\n${indent_6}"
        else
            stream_settings_list=""
            if [ "${outbounds_stream_network[outbounds_index]}" == "http" ] 
            then
                stream_settings_list="传输方式: ${green}http/2${normal}\n${indent_6}"
            elif [ -n "${outbounds_stream_network[outbounds_index]}" ]  
            then
                stream_settings_list="传输方式: ${green}${outbounds_stream_network[outbounds_index]}${normal}\n${indent_6}"
            fi
            if [ "${outbounds_protocol[outbounds_index]}" != "blackhole" ] && [ "${outbounds_protocol[outbounds_index]}" != "dns" ] && [ "${outbounds_protocol[outbounds_index]}" != "freedom" ]
            then
                if [ "${outbounds_stream_security[outbounds_index]}" == "none" ] 
                then
                    stream_settings_list="${stream_settings_list}$tls_name 加密: ${red}否${normal}\n${indent_6}"
                else
                    stream_settings_list="${stream_settings_list}$tls_name 加密: ${green}是${normal}\n${indent_6}"
                    if [ -n "${outbounds_stream_tls_server_name[outbounds_index]}" ] 
                    then
                        stream_settings_list="${stream_settings_list}指定证书域名: ${green}${outbounds_stream_tls_server_name[outbounds_index]}${normal}\n${indent_6}"
                    else
                        stream_settings_list="${stream_settings_list}指定证书域名: ${red}否${normal}\n${indent_6}"
                    fi
                    if [ "${outbounds_stream_tls_allow_insecure[outbounds_index]}" == "false" ] 
                    then
                        stream_settings_list="${stream_settings_list}允许不安全连接: ${red}否${normal}\n${indent_6}"
                    else
                        stream_settings_list="${stream_settings_list}允许不安全连接: ${green}是${normal}\n${indent_6}"
                    fi
                    if [ "${outbounds_stream_tls_disable_system_root[outbounds_index]}" == "false" ] 
                    then
                        stream_settings_list="${stream_settings_list}禁用操作系统自带 CA 证书: ${red}否${normal}\n${indent_6}"
                    else
                        stream_settings_list="${stream_settings_list}禁用操作系统自带 CA 证书: ${green}是${normal}\n${indent_6}"
                    fi
                    if [ -n "${outbounds_stream_tls_alpn[outbounds_index]}" ] 
                    then
                        stream_settings_list="${stream_settings_list}$tls_name 握手 ALPN: ${green}${outbounds_stream_tls_alpn[outbounds_index]//|/,}${normal}\n${indent_6}"
                    else
                        stream_settings_list="${stream_settings_list}$tls_name 握手 ALPN: ${green}h2,http/1.1${normal}\n${indent_6}"
                    fi
                    if [ -n "${outbounds_stream_tls_certificates_usage[outbounds_index]}" ] 
                    then
                        certificates_list="${green}证书:${normal}\n${indent_6}"
                        IFS="|" read -r -a usages <<< "${outbounds_stream_tls_certificates_usage[outbounds_index]}"
                        IFS="|" read -r -a certificate_files <<< "${outbounds_stream_tls_certificates_certificate_file[outbounds_index]}"
                        IFS="|" read -r -a key_files <<< "${outbounds_stream_tls_certificates_key_file[outbounds_index]}"
                        IFS="|" read -r -a certificates <<< "${outbounds_stream_tls_certificates_certificate[outbounds_index]}"
                        for((certificate_i=0;certificate_i<${#usages[@]};certificate_i++));
                        do
                            if [ "${usages[certificate_i]}" == "encipherment" ] 
                            then
                                certificate_usage="$tls_name 认证和加密"
                            elif [ "${usages[certificate_i]}" == "verify" ] 
                            then
                                certificate_usage="验证远端 $tls_name"
                            else
                                certificate_usage="签发其它证书"
                            fi
                            if [ -n "${certificates:-}" ] && [ -n "${certificates[certificate_i]}" ] 
                            then
                                certificates_list="$certificates_list$((certificate_i+1)). 用途: ${green}$certificate_usage [自签名]${normal}\n${indent_6}"
                            else
                                certificates_list="$certificates_list$((certificate_i+1)). 用途: ${green}$certificate_usage${normal}\n${indent_6}"
                            fi
                            if [ -n "${certificate_files[certificate_i]}" ] 
                            then
                                certificates_list="$certificates_list证书路径: ${green}${certificate_files[certificate_i]}${normal}\n${indent_6}"
                            fi
                            if [ -n "${key_files[certificate_i]}" ] 
                            then
                                certificates_list="$certificates_list密钥路径: ${green}${key_files[certificate_i]}${normal}\n${indent_6}"
                            fi
                        done
                        stream_settings_list="$stream_settings_list\n${indent_6}$certificates_list\n${indent_6}"
                    fi
                fi
            fi
            if [ "${outbounds_stream_network[outbounds_index]}" == "ws" ] 
            then
                stream_settings_list="$stream_settings_list路径: ${green}${outbounds_stream_path[outbounds_index]}${normal}\n${indent_6}"
                if [ -n "${outbounds_stream_ws_headers[outbounds_index]}" ] 
                then
                    IFS="|" read -r -a headers <<< "${outbounds_stream_ws_headers[outbounds_index]}"
                    headers_list=""
                    for header in "${headers[@]}"
                    do
                        headers_list="$headers_list${green}${header%%=*}${normal}: ${green}${header#*=}${normal}\n${indent_6}"
                    done
                    [ -n "$headers_list" ] && stream_settings_list="$stream_settings_list自定义 HTTP 头:\n${indent_6}$headers_list"
                fi
            elif [ "${outbounds_stream_network[outbounds_index]}" == "tcp" ] 
            then
                if [ "${outbounds_stream_header_type[outbounds_index]}" == "none" ] 
                then
                    stream_settings_list="$stream_settings_list数据包头部: ${red}不伪装${normal}\n${indent_6}"
                else
                    stream_settings_list="$stream_settings_list数据包头部: ${green}http 伪装${normal}\n${indent_6}"
                    if [ -n "${outbounds_stream_header_request[outbounds_index]}" ] 
                    then
                        IFS="|" read -r -a header_request <<< "${outbounds_stream_header_request[outbounds_index]}"
                        header_request_list=""
                        for request in "${header_request[@]}"
                        do
                            request_key=${request%%=*}
                            request_value=${request#*=}
                            if [ "$request_key" == "headers" ] 
                            then
                                IFS="!" read -r -a headers <<< "$request_value"
                                if [ -n "${headers:-}" ] 
                                then
                                    header_request_list="$header_request_list${green}headers${normal}:\n\033[8C"
                                    for header in "${headers[@]}"
                                    do
                                        header_key=${header%%=*}
                                        header_request_list="$header_request_list${green}$header_key => ${normal}\n\033[8C"
                                        header_value=${header#*=}
                                        IFS="~" read -r -a header_values <<< "$header_value"
                                        if [ -z "${header_values:-}" ] 
                                        then
                                            continue
                                        fi
                                        for header_value in "${header_values[@]}"
                                        do
                                            header_request_list="$header_request_list  ${green}$header_value${normal}\n\033[8C"
                                        done
                                    done
                                fi
                            else
                                header_request_list="$header_request_list${green}$request_key${normal}: ${green}${request_value//~/, }${normal}\n${indent_6}"
                            fi
                        done
                        [ -n "$header_request_list" ] && stream_settings_list="$stream_settings_list自定义 HTTP 头:\n${indent_6}$header_request_list"
                    fi
                fi
            elif [ "${outbounds_stream_network[outbounds_index]}" == "kcp" ] 
            then
                if [ "${outbounds_stream_header_type[outbounds_index]}" == "none" ] 
                then
                    stream_settings_list="$stream_settings_list数据包头部: ${red}不伪装${normal}\n${indent_6}"
                else
                    stream_settings_list="$stream_settings_list数据包头部: ${green}http 伪装${normal}\n${indent_6}"
                fi
            elif [ "${outbounds_stream_network[outbounds_index]}" == "http" ] 
            then
                stream_settings_list="$stream_settings_list路径: ${green}${outbounds_stream_path[outbounds_index]}${normal}\n${indent_6}"
                if [ -n "${outbounds_stream_http_host[outbounds_index]}" ] 
                then
                    stream_settings_list="$stream_settings_list通信域名: ${green}${outbounds_stream_http_host[outbounds_index]//|/, }${normal}\n${indent_6}"
                fi
            elif [ "${outbounds_stream_network[outbounds_index]}" == "quic" ] 
            then
                if [ "${outbounds_stream_quic_security[outbounds_index]}" == "none" ] 
                then
                    stream_settings_list="$stream_settings_list数据包加密方式: ${red}不加密${normal} 密钥: ${green}${outbounds_stream_quic_key[outbounds_index]}${normal}\n${indent_6}"
                else
                    stream_settings_list="$stream_settings_list数据包加密方式: ${green}${outbounds_stream_quic_security[outbounds_index]}${normal} 密钥: ${green}${outbounds_stream_quic_key[outbounds_index]}${normal}\n${indent_6}"
                fi
                if [ "${outbounds_stream_header_type[outbounds_index]}" == "none" ] 
                then
                    stream_settings_list="$stream_settings_list数据包头部: ${red}不伪装${normal}\n${indent_6}"
                else
                    stream_settings_list="$stream_settings_list数据包头部: ${green}http 伪装${normal}\n${indent_6}"
                fi
            fi
        fi
        if [ "${outbounds_mux_enabled[outbounds_index]}" == "true" ] 
        then
            mux_settings_list="${green}已开启 Mux${normal} 最大并发连接数: ${green}${outbounds_mux_concurrency[outbounds_index]}${normal}\n${indent_6}"
        else
            mux_settings_list=""
        fi
        outbounds_list=$outbounds_list"# ${green}$((outbounds_index+1))${normal}${indent_6}标签: ${green}${outbounds_tag[outbounds_index]:-无}${normal}\n${indent_6}$protocol_settings_list$stream_settings_list$mux_settings_list\n\n"
    done

    Println "$outbounds_list\n"
}

V2raySelectOutbound()
{
    echo -e "选择出站"
    while read -p "$i18n_default_cancel" outbound_num
    do
        case "$outbound_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$outbound_num" -gt 0 ] && [ "$outbound_num" -le $outbounds_count ]
                then
                    outbounds_index=$((outbound_num-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2rayDeleteOutbound()
{
    V2rayListOutbounds
    V2raySelectOutbound
    jq_path='["outbounds"]'
    JQ delete "$V2_CONFIG" "$outbounds_index"
    Println "$info 出站 ${outbounds_tag[outbounds_index]} 删除成功\n"
}

V2rayAddOutboundAccount()
{
    V2rayListOutbounds
    V2raySelectOutbound

    if [ "${outbounds_protocol[outbounds_index]}" == "vmess" ] 
    then
        V2raySetId
        V2raySetAlterId
        V2raySetVmessSecurity
        V2raySetLevel
        jq_path='["outbounds",'"$outbounds_index"',"settings","vnext",0,"users"]'
        new_account=$(
        $JQ_FILE -n --arg id "$id" --arg alterId "$alter_id" \
            --arg security "$vmess_security" --arg level "$level" \
        '{
            "id": $id,
            "alterId": $alterId | tonumber,
            "security": $security,
            "level": $level | tonumber
        }')
    elif [ "${outbounds_protocol[outbounds_index]}" == "vless" ] 
    then
        V2raySetId
        V2raySetLevel
        jq_path='["outbounds",'"$outbounds_index"',"settings","vnext",0,"users"]'
        if [ "$v2ray_name" == "xray" ] 
        then
            V2raySetOutboundFlow
            new_account=$(
            $JQ_FILE -n --arg id "$id" --arg flow "$flow" \
                --arg level "$level" \
            '{
                "id": $id,
                "flow": $flow,
                "encryption": "none",
                "level": $level | tonumber
            }')
        else
            new_account=$(
            $JQ_FILE -n --arg id "$id" --arg level "$level" \
            '{
                "id": $id,
                "encryption": "none",
                "level": $level | tonumber
            }')
        fi
    elif [ "${outbounds_protocol[outbounds_index]}" == "http" ] 
    then
        V2raySetHttpAccount
        new_account=$(
        $JQ_FILE -n --arg user "$user" --arg pass "$pass" \
        '{
            "user": $user,
            "pass": $pass
        }')
    elif [ "${outbounds_protocol[outbounds_index]}" == "socks" ] 
    then
        V2raySetHttpAccount
        V2raySetLevel
        new_account=$(
        $JQ_FILE -n --arg user "$user" --arg pass "$pass" \
        --arg level "$level" \
        '{
            "user": $user,
            "pass": $pass,
            "level": $level | tonumber
        }')
    elif [ "${outbounds_protocol[outbounds_index]}" == "trojan" ] 
    then
        V2raySetPassword
        V2raySetLevel
        V2raySetEmail
        jq_path='["outbounds",'"$outbounds_index"',"settings","clients"]'
        if [ "$v2ray_name" == "xray" ] 
        then
            V2raySetOutboundFlow
            new_account=$(
            $JQ_FILE -n --arg password "$password" --arg flow "$flow" \
            --arg level "$level" --arg email "$email" \
            '{
                "password": $password,
                "flow": $flow,
                "email": $email,
                "level": $level | tonumber
            }')
        else
            new_account=$(
            $JQ_FILE -n --arg password "$password" --arg level "$level" \
            --arg email "$email" \
            '{
                "password": $password,
                "email": $email,
                "level": $level | tonumber
            }')
        fi
    elif [ "${outbounds_protocol[outbounds_index]}" == "shadowsocks" ] 
    then
        Println "$error shadowsocks 协议不支持多账号\n"
        exit 1
    else
        Println "$error 无法添加账号到此协议\n"
        exit 1
    fi

    JQ add "$V2_CONFIG" "$new_account"
    Println "$info 出站账号添加成功\n"
}

V2rayListOutboundAccounts()
{
    V2rayListOutbounds
    V2raySelectOutbound

    if [ "${outbounds_protocol[outbounds_index]}" != "vmess" ] && [ "${outbounds_protocol[outbounds_index]}" != "vless" ] && [ "${outbounds_protocol[outbounds_index]}" != "http" ] && [ "${outbounds_protocol[outbounds_index]}" != "socks" ]
    then
        Println "$error 协议 ${outbounds_protocol[outbounds_index]} 没有账号\n"
        exit 1
    fi

    if [ "${outbounds_protocol[outbounds_index]}" == "shadowsocks" ] 
    then
        Println "邮箱: ${green}${outbounds_settings_email[outbounds_index]}${normal}\n密码: ${green}${outbounds_settings_password[outbounds_index]}${normal}\n等级: ${green}${outbounds_settings_user_level[outbounds_index]}${normal}\n"
        return 0
    fi

    accounts_count=0
    accounts_list=""
    while IFS="^" read -r map_id map_flow map_level map_alter_id map_security map_user map_pass map_address map_port map_email
    do
        accounts_count=$((accounts_count+1))
        if [ "${outbounds_protocol[outbounds_index]}" == "http" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}HTTP${normal} 用户名: ${green}$map_user${normal} 密码: ${green}$map_pass${normal}\n\n"
        elif [ "${outbounds_protocol[outbounds_index]}" == "socks" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}Socks${normal} 用户名: ${green}$map_user${normal} 密码: ${green}$map_pass${normal} 等级: ${green}$map_level${normal}\n\n"
        elif [ "${outbounds_protocol[outbounds_index]}" == "trojan" ] 
        then
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}Trojan${normal} 服务器地址: ${green}$map_address${normal} 服务器端口: ${green}$map_port${normal}\n${indent_6}密码: ${green}$map_pass${normal} 邮箱: ${green}$map_email${normal} 等级: ${green}$map_level${normal}\n\n"
        elif [ "${outbounds_protocol[outbounds_index]}" == "vless" ] 
        then
            if [ "$v2ray_name" == "xray" ] 
            then
                accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VLESS${normal} ID: ${green}$map_id${normal} 模式: ${green}$map_flow${normal} 等级: ${green}$map_level${normal} 加密方式: ${green}$map_security${normal}\n\n"
            else
                accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VLESS${normal} ID: ${green}$map_id${normal} 等级: ${green}$map_level${normal} 加密方式: ${green}$map_security${normal}\n\n"
            fi
        else
            accounts_list=$accounts_list"# ${green}$accounts_count${normal}${indent_6}传输协议: ${green}VMESS${normal} ID: ${green}$map_id${normal} 等级: ${green}$map_level${normal} alterId: ${green}$map_alter_id${normal} 加密方式: ${green}$map_security${normal}\n\n"
        fi
    done < <($JQ_FILE -r '.outbounds['"$outbounds_index"'].settings | (.vnext // .servers)[0].users[] | [.id,.flow,.level,.alterId,.security,.user,(.pass // .password),.address,.port,.email] | join("^")' "$V2_CONFIG")

    if [ -n "$accounts_list" ] 
    then
        echo "可用账号:"
        Println "$accounts_list\n"
    else
        Println "$error 此出站没有账号\n"
        exit 1
    fi
}

V2rayDeleteOutboundAccount()
{
    V2rayListOutboundAccounts

    if [ "${outbounds_protocol[outbounds_index]}" == "shadowsocks" ] 
    then
        Println "$error 请直接删除此出站\n"
        exit 1
    fi

    echo -e "# ${green}$((accounts_count+1))${normal}${indent_6}删除所有账号\n\n"
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" accounts_index
    do
        case "$accounts_index" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$accounts_index" -gt 0 ] && [ "$accounts_index" -le $((accounts_count+1)) ]
                then
                    accounts_index=$((accounts_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ "${outbounds_protocol[outbounds_index]}" == "http" ] 
    then
        group_name="servers"
    else
        group_name="vnext"
    fi

    if [ "$accounts_index" == "$accounts_count" ] 
    then
        jq_path='["outbounds",'"$outbounds_index"',"settings","'"$group_name"'",0,"users"]'
        JQ replace "$V2_CONFIG" "[]"
    else
        jq_path='["outbounds",'"$outbounds_index"',"settings","'"$group_name"'",0,"users"]'
        JQ delete "$V2_CONFIG" "$accounts_index"
    fi
    Println "$info 出站账号删除成功\n"
}

V2rayGetRouting()
{
    IFS=$'`\t' read -r routing_domain_strategy m_rules_type m_rules_domain m_rules_ip m_rules_port \
    m_rules_source_port m_rules_network m_rules_source m_rules_user m_rules_inbound_tag \
    m_rules_protocol m_rules_attrs m_rules_outbound_tag m_rules_balancer_tag m_balancers_tag \
    m_balancers_selector < <($JQ_FILE -r '[
    (.routing.domainStrategy|if . == "" // . == null then "AsIs" else . end + "`"),
    ([(.routing.rules // [])[]|.type|if . == "" // . == null then "field" else . end|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.domain // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.ip // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.port|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.sourcePort|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.network|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.source // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.user // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.inboundTag // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.protocol // [] |join("|")|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.attrs|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.outboundTag|. + "^"]|join("") + "`"),
    ([(.routing.rules // [])[]|.balancerTag|. + "^"]|join("") + "`"),
    ([(.routing.balancers // [])[]|.tag|. + "^"]|join("") + "`"),
    ([(.routing.balancers // [])[]|.selector // [] |join("|")|. + "^"]|join("") + "`")]|@tsv' "$V2_CONFIG")

    if [ -z "$m_rules_type" ] 
    then
        routing_rules_count=0
    else
        IFS="^" read -r -a routing_rules_type <<< "$m_rules_type"
        IFS="^" read -r -a routing_rules_domain <<< "$m_rules_domain"
        IFS="^" read -r -a routing_rules_ip <<< "$m_rules_ip"
        IFS="^" read -r -a routing_rules_port <<< "$m_rules_port"
        IFS="^" read -r -a routing_rules_source_port <<< "$m_rules_source_port"
        IFS="^" read -r -a routing_rules_network <<< "$m_rules_network"
        IFS="^" read -r -a routing_rules_source <<< "$m_rules_source"
        IFS="^" read -r -a routing_rules_user <<< "$m_rules_user"
        IFS="^" read -r -a routing_rules_inbound_tag <<< "$m_rules_inbound_tag"
        IFS="^" read -r -a routing_rules_protocol <<< "$m_rules_protocol"
        IFS="^" read -r -a routing_rules_attrs <<< "$m_rules_attrs"
        IFS="^" read -r -a routing_rules_outbound_tag <<< "$m_rules_outbound_tag"
        IFS="^" read -r -a routing_rules_balancer_tag <<< "$m_rules_balancer_tag"
        routing_rules_count=${#routing_rules_type[@]}
    fi

    if [ -z "$m_balancers_tag" ] 
    then
        routing_balancers_count=0
    else
        IFS="^" read -r -a routing_balancers_tag <<< "$m_balancers_tag"
        IFS="^" read -r -a routing_balancers_selector <<< "$m_balancers_selector"
        routing_balancers_count=${#routing_balancers_tag[@]}
    fi
}

V2rayListRouting()
{
    V2rayGetRouting
    if [ "$routing_rules_count" -eq 0 ] 
    then
        routing_rules_list="路由规则列表: ${red}无${normal}\n\n"
    else
        routing_rules_list="路由规则列表: \n"
        for((routing_rules_i=0;routing_rules_i<routing_rules_count;routing_rules_i++));
        do
            routing_rules_list="$routing_rules_list\n$((routing_rules_i+1)). 类型: ${green}${routing_rules_type[routing_rules_i]}${normal}\n"
            if [ -n "${routing_rules_protocol[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配入站协议: ${green}${routing_rules_protocol[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_inbound_tag[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配入站标签: ${green}${routing_rules_inbound_tag[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_outbound_tag[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配出站标签: ${green}${routing_rules_outbound_tag[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_balancer_tag[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配负载均衡器标签: ${green}${routing_rules_balancer_tag[routing_rules_i]}${normal}\n"
            fi
            routing_rules_list="$routing_rules_list匹配连接方式: ${green}${routing_rules_network[routing_rules_i]:-tcp,udp}${normal}\n"
            if [ -n "${routing_rules_domain[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配域名: ${green}${routing_rules_domain[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_source[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配来源 IP: ${green}${routing_rules_source[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_source_port[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配来源端口: ${green}${routing_rules_source_port[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_ip[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配目标 IP: ${green}${routing_rules_ip[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_port[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配目标端口: ${green}${routing_rules_port[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_user[routing_rules_i]}" ] 
            then
                routing_rules_list="$routing_rules_list匹配用户邮箱: ${green}${routing_rules_user[routing_rules_i]}${normal}\n"
            fi
            if [ -n "${routing_rules_attrs[routing_rules_i]}" ] 
            then
                routing_rules_list="${routing_rules_list}starlark 脚本: ${green}${routing_rules_attrs[routing_rules_i]}${normal}\n"
            fi
        done
    fi
    if [ "$routing_balancers_count" -eq 0 ] 
    then
        routing_balancers_list="负载均衡器列表: ${red}无${normal}\n"
    else
        routing_balancers_list="负载均衡器列表: \n\n"
        for((routing_balancers_i=0;routing_balancers_i<routing_balancers_count;routing_balancers_i++));
        do
            routing_balancers_list="$routing_balancers_list$((routing_balancers_i+1)). 负载均衡器标签: ${green}${routing_balancers_tag[routing_balancers_i]}${normal}\n"
            if [ -n "${routing_balancers_selector[routing_balancers_i]}" ] 
            then
                routing_balancers_list="$routing_balancers_list匹配出站标签字符串: ${green}${routing_balancers_selector[routing_balancers_i]//|/,}${normal}\n"
            fi
        done
    fi
    routing_list="域名解析策略: ${green}${routing_domain_strategy:-AsIs}${normal}\n\n$routing_rules_list\n$routing_balancers_list"
    Println "$routing_list\n"
}

V2raySetRouting()
{
    echo
    set_routing_options=( '添加路由规则' '添加负载均衡器' '设置域名解析策略' '删除路由规则' '删除负载均衡器' )
    inquirer list_input "选择操作" set_routing_options set_routing_option
    if [ "$set_routing_option" == "添加路由规则" ] 
    then
        echo
        add_routing_rule_options=( '快速选择入站出站' '详细设置' )
        inquirer list_input "选择添加路由方式" add_routing_rule_options add_routing_rule_option
        if [ "$add_routing_rule_option" == "快速选择入站出站" ] 
        then
            V2rayListInbounds
            V2raySelectInbound

            if [ -z "${inbounds_tag[inbounds_index]}" ] 
            then
                Println "$error 此入站没有标签\n"
                exit 1
            fi

            V2rayListOutbounds
            V2raySelectOutbound

            if [ -z "${outbounds_tag[outbounds_index]}" ] 
            then
                Println "$error 此出站没有标签\n"
                exit 1
            fi

            jq_path='["routing","rules"]'
            new_rule=$(
            $JQ_FILE -n --arg inbound_tag "${inbounds_tag[inbounds_index]}" --arg outbound_tag "${outbounds_tag[outbounds_index]}" \
            '{
                "type": "field",
                "inboundTag": [
                    $inbound_tag
                ],
                "outboundTag": $outbound_tag
            }')

            JQ add "$V2_CONFIG" "$new_rule" pre
            Println "$info 路由添加成功\n"
            return 0
        fi
        echo
        routing_rule_network_options=( 'tcp' 'udp' 'tcp,udp' )
        inquirer list_input "选择匹配的连接方式: " routing_rule_network_options routing_rule_network
        new_routing_rule=$(
        $JQ_FILE -n --arg network "$routing_rule_network" \
        '{
            "type": "field",
            "network": $network
        }')
        Println "$tip 多个域名用空格分隔, 格式如 127.0.0.1, 10.0.0.0/8, geoip:cn, geoip:private, ext:file:tag"
        inquirer text_input "输入匹配的域名: " routing_rule_domain "不设置"
        if [ "$routing_rule_domain" != "不设置" ] 
        then
            IFS=" " read -r -a domains <<< "$routing_rule_domain"
            printf -v routing_rule_domain ',"%s"' "${domains[@]}"
            routing_rule_domain=${routing_rule_domain:1}
            new_routing_rule=$(
            $JQ_FILE --argjson domain "[$routing_rule_domain]" \
            '. * 
            {
                "domain": $domain
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 多个 IP 范围用空格分隔"
        inquirer text_input "输入匹配的 IP 范围: " routing_rule_ip "不设置"
        if [ "$routing_rule_ip" != "不设置" ] 
        then
            IFS=" " read -r -a ips <<< "$routing_rule_ip"
            printf -v routing_rule_ip ',"%s"' "${ips[@]}"
            routing_rule_ip=${routing_rule_ip:1}
            new_routing_rule=$(
            $JQ_FILE --argjson ip "[$routing_rule_ip]" \
            '. * 
            {
                "ip": $ip
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 多个端口用空格分隔, 格式如 53 443 1000-2000"
        inquirer text_input "输入目标端口范围: " routing_rule_port "不设置"
        if [ "$routing_rule_port" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg port "${routing_rule_port// /,}" \
            '. * 
            {
                "port": $port
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 多个端口用空格分隔, 格式如 53 443 1000-2000"
        inquirer text_input "输入来源端口范围: " routing_rule_source_port "不设置"
        if [ "$routing_rule_source_port" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg sourcePort "${routing_rule_source_port// /,}" \
            '. * 
            {
                "sourcePort": $sourcePort
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 多个 IP 用空格分隔, 格式如 127.0.0.1, 10.0.0.0/8"
        inquirer text_input "输入匹配的来源 IP: " routing_rule_source "不设置"
        if [ "$routing_rule_source" != "不设置" ] 
        then
            IFS=" " read -r -a sources <<< "$routing_rule_source"
            printf -v routing_rule_source ',"%s"' "${sources[@]}"
            routing_rule_source=${routing_rule_source:1}
            new_routing_rule=$(
            $JQ_FILE --argjson routing_rule_source "[$routing_rule_source]" \
            '. * 
            {
                "source": $routing_rule_source
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 多个邮箱地址用空格分隔, Shadowsocks 和 VMess 支持此规则"
        inquirer text_input "输入匹配的邮箱地址: " routing_rule_user "不设置"
        if [ "$routing_rule_user" != "不设置" ] 
        then
            IFS=" " read -r -a users <<< "$routing_rule_user"
            printf -v routing_rule_user ',"%s"' "${users[@]}"
            routing_rule_user=${routing_rule_user:1}
            new_routing_rule=$(
            $JQ_FILE --argjson user "[$routing_rule_user]" \
            '. * 
            {
                "user": $user
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 可多选, 必须开启入站代理中的流量探测选项"
        routing_rule_protocols=( 'http' 'tls' 'bittorrent' )
        set +u
        inquirer checkbox_input "选择匹配的协议: " routing_rule_protocols routing_rule_protocols_selected
        set -u
        if [ -n "${routing_rule_protocols_selected:-}" ] 
        then
            printf -v routing_rule_protocol ',"%s"' "${routing_rule_protocols_selected[@]}"
            routing_rule_protocol=${routing_rule_protocol:1}
            new_routing_rule=$(
            $JQ_FILE --argjson protocol "[$routing_rule_protocol]" \
            '. * 
            {
                "protocol": $protocol
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 用于检测流量的属性值, 目前只有 http 入站代理会设置这一属性"
        inquirer text_input "输入 starlark 脚本: " routing_rule_attrs "不设置"
        if [ "$routing_rule_attrs" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg attrs "$routing_rule_attrs" \
            '. * 
            {
                "attrs": $attrs
            }' <<< "$new_routing_rule")
        fi
        echo
        inquirer text_input "输入匹配的入站标签: " routing_rule_inbound_tag "不设置"
        if [ "$routing_rule_inbound_tag" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg inboundTag "$routing_rule_inbound_tag" \
            '. * 
            {
                "inboundTag": [$inboundTag]
            }' <<< "$new_routing_rule")
        fi
        Println "$tip 出站标签 和 负载均衡器标签 须二选一, 同时指定时, 出站标签 生效"
        inquirer text_input "输入对应的出站标签: " routing_rule_outbound_tag "不设置"
        if [ "$routing_rule_outbound_tag" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg outboundTag "$routing_rule_outbound_tag" \
            '. * 
            {
                "outboundTag": $outboundTag
            }' <<< "$new_routing_rule")
        fi
        echo
        inquirer text_input "输入对应的负载均衡器标签: " routing_rule_balancer_tag "不设置"
        if [ "$routing_rule_balancer_tag" != "不设置" ] 
        then
            new_routing_rule=$(
            $JQ_FILE --arg balancerTag "$routing_rule_balancer_tag" \
            '. * 
            {
                "balancerTag": $balancerTag
            }' <<< "$new_routing_rule")
        fi
        jq_path='["routing","rules"]'
        JQ add "$V2_CONFIG" "$new_routing_rule" pre
        Println "$info 路由规则添加成功\n"
    elif [ "$set_routing_option" == "添加负载均衡器" ] 
    then
        Println "$tip 用于匹配路由规则"
        inquirer text_input "输入负载均衡器标签: " routing_balancer_tag "$i18n_cancel"
        ExitOnCancel routing_balancer_tag
        new_routing_balancer=$(
        $JQ_FILE --arg tag "$routing_balancer_tag" \
        '. * 
        {
            "tag": $tag
        }')
        Println "$tip 多个字符串用空格分隔"
        inquirer text_input "输入匹配出站标签字符串: " routing_balancer_selector "不设置"
        if [ "$routing_balancer_selector" != "不设置" ] 
        then
            IFS=" " read -r -a selectors <<< "$routing_balancer_selector"
            printf -v routing_balancer_selector ',"%s"' "${selectors[@]}"
            routing_balancer_selector=${routing_balancer_selector:1}
            new_routing_balancer=$(
            $JQ_FILE --argjson selector "[$routing_balancer_selector]" \
            '. * 
            {
                "selector": $selector
            }' <<< "$new_routing_balancer")
        fi
        jq_path='["routing","balancers"]'
        JQ add "$V2_CONFIG" "$new_routing_balancer"
        Println "$info 负载均衡器添加成功\n"
    elif [ "$set_routing_option" == "设置域名解析策略" ] 
    then
        echo
        routing_domain_strategy_options=( 'AsIs' 'IPIfNonMatch' 'IPOnDemand' )
        inquirer list_input "域名解析策略" routing_domain_strategy_options routing_domain_strategy
        jq_path='["routing","domainStrategy"]'
        JQ replace "$V2_CONFIG" \""$routing_domain_strategy"\"
        Println "$info 域名解析策略设置成功\n"
    elif [ "$set_routing_option" == "删除路由规则" ] 
    then
        V2rayListRouting
        [ "$routing_rules_count" -eq 0 ] && exit 1
        echo
        inquirer text_input "输入路由规则序号: " routing_rule_num "$i18n_cancel"
        ExitOnCancel routing_rule_num
        routing_rule_index=$((routing_rule_num-1))
        jq_path='["routing","rules"]'
        JQ delete "$V2_CONFIG" "$routing_rule_index"
        Println "$info 路由规则删除成功\n"
    else
        V2rayListRouting
        [ "$routing_balancers_count" -eq 0 ] && exit 1
        echo
        inquirer text_input "输入负载均衡器序号: " routing_balancer_num "$i18n_cancel"
        ExitOnCancel routing_balancer_num
        routing_balancer_index=$((routing_balancer_num-1))
        jq_path='["routing","balancers"]'
        JQ delete "$V2_CONFIG" "$routing_balancer_index"
        Println "$info 负载均衡器删除成功\n"
    fi
}

V2rayGetPolicy()
{
    IFS=$'`\t' read -r m_levels_id m_levels_handshake m_levels_conn_idle m_levels_uplink_only \
    m_levels_downlink_only m_levels_stats_user_uplink m_levels_stats_user_downlink \
    m_levels_buffer_size policy_system_stats_inbound_uplink policy_system_stats_inbound_downlink \
    policy_system_stats_outbound_uplink policy_system_stats_outbound_downlink < <($JQ_FILE -r '[
    ([.policy.levels // {}|to_entries[]|.key|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.handshake // 4|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.connIdle // 300|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.uplinkOnly // 2|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.downlinkOnly // 5|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.statsUserUplink // false|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.statsUserDownlink // false|tostring|. + "^"]|join("") + "`"),
    ([.policy.levels // {}|to_entries[]|.value.bufferSize // 512|tostring|. + "^"]|join("") + "`"),
    (.policy.system.statsInboundUplink // false|tostring|. + "`"),
    (.policy.system.statsInboundDownlink // false|tostring|. + "`"),
    (.policy.system.statsOutboundUplink // false|tostring|. + "`"),
    (.policy.system.statsOutboundDownlink // false|tostring|. + "`")]|@tsv' "$V2_CONFIG")

    if [ -n "$m_levels_id" ] 
    then
        IFS="^" read -r -a policy_levels_id <<< "$m_levels_id"
        policy_levels_count=${#policy_levels_id[@]}

        if_null=""

        for((policy_levels_i=0;policy_levels_i<policy_levels_count;policy_levels_i++));
        do
            if_null="$if_null^"
        done

        IFS="^" read -r -a policy_levels_handshake <<< "${m_levels_handshake:-$if_null}"
        IFS="^" read -r -a policy_levels_conn_idle <<< "${m_levels_conn_idle:-$if_null}"
        IFS="^" read -r -a policy_levels_uplink_only <<< "${m_levels_uplink_only:-$if_null}"
        IFS="^" read -r -a policy_levels_downlink_only <<< "${m_levels_downlink_only:-$if_null}"
        IFS="^" read -r -a policy_levels_stats_user_uplink <<< "${m_levels_stats_user_uplink:-$if_null}"
        IFS="^" read -r -a policy_levels_stats_user_downlink <<< "${m_levels_stats_user_downlink:-$if_null}"
        IFS="^" read -r -a policy_levels_buffer_size <<< "${m_levels_buffer_size:-$if_null}"
    else
        policy_levels_count=0
    fi
}

V2rayListPolicy()
{
    V2rayGetPolicy

    if [ "$policy_levels_count" -eq 0 ] 
    then
        default_levels='{
            "levels": {
                "0": {
                    "handshake": 4,
                    "connIdle": 300,
                    "uplinkOnly": 2,
                    "downlinkOnly": 5,
                    "statsUserUplink": false,
                    "statsUserDownlink": false,
                    "bufferSize": 512
                }
            },
            "system": {
                "statsInboundUplink": false,
                "statsInboundDownlink": false,
                "statsOutboundUplink": false,
                "statsOutboundDownlink": false
            }
        }'
        jq_path='["policy"]'
        JQ replace "$V2_CONFIG" "$default_levels"
        jq_path='["PolicyObject"]'
        JQ delete "$V2_CONFIG"
        V2rayGetPolicy
    fi

    levels_list="=== 用户等级数 ${green} $policy_levels_count ${normal}\n\n"
    for((i=0;i<policy_levels_count;i++));
    do
        if [ "${policy_levels_stats_user_uplink[i]}" == "true" ] 
        then
            policy_levels_stats_user_uplink_list="上行流量统计: ${green}是${normal}\n${indent_6}"
        else
            policy_levels_stats_user_uplink_list="上行流量统计: ${red}否${normal}\n${indent_6}"
        fi
        if [ "${policy_levels_stats_user_downlink[i]}" == "true" ] 
        then
            policy_levels_stats_user_downlink_list="下行流量统计: ${green}是${normal}\n${indent_6}"
        else
            policy_levels_stats_user_downlink_list="下行流量统计: ${red}否${normal}\n${indent_6}"
        fi
        levels_list="$levels_list# ${green}$((i+1))${normal}${indent_6}等级: ${green}${policy_levels_id[i]}${normal}\n${indent_6}握手时间限制: ${green}${policy_levels_handshake[i]}${normal} 秒\n${indent_6}连接空闲的时间限制: ${green}${policy_levels_conn_idle[i]}${normal} 秒\n${indent_6}出站代理时间限制: ${green}${policy_levels_uplink_only[i]}${normal} 秒\n${indent_6}入站代理时间限制: ${green}${policy_levels_downlink_only[i]}${normal} 秒\n${indent_6}缓存大小: ${green}${policy_levels_buffer_size[i]}${normal} kB\n${indent_6}$policy_levels_stats_user_uplink_list$policy_levels_stats_user_downlink_list\n\n"
    done

    if [ "$policy_system_stats_inbound_uplink" == "false" ] 
    then
        system_list="入站上行流量统计: ${red}否${normal}\n\n"
    else
        system_list="入站上行流量统计: ${green}是${normal}\n\n"
    fi

    if [ "$policy_system_stats_inbound_downlink" == "false" ] 
    then
        system_list="$system_list入站下行流量统计: ${red}否${normal}\n\n"
    else
        system_list="$system_list入站下行流量统计: ${green}是${normal}\n\n"
    fi

    if [ "$policy_system_stats_outbound_uplink" == "false" ] 
    then
        system_list="$system_list出站上行流量统计: ${red}否${normal}\n\n"
    else
        system_list="$system_list出站上行流量统计: ${green}是${normal}\n\n"
    fi

    if [ "$policy_system_stats_outbound_downlink" == "false" ] 
    then
        system_list="$system_list出站下行流量统计: ${red}否${normal}\n\n"
    else
        system_list="$system_list出站下行流量统计: ${green}是${normal}\n\n"
    fi

    policy_list="$levels_list$system_list"

    Println "$policy_list"
}

V2raySetPolicy()
{
    V2rayListPolicy
    yn_options=( '开启' '关闭' )
    echo
    set_policy_options=( '添加策略等级' '开关入站上行流量统计' '开关入站下行流量统计' '开关出站上行流量统计' '开关出站下行流量统计' '删除策略等级' )
    inquirer list_input "选择操作" set_policy_options set_policy_option
    echo
    if [ "$set_policy_option" == "添加策略等级" ] 
    then
        inquirer text_input "输入新的用户等级(数字): " policy_level_id "自动"
        if [ "$policy_level_id" == "自动" ] 
        then
            for((policy_level_id=0;policy_level_id<$((policy_levels_count+1));policy_level_id++));
            do
                policy_level_id_found=0
                for level_id in "${policy_levels_id[@]}"
                do
                    if [ "$level_id" -eq "$policy_level_id" ] 
                    then
                        policy_level_id_found=1
                        break
                    fi
                done
                if [ "$policy_level_id_found" -eq 0 ] 
                then
                    break
                fi
            done
            Println "$info 用户等级: ${green}$policy_level_id${normal}"
        elif [[ ! $policy_level_id =~ ^[0-9]+$ ]] 
        then
            Println "$error 必须是数字\n"
            exit 1
        else
            policy_level_id_found=0
            for level_id in "${policy_levels_id[@]}"
            do
                if [ "$level_id" -eq "$policy_level_id" ] 
                then
                    policy_level_id_found=1
                    break
                fi
            done
            if [ "$policy_level_id_found" -eq 1 ] 
            then
                Println "$error 等级 $policy_level_id 已经存在\n"
                exit 1
            fi
        fi
        echo
        inquirer text_input "入站握手时间限制: " policy_level_handshake 4
        echo
        inquirer text_input "入站出站连接空闲的时间限制: " policy_level_conn_idle 300
        echo
        inquirer text_input "出站线路关闭后的时间限制: " policy_level_uplink_only 2
        echo
        inquirer text_input "入站线路关闭后的时间限制: " policy_level_downlink_only 300
        echo
        inquirer text_input "每个连接的缓存大小: " policy_level_buffer_size 512
        echo
        inquirer list_input "当前等级的所有用户的上行流量统计" yn_options policy_level_stats_user_uplink
        if [ "$policy_level_stats_user_uplink" == "开启" ] 
        then
            policy_level_stats_user_uplink="true"
        else
            policy_level_stats_user_uplink="false"
        fi
        echo
        inquirer list_input "当前等级的所有用户的上行流量统计" yn_options policy_level_stats_user_downlink
        if [ "$policy_level_stats_user_downlink" == "开启" ] 
        then
            policy_level_stats_user_downlink="true"
        else
            policy_level_stats_user_downlink="false"
        fi
        new_policy_level=$(
        $JQ_FILE -n --arg handshake "$policy_level_handshake" --arg connIdle "$policy_level_conn_idle" \
        --arg uplinkOnly "$policy_level_uplink_only" --arg downlinkOnly "$policy_level_downlink_only" \
        --arg statsUserUplink "$policy_level_stats_user_uplink" --arg statsUserDownlink "$policy_level_stats_user_downlink" \
        --arg bufferSize "$policy_level_buffer_size" \
        '{
            "handshake": $handshake | tonumber,
            "connIdle": $connIdle | tonumber,
            "uplinkOnly": $uplinkOnly | tonumber,
            "downlinkOnly": $downlinkOnly | tonumber,
            "statsUserUplink": $statsUserUplink | test("true"),
            "statsUserDownlink": $statsUserDownlink | test("true"),
            "bufferSize": $bufferSize | tonumber
        }')
        jq_path='["policy","levels",'"$policy_level_id"']'
        JQ replace "$V2_CONFIG" "$new_policy_level"
        Println "$info 策略等级添加成功\n"
    elif [ "$set_policy_option" == "开关入站上行流量统计" ] 
    then
        inquirer list_input "所有入站代理的上行流量统计" yn_options policy_system_stats_inbound_uplink
        if [ "$policy_system_stats_inbound_uplink" == "开启" ] 
        then
            policy_system_stats_inbound_uplink="true"
        else
            policy_system_stats_inbound_uplink="false"
        fi
        JQ update "$V2_CONFIG" '.policy.system.statsInboundUplink='"$policy_system_stats_inbound_uplink"''
        Println "$info 入站上行流量统计设置成功\n"
    elif [ "$set_policy_option" == "开关入站下行流量统计" ] 
    then
        inquirer list_input "所有入站代理的下行流量统计" yn_options policy_system_stats_inbound_downlink
        if [ "$policy_system_stats_inbound_downlink" == "开启" ] 
        then
            policy_system_stats_inbound_downlink="true"
        else
            policy_system_stats_inbound_downlink="false"
        fi
        JQ update "$V2_CONFIG" '.policy.system.statsInboundDownlink='"$policy_system_stats_inbound_downlink"''
        Println "$info 入站下行流量统计设置成功\n"
    elif [ "$set_policy_option" == "开关出站上行流量统计" ] 
    then
        inquirer list_input "所有出站代理的上行流量统计" yn_options policy_system_stats_outbound_uplink
        if [ "$policy_system_stats_outbound_uplink" == "开启" ] 
        then
            policy_system_stats_outbound_uplink="true"
        else
            policy_system_stats_outbound_uplink="false"
        fi
        JQ update "$V2_CONFIG" '.policy.system.statsOutboundUplink='"$policy_system_stats_outbound_uplink"''
        Println "$info 出站上行流量统计设置成功\n"
    else
        inquirer list_input "所有出站代理的下行流量统计" yn_options policy_system_stats_outbound_downlink
        if [ "$policy_system_stats_outbound_downlink" == "开启" ] 
        then
            policy_system_stats_outbound_downlink="true"
        else
            policy_system_stats_outbound_downlink="false"
        fi
        JQ update "$V2_CONFIG" '.policy.system.statsOutboundDownlink='"$policy_system_stats_outbound_downlink"''
        Println "$info 出站下行流量统计设置成功\n"
    fi
}

V2rayGetReverse()
{
    IFS=$'`\t' read -r m_reverse_bridges_tag m_reverse_bridges_domain m_reverse_portals_tag \
    m_reverse_portals_domain < <($JQ_FILE -r '[
        ([.reverse.bridges // []|.[].tag]|join("^") + "`"),
        ([.reverse.bridges // []|.[].domain]|join("^") + "`"),
        ([.reverse.portals // []|.[].tag]|join("^") + "`"),
        ([.reverse.portals // []|.[].domain]|join("^") + "`")
    ]|@tsv' "$V2_CONFIG")

    if [ -z "$m_reverse_bridges_tag" ] 
    then
        reverse_bridges_count=0
    else
        IFS="^" read -r -a reverse_bridges_tag <<< "$m_reverse_bridges_tag"
        IFS="^" read -r -a reverse_bridges_domain <<< "$m_reverse_bridges_domain"
        reverse_bridges_count=${#reverse_bridges_tag[@]}
    fi

    if [ -z "$m_reverse_portals_tag" ] 
    then
        reverse_portals_count=0
    else
        IFS="^" read -r -a reverse_portals_tag <<< "$m_reverse_portals_tag"
        IFS="^" read -r -a reverse_portals_domain <<< "$m_reverse_portals_domain"
        reverse_portals_count=${#reverse_portals_tag[@]}
    fi
}

V2rayListReverse()
{
    V2rayGetReverse

    if [ "$reverse_bridges_count" -eq 0 ] 
    then
        reverse_bridges_list="bridge 列表: ${red}无${normal}\n\n"
    else
        reverse_bridges_list="bridge 列表:\n\n"
        for((reverse_bridges_i=0;reverse_bridges_i<reverse_bridges_count;reverse_bridges_i++));
        do
            reverse_bridges_list="$reverse_bridges_list$((reverse_bridges_i+1)). 标签: ${green}${reverse_bridges_tag[reverse_bridges_i]}${normal} 域名: ${green}${reverse_bridges_domain[reverse_bridges_i]}${normal}\n"
        done
    fi

    if [ "$reverse_portals_count" -eq 0 ] 
    then
        reverse_portals_list="portal 列表: ${red}无${normal}\n\n"
    else
        reverse_portals_list="portal 列表:\n\n"
        for((reverse_portals_i=0;reverse_portals_i<reverse_portals_count;reverse_portals_i++));
        do
            reverse_portals_list="$reverse_portals_list$((reverse_portals_i+1)). 标签: ${green}${reverse_portals_tag[reverse_portals_i]}${normal} 域名: ${green}${reverse_portals_domain[reverse_portals_i]}${normal}\n"
        done
    fi

    reverse_list="$reverse_bridges_list\n$reverse_portals_list"

    Println "$reverse_list"
}

V2raySetReverse()
{
    echo
    set_reverse_options=( '添加 bridge' '添加 portal' '删除 bridge' '删除 portal' )
    inquirer list_input "选择操作" set_reverse_options set_reverse_option
    if [ "$set_reverse_option" == "添加 bridge" ] 
    then
        echo
        inquirer text_input "输入标签: " reverse_bridge_tag "$i18n_cancel"
        ExitOnCancel reverse_bridge_tag
        echo
        inquirer text_input "输入域名: " reverse_bridge_domain "$i18n_cancel"
        ExitOnCancel reverse_bridge_domain
        new_reverse_bridge=(
        $JQ_FILE -n --arg tag "reverse_bridge_tag" --arg domain "$reverse_bridge_domain" \
        '{
            "tag": $tag,
            "domain": $domain
        }')
        jq_path='["reverse","bridges"]'
        JQ add "$V2_CONFIG" "$new_reverse_bridge"
        Println "$info bridge 添加成功\n"
    elif [ "$set_reverse_option" == "添加 portal" ] 
    then
        echo
        inquirer text_input "输入标签: " reverse_portal_tag "$i18n_cancel"
        ExitOnCancel reverse_portal_tag
        echo
        inquirer text_input "输入域名: " reverse_portal_domain "$i18n_cancel"
        ExitOnCancel reverse_portal_domain
        new_reverse_portal=(
        $JQ_FILE -n --arg tag "reverse_portal_tag" --arg domain "$reverse_portal_domain" \
        '{
            "tag": $tag,
            "domain": $domain
        }')
        jq_path='["reverse","portals"]'
        JQ add "$V2_CONFIG" "$new_reverse_portal"
        Println "$info portal 添加成功\n"
    elif [ "$set_reverse_option" == "删除 bridge" ] 
    then
        V2rayListReverse
        [ "$reverse_bridges_count" -eq 0 ] && exit 1
        inquirer text_input "输入 bridge 序号: " reverse_bridge_num "$i18n_cancel"
        ExitOnCancel reverse_bridge_num
        reverse_bridge_index=$((reverse_bridge_num-1))
        jq_path='["reverse","bridges"]'
        JQ delete "$V2_CONFIG" "$reverse_bridge_index"
        Println "$info bridge 删除成功\n"
    else
        V2rayListReverse
        [ "$reverse_portals_count" -eq 0 ] && exit 1
        inquirer text_input "输入 portal 序号: " reverse_portal_num "$i18n_cancel"
        ExitOnCancel reverse_portal_num
        reverse_portal_index=$((reverse_portal_num-1))
        jq_path='["reverse","portals"]'
        JQ delete "$V2_CONFIG" "$reverse_portal_index"
        Println "$info portal 删除成功\n"
    fi
}

V2rayGetDns()
{
    IFS=$'`\t' read -r m_dns_hosts_domain m_dns_hosts_address m_dns_servers \
    dns_client_ip dns_tag < <($JQ_FILE -r '[
    ([.dns.hosts // {}|to_entries[]|.key|. + "^"]|join("") + "`"),
    ([.dns.hosts // {}|to_entries[]|.value|. + "^"]|join("") + "`"),
    ([.dns.servers // []|.[]|if (.|type) == "object" then 
        ([
            .address,
            (.port // ""|tostring),
            (.domains // []|join(",")),
            (.expectIPs // []|join(","))
        ]|join("|"))
    else 
        . end|. + "^"]|join("") + "`"),
    (.dns.clientIp|. + "`"),
    (.dns.tag|. + "`")]|@tsv' "$V2_CONFIG")

    if [ -z "$m_dns_hosts_domain" ] 
    then
        dns_hosts_count=0
    else
        IFS="^" read -r -a dns_hosts_domain <<< "$m_dns_hosts_domain"
        IFS="^" read -r -a dns_hosts_address <<< "$m_dns_hosts_address"
        dns_hosts_count=${#dns_hosts_domain[@]}
    fi

    if [ -z "$m_dns_servers" ] 
    then
        dns_servers_count=0
    else
        IFS="^" read -r -a dns_servers <<< "$m_dns_servers"
        dns_servers_count=${#dns_servers[@]}
    fi
}

V2rayListDns()
{
    V2rayGetDns
    if [ "$dns_hosts_count" -eq 0 ] 
    then
        dns_hosts_list="静态 IP 列表: ${red}无${normal}\n"
    else
        dns_hosts_list="静态 IP 列表: \n${indent_6}"
        for((dns_hosts_i=0;dns_hosts_i<dns_hosts_count;dns_hosts_i++));
        do
            dns_hosts_list="$dns_hosts_list$((dns_hosts_i+1)). 域名: ${green}${dns_hosts_domain[dns_hosts_i]}${normal} 地址: ${green}${dns_hosts_address[dns_hosts_i]}${normal}\n${indent_6}"
        done
    fi
    if [ "$dns_servers_count" -eq 0 ] 
    then
        dns_servers_list="DNS 服务器列表: ${red}无${normal}\n"
    else
        dns_servers_list="DNS 服务器列表: \n\n"
        for((dns_servers_i=0;dns_servers_i<dns_servers_count;dns_servers_i++));
        do
            if [[ ${dns_servers[dns_servers_i]} =~ ^(.+)\|(.*)\|(.*)\|(.*)$ ]] 
            then
                if [ -z "${BASH_REMATCH[3]}" ] 
                then
                    dns_server_domain_list="使用的域名: ${red}未设置${normal}\n${indent_6}"
                else
                    dns_server_domain_list="使用的域名: ${green}${BASH_REMATCH[3]}${normal}\n${indent_6}"
                fi
                if [ -z "${BASH_REMATCH[4]}" ] 
                then
                    dns_server_expect_ips_list="IP 范围: ${red}未设置${normal}\n${indent_6}"
                else
                    dns_server_expect_ips_list="IP 范围: ${green}${BASH_REMATCH[4]}${normal}\n${indent_6}"
                fi
                dns_servers_list="$dns_servers_list$((dns_servers_i+1)).${indent_6}服务器地址: ${green}${BASH_REMATCH[1]}${normal} 端口: ${green}${BASH_REMATCH[2]:-53}${normal}\n${indent_6}$dns_server_domain_list$dns_server_expect_ips_list"
            else
                dns_servers_list="$dns_servers_list$((dns_servers_i+1)).${indent_6}服务器地址: ${green}${dns_servers[dns_servers_i]}${normal} 端口: ${green}53${normal}\n${indent_6}"
            fi
        done
    fi
    if [ -z "$dns_client_ip" ] 
    then
        dns_list="用于 dns 查询 IP: ${red}${dns_client_ip:-未设置}${normal}\n"
    else
        dns_list="用于 dns 查询 IP: ${green}${dns_client_ip:-未设置}${normal}\n"
    fi
    dns_list="$dns_list\n$dns_hosts_list\n$dns_servers_list"
    Println "$dns_list\n"
}

V2raySetDns()
{
    echo
    set_dns_options=( '添加静态 IP' '添加 dns 服务器' '设置用于 dns 查询的 IP 地址' '设置 dns 标签' '删除静态 IP' '删除 dns 服务器' )
    inquirer list_input "选择操作" set_dns_options set_dns_option
    if [ "$set_dns_option" == "添加静态 IP" ] 
    then
        Println "$tip 格式如 v2ray.com, regexp:xxx, domain:xxx, keyword:xxx, geosite:cn"
        inquirer text_input "输入域名" hosts_domain "$i18n_cancel"
        ExitOnCancel hosts_domain
        Println "$tip 格式如 127.0.0.1, v2ray.com, regexp:xxx, domain:xxx, keyword:xxx, geosite:cn"
        inquirer text_input "输入地址" hosts_address "$i18n_cancel"
        ExitOnCancel hosts_address
        jq_path='["dns","hosts","'"$hosts_domain"'"]'
        JQ replace "$V2_CONFIG" \""$hosts_address"\"
        Println "$info 静态 IP 添加成功\n"
    elif [ "$set_dns_option" == "添加 dns 服务器" ] 
    then
        Println "$tip 格式如: localhost, 8.8.8.8, https://host:port/dns-query, https+local://host:port/dns-query"
        inquirer text_input "输入服务器地址: " dns_server_address "$i18n_cancel"
        ExitOnCancel dns_server_address
        if [ "$dns_server_address" == "localhost" ] || [[ $dns_server_address =~ ^http ]]
        then
            jq_path='["dns","servers"]'
            JQ add "$V2_CONFIG" \""$dns_server_address"\"
            Println "$info dns 服务器添加成功\n"
            return 0
        fi
        echo
        inquirer text_input "输入服务器端口: " dns_server_port 53
        Println "$tip 用于 DNS 查询时通知 DNS 服务器, 客户端所在的地理位置"
        inquirer text_input "输入通知 DNS 的 IP 地址: " dns_server_client_ip "不设置"
        if [ "$dns_server_client_ip" == "不设置" ] 
        then
            dns_server_client_ip=""
        fi
        Println "$tip 优先使用此服务器进行查询, 多个域名用空格分隔, 格式和路由配置中相同"
        inquirer text_input "输入域名: " dns_server_domain "不设置"
        if [ "$dns_server_domain" == "不设置" ] 
        then
            dns_server_domain=""
        fi
        Println "$tip 当配置此项时, $v2ray_name DNS 会对返回的 IP 的进行校验, 只返回包含列表中的地址, 多个 IP 范围用空格分隔, 格式和路由配置中相同"
        inquirer text_input "输入 IP 范围: " dns_server_expect_ips "不设置"
        if [ "$dns_server_expect_ips" == "不设置" ] 
        then
            dns_server_expect_ips=""
        fi
        if [ -z "$dns_server_client_ip" ] && [ -z "$dns_server_domain" ] && [ -z "$dns_server_expect_ips" ] && [ "$dns_server_port" -eq 53 ]
        then
            jq_path='["dns","servers"]'
            JQ add "$V2_CONFIG" \""$dns_server_address"\"
            Println "$info dns 服务器添加成功\n"
            return 0
        fi
        new_dns_server=$(
        $JQ_FILE -n --arg address "$dns_server_address" --arg port "$dns_server_port" \
        '{
            "address": $address,
            "port": $port | tonumber
        }')
        if [ -n "$dns_server_client_ip" ] 
        then
            new_dns_server=$(
            $JQ_FILE --arg clientIp "$dns_server_client_ip" \
            '. * 
            {
                "clientIp": $clientIp
            }' <<< "$new_dns_server")
        fi
        if [ -n "$dns_server_domain" ] 
        then
            IFS=" " read -r -a domains <<< "$dns_server_domain"
            printf -v dns_server_domain ',"%s"' "${domains[@]}"
            dns_server_domain=${dns_server_domain:1}
            new_dns_server=$(
            $JQ_FILE --argjson domains "[$dns_server_domain]" \
            '. * 
            {
                "domains": $domains
            }' <<< "$new_dns_server")
        fi
        if [ -n "$dns_server_expect_ips" ] 
        then
            IFS=" " read -r -a expect_ips <<< "$dns_server_expect_ips"
            printf -v dns_server_expect_ips ',"%s"' "${expect_ips[@]}"
            dns_server_expect_ips=${dns_server_expect_ips:1}
            new_dns_server=$(
            $JQ_FILE --argjson expectIPs "[$dns_server_expect_ips]" \
            '. * 
            {
                "expectIPs": $expectIPs
            }' <<< "$new_dns_server")
        fi
        jq_path='["dns","servers"]'
        JQ add "$V2_CONFIG" \""$new_dns_server"\"
        Println "$info dns 服务器添加成功\n"
    elif [ "$set_dns_option" == "设置用于 dns 查询的 IP 地址" ] 
    then
        Println "$tip 用于 DNS 查询时通知服务器客户端的所在位置, 不能是私有地址"
        inquirer text_input "输入 IP 地址: " dns_client_ip "$i18n_cancel"
        ExitOnCancel dns_client_ip
        jq_path='["dns","clientIp"]'
        JQ replace "$V2_CONFIG" \""$dns_client_ip"\"
        Println "$info IP 地址设置成功\n"
    elif [ "$set_dns_option" == "设置 dns 标签" ] 
    then
        Println "$tip 可在路由使用 inboundTag 进行匹配"
        inquirer text_input "输入 dns 标签: " dns_tag "$i18n_cancel"
        ExitOnCancel dns_tag
        jq_path='["dns","tag"]'
        JQ replace "$V2_CONFIG" \""$dns_tag"\"
        Println "$info dns 标签设置成功\n"
    elif [ "$set_dns_option" == "删除静态 IP" ] 
    then
        V2rayListDns
        [ "$dns_hosts_count" -eq 0 ] && exit 1
        echo
        inquirer text_input "输入静态 IP 序号: " dns_host_num "$i18n_cancel"
        ExitOnCancel dns_host_num
        dns_host_index=$((dns_host_num-1))
        jq_path='["dns","hosts","'"${dns_hosts_domain[dns_host_index]}"'"]'
        JQ delete "$V2_CONFIG"
        Println "$info 静态 IP: ${dns_hosts_domain[dns_host_index]} => ${dns_hosts_address[dns_host_index]} 删除成功\n"
    else
        V2rayListDns
        [ "$dns_servers_count" -eq 0 ] && exit 1
        echo
        inquirer text_input "输入 dns 服务器序号: " dns_server_num "$i18n_cancel"
        ExitOnCancel dns_server_num
        dns_server_index=$((dns_server_num-1))
        jq_path='["dns","servers"]'
        JQ delete "$V2_CONFIG" "$dns_server_index"
        if [[ ${dns_servers[dns_server_index]} =~ ^(.+)\|(.*)\|(.*)\|(.*)$ ]] 
        then
            Println "$info dns 服务器: ${BASH_REMATCH[1]}:${BASH_REMATCH[2]:-53} 删除成功\n"
        fi
    fi
}

V2rayGetStats()
{
    IFS=$'`\t' read -r api_tag m_api_services < <($JQ_FILE -r '[(.api.tag + "`"),
    (.api.services // []|join("|") + "`")]|@tsv' "$V2_CONFIG")

    if [ -z "$api_tag" ] || [ -z "$m_api_services" ]
    then
        jq_path='["stats"]'
        JQ replace "$V2_CONFIG" "{}"
        api='{
            "tag": "api",
            "services": [
                "StatsService"
            ]
        }'
        jq_path='["api"]'
        JQ replace "$V2_CONFIG" "$api"
        if [ -z "$api_tag" ] 
        then
            api_tag="api"
        fi
    else
        IFS="|" read -r -a api_services <<< "$m_api_services"
        stats_service_found=0
        for api_service in "${api_services[@]}"
        do
            if [ "$api_service" == "StatsService" ] 
            then
                stats_service_found=1
                break
            fi
        done
        if [ "$stats_service_found" -eq 0 ] 
        then
            jq_path='["api","services"]'
            JQ add "$V2_CONFIG" "StatsService"
        fi
    fi

    V2rayGetRouting

    if [ "$routing_rules_count" -eq 0 ] 
    then
        Println "$error 请先添加一个路由: 入站协议为 dokodemo-door (需要创建此协议的入站), 出站标签是 $api_tag (不用创建出站)\n"
        exit 1
    else
        routing_rule_found=0
        for((i=0;i<routing_rules_count;i++));
        do
            if [ -n "${routing_rules_outbound_tag[i]}" ] 
            then
                IFS="|" read -r -a outbound_tags <<< "${routing_rules_outbound_tag[i]}"
                for outbound_tag in "${outbound_tags[@]}"
                do
                    if [ "$outbound_tag" == "$api_tag" ] 
                    then
                        routing_rule_found=1
                        api_inbound_tag=${routing_rules_inbound_tag[i]}
                        break 2
                    fi
                done
            fi
        done
        if [ "$routing_rule_found" -eq 0 ] || [ -z "${api_inbound_tag:-}" ]
        then
            Println "$error 请先添加协议为 dokodemo-door 的入站路由到标签是 $api_tag 的出站\n"
            exit 1
        fi
    fi

    V2rayListPolicy
    V2rayGetInbounds

    for((i=0;i<inbounds_count;i++));
    do
        if [ "${inbounds_tag[i]}" == "$api_inbound_tag" ] 
        then
            if [ "${inbounds_listen[i]}" == "0.0.0.0" ] 
            then
                api_inbound_listen="127.0.0.1"
            else
                api_inbound_listen=${inbounds_listen[i]}
            fi
            api_inbound_port=${inbounds_port[i]}
            break
        fi
    done

    if [ -z "${api_inbound_listen:-}" ] 
    then
        Println "$error 标签为 $api_inbound_tag 的入站不存在?\n"
        exit 1
    fi
}

V2rayGetTraffic()
{
    while IFS= read -r line
    do
        if [[ $line =~ value: ]] 
        then
            echo ${line#*:} | numfmt --to=iec --suffix=B
            break
        fi
    done < <($V2CTL_FILE api --server=$api_inbound_listen:$api_inbound_port StatsService.GetStats 'name: "'"$1"'>>>'"$2"'>>>traffic>>>'"$3"'" reset: false' 2> /dev/null)
    return 0
}

V2rayListStats()
{
    V2rayGetStats

    stats_list=""

    for((i=0;i<inbounds_count;i++));
    do
        stats_list="$stats_list入站标签: ${green}${inbounds_tag[i]}${normal} "
        if [ "$policy_system_stats_inbound_uplink" == "true" ] 
        then
            stats_list="$stats_list上行流量: ${green}$(V2rayGetTraffic inbound ${inbounds_tag[i]} uplink)${normal} "
        else
            stats_list="$stats_list上行流量: ${red}关闭${normal} "
        fi
        if [ "$policy_system_stats_inbound_downlink" == "true" ] 
        then
            stats_list="$stats_list下行流量: ${green}$(V2rayGetTraffic inbound ${inbounds_tag[i]} downlink)${normal}\n\n"
        else
            stats_list="$stats_list下行流量: ${red}关闭${normal}\n\n"
        fi
    done

    V2rayGetOutbounds
    for((i=0;i<outbounds_count;i++));
    do
        if [ -n "${outbounds_tag[i]}" ] 
        then
            stats_list="$stats_list出站标签: ${green}${outbounds_tag[i]}${normal} "
            if [ "$policy_system_stats_outbound_uplink" == "true" ] 
            then
                stats_list="$stats_list上行流量: ${green}$(V2rayGetTraffic outbound ${outbounds_tag[i]} uplink)${normal} "
            else
                stats_list="$stats_list上行流量: ${red}关闭${normal} "
            fi
            if [ "$policy_system_stats_outbound_downlink" == "true" ] 
            then
                stats_list="$stats_list下行流量: ${green}$(V2rayGetTraffic outbound ${outbounds_tag[i]} downlink)${normal}\n\n"
            else
                stats_list="$stats_list下行流量: ${red}关闭${normal}\n\n"
            fi
        fi
    done

    Println "$stats_list"

    echo
    inquirer list_input "查看特定用户的流量" ny_options continue_yn
    if [ "$continue_yn" == "$i18n_no" ] 
    then
        echo
    else
        V2rayListInboundAccounts

        if [ "${inbounds_protocol[inbounds_index]}" == "http" ] 
        then
            Println "$error 用户没有邮箱, 不会开启统计\n"
            exit 1
        elif [ "${inbounds_protocol[inbounds_index]}" == "shadowsocks" ] 
        then
            for((i=0;i<policy_levels_count;i++));
            do
                if [ "${policy_levels_id[i]}" == "${inbounds_settings_user_level[inbounds_index]}" ] 
                then
                    if [ "${policy_levels_stats_user_uplink[i]}" == "false" ] 
                    then
                        Println "上行流量: ${red}关闭${normal}"
                    else
                        Println "上行流量: ${green}$(V2rayGetTraffic user ${inbounds_settings_email[inbounds_index]} uplink)${normal}"
                    fi
                    if [ "${policy_levels_stats_user_downlink[i]}" == "false" ] 
                    then
                        Println "下行流量: ${red}关闭${normal}\n"
                    else
                        Println "下行流量: ${green}$(V2rayGetTraffic user ${inbounds_settings_email[inbounds_index]} downlink)${normal}\n"
                    fi
                    break
                fi
            done
            exit 0
        fi

        V2raySelectAccount

        for((i=0;i<policy_levels_count;i++));
        do
            if [ "${policy_levels_id[i]}" == "${accounts_level[accounts_index]}" ] 
            then
                if [ "${policy_levels_stats_user_uplink[i]}" == "false" ] 
                then
                    Println "上行流量: ${red}关闭${normal}"
                else
                    Println "上行流量: ${green}$(V2rayGetTraffic user ${accounts_email[accounts_index]} uplink)${normal}"
                fi
                if [ "${policy_levels_stats_user_downlink[i]}" == "false" ] 
                then
                    Println "下行流量: ${red}关闭${normal}\n"
                else
                    Println "下行流量: ${green}$(V2rayGetTraffic user ${accounts_email[accounts_index]} downlink)${normal}\n"
                fi
                break
            fi
        done
    fi
}

V2rayResetStats()
{
    V2rayGetStats
    AskIfContinue n "`gettext \"将重置所有的流量统计\"`"
    $V2CTL_FILE api --server=$api_inbound_listen:$api_inbound_port StatsService.QueryStats 'pattern: "" reset: true'
}

V2rayListInboundDomains()
{
    v2ray_domains_inbound_list=""
    v2ray_domains_inbound_count=0
    v2ray_domains_inbound=()
    v2ray_domains_inbound_https_port=()

    if ls -A "$nginx_prefix/conf/sites_available/"* > /dev/null 2>&1
    then
        for f in "$nginx_prefix/conf/sites_available/"*
        do
            domain=${f##*/}
            domain=${domain%.conf}
            if [ -e "$nginx_prefix/conf/sites_enabled/$domain.conf" ] 
            then
                v2ray_status_text="${green}开启${normal}"
            else
                v2ray_status_text="${red}关闭${normal}"
            fi
            if [[ $domain =~ ^([a-zA-Z0-9](([a-zA-Z0-9-]){0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$ ]] || grep -q "proxy_pass http://127.0.0.1:${inbounds_port[inbounds_index]}" < "$nginx_prefix/conf/sites_available/$domain.conf" 
            then
                server_found=0
                server_flag=0
                while IFS= read -r line 
                do
                    if [[ $line == *"server {"* ]] 
                    then
                        server_found=1
                        server_ports=""
                        is_inbound=0
                    fi

                    if [[ $server_found -eq 1 ]] && [[ $line == *"{"* ]]
                    then
                        server_flag=$((server_flag+1))
                    fi

                    if [[ $server_found -eq 1 ]] && [[ $line == *"}"* ]]
                    then
                        server_flag=$((server_flag-1))
                        if [[ $server_flag -eq 0 ]] 
                        then
                            server_found=0
                            if [[ $is_inbound -eq 1 ]]
                            then
                                v2ray_domains_inbound_count=$((v2ray_domains_inbound_count+1))
                                v2ray_domains_inbound+=("$domain")
                                v2ray_domains_inbound_https_port+=("$server_ports")
                                v2ray_domains_inbound_list=$v2ray_domains_inbound_list"${green}$v2ray_domains_inbound_count.${normal}${indent_6}域名: ${green}$domain${normal} nginx 端口: ${green}$server_ports${normal} nginx 路径: ${green}${inbounds_stream_path[inbounds_index]}${normal} 状态: $v2ray_status_text\n\n"
                            fi
                        fi
                    fi

                    if [[ $server_found -eq 1 ]] && [[ $line == *"listen "* ]]
                    then
                        line=${line#*listen }
                        line=${line% ssl;*}
                        lead=${line%%[^[:blank:]]*}
                        line=${line#${lead}}
                        [ -n "$server_ports" ] && server_ports="$server_ports, "
                        server_ports="$server_ports${line:0:-1}"
                    fi

                    if [[ $server_found -eq 1 ]] && [[ $line == *"proxy_pass http://127.0.0.1:${inbounds_port[inbounds_index]}"* ]]
                    then
                        is_inbound=1
                    fi
                done < "$nginx_prefix/conf/sites_available/$domain.conf"
            else
                continue
            fi
        done
    fi
    Println "绑定的${green}域名列表:${normal}\n\n${v2ray_domains_inbound_list:-无}\n\n"
}

V2rayDomainUpdateCrt()
{
    local domain=$1 quiet=${2:-0}

    [ "$quiet" -eq 0 ] && Println "$info 更新 $domain 证书..."

    if [ ! -f "$HOME/.acme.sh/acme.sh" ] 
    then
        DepInstall socat
        bash <(curl -s -m 20 https://get.acme.sh) > /dev/null
    fi

    if [ -f /etc/systemd/system/mmproxy-acme.service ] 
    then
        if [ -z "${tls_port:-}" ] 
        then
            tls_port=$(grep ^ExecStart= < /etc/systemd/system/mmproxy-acme.service)
            if [[ $tls_port =~ -4\ 127.0.0.1:([^ ]+) ]] 
            then
                tls_port=${BASH_REMATCH[1]}
            else
                tls_port=${tls_port#*-4 }
                tls_port=${tls_port#*:}
                tls_port=${tls_port%% *}
            fi
        fi

        ~/.acme.sh/acme.sh --force --issue --alpn --tlsport "$tls_port" -d "$domain" --standalone -k ec-256 > /dev/null
        ~/.acme.sh/acme.sh --force --installcert -d "$domain" --fullchainpath "/usr/local/share/$v2ray_name/$domain.crt" --keypath "/usr/local/share/$v2ray_name/$domain.key" --ecc > /dev/null
    else
        stopped=0

        if [ -d "$nginx_prefix" ] 
        then
            if [[ $(systemctl is-active $nginx_name) == "active" ]]
            then
                systemctl stop $nginx_name
                stopped=1
            fi

            sleep 1
        fi

        ~/.acme.sh/acme.sh --force --issue -d "$domain" --standalone -k ec-256 > /dev/null
        ~/.acme.sh/acme.sh --force --installcert -d "$domain" --fullchainpath "/usr/local/share/$v2ray_name/$domain.crt" --keypath "/usr/local/share/$v2ray_name/$domain.key" --ecc > /dev/null

        [ "$stopped" -eq 1 ] && systemctl start $nginx_name
    fi

    [ "$quiet" -eq 0 ] && Println "$info $domain 证书更新成功\n"

    return 0
}

V2rayNginxListDomains()
{
    v2ray_nginx_domains_list=""
    v2ray_nginx_domains_count=0
    v2ray_nginx_domains=()

    if ls -A "$nginx_prefix/conf/sites_available/"* > /dev/null 2>&1
    then
        for f in "$nginx_prefix/conf/sites_available/"*
        do
            domain=${f##*/}
            domain=${domain%.conf}
            v2ray_nginx_domains_count=$((v2ray_nginx_domains_count+1))
            v2ray_nginx_domains+=("$domain")
            if [ -e "$nginx_prefix/conf/sites_enabled/$domain.conf" ] 
            then
                v2ray_nginx_domain_status_text="${green} [开启] ${normal}"
            else
                v2ray_nginx_domain_status_text="${red} [关闭] ${normal}"
            fi
            v2ray_nginx_domains_list="$v2ray_nginx_domains_list ${green}$v2ray_nginx_domains_count.${normal}${indent_6}$domain $v2ray_nginx_domain_status_text\n\n"
        done
    fi

    Println "${green}域名列表:${normal}\n\n${v2ray_nginx_domains_list:-无}\n\n"
}

V2rayNginxSelectDomain()
{
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" v2ray_nginx_domains_index
    do
        case "$v2ray_nginx_domains_index" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$v2ray_nginx_domains_index" -gt 0 ] && [ "$v2ray_nginx_domains_index" -le "$v2ray_nginx_domains_count" ]
                then
                    v2ray_nginx_domains_index=$((v2ray_nginx_domains_index-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2rayNginxSelectDomainServer()
{
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" v2ray_nginx_domain_servers_num
    do
        case "$v2ray_nginx_domain_servers_num" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$v2ray_nginx_domain_servers_num" -gt 0 ] && [ "$v2ray_nginx_domain_servers_num" -le "$v2ray_nginx_domain_servers_count" ]
                then
                    v2ray_nginx_domain_servers_index=$((v2ray_nginx_domain_servers_num-1))
                    level_2_add_indices=( "${v2ray_nginx_domain_servers_indices[v2ray_nginx_domain_servers_index]}" )
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2rayNginxDomainServerUpdateCrt()
{
    v2ray_nginx_domain_server_name=${v2ray_nginx_domain_servers_name[v2ray_nginx_domain_servers_index]}

    if [[ $v2ray_nginx_domain_server_name =~ , ]] 
    then
        IFS="," read -r -a domains <<< "$v2ray_nginx_domain_server_name"

        echo
        set +u
        inquirer checkbox_input "选择域名: " domains domains_selected
        set -u

        for domain in "${domains_selected[@]}"
        do
            NginxDomainUpdateCrt "$domain"
            cp -f "$nginx_prefix/conf/sites_crt/$domain.crt" "/usr/local/share/$v2ray_name/$domain.crt"
            cp -f "$nginx_prefix/conf/sites_crt/$domain.key" "/usr/local/share/$v2ray_name/$domain.key"
            chown $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/*
        done

        return 0
    fi

    NginxDomainUpdateCrt "$v2ray_nginx_domain_server_name"
    cp -f "$nginx_prefix/conf/sites_crt/$v2ray_nginx_domain_server_name.crt" "/usr/local/share/$v2ray_name/$v2ray_nginx_domain_server_name.crt"
    cp -f "$nginx_prefix/conf/sites_crt/$v2ray_nginx_domain_server_name.key" "/usr/local/share/$v2ray_name/$v2ray_nginx_domain_server_name.key"
    chown $v2ray_name:$v2ray_name /usr/local/share/$v2ray_name/*
}

V2rayNginxDomainServerAddProxy()
{
    V2rayListInbounds nginx
    V2raySelectInbound

    if [ "${inbounds_stream_network[inbounds_index]}" == "domainsocket" ] 
    then
        Println "$error 不能使用此入站\n"
        exit 1
    fi

    if [ -z "${inbounds_stream_path[inbounds_index]}" ] 
    then
        Println "$error 此入站没有路径\n"
        exit 1
    fi

    proxy_path=${inbounds_stream_path[inbounds_index]}
    proxy_port=${inbounds_port[inbounds_index]}

    if [ "${inbounds_stream_network[inbounds_index]}" == "ws" ] 
    then
        new_proxy='
        {"directive":"location","args":["=","'"$proxy_path"'"],"block":[
            {"directive":"proxy_redirect","args":["off"]},
            {"directive":"proxy_pass","args":["http://127.0.0.1:'"$proxy_port"'"]},
            {"directive":"proxy_http_version","args":["1.1"]},
            {"directive":"proxy_set_header","args":["Upgrade","$http_upgrade"]},
            {"directive":"proxy_set_header","args":["Connection","upgrade"]}
        ]}'
    else
        new_proxy='
        {"directive":"location","args":["=","'"$proxy_path"'"],"block":[
            {"directive":"proxy_redirect","args":["off"]},
            {"directive":"proxy_pass","args":["http://127.0.0.1:'"$proxy_port"'"]},
            {"directive":"proxy_http_version","args":["1.1"]}
        ]}'
    fi

    jq_path='["config",0,"parsed",0,"block",'"$v2ray_nginx_domain_servers_index"',"block"]'
    JQs add parse_out "$new_proxy"

    NginxBuildConf parse_out

    Println "$info 代理添加成功\n"
}

V2rayNginxSelectDomainServerProxy()
{
    echo "`gettext \"输入序号\"`"
    while read -p "$i18n_default_cancel" v2ray_nginx_domain_server_proxies_num
    do
        case "$v2ray_nginx_domain_server_proxies_num" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            $v2ray_nginx_domain_server_update_crt_number)
                V2rayNginxDomainServerUpdateCrt
                exit 0
            ;;
            $v2ray_nginx_domain_server_add_proxy_number)
                V2rayNginxDomainServerAddProxy
                exit 0
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$v2ray_nginx_domain_server_proxies_num" -gt 0 ] && [ "$v2ray_nginx_domain_server_proxies_num" -le "$v2ray_nginx_domain_server_proxies_count" ]
                then
                    v2ray_nginx_domain_server_proxies_index=$((v2ray_nginx_domain_server_proxies_num-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

V2rayNginxListDomain()
{
    if [ "$v2ray_nginx_domains_count" -eq 0 ] 
    then
        Println "$error 请先使用 $nginx_name 管理面板添加域名\n"
        exit 1
    fi

    level_1_add_indices=( 0 )

    V2rayNginxSelectDomain
    NginxParseConfig ${v2ray_nginx_domains[v2ray_nginx_domains_index]}
    NginxGetConfig

    if [ "$level_3_d1_count" -eq 0 ] 
    then
        Println "$error 请先添加 ${v2ray_nginx_domains[v2ray_nginx_domains_index]} 配置\n"
        exit 1
    fi

    v2ray_nginx_domain_servers_list=""
    v2ray_nginx_domain_servers_count=0
    v2ray_nginx_domain_servers_indices=()
    v2ray_nginx_domain_servers_name=()
    v2ray_nginx_domain_servers_proxy=()

    level_1_index=0

    level_2_directive_d1=${level_2_directive_arr[level_1_index]}
    level_3_directive_d1=${level_3_directive_arr[level_1_index]}
    level_3_args_d1=${level_3_args_arr[level_1_index]}

    IFS="${delimiters[1]}" read -r -a level_2_directive_d1_arr <<< "$level_2_directive_d1${delimiters[1]}"
    IFS="${delimiters[2]}" read -r -a level_3_directive_d1_arr <<< "$level_3_directive_d1${delimiters[2]}"
    IFS="${delimiters[2]}" read -r -a level_3_args_d1_arr <<< "$level_3_args_d1${delimiters[2]}"

    if [ "$level_4_d1_count" -gt 0 ] 
    then
        level_4_directive_d1=${level_4_directive_arr[level_1_index]}
        level_4_args_d1=${level_4_args_arr[level_1_index]}
        IFS="${delimiters[3]}" read -r -a level_4_directive_d1_arr <<< "$level_4_directive_d1${delimiters[3]}"
        IFS="${delimiters[3]}" read -r -a level_4_args_d1_arr <<< "$level_4_args_d1${delimiters[3]}"
    fi

    for((level_2_index=0;level_2_index<${#level_2_directive_d1_arr[@]};level_2_index++));
    do
        if [ "${level_2_directive_d1_arr[level_2_index]}" == "server" ] 
        then
            level_3_directive_d2=${level_3_directive_d1_arr[level_2_index]}
            level_3_args_d2=${level_3_args_d1_arr[level_2_index]}

            IFS="${delimiters[1]}" read -r -a level_3_directive_d2_arr <<< "$level_3_directive_d2${delimiters[1]}"
            IFS="${delimiters[1]}" read -r -a level_3_args_d2_arr <<< "$level_3_args_d2${delimiters[1]}"

            if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ]
            then
                level_4_directive_d2=${level_4_directive_d1_arr[level_2_index]}
                level_4_args_d2=${level_4_args_d1_arr[level_2_index]}
                IFS="${delimiters[2]}" read -r -a level_4_directive_d2_arr <<< "$level_4_directive_d2${delimiters[2]}"
                IFS="${delimiters[2]}" read -r -a level_4_args_d2_arr <<< "$level_4_args_d2${delimiters[2]}"
            fi

            v2ray_nginx_domain_servers_count=$((v2ray_nginx_domain_servers_count+1))
            v2ray_nginx_domain_servers_indices+=("$level_2_index")
            v2ray_nginx_domain_server_listen_list=""
            v2ray_nginx_domain_server_name_list=""
            v2ray_nginx_domain_server_proxies=""
            v2ray_nginx_domain_server_proxies_list=""

            for((level_3_index=0;level_3_index<${#level_3_directive_d2_arr[@]};level_3_index++));
            do
                level_3_directive=${level_3_directive_d2_arr[level_3_index]}
                level_3_args=${level_3_args_d2_arr[level_3_index]}

                if [ "$level_3_directive" == "listen" ] 
                then
                    [ -n "$v2ray_nginx_domain_server_listen_list" ] && v2ray_nginx_domain_server_listen_list="$v2ray_nginx_domain_server_listen_list, "
                    v2ray_nginx_domain_server_listen_list="$v2ray_nginx_domain_server_listen_list${level_3_args//${delimiters[0]}/ }"
                elif [ "$level_3_directive" == "server_name" ] 
                then
                    [ -n "$v2ray_nginx_domain_server_name_list" ] && v2ray_nginx_domain_server_name_list="$v2ray_nginx_domain_server_name_list, "
                    v2ray_nginx_domain_server_name_list="$v2ray_nginx_domain_server_name_list${level_3_args//${delimiters[0]}/, }"
                elif [ "$level_3_directive" == "location" ] 
                then
                    if [ "$level_4_d1_count" -gt 0 ] && [ -n "${level_4_directive_d1_arr[level_2_index]}" ] && [ -n "${level_4_directive_d2_arr[level_3_index]}" ]
                    then
                        level_4_directive_d3=${level_4_directive_d2_arr[level_3_index]}
                        level_4_args_d3=${level_4_args_d2_arr[level_3_index]}
                        IFS="${delimiters[1]}" read -r -a level_4_directive_d3_arr <<< "$level_4_directive_d3${delimiters[1]}"
                        IFS="${delimiters[1]}" read -r -a level_4_args_d3_arr <<< "$level_4_args_d3${delimiters[1]}"

                        if [[ ${level_3_args} =~ ^=${delimiters[0]}(.+) ]] 
                        then
                            v2ray_nginx_domain_server_proxy_path=${BASH_REMATCH[1]}
                            for((level_4_index=0;level_4_index<${#level_4_directive_d3_arr[@]};level_4_index++));
                            do
                                if [ "${level_4_directive_d3_arr[level_4_index]}" == "proxy_pass" ] 
                                then
                                    if [[ ${level_4_args_d3_arr[level_4_index]} =~ ^http://127.0.0.1:(.+) ]] 
                                    then
                                        v2ray_nginx_domain_server_proxies="$v2ray_nginx_domain_server_proxies$level_3_index|$level_4_index|${BASH_REMATCH[1]}|$v2ray_nginx_domain_server_proxy_path "
                                        v2ray_nginx_domain_server_proxies_list="$v2ray_nginx_domain_server_proxies_list${indent_6}路径: ${green}$v2ray_nginx_domain_server_proxy_path${normal} => $v2ray_name 端口: ${green}${BASH_REMATCH[1]}${normal}\n"
                                    fi
                                    break
                                fi
                            done
                        fi
                    fi
                fi
            done

            if [ -z "$v2ray_nginx_domain_server_proxies_list" ] 
            then
                v2ray_nginx_domain_server_proxies_list="${red}未配置${normal}"
            fi

            v2ray_nginx_domain_servers_name+=("${v2ray_nginx_domain_server_name_list//, /,}")
            v2ray_nginx_domain_servers_proxy+=("$v2ray_nginx_domain_server_proxies")

            v2ray_nginx_domain_servers_list="$v2ray_nginx_domain_servers_list $v2ray_nginx_domain_servers_count.${indent_6}域名: ${green}${v2ray_nginx_domain_server_name_list:-未设置}${normal}\n${indent_6}端口: ${green}${v2ray_nginx_domain_server_listen_list:-未设置}${normal}\n${indent_6}代理: $v2ray_nginx_domain_server_proxies_list\n\n"
        fi
    done

    Println "域名 ${green}${v2ray_nginx_domains[v2ray_nginx_domains_index]}${normal} 配置:\n\n$v2ray_nginx_domain_servers_list"
}

V2rayConfigDomain()
{
    if [ -d "$nginx_prefix" ] 
    then
        echo
        v2ray_config_domain_options=( "$v2ray_name" nginx openresty )
        inquirer list_input "选择修改的配置" v2ray_config_domain_options v2ray_config_domain_option

        if [ "$v2ray_config_domain_option" != "$v2ray_name" ] 
        then
            if [ ! -d "/usr/local/$v2ray_config_domain_option" ] 
            then
                Println "$error 请先安装 $v2ray_config_domain_option\n"
                exit 1
            fi

            if [ "$v2ray_config_domain_option" == "nginx" ] 
            then
                nginx_prefix="/usr/local/nginx"
                nginx_name="nginx"
                nginx_ctl="nx"
            else
                nginx_prefix="/usr/local/openresty/nginx"
                nginx_name="openresty"
                nginx_ctl="or"
            fi

            NGINX_FILE="$nginx_prefix/sbin/nginx"

            V2rayNginxListDomains
            V2rayNginxListDomain

            V2rayNginxSelectDomainServer

            v2ray_nginx_domain_server_proxies_list=""
            v2ray_nginx_domain_server_proxies_count=0

            v2ray_nginx_domain_server_proxy=${v2ray_nginx_domain_servers_proxy[v2ray_nginx_domain_servers_index]}

            if [ -n "$v2ray_nginx_domain_server_proxy" ] 
            then
                v2ray_nginx_domain_server_location_indices=()
                v2ray_nginx_domain_server_proxy_indices=()
                v2ray_nginx_domain_server_proxies_port=()
                v2ray_nginx_domain_server_proxies_path=()
                v2ray_nginx_domain_server_proxies_list=""

                IFS=" " read -r -a v2ray_nginx_domain_server_proxies <<< "$v2ray_nginx_domain_server_proxy"

                for((i=0;i<${#v2ray_nginx_domain_server_proxies[@]};i++));
                do
                    if [[ ${v2ray_nginx_domain_server_proxies[i]} =~ ^([^|]+)\|([^|]+)\|([^|]+)\|(.+)$ ]] 
                    then
                        v2ray_nginx_domain_server_location_indices+=("${BASH_REMATCH[1]}")
                        v2ray_nginx_domain_server_proxy_indices+=("${BASH_REMATCH[2]}")
                        v2ray_nginx_domain_server_proxies_port+=("${BASH_REMATCH[3]}")
                        v2ray_nginx_domain_server_proxies_path+=("${BASH_REMATCH[4]}")
                        v2ray_nginx_domain_server_proxies_list="$v2ray_nginx_domain_server_proxies_list $((i+1)).${indent_6}路径: ${green}${BASH_REMATCH[4]}${normal} => 端口: ${green}${BASH_REMATCH[3]}${normal}\n\n"
                    fi
                done

                v2ray_nginx_domain_server_proxies_count=${#v2ray_nginx_domain_server_proxies_path[@]}
            fi

            v2ray_nginx_domain_server_update_crt_number=$((v2ray_nginx_domain_server_proxies_count+1))
            v2ray_nginx_domain_server_add_proxy_number=$((v2ray_nginx_domain_server_proxies_count+2))
            v2ray_nginx_domain_server_proxies_list="$v2ray_nginx_domain_server_proxies_list $v2ray_nginx_domain_server_update_crt_number.${indent_6}${green}更新证书${normal}\n\n"
            v2ray_nginx_domain_server_proxies_list="$v2ray_nginx_domain_server_proxies_list $v2ray_nginx_domain_server_add_proxy_number.${indent_6}${green}添加代理${normal}\n"

            Println "代理配置:\n\n$v2ray_nginx_domain_server_proxies_list"

            V2rayNginxSelectDomainServerProxy

            v2ray_nginx_domain_server_location_index=${v2ray_nginx_domain_server_location_indices[v2ray_nginx_domain_server_proxies_index]}
            v2ray_nginx_domain_server_proxy_index=${v2ray_nginx_domain_server_proxy_indices[v2ray_nginx_domain_server_proxies_index]}
            v2ray_nginx_domain_server_proxy_port=${v2ray_nginx_domain_server_proxies_port[v2ray_nginx_domain_server_proxies_index]}
            v2ray_nginx_domain_server_proxy_path=${v2ray_nginx_domain_server_proxies_path[v2ray_nginx_domain_server_proxies_index]}

            echo
            v2ray_nginx_domain_server_proxy_options=( '修改代理路径' '修改代理端口' '删除此代理' )
            inquirer list_input_index "选择操作" v2ray_nginx_domain_server_proxy_options v2ray_nginx_domain_server_proxy_options_index

            if [ "$v2ray_nginx_domain_server_proxy_options_index" -eq 0 ] 
            then
                echo
                inquirer text_input "输入新的代理路径: " new_path "$v2ray_nginx_domain_server_proxy_path"
                jq_path='["config",0,"parsed",0,"block",'"$v2ray_nginx_domain_servers_index"',"block",'"$v2ray_nginx_domain_server_location_index"',"args"]'
                JQs replace parse_out "$new_path"
            elif [ "$v2ray_nginx_domain_server_proxy_options_index" -eq 1 ] 
            then
                echo
                new_proxy_port_options=( '输入新的代理端口' '浏览并选择端口' )
                inquirer list_input_index "选择操作" new_proxy_port_options new_proxy_port_options_index

                if [ "$new_proxy_port_options" -eq 0 ] 
                then
                    echo
                    inquirer text_input "输入新的代理端口: " new_proxy_port "$v2ray_nginx_domain_server_proxy_port"
                else
                    V2rayListInbounds nginx
                    V2raySelectInbound

                    if [ "${inbounds_stream_network[inbounds_index]}" == "domainsocket" ] 
                    then
                        Println "$error 选择错误\n"
                        exit 1
                    fi

                    new_proxy_port=${inbounds_port[inbounds_index]}
                fi

                jq_path='["config",0,"parsed",0,"block",'"$v2ray_nginx_domain_servers_index"',"block",'"$v2ray_nginx_domain_server_location_index"',"block",'"$v2ray_nginx_domain_server_proxy_index"',"args"]'
                JQs replace parse_out "$new_proxy_port"
            else
                jq_path='["config",0,"parsed",0,"block",'"$v2ray_nginx_domain_servers_index"',"block"]'
                JQs delete parse_out "$v2ray_nginx_domain_server_location_index"
            fi

            NginxBuildConf parse_out

            Println "$info 操作成功\n"
            exit 0
        fi
    fi

    V2rayListInbounds direct

    V2raySelectInbound

    if [ -z "${inbounds_stream_tls_certificates_usage[inbounds_index]}" ] 
    then
        Println "$error 没有证书\n"
        exit 1
    fi

    certificates_list="${green}证书:${normal}\n${indent_6}"
    certificates_indices=()

    IFS="|" read -r -a usages <<< "${inbounds_stream_tls_certificates_usage[inbounds_index]}"
    IFS="|" read -r -a certificate_files <<< "${inbounds_stream_tls_certificates_certificate_file[inbounds_index]}"
    IFS="|" read -r -a key_files <<< "${inbounds_stream_tls_certificates_key_file[inbounds_index]}"
    IFS="|" read -r -a certificates <<< "${inbounds_stream_tls_certificates_certificate[inbounds_index]}"

    for((certificate_i=0;certificate_i<${#usages[@]};certificate_i++));
    do
        if [ -z "${certificate_files[certificate_i]}" ] || [ -z "${key_files[certificate_i]}" ]
        then
            continue
        fi

        certificates_indices+=("$certificate_i")

        if [ "${usages[certificate_i]}" == "encipherment" ] 
        then
            certificate_usage="$tls_name 认证和加密"
        elif [ "${usages[certificate_i]}" == "verify" ] 
        then
            certificate_usage="验证远端 $tls_name"
        else
            certificate_usage="签发其它证书"
        fi

        if [ -n "${certificates:-}" ] && [ -n "${certificates[certificate_i]}" ] 
        then
            certificates_list="$certificates_list${#certificates_indices[@]}.${indent_6}用途: ${green}$certificate_usage [自签名]${normal}\n"
        else
            certificates_list="$certificates_list${#certificates_indices[@]}.${indent_6}用途: ${green}$certificate_usage${normal}\n"
        fi

        certificates_list="${certificates_list}${indent_6}证书路径: ${green}${certificate_files[certificate_i]}${normal}\n"

        certificates_list="${certificates_list}${indent_6}密钥路径: ${green}${key_files[certificate_i]}${normal}\n\n"
    done

    if [ -z "$certificates_list" ] 
    then
        Println "$error 没有可管理证书\n"
        exit 1
    fi

    Println "$certificates_list"

    certificates_count=${#certificates_indices[@]}

    echo "选择证书"
    while read -p "$i18n_default_cancel" certificates_num
    do
        case "$certificates_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$certificates_num" -gt 0 ] && [ "$certificates_num" -le $certificates_count ]
                then
                    certificates_index=${certificates_indices[certificates_num-1]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    certificate_file=${certificate_files[certificates_index]}
    tls_settings_name=$(tr '[:upper:]' '[:lower:]' <<< "$tls_name")"Settings"

    echo
    certificates_options=( '更新证书' '修改证书路径' '修改密钥路径' )
    inquirer list_input_index "选择操作" certificates_options certificates_options_index

    if [ "$certificates_options_index" -eq 0 ] 
    then
        if [ -n "${certificates:-}" ] && [ -n "${certificates[certificates_index]}" ] 
        then
            if [ "$v2ray_name" == "xray" ] 
            then
                crt=$($V2CTL_FILE tls cert)
            elif [ "$usage" == "encipherment" ] 
            then
                echo
                inquirer list_input "是否是 CA 证书" yn_options ca_yn
                if [ "$ca_yn" == "$i18n_yes" ] 
                then
                    crt=$($V2CTL_FILE cert -ca)
                else
                    crt=$($V2CTL_FILE cert)
                fi
            else
                crt=$($V2CTL_FILE cert -ca)
            fi

            certificate=$($JQ_FILE "{\"usage\":\"${usages[certificates_index]}\"} * ." <<< "$crt")

            jq_path='["inbounds",'"$inbounds_index"',"streamSettings","'"$tls_settings_name"'","certificates",'"$certificates_index"',"keyFile"]'
            JQ replace "$V2_CONFIG" "$certificate"

            Println "$info 证书更新成功\n"
        else
            if [ -n "${inbounds_stream_tls_server_name[inbounds_index]}" ] 
            then
                certificate_name=${inbounds_stream_tls_server_name[inbounds_index]}
            else
                certificate_name=${certificate_file##*/}
                certificate_name=${certificate_name%.*}
            fi

            echo
            inquirer text_input "请输入证书域名: " certificate_domain "$certificate_name"

            Println "$info 更新 $certificate_domain 证书..."

            V2rayDomainUpdateCrt "$certificate_domain" 1

            jq_path='["inbounds",'"$inbounds_index"',"streamSettings","'"$tls_settings_name"'","certificates",'"$certificates_index"',"certificateFile"]'
            JQ update "$V2_CONFIG" "/usr/local/share/$v2ray_name/$certificate_domain.crt"

            jq_path='["inbounds",'"$inbounds_index"',"streamSettings","'"$tls_settings_name"'","certificates",'"$certificates_index"',"keyFile"]'
            JQ update "$V2_CONFIG" "/usr/local/share/$v2ray_name/$certificate_domain.key"

            Println "$info $certificate_domain 证书更新成功\n"
        fi
    elif [ "$certificates_options_index" -eq 1 ] 
    then
        V2raySetCertificateFile

        jq_path='["inbounds",'"$inbounds_index"',"streamSettings","'"$tls_settings_name"'","certificates",'"$certificates_index"',"certificateFile"]'
        JQ update "$V2_CONFIG" "$certificate_file"

        Println "$info 证书路径修改成功\n"
    else
        V2raySetKeyFile

        jq_path='["inbounds",'"$inbounds_index"',"streamSettings","'"$tls_settings_name"'","certificates",'"$certificates_index"',"keyFile"]'
        JQ update "$V2_CONFIG" "$key_file"

        Println "$info 密钥路径修改成功\n"
    fi
}

TrojanInstall()
{
    if [ -s "$TR_CONFIG" ] 
    then
        Println "$error $trojan_name 已存在...\n"
        AskIfContinue n "`gettext \"是否覆盖原安装\"`"
    fi

    DepsCheck
    JQInstall

    if ! grep -q "$trojan_name:" < "/etc/passwd"
    then
        if grep -q '\--group ' < <(adduser --help)
        then
            adduser $trojan_name --system --group --no-create-home > /dev/null
        else
            adduser $trojan_name --system --no-create-home > /dev/null
        fi
        usermod -s /usr/sbin/nologin $trojan_name
    fi

    Println "$info 安装 $trojan_name..."

    { curl -s -m 10 "$TR_LINK" || curl -s -m 30 "$TR_LINK_BACKUP"; } \
    | sed "s+nobody+$trojan_name+g" \
    | sed "s+ 'sha1'++g" \
    | sed "s+ 'sha256'++g" \
    | sed "s+ 'sha512'++g" \
    | sed "s+https://api.github.com/repos/p4gefau1t/trojan-go/releases/latest+$FFMPEG_MIRROR_LINK/$trojan_name.json+g" \
    | sed "s+https://github.com/p4gefau1t/trojan-go/releases/download+$FFMPEG_MIRROR_LINK/$trojan_name+g" | bash

    TrojanConfigInstall

    systemctl daemon-reload
    systemctl enable $trojan_name
    systemctl start $trojan_name

    Println "$info $trojan_name 安装成功\n"
}

CloudflareSetHostKey()
{
    Println "请输入 CFP host key"
    read -p "$i18n_default_cancel" cf_host_key
    [ -z "$cf_host_key" ] && Println "$i18n_canceled...\n" && exit 1
    Println "$info 稍等..."
    IFS=" " read -r result msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_list' \
        -d "host_key=$cf_host_key" \
        -d 'limit=1' \
        -d 'offset=0' \
        -d 'zone_status=ALL' \
        -d 'sub_status=ALL' \
        | $JQ_FILE '[.result,.msg]|join(" ")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        Println "$error ${msg:-超时, 请重试}\n" && exit 1
    fi

    Println "  CFP: ${green} $cf_host_key ${normal}\n"
}

CloudflareSetHostName()
{
    Println "请输入 CFP 邮箱或名称, 便于区分 host key"
    read -p "$i18n_default_cancel" cf_host_name
    [ -z "$cf_host_name" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  CFP 邮箱或名称: ${green} $cf_host_name ${normal}\n"
}

CloudflareAddHost()
{
    CloudflareSetHostKey
    CloudflareSetHostName

    if [ ! -s "$CF_CONFIG" ] 
    then
        printf '{"%s":[],"%s":[]}' "users" "hosts" > "$CF_CONFIG"
    fi

    new_host=$(
    $JQ_FILE -n --arg name "$cf_host_name" --arg key "$cf_host_key" \
        '{
            name: $name,
            key: $key,
            free: 0,
            zones: []
        }'
    )

    jq_path='["hosts"]'
    JQ add "$CF_CONFIG" "$new_host"
    Println "$info CFP 添加成功\n"
}

CloudflareSetUserEmail()
{
    Println "请输入用户邮箱"
    while read -p "$i18n_default_cancel" cf_user_email 
    do
        [ -z "$cf_user_email" ] && Println "$i18n_canceled...\n" && exit 1
        if [[ $cf_user_email =~ ^[A-Za-z0-9]([a-zA-Z0-9_\.\-]*)@([A-Za-z0-9]+)([a-zA-Z0-9\.\-]*)\.([A-Za-z]{2,})$ ]] 
        then
            break
        else
            Println "$error 邮箱格式错误, 请重新输入\n"
        fi
    done
    Println "  用户邮箱: ${green} $cf_user_email ${normal}\n"
}

CloudflareSetUserPass()
{
    Println "输入用户密码"
    while read -p "(默认: 随机): " cf_user_pass 
    do
        [ -z "$cf_user_pass" ] && cf_user_pass=$(RandStr)
        if [[ ${#cf_user_pass} -ge 8 ]] 
        then
            break
        else
            Println "$error 账号密码至少 8 位\n"
        fi
    done
    Println "  用户密码: ${green} $cf_user_pass ${normal}\n"
}

CloudflareSetUserToken()
{
    Println "$tip 需要 workers 和 zone(区域) 编辑权限, 以及 zone(区域) 的 Analytics 读取权限"
    inquirer text_input "请输入用户 Token: " cf_user_token "不设置"
    if [ "$cf_user_token" == "不设置" ] 
    then
        cf_user_token=""
    else
        if [[ $(curl -s -X GET "https://api.cloudflare.com/client/v4/user/tokens/verify" \
            -H "Authorization: Bearer $cf_user_token" \
            -H "Content-Type:application/json" | $JQ_FILE -r '.success') == "false" ]]
        then
            Println "$error Token 验证失败\n"
            exit 1
        fi
    fi
}

CloudflareSetUserKey()
{
    echo
    inquirer text_input "请输入用户 Global API KEY: " cf_user_api_key "不设置"
    if [ "$cf_user_api_key" == "不设置" ] 
    then
        cf_user_api_key=""
    fi
}

CloudflareGetHosts()
{
    cf_hosts_list=""
    cf_hosts_count=0
    cf_hosts_name=()
    cf_hosts_key=()
    cf_hosts_zones_count=()
    cf_hosts_zone_name=()
    cf_hosts_zone_resolve_to=()
    cf_hosts_zone_user_email=()
    cf_hosts_zone_user_unique_id=()
    cf_hosts_zone_always_use_https=()
    cf_hosts_zone_ssl=()
    cf_hosts_zone_subdomains=()
    while IFS="^" read -r name key zones_count zone_name zone_resolve_to zone_user_email zone_user_unique_id zone_always_use_https zone_ssl zone_subdomains
    do
        cf_hosts_count=$((cf_hosts_count+1))
        name=${name#\"}
        cf_hosts_name+=("$name")
        cf_hosts_key+=("$key")
        cf_hosts_zones_count+=("$zones_count")
        cf_hosts_zone_name+=("$zone_name")
        cf_hosts_zone_resolve_to+=("$zone_resolve_to")
        cf_hosts_zone_user_email+=("$zone_user_email")
        zone_user_unique_id=${zone_user_unique_id%\"}
        cf_hosts_zone_user_unique_id+=("$zone_user_unique_id")
        cf_hosts_zone_always_use_https+=("$zone_always_use_https")
        cf_hosts_zone_ssl+=("$zone_ssl")
        zone_subdomains=${zone_subdomains%\"}
        cf_hosts_zone_subdomains+=("$zone_subdomains")

        cf_hosts_list="$cf_hosts_list ${green}$cf_hosts_count.${normal}${indent_6}CFP: ${green}$name${normal}  host key: ${green}$key${normal}  域名数: ${green}$zones_count${normal}\n\n"
    done < <($JQ_FILE '.hosts[]|[.name,.key,(.zones|length),([.zones[].name]|join("|")),([.zones[].resolve_to]|join("|")),([.zones[].user_email]|join("|")),([.zones[].user_unique_id]|join("|")),([.zones[].always_use_https]|join("|")),([.zones[].ssl]|join("|")),([.zones[].subdomains]|join("|"))]|join("^")' "$CF_CONFIG")
    return 0
}

CloudflareListHosts()
{
    if [ ! -s "$CF_CONFIG" ] 
    then
        Println "$error 请先添加 CFP\n" && exit 1
    fi

    CloudflareGetHosts

    if [ "$cf_hosts_count" -gt 0 ] 
    then
        Println "$cf_hosts_list"
    else
        Println "$error 请先添加 CFP\n" && exit 1
    fi
}

CloudflareListHost()
{
    CloudflareListHosts
}

CloudflareSetZoneResolve()
{
    Println "请输入 CNAME 经 cloudflare 中转后默认解析到的地址, 比如 resolve-to-cloudflare.example.com"
    echo -e "$tip 此地址应指向源站\n"
    read -p "$i18n_default_cancel" cf_zone_resolve_to
    [ -z "$cf_zone_resolve_to" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  默认解析地址: ${green} $cf_zone_resolve_to ${normal}\n"
}

CloudflareSetZoneAlwaysUseHttps()
{
    echo
    if [[ ${cf_zone_always_use_https:-} == "on" ]] 
    then
        inquirer list_input "始终使用 https 访问域名, 开启后客户端和 cloudflare 之间连接始终为 https" yn_options cf_zone_always_use_https_yn
    else
        inquirer list_input "始终使用 https 访问域名, 开启后客户端和 cloudflare 之间连接始终为 https" ny_options cf_zone_always_use_https_yn
    fi

    if [[ $cf_zone_always_use_https_yn == "$i18n_yes" ]] 
    then
        cf_zone_always_use_https='on'
    else
        cf_zone_always_use_https='off'
    fi
    Println "  始终使用 https: ${green} $cf_zone_always_use_https ${normal}\n"
}

CloudflareSetZoneSsl()
{
    Println "选择域名 ${green}$cf_zone_name${normal} SSL 设置

  ${green}1.${normal} off ( 客户端 <= http => cloudflare <= http => 源站)
  ${green}2.${normal} flexible ( 客户端 <= https => cloudflare <= http => 源站)
  ${green}3.${normal} full ( 客户端 <= https => cloudflare <= https => 源站[ SSL证书/自定义证书 ])
  ${green}4.${normal} strict ( 客户端 <= https => cloudflare <= https => 源站[ CA SSL证书 ])
    "
    case ${cf_zone_ssl:-} in
        "off") ssl_num=1
        ;;
        "flexible"|"") ssl_num=2
        ;;
        "full") ssl_num=3
        ;;
        "strict") ssl_num=4
        ;;
    esac
    while read -p "(默认: $ssl_num): " cf_zone_ssl_num
    do
        case $cf_zone_ssl_num in
            ""|2) 
                cf_zone_ssl='flexible'
                break
            ;;
            1) 
                cf_zone_ssl='off'
                break
            ;;
            3) 
                cf_zone_ssl='full'
                break
            ;;
            4) 
                cf_zone_ssl='strict'
                break
            ;;
            *) 
                Println "$error $i18n_input_correct_no\n"
            ;;
        esac
    done
    Println "  SSL 设置: ${green} $cf_zone_ssl ${normal}\n"
}

CloudflareGetUsers()
{
    cf_users_list=""
    cf_users_count=0
    cf_users_email=()
    cf_users_pass=()
    cf_users_token=()
    cf_users_api_key=()
    while IFS="^" read -r email pass token key
    do
        cf_users_count=$((cf_users_count+1))
        email=${email#\"}
        cf_users_email+=("$email")
        cf_users_pass+=("$pass")
        cf_users_token+=("$token")
        key=${key%\"}
        cf_users_api_key+=("$key")

        cf_users_list="$cf_users_list ${green}$cf_users_count.${normal}${indent_6}邮箱: ${green}$email${normal}  密码: ${green}$pass${normal}\n${indent_6}Token: ${green}${token:-无}${normal}\n${indent_6}Key: ${green}${key:-无}${normal}\n\n"
    done < <($JQ_FILE '.users[]|[.email,.pass,.token,.key]|join("^")' "$CF_CONFIG")
    return 0
}

CloudflareListUsers()
{
    if [ ! -s "$CF_CONFIG" ] 
    then
        Println "$error 请先添加用户\n" && exit 1
    fi

    CloudflareGetUsers

    if [ "$cf_users_count" -gt 0 ] 
    then
        Println "$cf_users_list"
    else
        Println "$error 没有用户\n"
    fi
}

CloudflareAddUser()
{
    CloudflareSetUserEmail
    CloudflareSetUserPass
    CloudflareSetUserToken
    CloudflareSetUserKey

    if [ ! -s "$CF_CONFIG" ] 
    then
        printf '{"%s":[],"%s":[]}' "users" "hosts" > "$CF_CONFIG"
    fi

    new_user=$(
    $JQ_FILE -n --arg email "$cf_user_email" --arg pass "$cf_user_pass" \
        --arg token "$cf_user_token" --arg key "$cf_user_api_key" \
        '{
            email: $email,
            pass: $pass,
            token: $token,
            key: $key
        }'
    )

    jq_path='["users"]'
    JQ add "$CF_CONFIG" "$new_user"
    Println "$info 用户添加成功\n"
}

CloudflareListUser()
{
    CloudflareListUsers

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    cf_user_email=${cf_users_email[cf_users_index]}
                    cf_user_pass=${cf_users_pass[cf_users_index]}
                    cf_user_token=${cf_users_token[cf_users_index]}
                    cf_user_api_key=${cf_users_api_key[cf_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ -n "$cf_user_api_key" ] 
    then
        curl_header_auth_email="X-Auth-Email: $cf_user_email"
        curl_header_auth_key="X-Auth-Key: $cf_user_api_key"
        curl_header_auth_token=""
    else
        curl_header_auth_email=""
        curl_header_auth_key=""
        curl_header_auth_token="Authorization: Bearer $cf_user_token"
    fi

    delimiters=( $'\001' )
    IFS=$'\002\t' read -r success error_message CF_ACCOUNT_ID < <(
    JQs flat "$(curl -s -X GET -H ''"$curl_header_auth_email"'' -H ''"$curl_header_auth_key"'' -H ''"$curl_header_auth_token"'' \
    -H 'Content-Type: application/json' https://api.cloudflare.com/client/v4/accounts)" '' \
    '[.success + "\u0002",
    (.errors|if . == "" then {} else . end).message + "\u0002",
    (.result|if . == "" then {} else . end).id + "\u0002"]
    |@tsv' "${delimiters[@]}")

    if [ "$success" == "false" ] 
    then
        Println "$error 获取账号 ID 失败: ${error_message//$'\001'/, }\n"
        exit 1
    fi

    end_epoch=$(date --utc -d 'tomorrow 00:00:00' +%s)
    start_epoch=$(date --utc -d 'today 00:00:00' +%s)
    start_date=$(date --utc --date="@$start_epoch" +'%Y-%m-%dT%H:%m:%SZ')
    end_date=$(date --utc --date="@$end_epoch" +'%Y-%m-%dT%H:%m:%SZ')

    PAYLOAD='{ "query":
    "query {
        viewer {
        accounts(filter: { accountTag: $accountTag }) {
        workersInvocationsAdaptive(
            filter: {
            datetime_geq: $datetimeStart,
            datetime_leq: $datetimeEnd
            }
            limit: 100
        ) {
            sum {
                requests
                subrequests
                errors
            }
            }
        }
        }
    }",'

    PAYLOAD="$PAYLOAD

    \"variables\": {
        \"accountTag\": \"$CF_ACCOUNT_ID\",
        \"datetimeStart\": \"$start_date\",
        \"datetimeEnd\": \"$end_date\"
    }
    }"

    delimiters=( $'\001' )
    IFS=$'\002\t' read -r cf_workers_requests error_message < <(
    JQs flat "$(curl -s -X POST -H ''"$curl_header_auth_email"'' -H ''"$curl_header_auth_key"'' -H ''"$curl_header_auth_token"'' \
    --data "$(echo $PAYLOAD)" -H 'Content-Type: application/json' https://api.cloudflare.com/client/v4/graphql)" '' \
    '[((.data|if . == "" then {} else . end).viewer.accounts.workersInvocationsAdaptive|if . == "" then {} else . end).sum.requests + "\u0002",
    (.errors|if . == "" then {} else . end).message + "\u0002"]|@tsv' "{delimiters[@]}")

    if [ -z "$cf_workers_requests" ] 
    then
        Println "$error 获取 workers 访问数失败: ${error_message//$'\001'/, }\n"
        exit 1
    fi

    Println "$info workers 访问总数: $cf_workers_requests\n"
}

CloudflareAddZone()
{
    CloudflareGetUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    CloudflareListHosts

    echo -e "选择 CFP"
    while read -p "$i18n_default_cancel" cf_hosts_num
    do
        case "$cf_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_hosts_num" -gt 0 ] && [ "$cf_hosts_num" -le "$cf_hosts_count" ]
                then
                    cf_hosts_index=$((cf_hosts_num-1))
                    cf_host_name=${cf_hosts_name[cf_hosts_index]}
                    cf_host_key=${cf_hosts_key[cf_hosts_index]}
                    cf_host_zone_name=${cf_hosts_zone_name[cf_hosts_index]}
                    IFS="|" read -r -a cf_host_zones_name <<< "$cf_host_zone_name"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$cf_users_list"

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    cf_user_email=${cf_users_email[cf_users_index]}
                    cf_user_pass=${cf_users_pass[cf_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 稍等..."
    result=""
    until [ "$result" == "success" ] 
    do
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        cf_user_unique_id=${random_number: -12}
        IFS="^" read -r result err_code msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
            -d 'act=user_create' \
            -d "host_key=$cf_host_key" \
            -d "cloudflare_email=$cf_user_email" \
            -d "cloudflare_pass=$cf_user_pass" \
            -d "unique_id=$cf_user_unique_id" \
            | $JQ_FILE '[.result,.err_code,.msg]|join("^")'
        ) || true

        result=${result#\"}
        msg=${msg%\"}
        if [ "$result" == "error" ] 
        then
            Println "$error $msg"
        fi
    done

    Println "请输入根域名"
    echo -e "$tip 如果域名已经由 cloudflare 解析, 请先到官方 cloudflare 面板中删除\n"
    while read -p "$i18n_default_cancel" cf_zone_name
    do
        if [ -z "$cf_zone_name" ] 
        then
            Println "$i18n_canceled...\n"
            exit 1
        elif [[ $cf_zone_name =~ ^([a-zA-Z0-9][\-a-zA-Z0-9]*\.)+[\-a-zA-Z0-9]{2,20}$ ]] 
        then
            Println "  域名: ${green} $cf_zone_name ${normal}\n"
            break
        else
            Println "$error 输入错误, 请输入根域名, 不能是二级域名"
        fi
    done

    for cf_host_zone_name in ${cf_host_zones_name[@]+"${cf_host_zones_name[@]}"}
    do
        if [ "$cf_host_zone_name" == "$cf_zone_name" ] 
        then
            Println "$error 域名已经存在\n"
            exit 1
        fi
    done

    CloudflareSetZoneResolve
    CloudflareSetZoneAlwaysUseHttps
    CloudflareSetZoneSsl

    new_zone=$(
    $JQ_FILE -n --arg name "$cf_zone_name" --arg resolve_to "$cf_zone_resolve_to" \
        --arg user_email "$cf_user_email" --arg user_unique_id "$cf_user_unique_id" \
        --arg always_use_https "$cf_zone_always_use_https" --arg ssl "$cf_zone_ssl" \
        '{
            name: $name,
            resolve_to: $resolve_to,
            user_email: $user_email,
            user_unique_id: $user_unique_id | tonumber,
            always_use_https: $always_use_https,
            ssl: $ssl
        }'
    )

    jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
    JQ add "$CF_CONFIG" "$new_zone"
    Println "$info 源站添加成功\n"
}

CloudflareListZones()
{
    CloudflareListHosts

    echo -e "选择 CFP"
    while read -p "$i18n_default_cancel" cf_hosts_num
    do
        case "$cf_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_hosts_num" -gt 0 ] && [ "$cf_hosts_num" -le "$cf_hosts_count" ]
                then
                    cf_hosts_index=$((cf_hosts_num-1))
                    cf_host_name=${cf_hosts_name[cf_hosts_index]}
                    cf_host_key=${cf_hosts_key[cf_hosts_index]}
                    cf_zones_count=${cf_hosts_zones_count[cf_hosts_index]}
                    cf_zone_name=${cf_hosts_zone_name[cf_hosts_index]}
                    cf_zone_resolve_to=${cf_hosts_zone_resolve_to[cf_hosts_index]}
                    cf_zone_user_email=${cf_hosts_zone_user_email[cf_hosts_index]}
                    cf_zone_user_unique_id=${cf_hosts_zone_user_unique_id[cf_hosts_index]}
                    cf_zone_always_use_https=${cf_hosts_zone_always_use_https[cf_hosts_index]}
                    cf_zone_ssl=${cf_hosts_zone_ssl[cf_hosts_index]}
                    cf_zone_subdomains=${cf_hosts_zone_subdomains[cf_hosts_index]}
                    IFS="|" read -r -a cf_zones_name <<< "$cf_zone_name"
                    IFS="|" read -r -a cf_zones_resolve_to <<< "$cf_zone_resolve_to"
                    IFS="|" read -r -a cf_zones_user_email <<< "$cf_zone_user_email"
                    IFS="|" read -r -a cf_zones_user_unique_id <<< "$cf_zone_user_unique_id"
                    IFS="|" read -r -a cf_zones_always_use_https <<< "${cf_zone_always_use_https}|"
                    IFS="|" read -r -a cf_zones_ssl <<< "${cf_zone_ssl}|"
                    IFS="|" read -r -a cf_zones_subdomains <<< "${cf_zone_subdomains}|"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    cf_zones_list=""
    for((i=0;i<cf_zones_count;i++));
    do
        cf_zones_list="$cf_zones_list ${green}$((i+1)).${normal}${indent_6}源站: ${green}${cf_zones_name[i]}${normal} 用户: ${green}${cf_zones_user_email[i]}${normal}\n${indent_6}始终 https: ${green}${cf_zones_always_use_https[i]:-off}${normal}  ssl: ${green}${cf_zones_ssl[i]:-flexible}${normal}\n\n"
    done

    [ -z "$cf_zones_list" ] && Println "$error 请先添加源站\n" && exit 1

    Println "$cf_zones_list"
}

CloudflareListZone()
{
    CloudflareListZones
}

CloudflareGetZone()
{
    IFS="^" read -r result cf_zone_hosted_cnames cf_zone_forward_tos cf_zone_ssl_status cf_zone_ssl_meta_tag msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_lookup' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        | $JQ_FILE '[.result,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),.response.ssl_status,.response.ssl_meta_tag,.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        Println "$error ${msg:-超时, 请重试}\n" && exit 1
    fi

    IFS="|" read -r -a cf_zone_hosted_cnames_arr <<< "$cf_zone_hosted_cnames"
    IFS="|" read -r -a cf_zone_forward_tos_arr <<< "$cf_zone_forward_tos"

    cf_hosted_cnames=()
    cf_resolve_tos=()
    cf_forward_tos=()

    for cf_zone_hosted_cname in "${cf_zone_hosted_cnames_arr[@]}"
    do
        cf_hosted_cname=${cf_zone_hosted_cname%%=*}
        cf_resolve_to=${cf_zone_hosted_cname#*=}
        cf_hosted_cnames+=("$cf_hosted_cname")
        cf_resolve_tos+=("$cf_resolve_to")
        for cf_zone_forward_to in "${cf_zone_forward_tos_arr[@]}"
        do
            if [ "${cf_zone_forward_to%%=*}" == "$cf_hosted_cname" ] 
            then
                cf_forward_tos+=("${cf_zone_forward_to#*=}")
                break
            fi
        done
    done
}

CloudflareMoveZone()
{
    CloudflareListZones

    echo -e "选择源站"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case "$cf_zones_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_zones_count" ]
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_zone_name=${cf_zones_name[cf_zones_index]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[cf_zones_index]}
                    cf_user_email=${cf_zones_user_email[cf_zones_index]}
                    cf_user_unique_id=${cf_zones_user_unique_id[cf_zones_index]}
                    cf_zone_always_use_https=${cf_zones_always_use_https[cf_zones_index]}
                    cf_zone_ssl=${cf_zones_ssl[cf_zones_index]}
                    cf_zone_subdomains=${cf_zones_subdomains[cf_zones_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    CloudflareGetUser

    CloudflareGetZone

    Println "$info 删除源站 ..."

    IFS="^" read -r result err_code msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_delete' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        | $JQ_FILE '[.result,.err_code,.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        if [ "$err_code" -eq 115 ] || [ "$err_code" -eq 703 ]
        then
            Println "$error 此用户已被 CFP 删除或未添加成功, 可以到 Cloudflare 官网手动删除源站或者重新添加 !"
        else
            Println "$error ${msg:-超时, 请重试}\n"
        fi
        exit 1
    else
        jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
        JQ delete "$CF_CONFIG" "$cf_zones_index"
        Println "$info $cf_zone_name 删除成功"
    fi

    CloudflareListHosts

    echo -e "选择移动到的 CFP"
    while read -p "$i18n_default_cancel" cf_hosts_num
    do
        case "$cf_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_hosts_num" -gt 0 ] && [ "$cf_hosts_num" -le "$cf_hosts_count" ]
                then
                    cf_hosts_index=$((cf_hosts_num-1))
                    cf_host_name=${cf_hosts_name[cf_hosts_index]}
                    cf_host_key=${cf_hosts_key[cf_hosts_index]}
                    cf_host_zone_name=${cf_hosts_zone_name[cf_hosts_index]}
                    IFS="|" read -r -a cf_host_zones_name <<< "$cf_host_zone_name"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    for cf_host_zone_name in "${cf_host_zones_name[@]}"
    do
        if [ "$cf_host_zone_name" == "$cf_zone_name" ] 
        then
            Println "$error 域名已经存在\n"
            return 0
        fi
    done

    CloudflareGetUsers

    Println "$cf_users_list"

    echo -e "选择移动到的用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    cf_user_email=${cf_users_email[cf_users_index]}
                    cf_user_pass=${cf_users_pass[cf_users_index]}
                    cf_user_api_key=${cf_users_api_key[cf_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 移动中 ..."
    cf_user_key=""
    until [ -n "$cf_user_key" ] 
    do
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        cf_user_unique_id=${random_number: -12}
        IFS="^" read -r result cf_user_key cf_user_api_key msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
            -d 'act=user_create' \
            -d "host_key=$cf_host_key" \
            -d "cloudflare_email=$cf_user_email" \
            -d "cloudflare_pass=$cf_user_pass" \
            -d "unique_id=$cf_user_unique_id" \
            | $JQ_FILE '[.result,.response.user_key,.response.user_api_key,.msg]|join("^")'
        ) || true

        result=${result#\"}
        msg=${msg%\"}
        if [ "$result" == "error" ] 
        then
            Println "$error $msg"
            if [[ $msg == *"assword"* ]] 
            then
                Println "$error 请检查密码是否正确\n"
                exit 1
            fi
        elif [ -z "${cf_users_api_key[cf_users_index]}" ] 
        then
            jq_path='["users",'"$cf_users_index"',"key"]'
            JQ update "$CF_CONFIG" "$cf_user_api_key"
            Println "$info 用户 $cf_user_email API Key 添加成功\n"
        fi
    done

    new_zone=$(
    $JQ_FILE -n --arg name "$cf_zone_name" --arg resolve_to "$cf_zone_resolve_to" \
        --arg user_email "$cf_user_email" --arg user_unique_id "$cf_user_unique_id" \
        --arg always_use_https "$cf_zone_always_use_https" --arg ssl "$cf_zone_ssl" --arg subdomains "$cf_zone_subdomains" \
        '{
            name: $name,
            resolve_to: $resolve_to,
            user_email: $user_email,
            user_unique_id: $user_unique_id | tonumber,
            always_use_https: $always_use_https,
            ssl: $ssl,
            subdomains: $subdomains
        }'
    )

    jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
    JQ add "$CF_CONFIG" "$new_zone"

    subdomains=""

    for((i=0;i<${#cf_hosted_cnames[@]};i++));
    do
        if [[ ${cf_hosted_cnames[i]} =~ ^([^.]+).([^.]+)$ ]] 
        then
            continue
        fi
        cf_hosted_cname=${cf_hosted_cnames[i]}
        cf_hosted_cname=${cf_hosted_cname%.*}
        cf_hosted_cname_prefix=${cf_hosted_cname%.*}
        [ -n "$subdomains" ] && subdomains="$subdomains,"
        subdomains="$subdomains$cf_hosted_cname_prefix:${cf_resolve_tos[i]}"
    done

    CloudflareGetUser

    IFS="^" read -r result cf_zone_resolving_to cf_zone_hosted_cnames cf_zone_forward_tos msg < <(curl -s -Lm 20 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_set' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        -d "resolve_to=$cf_zone_resolve_to" \
        -d "subdomains=$subdomains" \
        | $JQ_FILE '[.result,.response.resolving_to,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        Println "$error ${msg:-连接超时, 请查看是否已经完成}\n" && exit 1
    fi

    Println "$info 源站移动成功\n"
}

CloudflareGetUser()
{
    cf_user_key=""
    add_subdomains=0
    unset cf_users_i
    until [ -n "$cf_user_key" ] 
    do
        IFS="^" read -r result cf_user_key cf_user_api_key msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
            -d 'act=user_lookup' \
            -d "host_key=$cf_host_key" \
            -d "unique_id=$cf_user_unique_id" \
            | $JQ_FILE '[.result,.response.user_key,.response.user_api_key,.msg]|join("^")'
        ) || true

        if [ -n "$cf_user_api_key" ] && [ -n "${cf_users_i:-}" ] && [ -z "${cf_users_api_key[cf_users_i]}" ]
        then
            jq_path='["users",'"$cf_users_i"',"key"]'
            JQ update "$CF_CONFIG" "$cf_user_api_key"
            Println "$info 用户 ${cf_users_email[cf_users_i]} API Key 添加成功\n"
        fi

        result=${result#\"}
        msg=${msg%\"}

        if [ -z "$result" ] || [ "$result" == "error" ]
        then
            Println "$error ${msg:-超时, 请重试}\n" && exit 1
        fi

        if [ -z "$cf_user_key" ] 
        then
            if [ "${monitor:-0}" -eq 1 ] 
            then
                MonitorError "源站 $cf_zone_name 的用户已被 CFP 删除或未添加成功, 尝试重新添加 ..."
            fi
            Println "$error 源站 $cf_zone_name 的用户已被 CFP 删除或未添加成功, 尝试重新添加 ..."

            if [ -z "${cf_user_pass:-}" ] 
            then
                CloudflareGetUsers
                for((cf_users_i=0;cf_users_i<cf_users_count;cf_users_i++));
                do
                    if [ "${cf_users_email[cf_users_i]}" == "$cf_user_email" ] 
                    then
                        cf_user_pass=${cf_users_pass[cf_users_i]}
                        break
                    fi
                done
            fi

            if [ -z "${cf_user_pass:-}" ] 
            then
                Println "$error 请先添加账号 $cf_user_email\n"
                exit 1
            fi

            IFS="^" read -r result err_code msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
                -d 'act=user_create' \
                -d "host_key=$cf_host_key" \
                -d "cloudflare_email=$cf_user_email" \
                -d "cloudflare_pass=$cf_user_pass" \
                -d "unique_id=$cf_user_unique_id" \
                | $JQ_FILE '[.result,.err_code,.msg]|join("^")'
            ) 

            result=${result#\"}
            msg=${msg%\"}
            if [ "$result" == "error" ] 
            then
                Println "$error $msg"
            fi

            add_subdomains=1
        elif [ "$add_subdomains" -eq 1 ] && [ -n "${cf_zone_subdomains:-}" ]
        then
            IFS="^" read -r result cf_zone_resolving_to cf_zone_hosted_cnames cf_zone_forward_tos msg < <(curl -s -Lm 20 https://api.cloudflare.com/host-gw.html \
                -d 'act=zone_set' \
                -d "host_key=$cf_host_key" \
                -d "user_key=$cf_user_key" \
                -d "zone_name=$cf_zone_name" \
                -d "resolve_to=$cf_zone_resolve_to" \
                -d "subdomains=$cf_zone_subdomains" \
                | $JQ_FILE '[.result,.response.resolving_to,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
                |([.key,.value]|join("="))]
                |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
                |([.key,.value]|join("="))]
                |join("|")),.msg]|join("^")'
            ) || true

            result=${result#\"}
            msg=${msg%\"}

            if [ -z "$result" ] || [ "$result" == "error" ]
            then
                Println "$error ${msg:-连接超时, 请查看是否已经完成}\n"
            fi
        fi
    done
}

CloudflareAddSubdomain()
{
    CloudflareListZones

    echo -e "选择源站"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case "$cf_zones_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_zones_count" ]
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_zone_name=${cf_zones_name[cf_zones_index]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[cf_zones_index]}
                    cf_user_email=${cf_zones_user_email[cf_zones_index]}
                    cf_user_unique_id=${cf_zones_user_unique_id[cf_zones_index]}
                    cf_zone_always_use_https=${cf_zones_always_use_https[cf_zones_index]}
                    cf_zone_ssl=${cf_zones_ssl[cf_zones_index]}
                    cf_zone_subdomains=${cf_zones_subdomains[cf_zones_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    #cf_user_pass=$($JQ_FILE -r '.users[]|select(.email=="'"$cf_user_email"'") | .pass' $CF_CONFIG)

    #[ -z "$cf_user_pass" ] && Println "$error 用户 $cf_user_email 不存在\n" && exit 1

    CloudflareGetUser

    Println "请输入子域名前缀, 比如 www, 多个前缀用空格分隔"
    read -p "$i18n_default_cancel" cf_zone_subdomains_prefix_input
    [ -z "$cf_zone_subdomains_prefix_input" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  子域名: ${green} $cf_zone_subdomains_prefix_input ${normal}\n"

    IFS=" " read -r -a cf_zone_subdomains_prefix <<< "$cf_zone_subdomains_prefix_input"
    cf_zone_subdomains_resolve_to=()
    for cf_zone_subdomain_prefix in "${cf_zone_subdomains_prefix[@]}"
    do
        Println "请输入子域名 $cf_zone_subdomain_prefix.$cf_zone_name 经 cloudflare 中转后解析地址"
        read -p "(默认: $cf_zone_resolve_to): " cf_zone_subdomain_resolve_to
        cf_zone_subdomain_resolve_to=${cf_zone_subdomain_resolve_to:-$cf_zone_resolve_to}
        cf_zone_subdomains_resolve_to+=("$cf_zone_subdomain_resolve_to")
    done

    CloudflareGetZone
    for((i=0;i<${#cf_hosted_cnames[@]};i++));
    do
        if [[ ${cf_hosted_cnames[i]} =~ ^([^.]+).([^.]+)$ ]] 
        then
            continue
        fi

        for cf_zone_subdomain_prefix in "${cf_zone_subdomains_prefix[@]}"
        do
            if [ "$cf_zone_subdomain_prefix.$cf_zone_name" == "${cf_hosted_cnames[i]}" ] 
            then
                continue 2
            fi
        done

        cf_hosted_cname=${cf_hosted_cnames[i]}
        cf_hosted_cname=${cf_hosted_cname%.*}
        cf_hosted_cname_prefix=${cf_hosted_cname%.*}
        cf_zone_subdomains_prefix+=("$cf_hosted_cname_prefix")
        cf_zone_subdomains_resolve_to+=("${cf_resolve_tos[i]}")
    done

    subdomains=""

    for((i=0;i<${#cf_zone_subdomains_prefix[@]};i++));
    do
        [ -n "$subdomains" ] && subdomains="$subdomains,"
        if [ "${cf_zone_subdomains_resolve_to[i]}" != "$cf_zone_resolve_to" ] 
        then
            subdomains="$subdomains${cf_zone_subdomains_prefix[i]}:${cf_zone_subdomains_resolve_to[i]}"
        else
            subdomains="$subdomains${cf_zone_subdomains_prefix[i]}"
        fi
    done

    jq_path='["hosts",'"$cf_hosts_index"',"zones",'"$cf_zones_index"']'
    new_zone=$(
    $JQ_FILE -n --arg name "$cf_zone_name" --arg resolve_to "$cf_zone_resolve_to" \
        --arg user_email "$cf_user_email" --arg user_unique_id "$cf_user_unique_id" \
        --arg always_use_https "$cf_zone_always_use_https" --arg ssl "$cf_zone_ssl" --arg subdomains "$subdomains" \
        '{
            name: $name,
            resolve_to: $resolve_to,
            user_email: $user_email,
            user_unique_id: $user_unique_id | tonumber,
            always_use_https: $always_use_https,
            ssl: $ssl,
            subdomains: $subdomains
        }'
    )
    JQ replace "$CF_CONFIG" "$new_zone"

    Println "$info 稍等..."
    IFS="^" read -r result cf_zone_resolving_to cf_zone_hosted_cnames cf_zone_forward_tos msg < <(curl -s -Lm 20 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_set' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        -d "resolve_to=$cf_zone_resolve_to" \
        -d "subdomains=$subdomains" \
        | $JQ_FILE '[.result,.response.resolving_to,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        Println "$error ${msg:-连接超时, 请查看是否已经完成}\n" && exit 1
    fi

    IFS="|" read -r -a cf_zone_hosted_cnames_arr <<< "$cf_zone_hosted_cnames"
    IFS="|" read -r -a cf_zone_forward_tos_arr <<< "$cf_zone_forward_tos"

    cf_hosted_cnames=()
    cf_resolve_tos=()
    cf_forward_tos=()

    for cf_zone_hosted_cname in "${cf_zone_hosted_cnames_arr[@]}"
    do
        cf_hosted_cname=${cf_zone_hosted_cname%%=*}
        cf_resolve_to=${cf_zone_hosted_cname#*=}
        cf_hosted_cnames+=("$cf_hosted_cname")
        cf_resolve_tos+=("$cf_resolve_to")
        for cf_zone_forward_to in "${cf_zone_forward_tos_arr[@]}"
        do
            if [ "${cf_zone_forward_to%%=*}" == "$cf_hosted_cname" ] 
            then
                cf_forward_tos+=("${cf_zone_forward_to#*=}")
                break
            fi
        done
    done

    msg=""

    if [ "$cf_zone_resolving_to" != "$cf_zone_name" ] 
    then
        zone_found=0
        for cf_resolve_to in "${cf_resolve_tos[@]}"
        do
            if [ "$cf_resolve_to" == "$cf_zone_name" ] 
            then
                zone_found=1
                break
            fi
        done
        if [ "$zone_found" -eq 0 ] && [[ ${cf_forward_tos[0]} =~ ([^.]+).([^.]+).([^.]+)$ ]] 
        then
            cf_zone_name_resolve_to="$cf_zone_name.${BASH_REMATCH[1]}.${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
            msg="请添加域名 ${green}$cf_zone_name${normal} CNAME 记录到 ${green}$cf_zone_name_resolve_to${normal}\n\n"
        fi
    fi

    for((i=0;i<${#cf_hosted_cnames[@]};i++));
    do
        for cf_zone_subdomain_prefix in "${cf_zone_subdomains_prefix[@]}"
        do
            if [ "$cf_zone_subdomain_prefix.$cf_zone_name" == "${cf_hosted_cnames[i]}" ] 
            then
                msg="$msg请添加域名 ${green}${cf_hosted_cnames[i]}${normal} CNAME 记录到 ${green}${cf_forward_tos[i]}${normal}\n\n"
                break
            fi
        done
    done

    Println "$msg"
    Println "$info 子域名添加成功\n"
}

CloudflareListSubdomain()
{
    CloudflareListZones

    echo -e "选择源站"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case "$cf_zones_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_zones_count" ]
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_zone_name=${cf_zones_name[cf_zones_index]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[cf_zones_index]}
                    cf_user_email=${cf_zones_user_email[cf_zones_index]}
                    cf_user_unique_id=${cf_zones_user_unique_id[cf_zones_index]}
                    cf_zone_subdomains=${cf_zones_subdomains[cf_zones_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    #cf_user_pass=$($JQ_FILE -r '.users[]|select(.email=="'"$cf_user_email"'") | .pass' $CF_CONFIG)

    #[ -z "$cf_user_pass" ] && Println "$error 用户 $cf_user_email 不存在\n" && exit 1

    CloudflareGetUser
    CloudflareGetZone

    cf_subdomains_list=""
    for((i=0;i<${#cf_hosted_cnames[@]};i++));
    do
        cf_subdomains_list="$cf_subdomains_list ${green}$((i+1)).${normal}${indent_6}CNAME: ${green}${cf_hosted_cnames[i]}${normal} => ${green}${cf_forward_tos[i]}${normal}\n${indent_6}解析地址: ${green}${cf_resolve_tos[i]}${normal}\n\n"
    done

    if [ -z "$cf_subdomains_list" ] 
    then
        cf_subdomains_list="$error 没有子域名\n\n$tip 至少添加一个子域名才能激活源站 cloudflare 解析\n"
        ssl_status=""
        ssl_meta_tag=""
        if [ -n "$cf_zone_subdomains" ] 
        then
            IFS="^" read -r result cf_zone_resolving_to cf_zone_hosted_cnames cf_zone_forward_tos msg < <(curl -s -Lm 20 https://api.cloudflare.com/host-gw.html \
                -d 'act=zone_set' \
                -d "host_key=$cf_host_key" \
                -d "user_key=$cf_user_key" \
                -d "zone_name=$cf_zone_name" \
                -d "resolve_to=$cf_zone_resolve_to" \
                -d "subdomains=$cf_zone_subdomains" \
                | $JQ_FILE '[.result,.response.resolving_to,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
                |([.key,.value]|join("="))]
                |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
                |([.key,.value]|join("="))]
                |join("|")),.msg]|join("^")'
            ) || true

            result=${result#\"}
            msg=${msg%\"}

            if [ -z "$result" ] || [ "$result" == "error" ]
            then
                Println "$error ${msg:-连接超时, 请查看是否已经完成}\n"
            fi

            CloudflareGetZone

            cf_subdomains_list=""
            for((i=0;i<${#cf_hosted_cnames[@]};i++));
            do
                cf_subdomains_list="$cf_subdomains_list ${green}$((i+1)).${normal}${indent_6}CNAME: ${green}${cf_hosted_cnames[i]}${normal} => ${green}${cf_forward_tos[i]}${normal}\n${indent_6}解析地址: ${green}${cf_resolve_tos[i]}${normal}\n\n"
            done

            if [ "$cf_zone_ssl_status" == "ready" ] 
            then
                ssl_status="SSL 状态: ${green}激活${normal}\n"
                ssl_meta_tag=""
            else
                ssl_status="SSL 状态: ${red}无${normal}\n"
                if [ -n "$cf_zone_ssl_meta_tag" ]
                then
                    ssl_meta_tag="\n请在子域名页面 HEAD 处添加 ${green}$cf_zone_ssl_meta_tag${normal} 以激活 ssl\n"
                else
                    ssl_meta_tag=""
                fi
            fi

            Println "${cf_subdomains_list}$ssl_status$ssl_meta_tag"
        fi
    elif [ "$cf_zone_ssl_status" == "ready" ] 
    then
        ssl_status="SSL 状态: ${green}激活${normal}\n"
        ssl_meta_tag=""
    else
        ssl_status="SSL 状态: ${red}无${normal}\n"
        if [ -n "$cf_zone_ssl_meta_tag" ]
        then
            ssl_meta_tag="\n请在子域名页面 HEAD 处添加 ${green}$cf_zone_ssl_meta_tag${normal} 以激活 ssl\n"
        else
            ssl_meta_tag=""
        fi
    fi

    Println "${cf_subdomains_list}$ssl_status$ssl_meta_tag"
}

CloudflareDelZone()
{
    CloudflareListZones

    echo -e "选择源站"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case "$cf_zones_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_zones_count" ]
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_zone_name=${cf_zones_name[cf_zones_index]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[cf_zones_index]}
                    cf_user_email=${cf_zones_user_email[cf_zones_index]}
                    cf_user_unique_id=${cf_zones_user_unique_id[cf_zones_index]}
                    cf_zone_subdomains=${cf_zones_subdomains[cf_zones_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    CloudflareGetUser
    Println "$info 稍等..."
    IFS="^" read -r result err_code msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_delete' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        | $JQ_FILE '[.result,.err_code,.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        if [ "$err_code" -eq 115 ] || [ "$err_code" -eq 703 ]
        then
            Println "$error 此用户已被 CFP 删除或未添加成功, 可以到 Cloudflare 官网手动删除源站或者重新添加 !"
        else
            Println "$error ${msg:-超时, 请重试}\n"
        fi
        echo
        AskIfContinue n "`gettext \"是否仍要删除此源站, 只有这里和官网都删除才能重新添加此源站\"`"

        jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
        JQ delete "$CF_CONFIG" "$cf_zones_index"
        Println "$info $cf_zone_name 删除成功\n"
    else
        jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
        JQ delete "$CF_CONFIG" "$cf_zones_index"
        Println "$info $cf_zone_name 删除成功\n"
    fi
}

CloudflareDelHost()
{
    CloudflareListHosts

    echo -e "选择 CFP"
    while read -p "$i18n_default_cancel" cf_hosts_num
    do
        case "$cf_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_hosts_num" -gt 0 ] && [ "$cf_hosts_num" -le "$cf_hosts_count" ]
                then
                    cf_hosts_index=$((cf_hosts_num-1))
                    cf_host_name=${cf_hosts_name[cf_hosts_index]}
                    cf_host_key=${cf_hosts_key[cf_hosts_index]}
                    cf_zones_count=${cf_hosts_zones_count[cf_hosts_index]}
                    cf_zone_name=${cf_hosts_zone_name[cf_hosts_index]}
                    cf_zone_user_unique_id=${cf_hosts_zone_user_unique_id[cf_hosts_index]}
                    IFS="|" read -r -a cf_zones_name <<< "$cf_zone_name"
                    IFS="|" read -r -a cf_zones_user_unique_id <<< "$cf_zone_user_unique_id"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ "$cf_zones_count" -gt 0 ] 
    then
        echo
        AskIfContinue n "`gettext \"是否删除此 CFP 下所有的源站\"`"

        for((i=0;i<${#cf_zones_name[@]};i++));
        do
            cf_zone_name=${cf_zones_name[i]}
            cf_user_unique_id=${cf_zones_user_unique_id[i]}

            CloudflareGetUser

            IFS="^" read -r result msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
                -d 'act=zone_delete' \
                -d "host_key=$cf_host_key" \
                -d "user_key=$cf_user_key" \
                -d "zone_name=$cf_zone_name" \
                | $JQ_FILE '[.result,.msg]|join("^")'
            ) || true

            result=${result#\"}
            msg=${msg%\"}

            if [ -z "$result" ] || [ "$result" == "error" ]
            then
                Println "$error 删除 $cf_zone_name 发送错误: ${msg:-超时, 请重试}\n" && exit 1
            fi

            jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
            JQ delete "$CF_CONFIG" "$i"

            Println "$info $cf_zone_name 删除成功\n"
        done
    fi
}

CloudflareEditUser()
{
    CloudflareListUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    cf_user_email=${cf_users_email[cf_users_index]}
                    cf_user_pass=${cf_users_pass[cf_users_index]}
                    cf_user_token=${cf_users_token[cf_users_index]}
                    cf_user_api_key=${cf_users_api_key[cf_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "请输入用户邮箱"
    read -p "(默认: $cf_user_email): " cf_user_email_new
    cf_user_email_new=${cf_user_email_new:-$cf_user_email}
    Println "  用户邮箱: ${green} $cf_user_email_new ${normal}\n"

    Println "请输入用户密码"
    read -p "(默认: $cf_user_pass): " cf_user_pass_new
    cf_user_pass_new=${cf_user_pass_new:-$cf_user_pass}
    Println "  用户密码: ${green} $cf_user_pass_new ${normal}\n"

    Println "请输入用户 Token"
    read -p "(默认: ${cf_user_token:-不设置}): " cf_user_token_new
    cf_user_token_new=${cf_user_token_new:-$cf_user_token}
    Println "  用户 Token: ${green} ${cf_user_token_new:-不设置} ${normal}\n"

    Println "请输入用户 Key"
    read -p "(默认: ${cf_user_api_key:-不设置}): " cf_user_api_key_new
    cf_user_api_key_new=${cf_user_api_key_new:-$cf_user_api_key}
    Println "  用户 Token: ${green} ${cf_user_api_key_new:-不设置} ${normal}\n"

    new_user=$(
    $JQ_FILE -n --arg email "$cf_user_email_new" --arg pass "$cf_user_pass_new" \
        --arg token "$cf_user_token_new" --arg key "$cf_user_api_key_new" \
        '{
            email: $email,
            pass: $pass,
            token: $token,
            key: $key
        }'
    )

    jq_path='["users",'"$cf_users_index"']'
    JQ replace "$CF_CONFIG" "$new_user"
    Println "$info 用户修改成功\n"
}

CloudflareRegenHost()
{
    CloudflareListHosts

    echo "选择 CFP"
    echo -e "$tip 请勿更改公开的 CFP !\n"
    while read -p "$i18n_default_cancel" cf_hosts_num
    do
        case "$cf_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_hosts_num" -gt 0 ] && [ "$cf_hosts_num" -le "$cf_hosts_count" ]
                then
                    cf_hosts_index=$((cf_hosts_num-1))
                    cf_host_name=${cf_hosts_name[cf_hosts_index]}
                    cf_host_key=${cf_hosts_key[cf_hosts_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 稍等..."
    IFS="^" read -r result cf_host_key_new msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=host_key_regen' \
        -d "host_key=$cf_host_key" \
        | $JQ_FILE '[.result,.request."host:key".__host_key,.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        Println "$error ${msg:-超时, 请重试}\n" && exit 1
    fi

    jq_path='["hosts",'"$cf_hosts_index"',"key"]'
    JQ update "$CF_CONFIG" "$cf_host_key_new"

    Println "$info $cf_host_name host key 修改成功"
}

CloudflareListToken()
{
    CloudflareListUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    cf_user_email=${cf_users_email[cf_users_index]}
                    cf_user_pass=${cf_users_pass[cf_users_index]}
                    cf_user_api_key=${cf_users_api_key[cf_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ -z "$cf_user_api_key" ] 
    then
        Println "$error 此用户没有 Global API Key, 请手动添加\n"
        exit 1
    fi

    IFS="#" read -r success token < <(curl -s \
        -X GET "https://api.cloudflare.com/client/v4/user/tokens?page=1&per_page=50&direction=desc" \
        -H "X-Auth-Email:$cf_user_email" \
        -H "X-Auth-Key:$cf_user_api_key" \
        -H "Content-Type: application/json" \
        | $JQ_FILE '[.success,(.result|to_entries|map([.value.id,.value.name,.value.status,([.value.policies[].permission_groups[].name]|join(", "))]|join("|"))|join("^"))]|join("#")' 2> /dev/null
    ) || true

    success=${success#\"}
    token=${token%\"}

    if [ "$success" != "true" ] 
    then
        Println "$error 获取 Token 错误, 必须是 Global API Key 才可以获取用户 Token \n"
        exit 1
    fi

    IFS="^" read -r -a tokens <<< "$token"
    tokens_count=${#tokens[@]}
    tokens_list=""
    tokens_id=()

    for((i=0;i<tokens_count;i++));
    do
        IFS="|" read -r token_id token_name token_status token_permission <<< "${tokens[i]}"
        tokens_id+=("$token_id")
        tokens_list="$tokens_list ${green}$((i+1)).${normal}${indent_6}名称: ${green}$token_name${normal}  状态: ${green}$token_status${normal}\n${indent_6}权限: ${green}${token_permission:-无}${normal}\n\n"
    done

    Println "$tokens_list"
}

CloudflareAddToken()
{
    CloudflareListToken

    echo -e "选择 Token"

    while read -p "$i18n_default_cancel" tokens_num
    do
        case $tokens_num in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *) 
                if [ "$tokens_num" -gt 0 ] && [ "$tokens_num" -le "$tokens_count" ] 
                then
                    tokens_index=$((tokens_num-1))
                    token_id=${tokens_id[tokens_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    echo
    AskIfContinue n "`gettext \"需要更新此 Token 后才能添加到脚本, 是否继续\"`"

    Println "$info 更新 Token"
    cf_user_token_new=$(curl -s -X PUT https://api.cloudflare.com/client/v4/user/tokens/$token_id/value \
        -H "X-Auth-Email:$cf_user_email" \
        -H "X-Auth-Key:$cf_user_api_key" \
        -H "Content-Type: application/json" \
        --data '{}' | $JQ_FILE -r '.result'
    ) || true

    if [ -z "$cf_user_token_new" ] || [ "$cf_user_token_new" == null ]
    then
        Println "$error 更新 Token 失败\n"
    else
        Println "$info Token 更新成功: $cf_user_token_new"
        jq_path='["users",'"$cf_users_index"',"token"]'
        JQ update "$CF_CONFIG" "$cf_user_token_new"
        Println "$info 用户 Token 添加成功\n"
    fi
}

CloudflareUpdateToken()
{
    CloudflareListToken

    echo -e "选择 Token"

    while read -p "$i18n_default_cancel" tokens_num
    do
        case $tokens_num in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *) 
                if [ "$tokens_num" -gt 0 ] && [ "$tokens_num" -le "$tokens_count" ] 
                then
                    tokens_index=$((tokens_num-1))
                    token_id=${tokens_id[tokens_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 更新 Token"
    cf_user_token_new=$(curl -s -X PUT https://api.cloudflare.com/client/v4/user/tokens/$token_id/value \
        -H "X-Auth-Email:$cf_user_email" \
        -H "X-Auth-Key:$cf_user_api_key" \
        -H "Content-Type: application/json" \
        --data '{}' | $JQ_FILE -r '.result'
    ) || true
    if [ -z "$cf_user_token_new" ] || [ "$cf_user_token_new" == null ]
    then
        Println "$error 更新 Token 失败\n"
    else
        Println "$info Token 更新成功: $cf_user_token_new\n"
    fi
}

CloudflareDelUser()
{
    CloudflareListUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" cf_users_num
    do
        case "$cf_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_users_num" -gt 0 ] && [ "$cf_users_num" -le "$cf_users_count" ]
                then
                    cf_users_index=$((cf_users_num-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    jq_path='["users"]'
    JQ delete "$CF_CONFIG" "$cf_users_index"
    Println "$info 用户删除成功\n"
}

CloudflareEditZone()
{
    CloudflareListZones

    echo -e "选择源站"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case "$cf_zones_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_zones_count" ]
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_zone_name=${cf_zones_name[cf_zones_index]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[cf_zones_index]}
                    cf_user_email=${cf_zones_user_email[cf_zones_index]}
                    cf_user_unique_id=${cf_zones_user_unique_id[cf_zones_index]}
                    cf_zone_always_use_https=${cf_zones_always_use_https[cf_zones_index]}
                    cf_zone_ssl=${cf_zones_ssl[cf_zones_index]}
                    cf_zone_subdomains=${cf_zones_subdomains[cf_zones_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "  选择需要修改的设置

  ${green}1.${normal} Always Use HTTPS
  ${green}2.${normal} SSL

  "
    while read -p "$i18n_default_cancel" zone_edit_num
    do
        case $zone_edit_num in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            1) 
                CloudflareSetZoneAlwaysUseHttps
                break
            ;;
            2) 
                CloudflareSetZoneSsl
                break
            ;;
            *) 
                Println "$error $i18n_input_correct_no\n"
            ;;
        esac
    done

    new_zone=$(
    $JQ_FILE -n --arg name "$cf_zone_name" --arg resolve_to "$cf_zone_resolve_to" \
        --arg user_email "$cf_user_email" --arg user_unique_id "$cf_user_unique_id" \
        --arg always_use_https "${cf_zone_always_use_https:-off}" --arg ssl "${cf_zone_ssl:-flexible}" --arg subdomains "$cf_zone_subdomains" \
        '{
            name: $name,
            resolve_to: $resolve_to,
            user_email: $user_email,
            user_unique_id: $user_unique_id | tonumber,
            always_use_https: $always_use_https,
            ssl: $ssl,
            subdomains: $subdomains
        }'
    )

    jq_path='["hosts",'"$cf_hosts_index"',"zones",'"$cf_zones_index"']'
    JQ replace "$CF_CONFIG" "$new_zone"
    Println "$info 源站修改成功\n"
}

CloudflarePartnerMenu()
{
    Println "  cloudflare 面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 查看 源站 CNAME
  ${green}2.${normal} 添加 源站 CNAME
  ${green}3.${normal} 查看 源站
  ${green}4.${normal} 添加 源站
  ${green}5.${normal} 设置 源站
  ${green}6.${normal} 移动 源站
  ${green}7.${normal} 查看 用户
  ${green}8.${normal} 添加 用户
  ${green}9.${normal} 更改 用户
 ${green}10.${normal} 查看 用户 Token
 ${green}11.${normal} 添加 用户 Token
 ${green}12.${normal} 更新 用户 Token
 ${green}13.${normal} 查看 CFP
 ${green}14.${normal} 添加 CFP
 ${green}15.${normal} 更改 CFP
 ${green}16.${normal} 删除 源站
 ${green}17.${normal} 删除 用户
 ${green}18.${normal} 删除 CFP
 ${green}19.${normal} 获取最优 IP
 ${green}20.${normal} 更新脚本

 $tip 当前: ${green}partner${normal} 面板
 $tip 输入: w 切换到 workers 面板\n\n"
    read -p "`gettext \"输入序号\"` [1-20]: " cloudflare_partner_num
    case $cloudflare_partner_num in
        w)
            CloudflareWorkersMenu
        ;;
        1) CloudflareListSubdomain
        ;;
        2) CloudflareAddSubdomain
        ;;
        3) CloudflareListZone
        ;;
        4) CloudflareAddZone
        ;;
        5) CloudflareEditZone
        ;;
        6) CloudflareMoveZone
        ;;
        7) CloudflareListUser
        ;;
        8) CloudflareAddUser
        ;;
        9) CloudflareEditUser
        ;;
        10) CloudflareListToken
        ;;
        11) CloudflareAddToken
        ;;
        12) CloudflareUpdateToken
        ;;
        13) CloudflareListHost
        ;;
        14) CloudflareAddHost
        ;;
        15) CloudflareRegenHost
        ;;
        16) CloudflareDelZone
        ;;
        17) CloudflareDelUser
        ;;
        18) CloudflareDelHost
        ;;
        19) 
            Println "$info 一键获取最优 IP 脚本 Mac/Linux: \n\nhttps://github.com/woniuzfb/cloudflare-fping\n"
        ;;
        20) ShFileUpdate cloudflare
        ;;
        *) Println "$error $i18n_input_correct_number [1-20]\n"
        ;;
    esac
}

WranglerInstall()
{
    if [[ -x $(command -v cargo) ]] 
    then
        echo
        inquirer list_input "检测到 cargo, 是否使用 cargo 安装 wrangler, 否则使用 npm 安装" ny_options user_cargo_yn

        if [[ $user_cargo_yn == "$i18n_yes" ]] 
        then
            cargo install wrangler
            Println "$info wrangler 安装成功\n"
            exit 0
        fi
    fi
    if [[ ! -x $(command -v node) ]] || [[ ! -x $(command -v npm) ]] 
    then
        NodejsInstall
    fi
    Println "$info 国内可能会因网络原因安装失败, 可以手动下载 wrangler 覆盖 ~/.wrangler/bin/wrangler ...\n"
    npm i @cloudflare/wrangler -g --unsafe-perm=true --allow-root
    Println "$info wrangler 安装成功\n"
}

WranglerUpdate()
{
    if [[ ! -x $(command -v wrangler) ]] 
    then
        Println "$error wrangler 未安装\n"
        exit 1
    fi
    if [[ -x $(command -v cargo) ]] 
    then
        echo
        inquirer list_input "检测到 cargo, 是否使用 cargo 更新 wrangler, 否则使用 npm 更新" ny_options user_cargo_yn

        if [[ $user_cargo_yn == "$i18n_yes" ]] 
        then
            cargo install wrangler --force
            Println "$info wrangler 更新成功\n"
            exit 0
        fi
    fi
    if [[ ! -x $(command -v node) ]] || [[ ! -x $(command -v npm) ]] 
    then
        NodejsInstall
    fi
    npm uninstall -g @cloudflare/wrangler && npm install -g @cloudflare/wrangler --unsafe-perm=true --allow-root
    Println "$info wrangler 更新成功\n"
}

CloudflareSetWorkerName()
{
    Println "请输入 cloudflare worker 名称"
    read -p "$i18n_default_cancel" cf_worker_name
    [ -z "$cf_worker_name" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  worker 名称: ${green} $cf_worker_name ${normal}\n"
}

CloudflareSetWorkerPath()
{
    Println "请输入 cloudflare worker 路径名称"
    while read -p "$i18n_default_cancel" cf_worker_path 
    do
        case $cf_worker_path in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9A-Za-z_-.@]*) 
                Println "$error 路径格式错误\n"
            ;;
            *) 
                break
            ;;
        esac
    done
    Println "  worker 路径: ${green} $cf_worker_path ${normal}\n"
}

CloudflareSetWorkerProjectName()
{
    Println "请输入 cloudflare worker 项目名称"
    while read -p "(默认: 随机): " cf_worker_project_name 
    do
        case $cf_worker_project_name in
            "") 
                printf -v cf_worker_project_name '%(%s)T' -1
                cf_worker_project_name="$(RandStr)_$cf_worker_project_name"
                break
            ;;
            *) 
                if [[ $cf_worker_project_name =~ ^[A-Za-z0-9](([a-zA-Z0-9\_\-]{0,61})[A-Za-z0-9])?$ ]] 
                then
                    cf_worker_project_name=$(tr '[:upper:]' '[:lower:]' <<< "$cf_worker_project_name")
                    break
                else
                    Println "$error 项目名称格式错误\n"
                fi
            ;;
        esac
    done
    Println "  worker 项目名称: ${green} $cf_worker_project_name ${normal}\n"
}

CloudflareAddWorker()
{
    if [ ! -s "$CF_CONFIG" ] 
    then
        printf '{"%s":[],"%s":[],"%s":[]}' "users" "hosts" "workers" > "$CF_CONFIG"
    fi

    [ ! -d "$CF_WORKERS_ROOT" ] && mkdir -p "$CF_WORKERS_ROOT"
    cd "$CF_WORKERS_ROOT"

    Println "
  ${green}1.${normal} stream proxy ( 适用于 IBM CF 中转加速 )
  ${green}2.${normal} xtream codes proxy
  ${green}3.${normal} 自定义 worker

    "
    while read -p "选择 worker: " add_cf_worker_num 
    do
        case $add_cf_worker_num in
            1) 
                if [ ! -d "$CF_WORKERS_ROOT/stream_proxy" ] 
                then
                    wrangler generate "stream_proxy"
                    wget --timeout=10 --tries=1 --no-check-certificate "$STREAM_PROXY_LINK" -qO "$CF_WORKERS_ROOT/stream_proxy/index.js" \
                    || wget --timeout=10 --tries=3 --no-check-certificate "$STREAM_PROXY_LINK_BACKUP" -qO "$CF_WORKERS_ROOT/stream_proxy/index.js"
                fi

                CloudflareSetWorkerName
                cf_worker_path="stream_proxy"
                CloudflareSetWorkerProjectName
                break
            ;;
            2) 
                if [ ! -d "$CF_WORKERS_ROOT/xtream_codes_proxy" ] 
                then
                    wrangler generate "xtream_codes_proxy"
                    wget --timeout=10 --tries=1 --no-check-certificate "$XTREAM_CODES_PROXY_LINK" -qO "$CF_WORKERS_ROOT/xtream_codes_proxy/index.js" \
                    || wget --timeout=10 --tries=3 --no-check-certificate "$XTREAM_CODES_PROXY_LINK_BACKUP" -qO "$CF_WORKERS_ROOT/xtream_codes_proxy/index.js"
                fi

                CloudflareSetWorkerName
                cf_worker_path="xtream_codes_proxy"
                CloudflareSetWorkerProjectName
                break
            ;;
            3) 
                CloudflareListWorkers
                CloudflareSetWorkerName
                CloudflareSetWorkerPath
                CloudflareSetWorkerProjectName

                if [ -d "$CF_WORKERS_ROOT/$cf_worker_path" ] 
                then
                    echo
                    AskIfContinue n "`gettext \"路径已经存在, 是否仍要添加\"`"
                else
                    wrangler generate "$cf_worker_path"
                fi
                break
            ;;
            *) 
                Println "$error $i18n_input_correct_no\n"
            ;;
        esac
    done

    new_worker=$(
    $JQ_FILE -n --arg name "$cf_worker_name" --arg path "$cf_worker_path" --arg project_name "$cf_worker_project_name" \
        '{
            name: $name,
            path: $path,
            project_name: $project_name
        }'
    )
    jq_path='["workers"]'
    JQ add "$CF_CONFIG" "$new_worker"
    Println "$info worker: $cf_worker_name 添加成功\n"
}

CloudflareGetWorkers()
{
    cf_workers_list=""
    cf_workers_count=0
    cf_workers_name=()
    cf_workers_path=()
    cf_workers_project_name=()
    while IFS=" " read -r name path project_name
    do
        cf_workers_count=$((cf_workers_count+1))
        name=${name#\"}
        cf_workers_name+=("$name")
        cf_workers_path+=("$path")
        project_name=${project_name%\"}
        cf_workers_project_name+=("$project_name")

        cf_workers_list="$cf_workers_list ${green}$cf_workers_count.${normal}${indent_6}名称: ${green}$name${normal}  路径: ${green}$path${normal}\n${indent_6}项目名称: ${green}$project_name${normal}\n\n"
    done < <($JQ_FILE '(.workers| if .== null then [] else . end)[]|[.name,.path,.project_name]|join(" ")' "$CF_CONFIG")
    return 0
}

CloudflareListWorkers()
{
    if [ ! -s "$CF_CONFIG" ] 
    then
        Println "$error 请先添加 worker\n" && exit 1
    fi

    CloudflareGetWorkers

    if [ "$cf_workers_count" -gt 0 ] 
    then
        Println "$cf_workers_list"
    else
        Println "$error 没有 worker\n"
    fi
}

CloudflareListWorker()
{
    CloudflareListWorkers
}

CloudflareEditWorker()
{
    CloudflareListWorkers

    if [ "$cf_workers_count" -eq 0 ] 
    then
        echo -e "$error 请先添加 worker\n"
        exit 1
    fi

    echo -e "选择 worker"
    while read -p "$i18n_default_cancel" cf_workers_num
    do
        case "$cf_workers_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_workers_num" -gt 0 ] && [ "$cf_workers_num" -le "$cf_workers_count" ]
                then
                    cf_workers_index=$((cf_workers_num-1))
                    cf_worker_name=${cf_workers_name[cf_workers_index]}
                    cf_worker_path=${cf_workers_path[cf_workers_index]}
                    cf_worker_project_name=${cf_workers_project_name[cf_workers_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "请输入 cloudflare worker 名称"
    read -p "(默认: $cf_worker_name): " cf_worker_name_new
    cf_worker_name_new=${cf_worker_name_new:-$cf_worker_name}
    Println "  worker 名称: ${green} $cf_worker_name_new ${normal}\n"

    Println "请输入 cloudflare worker 路径名称"
    while read -p "(默认: $cf_worker_path): " cf_worker_path_new 
    do
        case $cf_worker_path_new in
            "") 
                cf_worker_path_new=$cf_worker_path
                break
            ;;
            *[!0-9A-Za-z_-]*) 
                Println "$error 路径格式错误\n"
            ;;
            *) 
                if [ "$cf_worker_path_new" == "$cf_worker_path" ] 
                then
                    break
                elif [ -d "$CF_WORKERS_ROOT/$cf_worker_path_new" ] 
                then
                    echo
                    inquirer list_input "路径已经存在, 是否仍要修改" ny_options force_edit_yn

                    if [[ $force_edit_yn == "$i18n_no" ]] 
                    then
                        continue
                    else
                        if [ -d "$CF_WORKERS_ROOT/$cf_worker_path" ] 
                        then
                            echo
                            inquirer list_input "是否删除原路径目录" yn_options delete_old_path_yn

                            if [[ $delete_old_path_yn == "$i18n_yes" ]] 
                            then
                                rm -rf "$CF_WORKERS_ROOT/${cf_worker_path:-notfound}"
                            fi  
                        fi
                        break
                    fi
                else
                    if [ "$cf_worker_path" == "stream_proxy" ] || [ "$cf_worker_path" == "xc_proxy" ]
                    then
                        cp -r "$CF_WORKERS_ROOT/$cf_worker_path" "$CF_WORKERS_ROOT/$cf_worker_path_new"
                    else
                        mv "$CF_WORKERS_ROOT/$cf_worker_path" "$CF_WORKERS_ROOT/$cf_worker_path_new"
                    fi
                    break
                fi
            ;;
        esac
    done
    Println "  worker 路径: ${green} $cf_worker_path_new ${normal}\n"

    Println "请输入 cloudflare worker 项目名称"
    while read -p "(默认: $cf_worker_project_name): " cf_worker_project_name_new
    do
        case $cf_worker_project_name_new in
            "") 
                cf_worker_project_name_new=$cf_worker_project_name
                break
            ;;
            *) 
                if [[ $cf_worker_project_name_new =~ ^[A-Za-z0-9](([a-zA-Z0-9\_\-]{0,61})[A-Za-z0-9])?$ ]] 
                then
                    cf_worker_project_name_new=$(tr '[:upper:]' '[:lower:]' <<< "$cf_worker_project_name_new")
                    break
                else
                    Println "$error 项目名称格式错误\n"
                fi
            ;;
        esac
    done
    Println "  worker 项目名称: ${green} $cf_worker_project_name_new ${normal}\n"

    new_worker=$(
    $JQ_FILE -n --arg name "$cf_worker_name_new" --arg path "$cf_worker_path_new" \
        --arg project_name "$cf_worker_project_name_new" \
        '{
            name: $name,
            path: $path,
            project_name: $project_name
        }'
    )

    jq_path='["workers",'"$cf_workers_index"']'
    JQ replace "$CF_CONFIG" "$new_worker"
    Println "$info worker 修改成功\n"
}

CloudflareDelWorker()
{
    CloudflareListWorkers

    if [ "$cf_workers_count" -eq 0 ] 
    then
        echo -e "$error 请先添加 worker\n"
        exit 1
    fi

    echo -e "选择 worker"
    while read -p "$i18n_default_cancel" cf_workers_num
    do
        case "$cf_workers_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_workers_num" -gt 0 ] && [ "$cf_workers_num" -le "$cf_workers_count" ]
                then
                    cf_workers_index=$((cf_workers_num-1))
                    cf_worker_name=${cf_workers_name[cf_workers_index]}
                    cf_worker_path=${cf_workers_path[cf_workers_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ -d "$CF_WORKERS_ROOT/$cf_worker_path" ] 
    then
        echo
        inquirer list_input "是否删除 worker 目录 $CF_WORKERS_ROOT/$cf_worker_path" ny_options del_cf_worker_path

        if [[ $del_cf_worker_path == "$i18n_yes" ]] 
        then
            rm -rf "$CF_WORKERS_ROOT/${cf_worker_path:-notfound}"
        fi
    fi

    jq_path='["workers"]'
    JQ delete "$CF_CONFIG" "$cf_workers_index"
    Println "$info worker: $cf_worker_name 删除成功\n"
}

CloudflareDeployWorker()
{
    CloudflareListWorkers

    if [ "$cf_workers_count" -eq 0 ] 
    then
        echo -e "$error 请先添加 worker\n"
        exit 1
    fi

    echo -e "选择 worker"
    while read -p "$i18n_default_cancel" cf_workers_num
    do
        case "$cf_workers_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$cf_workers_num" -gt 0 ] && [ "$cf_workers_num" -le "$cf_workers_count" ]
                then
                    cf_workers_index=$((cf_workers_num-1))
                    cf_worker_name=${cf_workers_name[cf_workers_index]}
                    cf_worker_path=${cf_workers_path[cf_workers_index]}
                    cf_worker_project_name=${cf_workers_project_name[cf_workers_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ ! -d "$CF_WORKERS_ROOT/$cf_worker_path" ] 
    then
        Println "$error worker 目录: $CF_WORKERS_ROOT/$cf_worker_path 不存在\n"
        exit 1
    fi

    CloudflareListUsers

    echo -e " ${green}$((cf_users_count+1)).${normal}${indent_6}全部"

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    cf_users_indices=()
    Println "选择用户, 多个用户用空格分隔, 比如 5 7 9-11"
    while read -p "$i18n_default_cancel" cf_users_num 
    do
        [ -z "$cf_users_num" ] && Println "$i18n_canceled...\n" && exit 1

        if [[ $cf_users_num -eq $((cf_users_count+1)) ]] 2> /dev/null
        then
            for((i=0;i<cf_users_count;i++));
            do
                cf_users_indices+=("$i")
            done
            break
        fi

        IFS=" " read -ra cf_users_num_arr <<< "$cf_users_num"

        error_no=0
        for cf_user_num in "${cf_users_num_arr[@]}"
        do
            case "$cf_user_num" in
                *"-"*)
                    cf_user_num_start=${cf_user_num%-*}
                    cf_user_num_end=${cf_user_num#*-}
                    if [[ $cf_user_num_start == *[!0-9]* ]] || [[ $cf_user_num_end == *[!0-9]* ]] || \
                    [ "$cf_user_num_start" -eq 0 ] || [ "$cf_user_num_end" -eq 0 ] || \
                    [ "$cf_user_num_end" -gt "$cf_users_count" ] || \
                    [ "$cf_user_num_start" -ge "$cf_user_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$cf_user_num" -lt 1 ] || [ "$cf_user_num" -gt "$cf_users_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                for element in "${cf_users_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start-1;i<end;i++));
                        do
                            cf_users_indices+=("$i")
                        done
                    else
                        cf_users_indices+=("$((element-1))")
                    fi
                done
                break
            ;;
        esac
    done

    for cf_users_index in "${cf_users_indices[@]}"
    do
        cf_user_email=${cf_users_email[cf_users_index]}
        Println "$info 部署到 $cf_user_email\n"

        cf_user_pass=${cf_users_pass[cf_users_index]}
        cf_user_token=${cf_users_token[cf_users_index]}
        cf_user_api_key=${cf_users_api_key[cf_users_index]}

        if [ -n "$cf_user_api_key" ] 
        then
            curl_header_auth_email="X-Auth-Email: $cf_user_email"
            curl_header_auth_key="X-Auth-Key: $cf_user_api_key"
            curl_header_auth_token=""
        else
            curl_header_auth_email=""
            curl_header_auth_key=""
            curl_header_auth_token="Authorization: Bearer $cf_user_token"
        fi

        if [ -z "$cf_user_token" ] && [ -z "$cf_user_api_key" ]
        then
            if [ "$cf_use_api" -eq 1 ] 
            then
                Println "$error 请添加账号 $cf_user_email Token 或 Key\n"
                exit 1
            fi
            Println "$info 尝试获取用户 Token ..."

            if [[ ! -x $(command -v python3) ]] 
            then
                Println "$info 安装 python3 ..."
                PythonInstall
            fi

            Println "$info 更新 ${CF_WORKERS_FILE##*/}"
            wget --timeout=10 --tries=1 --no-check-certificate "$CF_WORKERS_LINK" -qO "$CF_WORKERS_FILE" \
            || wget --timeout=10 --tries=3 --no-check-certificate "$CF_WORKERS_LINK_BACKUP" -qO "$CF_WORKERS_FILE"

            for((i=0;i<3;i++));
            do
                if cf_user_token=$(python3 \
                    "$CF_WORKERS_FILE" -e "$cf_user_email" -p "$cf_user_pass" -o api_token
                ) 
                then
                    break
                else
                    sleep 10
                fi
            done

            if [ -z "$cf_user_token" ] 
            then
                Println "$error 无法获取用户 ID, 账号或密码错误 或者 cloudflare 暂时限制登录\n"
                exit 1
            else
                cf_users_token[cf_users_index]=$cf_user_token

                new_user=$(
                $JQ_FILE -n --arg email "$cf_user_email" --arg pass "$cf_user_pass" \
                    --arg token "$cf_user_token" --arg key "$cf_user_api_key" \
                    '{
                        email: $email,
                        pass: $pass,
                        token: $token,
                        key: $key
                    }'
                )

                jq_path='["users",'"$cf_users_index"']'
                JQ replace "$CF_CONFIG" "$new_user"
                Println "$info 获取用户 $cf_user_email Token 成功"
            fi
        fi

        CF_ACCOUNT_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts" \
            -H "Content-Type: application/json" \
            -H ''"$curl_header_auth_email"'' \
            -H ''"$curl_header_auth_key"'' \
            -H ''"$curl_header_auth_token"'' \
            | $JQ_FILE -r '.result[0].id'
        ) || true
        if [ -z "$CF_ACCOUNT_ID" ] || [ "$CF_ACCOUNT_ID" == null ]
        then
            Println "$error 无法获取用户 ID, Token 错误 ?\n"
            exit 1
        fi

        if [ "$cf_worker_path" == "stream_proxy" ] 
        then
            if [ -s "$IBM_CONFIG" ] && [ -z "${upstream:-}" ]
            then
                IbmGetCfApps
                if [ "$ibm_cf_apps_count" -gt 0 ] 
                then
                    echo
                    inquirer list_input "是否使用 IBM CF APP 中转" yn_options use_ibm_cf_app_yn

                    if [ "$use_ibm_cf_app_yn" == "$i18n_yes" ] 
                    then
                        IbmListCfApps
                        echo -e "选择 APP"
                        while read -p "$i18n_default_cancel" ibm_cf_apps_num
                        do
                            case "$ibm_cf_apps_num" in
                                "")
                                    Println "$i18n_canceled...\n" && exit 1
                                ;;
                                *[!0-9]*)
                                    Println "$error $i18n_input_correct_no\n"
                                ;;
                                *)
                                    if [ "$ibm_cf_apps_num" -gt 0 ] && [ "$ibm_cf_apps_num" -le "$ibm_cf_apps_count" ]
                                    then
                                        ibm_cf_apps_index=$((ibm_cf_apps_num-1))
                                        ibm_cf_app_name=${ibm_cf_apps_name[ibm_cf_apps_index]}
                                        ibm_user_email=${ibm_cf_apps_user_email[ibm_cf_apps_index]}
                                        ibm_cf_app_routes_count=${ibm_cf_apps_routes_count[ibm_cf_apps_index]}
                                        ibm_cf_app_route_hostname=${ibm_cf_apps_route_hostname[ibm_cf_apps_index]}
                                        ibm_cf_app_route_port=${ibm_cf_apps_route_port[ibm_cf_apps_index]}
                                        ibm_cf_app_route_domain=${ibm_cf_apps_route_domain[ibm_cf_apps_index]}
                                        ibm_cf_app_route_path=${ibm_cf_apps_route_path[ibm_cf_apps_index]}
                                        IFS="|" read -r -a ibm_cf_app_routes_hostname <<< "$ibm_cf_app_route_hostname"
                                        IFS="|" read -r -a ibm_cf_app_routes_port <<< "$ibm_cf_app_route_port"
                                        IFS="|" read -r -a ibm_cf_app_routes_domain <<< "$ibm_cf_app_route_domain"
                                        IFS="|" read -r -a ibm_cf_app_routes_path <<< "${ibm_cf_app_route_path}|"
                                        break
                                    else
                                        Println "$error $i18n_input_correct_no\n"
                                    fi
                                ;;
                            esac
                        done

                        ibm_cf_apps_list=""
                        ibm_cf_apps_link=()
                        for((i=0;i<ibm_cf_app_routes_count;i++));
                        do
                            if [ -n "${ibm_cf_app_routes_path[i]}" ] 
                            then
                                path="/${ibm_cf_app_routes_path[i]}"
                            else
                                path=""
                            fi
                            upstream="${ibm_cf_app_routes_hostname[i]}.${ibm_cf_app_routes_domain[i]}$path"
                            ibm_cf_apps_link+=("$upstream")
                            ibm_cf_apps_list="$ibm_cf_apps_list ${green}$((i+1)).${normal}${indent_6}$upstream\n\n"
                        done

                        Println "$ibm_cf_apps_list"

                        echo -e "选择链接"
                        while read -p "$i18n_default_cancel" ibm_cf_apps_link_num 
                        do
                            case $ibm_cf_apps_link_num in
                                "") 
                                    Println "$i18n_canceled...\n"
                                    exit 1
                                ;;
                                *[!0-9]*) 
                                    Println "$error $i18n_input_correct_no\n"
                                ;;
                                *) 
                                    if [ "$ibm_cf_apps_link_num" -gt 0 ] && [ "$ibm_cf_apps_link_num" -le "$ibm_cf_app_routes_count" ] 
                                    then
                                        ibm_cf_apps_link_index=$((ibm_cf_apps_link_num-1))
                                        upstream=${ibm_cf_apps_link[ibm_cf_apps_link_index]}
                                        break
                                    else
                                        Println "$error $i18n_input_correct_no\n"
                                    fi
                                ;;
                            esac
                        done
                    fi
                fi
            fi
            if [ -z "${upstream:-}" ] 
            then
                Println "$info 输入源站 ip 或者 中转服务器的域名(比如 IBM CF APP 的域名)"
                read -p "$i18n_default_cancel" upstream
                [ -z "$upstream" ] && Println "$i18n_canceled...\n" && exit 1
            fi
            sed -i 's/const upstream = .*/const upstream = "'"$upstream"'"/' "$CF_WORKERS_ROOT/$cf_worker_path/index.js"
        fi

        cd "$CF_WORKERS_ROOT/$cf_worker_path"
        sed -i 's/account_id = .*/account_id = "'"$CF_ACCOUNT_ID"'"/' "$CF_WORKERS_ROOT/$cf_worker_path/wrangler.toml"
        sed -i 's/name = .*/name = "'"$cf_worker_project_name"'"/' "$CF_WORKERS_ROOT/$cf_worker_path/wrangler.toml"

        if CF_API_TOKEN=$cf_user_token wrangler publish 
        then
            Println "$info worker 部署成功\n"
        elif [ "$cf_use_api" -eq 1 ] 
        then
            Println "$error 请检查 Token 权限\n"
            exit 1
        else
            Println "$error 请检查 Token 权限, 尝试修复 ...\n"

            if [[ ! -x $(command -v python3) ]] 
            then
                Println "$info 安装 python3 ..."
                PythonInstall
            fi

            if [ "$sh_debug" -eq 0 ] && [ ! -f "$IPTV_ROOT/VIP" ]
            then
                curl -s -Lm 10 "$CF_WORKERS_LINK" -o "$CF_WORKERS_FILE" \
                || curl -s -Lm 20 "$CF_WORKERS_LINK_BACKUP" -o "$CF_WORKERS_FILE"
            fi

            for((i=0;i<3;i++));
            do
                if [[ $(python3 "$CF_WORKERS_FILE" -e "$cf_user_email" -p "$cf_user_pass" -o add_subdomain) == "ok" ]] 
                then
                    CF_API_TOKEN=$cf_user_token wrangler publish
                    break
                else
                    sleep 10
                fi
            done
        fi
    done
}

CloudflareListWorkersRoutes()
{
    if [ ! -s "$CF_CONFIG" ] 
    then
        Println "$error 请先添加用户\n" && exit 1
    fi

    CloudflareGetUsers

    if [ "$cf_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    cf_users_zones_list=""
    cf_users_zones_count=0
    cf_users_zones_name=()
    cf_users_zones_id=()
    cf_users_zones_account_id=()
    cf_users_zones_account_token=()
    cf_users_zones_account_api_key=()
    cf_users_zones_account_email=()
    cf_users_zones_routes_count=()
    cf_users_zones_route_id=()
    cf_users_zones_route_script=()
    cf_users_zones_route_pattern=()
    for((i=0;i<cf_users_count;i++));
    do
        if [ -n "${cf_users_api_key[i]:-}" ] 
        then
            curl_header_auth_email="X-Auth-Email: ${cf_users_email[i]}"
            curl_header_auth_key="X-Auth-Key: ${cf_users_api_key[i]}"
            curl_header_auth_token=""
        elif [ -n "${cf_users_token[i]:-}" ] 
        then
            curl_header_auth_email=""
            curl_header_auth_key=""
            curl_header_auth_token="Authorization: Bearer ${cf_users_token[i]}"
        else
            continue
        fi

        IFS=" " read -r zone_id zone_name account_id < <(curl -s -X GET "https://api.cloudflare.com/client/v4/zones" \
            -H "Content-Type: application/json" \
            -H ''"$curl_header_auth_email"'' \
            -H ''"$curl_header_auth_key"'' \
            -H ''"$curl_header_auth_token"'' \
            | $JQ_FILE -r '[([.result[].id]|join("|")),([.result[].name]|join("|")),([.result[].account.id]|join("|"))]|join(" ")' 2> /dev/null
        ) || Println "$error Token 权限错误 ?"
        IFS="|" read -r -a zones_id <<< "$zone_id"
        IFS="|" read -r -a zones_name <<< "$zone_name"
        IFS="|" read -r -a accounts_id <<< "$account_id"
        for((j=0;j<${#zones_id[@]};j++));
        do
            cf_users_zones_count=$((cf_users_zones_count+1))
            IFS="^" read -r count id script pattern < <(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/workers/routes" \
                -H "Content-Type: application/json" \
                -H ''"$curl_header_auth_email"'' \
                -H ''"$curl_header_auth_key"'' \
                -H ''"$curl_header_auth_token"'' \
                | $JQ_FILE '[(.result|length),([.result[].id]|join(" ")),([.result[].script]|join(" ")),([.result[].pattern]|join(" "))]|join("^")'
            )

            count=${count#\"}
            pattern=${pattern%\"}
            cf_users_zones_routes_count+=("$count")
            cf_users_zones_route_id+=("$id")
            cf_users_zones_route_script+=("$script")
            cf_users_zones_route_pattern+=("$pattern")

            cf_users_zones_id+=("${zones_id[j]}")
            cf_users_zones_name+=("${zones_name[j]}")
            cf_users_zones_account_id+=("${accounts_id[j]}")
            cf_users_zones_account_token+=("${cf_users_token[i]}")
            cf_users_zones_account_api_key+=("${cf_users_api_key[i]}")
            cf_users_zones_account_email+=("${cf_users_email[i]}")
            cf_users_zones_list="$cf_users_zones_list $cf_users_zones_count.${indent_6}${green}${zones_name[j]}${normal}  路由数: ${green}$count${normal}\n\n"
        done
    done

    if [ "$cf_users_zones_count" -eq 0 ] 
    then
        Println "$error 没有找到域名, 请先添加源站\n"
        exit 1
    fi

    Println "$cf_users_zones_list"
}

CloudflareConfigWorkerRoute()
{
    Println "$info 搜索路由 ..."

    CloudflareListWorkersRoutes

    echo -e "选择域名"
    while read -p "$i18n_default_cancel" cf_zones_num
    do
        case $cf_zones_num in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_no\n"
            ;;
            *) 
                if [ "$cf_zones_num" -gt 0 ] && [ "$cf_zones_num" -le "$cf_users_zones_count" ] 
                then
                    cf_zones_index=$((cf_zones_num-1))
                    cf_users_zone_name=${cf_users_zones_name[cf_zones_index]}
                    cf_users_zone_id=${cf_users_zones_id[cf_zones_index]}
                    cf_users_zone_account_id=${cf_users_zones_account_id[cf_zones_index]}
                    cf_users_zone_account_token=${cf_users_zones_account_token[cf_zones_index]}
                    cf_users_zone_account_api_key=${cf_users_zones_account_api_key[cf_zones_index]}
                    cf_users_zone_account_email=${cf_users_zones_account_email[cf_zones_index]}
                    cf_users_zone_routes_count=${cf_users_zones_routes_count[cf_zones_index]}
                    cf_users_zone_route_id=${cf_users_zones_route_id[cf_zones_index]}
                    cf_users_zone_route_script=${cf_users_zones_route_script[cf_zones_index]}
                    cf_users_zone_route_pattern=${cf_users_zones_route_pattern[cf_zones_index]}
                    if [ -n "$cf_users_zone_account_api_key" ] 
                    then
                        curl_header_auth_email="X-Auth-Email: $cf_users_zone_account_email"
                        curl_header_auth_key="X-Auth-Key: $cf_users_zone_account_api_key"
                        curl_header_auth_token=""
                    elif [ -n "$cf_users_zone_account_token" ] 
                    then
                        curl_header_auth_email=""
                        curl_header_auth_key=""
                        curl_header_auth_token="Authorization: Bearer $cf_users_zone_account_token"
                    else
                        Println "$error 请添加账号 $cf_users_zone_account_email Token 或 Key\n"
                        exit 1
                    fi
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ "$cf_users_zone_routes_count" -gt 0 ] 
    then
        IFS=" " read -r -a cf_users_zone_routes_id <<< "$cf_users_zone_route_id"
        IFS=" " read -r -a cf_users_zone_routes_script <<< "$cf_users_zone_route_script"
        IFS=" " read -r -a cf_users_zone_routes_pattern <<< "$cf_users_zone_route_pattern"

        cf_users_zone_routes_list=""
        for((i=0;i<cf_users_zone_routes_count;i++));
        do
            cf_users_zone_routes_list="$cf_users_zone_routes_list $((i+1)).${indent_6}${green}${cf_users_zone_routes_pattern[i]}${normal} => ${green}${cf_users_zone_routes_script[i]}${normal}\n\n"
        done

        cf_users_zone_route_add_num=$((cf_users_zone_routes_count+1))
        cf_users_zone_routes_list="$cf_users_zone_routes_list $cf_users_zone_route_add_num.${indent_6}${green}添加路由${normal}\n"
        Println "$cf_users_zone_routes_list"

        while read -p "$i18n_default_cancel" cf_users_zone_routes_num
        do
            if [ "$cf_users_zone_routes_num" == "$cf_users_zone_route_add_num" ] 
            then
                break
            fi
            case $cf_users_zone_routes_num in
                "") 
                    Println "$i18n_canceled...\n"
                    exit 1
                ;;
                *[!0-9]*) 
                    Println "$error $i18n_input_correct_no\n"
                ;;
                *) 
                    if [ "$cf_users_zone_routes_num" -gt 0 ] && [ "$cf_users_zone_routes_num" -le "$cf_users_zone_routes_count" ] 
                    then
                        cf_users_zone_routes_index=$((cf_users_zone_routes_num-1))
                        cf_users_zone_route_id=${cf_users_zone_routes_id[cf_users_zone_routes_index]}
                        cf_users_zone_route_script=${cf_users_zone_routes_script[cf_users_zone_routes_index]}
                        cf_users_zone_route_pattern=${cf_users_zone_routes_pattern[cf_users_zone_routes_index]}
                        Println " ${green}$cf_users_zone_route_pattern${normal} => ${green}$cf_users_zone_route_script${normal}\n\n ${green}1.${normal}${indent_6}更改路由\n ${green}2.${normal}${indent_6}删除路由\n"
                        read -p "$i18n_default_cancel" cf_users_zone_route_num
                        case $cf_users_zone_route_num in
                            "") 
                                Println "$i18n_canceled...\n"
                                exit 1
                            ;;
                            1) 
                                Println "$info 输入已经存在的 worker 项目名称"
                                echo -e "$tip 输入的是项目名称, 不是序号\n"
                                read -p "(默认: $cf_users_zone_route_script): " script
                                script=${script:-$cf_users_zone_route_script}
                                Println "$info 输入路由, 比如 abc.domain.com/*"
                                read -p "(默认: $cf_users_zone_route_pattern): " pattern
                                pattern=${pattern:-$cf_users_zone_route_pattern}
                                if [[ $(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$cf_users_zone_id/workers/routes/$cf_users_zone_route_id" \
                                    -H ''"$curl_header_auth_email"'' \
                                    -H ''"$curl_header_auth_key"'' \
                                    -H ''"$curl_header_auth_token"'' \
                                    -H "Content-Type: application/json" \
                                    --data '{"pattern":"'"$pattern"'","script":"'"$script"'"}' \
                                    | $JQ_FILE -r '.success' ) == "true" ]]
                                then
                                    Println "$info 路由更改成功\n"
                                else
                                    Println "$error 路由更改失败\n"
                                fi
                            ;;
                            2) 
                                if [[ $(curl -s -X DELETE "https://api.cloudflare.com/client/v4/zones/$cf_users_zone_id/workers/routes/$cf_users_zone_route_id" \
                                    -H ''"$curl_header_auth_email"'' \
                                    -H ''"$curl_header_auth_key"'' \
                                    -H ''"$curl_header_auth_token"'' \
                                    -H "Content-Type: application/json" \
                                    | $JQ_FILE -r '.success' ) == "true" ]] 
                                then
                                    Println "$info 路由删除成功\n"
                                else
                                    Println "$info 路由删除成功\n"
                                fi
                            ;;
                            *[!0-9]*)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *) 
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                        esac
                        exit 0
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done
    fi

    CloudflareGetWorkers

    if [ "$cf_workers_count" -gt 0 ] 
    then
        Println "$cf_workers_list"
    else
        Println "$error 本地没有 worker"
    fi

    Println "$info 输入已经存在的 worker 项目名称"
    echo -e "$tip 输入的是项目名称, 不是序号\n"
    read -p "$i18n_default_cancel" script
    [ -z "$script" ] && Println "$i18n_canceled...\n" && exit 1
    if [[ $script =~ ^[0-9]+$ ]] && [ "$script" -le "$cf_workers_count" ] && [ "$script" -gt 0 ]
    then
        cf_workers_index=$((script-1))
        echo
        inquirer list_input "是想要输入 ${cf_workers_project_name[cf_workers_index]}" yn_options mistake_yn

        if [[ $mistake_yn == "$i18n_yes" ]] 
        then
            script=${cf_workers_project_name[cf_workers_index]}
        fi
    fi
    Println "$info 输入路由,比如 abc.domain.com/*"
    read -p "$i18n_default_cancel" pattern
    [ -z "$pattern" ] && Println "$i18n_canceled...\n" && exit 1
    if [[ $(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$cf_users_zone_id/workers/routes" \
        -H ''"$curl_header_auth_email"'' \
        -H ''"$curl_header_auth_key"'' \
        -H ''"$curl_header_auth_token"'' \
        -H "Content-Type: application/json" \
        --data '{"pattern":"'"$pattern"'","script":"'"$script"'"}' \
        | $JQ_FILE -r '.success' ) == "true" ]]
    then
        Println "$info 路由添加成功\n"
    else
        Println "$error 路由添加失败\n"
    fi
}

CloudflareWorkersMonitorMoveZone()
{
    CloudflareGetUser

    Println "$info 删除源站 ..."

    IFS="^" read -r result err_code msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_delete' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        | $JQ_FILE '[.result,.err_code,.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        if [ "$err_code" -eq 115 ] || [ "$err_code" -eq 703 ]
        then
            Println "$error 此用户已被 CFP 删除或未添加成功, 可以到 Cloudflare 官网手动删除源站或者重新添加 !"
        else
            Println "$error ${msg:-超时, 请重试}\n"
        fi
        MonitorError "move zone 删除源站 $err_code, $msg"
        exit 1
    else
        jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
        JQ delete "$CF_CONFIG" name "\"$cf_zone_name\""
        Println "$info $cf_zone_name 删除成功"
    fi

    Println "$info 移动中 ..."
    cf_user_key=""
    until [ -n "$cf_user_key" ] 
    do
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        cf_user_unique_id=${random_number: -12}
        IFS="^" read -r result cf_user_key cf_user_api_key msg < <(curl -s -Lm 50 https://api.cloudflare.com/host-gw.html \
            -d 'act=user_create' \
            -d "host_key=$cf_host_key" \
            -d "cloudflare_email=$cf_user_email_new" \
            -d "cloudflare_pass=$cf_user_pass_new" \
            -d "unique_id=$cf_user_unique_id" \
            | $JQ_FILE '[.result,.response.user_key,.response.user_api_key,.msg]|join("^")'
        ) || true

        result=${result#\"}
        msg=${msg%\"}
        if [ "$result" == "error" ] 
        then
            Println "$error $msg"
            if [[ $msg == *"assword"* ]] 
            then
                Println "$error 请检查密码是否正确\n"
                MonitorError "move zone 移动中 请检查密码是否正确, $msg"
                exit 1
            fi
        elif [ -z "$cf_user_api_key_new" ] 
        then
            jq_path='["users",'"$cf_users_index"',"key"]'
            JQ update "$CF_CONFIG" "$cf_user_api_key"
            Println "$info 用户 $cf_user_email_new API Key 添加成功\n"
            cf_user_api_key_new=$cf_user_api_key
        fi
    done

    cf_zones_user_unique_id[zone_index]=$cf_user_unique_id

    cf_user_email=$cf_user_email_new
    cf_user_pass=$cf_user_pass_new
    cf_user_token=$cf_user_token_new

    if [ -z "$cf_zone_subdomains" ] 
    then
        CloudflareGetUser
        CloudflareGetZone
        for((i=0;i<${#cf_hosted_cnames[@]};i++));
        do
            if [[ ${cf_hosted_cnames[i]} =~ ^([^.]+).([^.]+)$ ]] 
            then
                continue
            fi
            cf_hosted_cname=${cf_hosted_cnames[i]}
            cf_hosted_cname=${cf_hosted_cname%.*}
            cf_hosted_cname_prefix=${cf_hosted_cname%.*}
            [ -n "$cf_zone_subdomains" ] && cf_zone_subdomains="$cf_zone_subdomains,"
            cf_zone_subdomains="$cf_zone_subdomains$cf_hosted_cname_prefix:${cf_resolve_tos[i]}"
        done
    fi

    new_zone=$(
    $JQ_FILE -n --arg name "$cf_zone_name" --arg resolve_to "$cf_zone_resolve_to" \
        --arg user_email "$cf_user_email" --arg user_unique_id "$cf_user_unique_id" \
        --arg always_use_https "$cf_zone_always_use_https" --arg ssl "$cf_zone_ssl" --arg subdomains "$cf_zone_subdomains" \
        '{
            name: $name,
            resolve_to: $resolve_to,
            user_email: $user_email,
            user_unique_id: $user_unique_id | tonumber,
            always_use_https: $always_use_https,
            ssl: $ssl,
            subdomains: $subdomains
        }'
    )

    jq_path='["hosts",'"$cf_hosts_index"',"zones"]'
    JQ add "$CF_CONFIG" "$new_zone"

    CloudflareGetUser

    IFS="^" read -r result cf_zone_resolving_to cf_zone_hosted_cnames cf_zone_forward_tos msg < <(curl -s -Lm 20 https://api.cloudflare.com/host-gw.html \
        -d 'act=zone_set' \
        -d "host_key=$cf_host_key" \
        -d "user_key=$cf_user_key" \
        -d "zone_name=$cf_zone_name" \
        -d "resolve_to=$cf_zone_resolve_to" \
        -d "subdomains=$cf_zone_subdomains" \
        | $JQ_FILE '[.result,.response.resolving_to,([(.response.hosted_cnames| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),([(.response.forward_tos| if .== null then {} else . end)|to_entries[]
        |([.key,.value]|join("="))]
        |join("|")),.msg]|join("^")'
    ) || true

    result=${result#\"}
    msg=${msg%\"}

    if [ -z "$result" ] || [ "$result" == "error" ]
    then
        MonitorError "move zone 连接超时, 请查看是否已经完成 $msg"
        Println "$error ${msg:-连接超时, 请查看是否已经完成}\n"
    fi

    Println "$info 源站移动成功\n"
}

CloudflareWorkersMonitorUpdateRoutes()
{
    zone_cnames=()
    zone_resolves=()

    if [ -n "$cf_zone_subdomains" ] 
    then
        IFS="," read -r -a pairs <<< "$cf_zone_subdomains"
        for pair in "${pairs[@]}"
        do
            if [[ $pair == *":"* ]] 
            then
                zone_cnames+=("${pair%:*}.$cf_zone_name")
                zone_resolves+=("${pair#*:}")
            else
                zone_cnames+=("$pair.$cf_zone_name")
                zone_resolves+=("$cf_zone_resolve_to")
            fi
        done
    else
        CloudflareGetUser
        CloudflareGetZone
        for((j=0;j<${#cf_hosted_cnames[@]};j++));
        do
            if [[ ${cf_resolve_tos[j]} =~ ^([^.]+).([^.]+).workers.dev$ ]] 
            then
                zone_cnames+=("${cf_hosted_cnames[j]}")
                zone_resolves+=("${cf_resolve_tos[j]}")
            fi
        done
    fi

    workers_pattern=()
    for worker_project_name in "${workers_project_name[@]}"
    do
        zone_cname_found=0
        for((j=0;j<${#zone_cnames[@]};j++));
        do
            zone_resolve_to=${zone_resolves[j]}
            if [[ ${zone_resolve_to%%.*} == "$worker_project_name" ]] 
            then
                zone_cname_found=1
                worker_pattern="${zone_cnames[j]}/*"
                break
            fi
        done
        if [ "$zone_cname_found" -eq 0 ] 
        then
            if [ "$worker_project_name" == "${cf_zone_name%.*}" ] 
            then
                worker_pattern="$cf_zone_name/*"
            else
                worker_pattern="$worker_project_name.$cf_zone_name/*"
            fi
        fi
        workers_pattern+=("$worker_pattern")
    done

    IFS=" " read -r zone_id zone_name account_id < <(curl -s -X GET "https://api.cloudflare.com/client/v4/zones" \
        -H "Content-Type: application/json" \
        -H ''"$curl_header_auth_email"'' \
        -H ''"$curl_header_auth_key"'' \
        -H ''"$curl_header_auth_token"'' \
        | $JQ_FILE -r '[([.result[].id]|join("|")),([.result[].name]|join("|")),([.result[].account.id]|join("|"))]|join(" ")' 2> /dev/null
    ) || Println "$error Token 权限错误 ?"

    IFS="|" read -r -a zones_id <<< "$zone_id"
    IFS="|" read -r -a zones_name <<< "$zone_name"
    IFS="|" read -r -a accounts_id <<< "$account_id"

    for((j=0;j<${#zones_id[@]};j++));
    do
        if [ "${zones_name[j]}" == "$cf_zone_name" ] 
        then
            cf_zone_always_use_https=${cf_zone_always_use_https:-off}
            zone_always_use_https=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/settings/always_use_https" \
                -H "Content-Type: application/json" \
                -H ''"$curl_header_auth_email"'' \
                -H ''"$curl_header_auth_key"'' \
                -H ''"$curl_header_auth_token"'' \
                | $JQ_FILE -r '.result.value'
            )

            if [ "$zone_always_use_https" != "$cf_zone_always_use_https" ] 
            then
                fail_time=0
                until [[ $(curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/settings/always_use_https" \
                    -H ''"$curl_header_auth_email"'' \
                    -H ''"$curl_header_auth_key"'' \
                    -H ''"$curl_header_auth_token"'' \
                    -H "Content-Type: application/json" \
                    --data '{"value":"'"$cf_zone_always_use_https"'"}' | $JQ_FILE -r '.success') == "true" ]] 
                do
                    MonitorError "域名: $cf_zone_name always_use_https 设置失败, Token: $cf_user_token, zone id: ${zones_id[j]}, $zone_always_use_https => $cf_zone_always_use_https"
                    Println "$error 域名: $cf_zone_name always_use_https 设置失败\n"
                    fail_time=$((fail_time+1))
                    [ "$fail_time" -ge 5 ] && exit 1
                done
                Println "$info 域名: $cf_zone_name always_use_https 设置成功\n"
            fi

            cf_zone_ssl=${cf_zone_ssl:-flexible}
            zone_ssl=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/settings/ssl" \
                -H "Content-Type: application/json" \
                -H ''"$curl_header_auth_email"'' \
                -H ''"$curl_header_auth_key"'' \
                -H ''"$curl_header_auth_token"'' \
                | $JQ_FILE -r '.result.value'
            )

            if [ "$zone_ssl" != "$cf_zone_ssl" ] 
            then
                fail_time=0
                until [[ $(curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/settings/ssl" \
                    -H ''"$curl_header_auth_email"'' \
                    -H ''"$curl_header_auth_key"'' \
                    -H ''"$curl_header_auth_token"'' \
                    -H "Content-Type: application/json" \
                    --data '{"value":"'"$cf_zone_ssl"'"}' | $JQ_FILE -r '.success') == "true" ]] 
                do
                    MonitorError "域名: $cf_zone_name ssl 设置失败, Token: $cf_user_token, zone id: ${zones_id[j]}, $zone_ssl => $cf_zone_ssl"
                    Println "$error 域名: $cf_zone_name ssl 设置失败\n"
                    fail_time=$((fail_time+1))
                    [ "$fail_time" -ge 5 ] && exit 1
                done
                Println "$info 域名: $cf_zone_name ssl 设置成功\n"
            fi

            IFS="^" read -r count id script pattern < <(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/workers/routes" \
                -H "Content-Type: application/json" \
                -H ''"$curl_header_auth_email"'' \
                -H ''"$curl_header_auth_key"'' \
                -H ''"$curl_header_auth_token"'' \
                | $JQ_FILE '[(.result|length),([.result[].id]|join(" ")),([.result[].script]|join(" ")),([.result[].pattern]|join(" "))]|join("^")'
            )

            pattern=${pattern%\"}

            IFS=" " read -r -a ids <<< "$id"
            IFS=" " read -r -a scripts <<< "$script"
            IFS=" " read -r -a patterns <<< "$pattern"

            for((k=0;k<workers_count;k++));
            do
                pattern_found=0
                if [[ $update_workers_data_yn == "$i18n_yes" ]] 
                then
                    script_found=0
                else
                    script_found=0
                    for script in "${scripts[@]}"
                    do
                        if [ "$script" == "${workers_project_name[k]}" ] 
                        then
                            script_found=1
                            break
                        fi
                    done
                fi
                for((m=0;m<${#patterns[@]};m++));
                do
                    if [ "${patterns[m]}" == "${workers_pattern[k]}" ] 
                    then
                        pattern_found=1
                        id=${ids[m]}
                        break
                    fi
                done
                if [ "$script_found" -eq 0 ] 
                then
                    fail_time=0
                    until [[ $(curl -s -X PUT "https://api.cloudflare.com/client/v4/accounts/${accounts_id[j]}/workers/scripts/${workers_project_name[k]}" \
                        -H ''"$curl_header_auth_email"'' \
                        -H ''"$curl_header_auth_key"'' \
                        -H ''"$curl_header_auth_token"'' \
                        -H "Content-Type: application/javascript" \
                        --data "${workers_data[k]}" | $JQ_FILE -r '.success') == "true" ]] 
                    do
                        MonitorError "部署 worker 失败 Token: $cf_user_token, pattern: ${workers_pattern[k]}, script: ${workers_project_name[k]}"
                        Println "$error worker: ${workers_name[j]} 部署失败\n"
                        fail_time=$((fail_time+1))
                        [ "$fail_time" -ge 5 ] && exit 1
                    done
                    Println "$info worker: ${workers_name[j]} 部署成功\n"
                fi
                if [ "$pattern_found" -eq 1 ] 
                then
                    fail_time=0
                    until [[ $(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/workers/routes/$id" \
                        -H ''"$curl_header_auth_email"'' \
                        -H ''"$curl_header_auth_key"'' \
                        -H ''"$curl_header_auth_token"'' \
                        -H "Content-Type: application/json" \
                        --data '{"pattern":"'"${workers_pattern[k]}"'","script":"'"${workers_project_name[k]}"'"}' \
                        | $JQ_FILE -r '.success' ) == "true" ]] 
                    do
                        MonitorError "路由添加失败 Token: $cf_user_token, pattern: ${workers_pattern[k]}, script: ${workers_project_name[k]}"
                        Println "$error 路由添加失败\n"
                        fail_time=$((fail_time+1))
                        [ "$fail_time" -ge 5 ] && exit 1
                    done
                    Println "$info 路由修改成功\n"
                else
                    fail_time=0
                    until [[ $(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zones_id[j]}/workers/routes" \
                        -H ''"$curl_header_auth_email"'' \
                        -H ''"$curl_header_auth_key"'' \
                        -H ''"$curl_header_auth_token"'' \
                        -H "Content-Type: application/json" \
                        --data '{"pattern":"'"${workers_pattern[k]}"'","script":"'"${workers_project_name[k]}"'"}' \
                        | $JQ_FILE -r '.success' ) == "true" ]] 
                    do
                        MonitorError "路由添加失败 Token: $cf_user_token, pattern: ${workers_pattern[k]}, script: ${workers_project_name[k]}"
                        Println "$error 路由添加失败\n"
                        fail_time=$((fail_time+1))
                        [ "$fail_time" -ge 5 ] && exit 1
                    done
                    Println "$info 路由添加成功\n"
                fi
            done
            break
        fi
    done
}

CloudflareWorkersMonitorDeploy()
{
    CF_ACCOUNT_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts" \
        -H "Content-Type: application/json" \
        -H ''"$curl_header_auth_email"'' \
        -H ''"$curl_header_auth_key"'' \
        -H ''"$curl_header_auth_token"'' \
        | $JQ_FILE -r '.result[0].id'
    ) || true
    if [ -z "$CF_ACCOUNT_ID" ] || [ "$CF_ACCOUNT_ID" == null ]
    then
        MonitorError "无法获取用户 ID, Token 错误 ? $cf_user_token"
        Println "$error 无法获取用户 ID, Token 错误 ?\n"
        exit 1
    fi

    for((j=0;j<workers_count;j++));
    do
        if [[ $(curl -s -X PUT "https://api.cloudflare.com/client/v4/accounts/$CF_ACCOUNT_ID/workers/scripts/${workers_project_name[j]}" \
            -H ''"$curl_header_auth_email"'' \
            -H ''"$curl_header_auth_key"'' \
            -H ''"$curl_header_auth_token"'' \
            -H "Content-Type: application/javascript" \
            --data "${workers_data[j]}" | $JQ_FILE -r '.success') == "true" ]]
        then
            Println "$info ${workers_name[j]} 部署成功\n"
        fi
    done
}

CloudflareWorkersMonitorGetRequests()
{
    local cf_user_email=$1 cf_user_token=$2 cf_user_api_key=$3
    if [ -n "$cf_user_api_key" ] 
    then
        curl_header_auth_email="X-Auth-Email: $cf_user_email"
        curl_header_auth_key="X-Auth-Key: $cf_user_api_key"
        curl_header_auth_token=""
    else
        curl_header_auth_email=""
        curl_header_auth_key=""
        curl_header_auth_token="Authorization: Bearer $cf_user_token"
    fi

    delimiters=( $'\001' )
    IFS=$'\002\t' read -r success error_message CF_ACCOUNT_ID < <(
    JQs flat "$(curl -s -X GET -H ''"$curl_header_auth_email"'' -H ''"$curl_header_auth_key"'' -H ''"$curl_header_auth_token"'' \
    -H 'Content-Type: application/json' https://api.cloudflare.com/client/v4/accounts)" '' \
    '[.success + "\u0002",
    (.errors|if . == "" then {} else . end).message + "\u0002",
    (.result|if . == "" then {} else . end).id + "\u0002"]|@tsv' "${delimiters[@]}")

    if [ "$success" == "false" ] 
    then
        request_count="获取账号 ID 失败: ${error_message//$'\001'/, }"
        return 0
    fi

    end_epoch=$(date --utc -d 'tomorrow 00:00:00' +%s)
    start_epoch=$(date --utc -d 'today 00:00:00' +%s)
    start_date=$(date --utc --date="@$start_epoch" +'%Y-%m-%dT%H:%m:%SZ')
    end_date=$(date --utc --date="@$end_epoch" +'%Y-%m-%dT%H:%m:%SZ')

    PAYLOAD='{ "query":
    "query {
        viewer {
        accounts(filter: { accountTag: $accountTag }) {
        workersInvocationsAdaptive(
            filter: {
            datetime_geq: $datetimeStart,
            datetime_leq: $datetimeEnd
            }
            limit: 100
        ) {
            sum {
                requests
                subrequests
                errors
            }
            }
        }
        }
    }",'

    PAYLOAD="$PAYLOAD

    \"variables\": {
        \"accountTag\": \"$CF_ACCOUNT_ID\",
        \"datetimeStart\": \"$start_date\",
        \"datetimeEnd\": \"$end_date\"
    }
    }"

    delimiters=( $'\001' )
    IFS=$'\002\t' read -r cf_workers_requests error_message < <(
    JQs flat "$(curl -s -X POST -H ''"$curl_header_auth_email"'' -H ''"$curl_header_auth_key"'' -H ''"$curl_header_auth_token"'' \
    --data "$(echo $PAYLOAD)" -H 'Content-Type: application/json' https://api.cloudflare.com/client/v4/graphql)" '' \
    '[((.data|if . == "" then {} else . end).viewer.accounts.workersInvocationsAdaptive|if . == "" then {} else . end).sum.requests + "\u0002",
    (.errors|if . == "" then {} else . end).message + "\u0002"]|@tsv' "${delimiters[@]}")

    if [ -z "$cf_workers_requests" ] 
    then
        request_count="获取 workers 访问数失败: ${error_message//$'\001'/, }"
        return 0
    fi

    request_count=$cf_workers_requests
}

CloudflareWorkersMonitor()
{
    trap '' HUP INT
    trap 'MonitorError $LINENO' ERR

    pid_file="$CF_WORKERS_ROOT/cf_workers.pid"
    printf '%s' "$BASHPID" > "$pid_file"
    {
        flock -x 204
        {
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            printf '%s\n' "$date_now 启动 workers 监控  PID $BASHPID !" >> "$MONITOR_LOG"

            clear=$(date --utc -d 'tomorrow 00:00:10' +%s)
            emails_dead=()

            if [ "$sh_debug" -eq 0 ] 
            then
                monitor=1
            fi

            while true 
            do
                printf -v now '%(%s)T' -1
                if [ "$now" -ge "$clear" ] 
                then
                    clear=$(date --utc -d 'tomorrow 00:00:10' +%s)
                    emails_dead=()
                    start_from_begin=1
                fi

                zone_index=${zones_index_monitor[0]}
                cf_zone_user_email=${cf_zones_user_email[zone_index]}
                cf_zone_user_pass=${cf_zones_user_pass[zone_index]}
                cf_zone_user_token=${cf_zones_user_token[zone_index]}
                cf_zone_user_api_key=${cf_zones_user_api_key[zone_index]}

                if [ -n "$cf_zone_user_api_key" ] 
                then
                    curl_header_auth_email="X-Auth-Email: $cf_zone_user_email"
                    curl_header_auth_key="X-Auth-Key: $cf_zone_user_api_key"
                    curl_header_auth_token=""
                else
                    curl_header_auth_email=""
                    curl_header_auth_key=""
                    curl_header_auth_token="Authorization: Bearer $cf_zone_user_token"
                fi

                dead_email=0
                for email in ${emails_dead[@]+"${emails_dead[@]}"}
                do
                    if [ "$email" == "$cf_zone_user_email" ] 
                    then
                        dead_email=1
                        break
                    fi
                done

                if [ "$dead_email" -eq 0 ] 
                then
                    for((i=0;i<20;i++));
                    do
                        if [ "$cf_use_api" -eq 1 ] 
                        then
                            CloudflareWorkersMonitorGetRequests "$cf_zone_user_email" "$cf_zone_user_token" "$cf_zone_user_api_key"
                            if [ -z "$request_count" ] || [[ $request_count == *[!0-9]* ]]
                            then
                                MonitorError "request_count : ${request_count:-无}"
                                sleep 10
                            else
                                if [ "$request_count" -gt "$cf_workers_monitor_request_counts" ] 
                                then
                                    dead_email=1
                                    emails_dead+=("$cf_zone_user_email")
                                fi
                                break
                            fi
                        elif request_count_json=$(python3 \
                            "$CF_WORKERS_FILE" -e "$cf_zone_user_email" -p "$cf_zone_user_pass" -o request_count
                        ) 
                        then
                            IFS=" " read -r success request_count api_token < <($JQ_FILE -r '[.success,.result.totals.requestCount,.api_token]|join(" ")' <<< "$request_count_json")

                            if [ "$success" == "true" ] && [ -n "$request_count" ] 
                            then
                                if [ "$request_count" -gt "$cf_workers_monitor_request_counts" ] 
                                then
                                    dead_email=1
                                    emails_dead+=("$cf_zone_user_email")
                                fi
                                break
                            else
                                MonitorError "request_count_json 1 : $request_count_json"
                                sleep 30
                            fi
                        else
                            sleep 10
                        fi
                    done
                fi

                if [ "$dead_email" -eq 1 ] 
                then
                    if [ "$start_from_begin" -eq 1 ] 
                    then
                        continue=0
                    else
                        continue=1
                    fi
                    for((cf_users_index=0;i<cf_users_count;cf_users_index++));
                    do
                        if [ "$continue" -eq 1 ]
                        then
                            if [ "${cf_users_email[cf_users_index]}" == "$cf_zone_user_email" ]
                            then
                                continue=0
                            fi
                            continue
                        fi

                        for email in ${emails_dead[@]+"${emails_dead[@]}"}
                        do
                            if [ "$email" == "${cf_users_email[cf_users_index]}" ] 
                            then
                                continue 2
                            fi
                        done

                        if [ "$cf_use_api" -eq 0 ] && [ -z "${cf_users_token[cf_users_index]}" ] && [ -z "${cf_users_api_key[cf_users_index]}" ] 
                        then
                            for((index=0;index<10;index++));
                            do
                                if cf_user_token=$(python3 \
                                    "$CF_WORKERS_FILE" -e "${cf_users_email[cf_users_index]}" -p "${cf_users_pass[cf_users_index]}" -o api_token
                                )
                                then
                                    break
                                else
                                    sleep 20
                                fi
                            done

                            if [ -n "$cf_user_token" ] 
                            then
                                cf_users_token[cf_users_index]=$cf_user_token

                                new_user=$(
                                $JQ_FILE -n --arg email "${cf_users_email[cf_users_index]}" --arg pass "${cf_users_pass[cf_users_index]}" \
                                    --arg token "${cf_users_token[cf_users_index]}" --arg key "${cf_users_api_key[cf_users_index]}" \
                                    '{
                                        email: $email,
                                        pass: $pass,
                                        token: $token,
                                        key: $key
                                    }'
                                )

                                jq_path='["users"]'
                                JQ delete "$CF_CONFIG" email "\"${cf_users_email[cf_users_index]}\""
                                jq_path='["users"]'
                                JQ add "$CF_CONFIG" "$new_user"
                                Println "$info 用户 ${cf_users_email[cf_users_index]} 修改成功\n"
                            else
                                continue
                            fi
                        fi

                        cf_user_email_new=${cf_users_email[cf_users_index]}
                        cf_user_pass_new=${cf_users_pass[cf_users_index]}
                        cf_user_token_new=${cf_users_token[cf_users_index]}
                        cf_user_api_key_new=${cf_users_api_key[cf_users_index]}

                        for zone_index in "${zones_index_monitor[@]}"
                        do
                            cf_zone_name=${cf_zones_name[zone_index]}
                            cf_zone_host_name=${cf_zones_host_name[zone_index]}
                            cf_zone_host_key=${cf_zones_host_key[zone_index]}
                            cf_zone_user_email=${cf_zones_user_email[zone_index]}
                            cf_zone_user_pass=${cf_zones_user_pass[zone_index]}
                            cf_zone_user_token=${cf_zones_user_token[zone_index]}
                            cf_zone_user_unique_id=${cf_zones_user_unique_id[zone_index]}
                            cf_zone_resolve_to=${cf_zones_resolve_to[zone_index]}
                            cf_zone_always_use_https=${cf_zones_always_use_https[zone_index]}
                            cf_zone_ssl=${cf_zones_ssl[zone_index]}
                            cf_zone_subdomains=${cf_zones_subdomains[zone_index]}

                            cf_zones_user_email[zone_index]=$cf_user_email_new
                            cf_zones_user_pass[zone_index]=$cf_user_pass_new
                            cf_zones_user_token[zone_index]=$cf_user_token_new

                            cf_user_unique_id=$cf_zone_user_unique_id
                            cf_host_key=$cf_zone_host_key
                            cf_hosts_index=${cf_zones_host_index[zone_index]}
                            cf_user_email=$cf_zone_user_email
                            cf_user_pass=$cf_zone_user_pass
                            cf_user_token=$cf_zone_user_token

                            CloudflareWorkersMonitorMoveZone

                            cf_zones_user_api_key[zone_index]=$cf_user_api_key_new
                            cf_zone_user_api_key=${cf_zones_user_api_key[zone_index]}
                            cf_user_api_key=$cf_zone_user_api_key

                            curl_header_auth_email="X-Auth-Email: $cf_user_email_new"
                            curl_header_auth_key="X-Auth-Key: $cf_user_api_key"
                            curl_header_auth_token=""

                            CloudflareWorkersMonitorUpdateRoutes
                        done

                        for((index=0;index<20;index++));
                        do
                            if [ "$cf_use_api" -eq 1 ] 
                            then
                                CloudflareWorkersMonitorGetRequests "$cf_user_email_new" "$cf_user_token_new" "$cf_user_api_key_new"
                                if [ -z "$request_count" ] || [[ $request_count == *[!0-9]* ]]
                                then
                                    MonitorError "request_count 2 : ${request_count:-无}"
                                    sleep 10
                                else
                                    if [ "$request_count" -gt "$cf_workers_monitor_request_counts" ] 
                                    then
                                        emails_dead+=("$cf_user_email_new")
                                        break
                                    else
                                        dead_email=0
                                        break 2
                                    fi
                                fi
                            elif request_count_json=$(python3 \
                                "$CF_WORKERS_FILE" -e "$cf_user_email_new" -p "$cf_user_pass_new" -o request_count
                            ) 
                            then
                                IFS=" " read -r success request_count api_token < <($JQ_FILE -r '[.success,.result.totals.requestCount,.api_token]|join(" ")' <<< "$request_count_json")

                                if [ "$success" == "true" ] && [ -n "$request_count" ] 
                                then
                                    if [ "$request_count" -gt "$cf_workers_monitor_request_counts" ] 
                                    then
                                        emails_dead+=("$cf_user_email_new")
                                        break
                                    else
                                        dead_email=0
                                        break 2
                                    fi
                                else
                                    MonitorError "request_count_json 2 : $request_count_json"
                                    sleep 30
                                fi
                            else
                                sleep 10
                            fi
                        done
                    done
                else
                    for zone_index in "${zones_index_monitor[@]}"
                    do
                        cf_zone_name=${cf_zones_name[zone_index]}
                        cf_zone_host_name=${cf_zones_host_name[zone_index]}
                        cf_zone_host_key=${cf_zones_host_key[zone_index]}
                        cf_zone_user_email=${cf_zones_user_email[zone_index]}
                        cf_zone_user_pass=${cf_zones_user_pass[zone_index]}
                        cf_zone_user_token=${cf_zones_user_token[zone_index]}
                        cf_zone_user_api_key=${cf_zones_user_api_key[zone_index]}
                        cf_zone_user_unique_id=${cf_zones_user_unique_id[zone_index]}
                        cf_zone_resolve_to=${cf_zones_resolve_to[zone_index]}
                        cf_zone_always_use_https=${cf_zones_always_use_https[zone_index]}
                        cf_zone_ssl=${cf_zones_ssl[zone_index]}
                        cf_zone_subdomains=${cf_zones_subdomains[zone_index]}

                        cf_user_unique_id=$cf_zone_user_unique_id
                        cf_host_key=$cf_zone_host_key
                        cf_user_email=$cf_zone_user_email
                        cf_user_pass=$cf_zone_user_pass
                        cf_user_token=$cf_zone_user_token
                        cf_user_api_key=$cf_zone_user_api_key

                        if [ -n "$cf_user_token" ] || [ -n "$cf_user_api_key" ]
                        then
                            CloudflareWorkersMonitorUpdateRoutes
                        else
                            for((index=0;index<20;index++));
                            do
                                if cf_user_token=$(python3 \
                                    "$CF_WORKERS_FILE" -e "$cf_user_email" -p "$cf_user_pass" -o api_token
                                ) 
                                then
                                    if [ -n "$cf_user_token" ] 
                                    then
                                        cf_zones_user_token[zone_index]=$cf_user_token
                                        CloudflareWorkersMonitorUpdateRoutes
                                        break
                                    else
                                        MonitorError "无法获取 $cf_zone_user_email Token"
                                        sleep 30
                                    fi
                                else
                                    sleep 10
                                fi
                            done
                        fi
                    done
                fi

                PrepTerm
                sleep "$cf_workers_monitor_seconds" &
                WaitTerm

                CloudflareGetUsers
            done
        } 204>&-
    } 204<"$pid_file"
}

CloudflareEnableWorkersMonitor()
{
    # deprecated
    if [ -s "/tmp/cf_workers.pid" ] && kill -0 "$(< /tmp/cf_workers.pid)" 2> /dev/null
    then
        Println "$error workers 监控已开启\n" && exit 1
    fi

    if [ -s "$CF_WORKERS_ROOT/cf_workers.pid" ] && kill -0 "$(< $CF_WORKERS_ROOT/cf_workers.pid)" 2> /dev/null
    then
        Println "$error workers 监控已开启\n" && exit 1
    fi

    CloudflareListWorkers

    if [ "$cf_workers_count" -eq 0 ] 
    then
        echo -e "$error 请先添加 worker\n"
        exit 1
    fi

    workers_name=()
    workers_path=()
    workers_project_name=()
    echo -e "选择 worker, 多个 worker 用空格分隔, 比如 5 7 9-11"
    while read -p "$i18n_default_cancel" workers_num 
    do
        [ -z "$workers_num" ] && Println "$i18n_canceled...\n" && exit 1
        IFS=" " read -ra workers_num_arr <<< "$workers_num"

        error_no=0
        for worker_num in "${workers_num_arr[@]}"
        do
            case "$worker_num" in
                *"-"*)
                    worker_num_start=${worker_num%-*}
                    worker_num_end=${worker_num#*-}
                    if [[ $worker_num_start == *[!0-9]* ]] || [[ $worker_num_end == *[!0-9]* ]] || \
                    [ "$worker_num_start" -eq 0 ] || [ "$worker_num_end" -eq 0 ] || \
                    [ "$worker_num_end" -gt "$cf_workers_count" ] || \
                    [ "$worker_num_start" -ge "$worker_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$worker_num" -lt 1 ] || [ "$worker_num" -gt "$cf_workers_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                for element in "${workers_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start;i<=end;i++));
                        do
                            cf_workers_index=$((i-1))
                            workers_name+=("${cf_workers_name[cf_workers_index]}")
                            workers_path+=("${cf_workers_path[cf_workers_index]}")
                            workers_project_name+=("${cf_workers_project_name[cf_workers_index]}")
                        done
                    else
                        cf_workers_index=$((element-1))
                        workers_name+=("${cf_workers_name[cf_workers_index]}")
                        workers_path+=("${cf_workers_path[cf_workers_index]}")
                        workers_project_name+=("${cf_workers_project_name[cf_workers_index]}")
                    fi
                done
                break
            ;;
        esac
    done

    ibm_cf_apps_count=0
    if [ -s "$IBM_CONFIG" ] 
    then
        IbmGetCfApps
    fi
    workers_data=()
    stream_proxy_history=()
    workers_count=${#workers_name[@]}

    workers_monitor_stream_proxy_pairs=()
    workers_monitor_stream_proxy_list=""
    workers_monitor_stream_proxy_count=0
    while IFS="^" read -r history_date history_pair
    do
        history_date=${history_date#\"}
        history_date=${history_date%\"}
        if [ -n "$history_date" ] 
        then
            workers_monitor_stream_proxy_count=$((workers_monitor_stream_proxy_count+1))
            history_pair=${history_pair%\"}
            workers_monitor_stream_proxy_pairs+=("$history_pair")
            history_pair=${history_pair// / => }
            workers_monitor_stream_proxy_pairs_list=${history_pair//|/$'\n' }
            printf -v date '%(%m-%d %H:%M:%S)T' "$history_date"
            workers_monitor_stream_proxy_list="$workers_monitor_stream_proxy_list $workers_monitor_stream_proxy_count. ${green}$date${normal}\n $workers_monitor_stream_proxy_pairs_list\n\n"
        fi
    done < <($JQ_FILE '(.workers_monitor.stream_proxy| if .== null then [] else . end)[]|([.date,(.pairs|to_entries|map([.value.project_name,.value.upstream]|join(" "))|join("|"))]|join("^"))' "$CF_CONFIG")

    if [ -n "$workers_monitor_stream_proxy_list" ] 
    then
        Println "$workers_monitor_stream_proxy_list"
        while read -p "选择 stream proxy worker 历史配置(默认: 不选择): " history_num
        do
            case $history_num in
                "") 
                    break
                ;;
                *[!0-9]*) 
                    Println "$error $i18n_input_correct_no\n"
                ;;
                *) 
                    if [ "$history_num" -gt 0 ] && [ "$history_num" -le "$workers_monitor_stream_proxy_count" ] 
                    then
                        history_index=$((history_num-1))
                        pair=${workers_monitor_stream_proxy_pairs[history_index]}
                        IFS="|" read -r -a pairs <<< "$pair"
                        break
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done
    fi

    for((i=0;i<workers_count;i++));
    do
        if [ "${workers_path[i]}" == "stream_proxy" ] && [ -n "${history_num:-}" ] 
        then
            for pair in "${pairs[@]}"
            do
                if [ "${pair% *}" == "${workers_project_name[i]}" ]
                then
                    sed -i 's/const upstream = .*/const upstream = "'"${pair#* }"'"/' "$CF_WORKERS_ROOT/stream_proxy/index.js"
                    worker_data=$(< "$CF_WORKERS_ROOT/stream_proxy/index.js")
                    workers_data+=("$worker_data")
                    continue 2
                fi
            done
        fi
        if [ "${workers_path[i]}" == "stream_proxy" ]
        then
            if [ "$ibm_cf_apps_count" -gt 0 ] 
            then
                echo
                inquirer list_input "是否使用 IBM CF APP 中转 worker: ${workers_name[i]}" yn_options use_ibm_cf_app_yn

                if [[ $use_ibm_cf_app_yn == "$i18n_yes" ]] 
                then
                    IbmListCfApps
                    echo -e "选择 APP"
                    while read -p "$i18n_default_cancel" ibm_cf_apps_num
                    do
                        case "$ibm_cf_apps_num" in
                            "")
                                Println "$i18n_canceled...\n" && exit 1
                            ;;
                            *[!0-9]*)
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *)
                                if [ "$ibm_cf_apps_num" -gt 0 ] && [ "$ibm_cf_apps_num" -le "$ibm_cf_apps_count" ]
                                then
                                    ibm_cf_apps_index=$((ibm_cf_apps_num-1))
                                    ibm_cf_app_name=${ibm_cf_apps_name[ibm_cf_apps_index]}
                                    ibm_user_email=${ibm_cf_apps_user_email[ibm_cf_apps_index]}
                                    ibm_cf_app_routes_count=${ibm_cf_apps_routes_count[ibm_cf_apps_index]}
                                    ibm_cf_app_route_hostname=${ibm_cf_apps_route_hostname[ibm_cf_apps_index]}
                                    ibm_cf_app_route_port=${ibm_cf_apps_route_port[ibm_cf_apps_index]}
                                    ibm_cf_app_route_domain=${ibm_cf_apps_route_domain[ibm_cf_apps_index]}
                                    ibm_cf_app_route_path=${ibm_cf_apps_route_path[ibm_cf_apps_index]}
                                    IFS="|" read -r -a ibm_cf_app_routes_hostname <<< "$ibm_cf_app_route_hostname"
                                    IFS="|" read -r -a ibm_cf_app_routes_port <<< "$ibm_cf_app_route_port"
                                    IFS="|" read -r -a ibm_cf_app_routes_domain <<< "$ibm_cf_app_route_domain"
                                    IFS="|" read -r -a ibm_cf_app_routes_path <<< "${ibm_cf_app_route_path}|"
                                    break
                                else
                                    Println "$error $i18n_input_correct_no\n"
                                fi
                            ;;
                        esac
                    done

                    ibm_cf_apps_list=""
                    ibm_cf_apps_link=()
                    for((j=0;j<ibm_cf_app_routes_count;j++));
                    do
                        if [ -n "${ibm_cf_app_routes_path[j]}" ] 
                        then
                            path="/${ibm_cf_app_routes_path[j]}"
                        else
                            path=""
                        fi
                        upstream="${ibm_cf_app_routes_hostname[j]}.${ibm_cf_app_routes_domain[j]}$path"
                        ibm_cf_apps_link+=("$upstream")
                        ibm_cf_apps_list="$ibm_cf_apps_list ${green}$((j+1)).${normal}${indent_6}$upstream\n\n"
                    done

                    Println "$ibm_cf_apps_list"

                    echo -e "选择链接"
                    while read -p "$i18n_default_cancel" ibm_cf_apps_link_num 
                    do
                        case $ibm_cf_apps_link_num in
                            "") 
                                Println "$i18n_canceled...\n"
                                exit 1
                            ;;
                            *[!0-9]*) 
                                Println "$error $i18n_input_correct_no\n"
                            ;;
                            *) 
                                if [ "$ibm_cf_apps_link_num" -gt 0 ] && [ "$ibm_cf_apps_link_num" -le "$ibm_cf_app_routes_count" ] 
                                then
                                    ibm_cf_apps_link_index=$((ibm_cf_apps_link_num-1))
                                    upstream=${ibm_cf_apps_link[ibm_cf_apps_link_index]}
                                    break
                                else
                                    Println "$error $i18n_input_correct_no\n"
                                fi
                            ;;
                        esac
                    done
                fi
            fi
            if [ -z "${upstream:-}" ] 
            then
                Println "$info 输入源站 ip 或者 中转服务器的域名(比如 IBM CF APP 的域名)"
                read -p "$i18n_default_cancel" upstream
                [ -z "$upstream" ] && Println "$i18n_canceled...\n" && exit 1
            fi
            sed -i 's/const upstream = .*/const upstream = "'"$upstream"'"/' "$CF_WORKERS_ROOT/${workers_path[i]}/index.js"
            stream_proxy_history+=("${workers_project_name[i]} $upstream")
        fi
        worker_data=$(< "$CF_WORKERS_ROOT/${workers_path[i]}/index.js")
        workers_data+=("$worker_data")
    done

    echo
    inquirer list_input "是否更新远端 worker" ny_options update_workers_data_yn

    if [ -n "${stream_proxy_history:-}" ] 
    then
        if [ -n "${pairs:-}" ] 
        then
            for pair in "${pairs[@]}"
            do
                stream_proxy_history+=("$pair")
            done
        fi
        new_historys=""
        for history in "${stream_proxy_history[@]}"
        do
            new_history=$(
            $JQ_FILE -n --arg project_name "${history% *}" --arg upstream "${history#* }" \
                '{
                    project_name: $project_name,
                    upstream: $upstream
                }'
            )
            [ -n "$new_historys" ] && new_historys="$new_historys,"
            new_historys="$new_historys$new_history"
        done

        new_workers_monitor_history=$(
        $JQ_FILE -n --argjson pairs "[$new_historys]" --arg date "$(date +%s)" \
            '{
                date: $date | tonumber,
                pairs: $pairs
            }'
        )
        jq_path='["workers_monitor","stream_proxy"]'
        JQ add "$CF_CONFIG" "$new_workers_monitor_history"
    fi

    CloudflareGetHosts

    if [ "$cf_hosts_count" -eq 0 ] 
    then
        Println "$error 请先添加 CFP\n" && exit 1
    fi

    cf_zones_count=0
    cf_zones_host_index=()
    cf_zones_host_name=()
    cf_zones_host_key=()
    cf_zones_name=()
    cf_zones_resolve_to=()
    cf_zones_always_use_https=()
    cf_zones_ssl=()
    cf_zones_subdomains=()
    cf_zones_user_email=()
    cf_zones_user_unique_id=()
    for((i=0;i<cf_hosts_count;i++));
    do
        cf_host_name=${cf_hosts_name[i]}
        cf_host_key=${cf_hosts_key[i]}
        cf_host_zones_count=${cf_hosts_zones_count[i]}
        cf_zones_count=$((cf_zones_count+cf_host_zones_count))
        cf_host_zone_name=${cf_hosts_zone_name[i]}
        cf_host_zone_resolve_to=${cf_hosts_zone_resolve_to[i]}
        cf_host_zone_always_use_https=${cf_hosts_zone_always_use_https[i]}
        cf_host_zone_ssl=${cf_hosts_zone_ssl[i]}
        cf_host_zone_subdomains=${cf_hosts_zone_subdomains[i]}
        cf_host_zone_user_email=${cf_hosts_zone_user_email[i]}
        cf_host_zone_user_unique_id=${cf_hosts_zone_user_unique_id[i]}
        IFS="|" read -r -a cf_host_zones_name <<< "$cf_host_zone_name"
        IFS="|" read -r -a cf_host_zones_resolve_to <<< "$cf_host_zone_resolve_to"
        IFS="|" read -r -a cf_host_zones_always_use_https <<< "${cf_host_zone_always_use_https}|"
        IFS="|" read -r -a cf_host_zones_ssl <<< "${cf_host_zone_ssl}|"
        IFS="|" read -r -a cf_host_zones_subdomains <<< "${cf_host_zone_subdomains}|"
        IFS="|" read -r -a cf_host_zones_user_email <<< "$cf_host_zone_user_email"
        IFS="|" read -r -a cf_host_zones_user_unique_id <<< "$cf_host_zone_user_unique_id"

        for((j=0;j<cf_host_zones_count;j++));
        do
            cf_zones_host_index+=("$i")
            cf_zones_host_name+=("$cf_host_name")
            cf_zones_host_key+=("$cf_host_key")
            cf_zones_name+=("${cf_host_zones_name[j]}")
            cf_zones_resolve_to+=("${cf_host_zones_resolve_to[j]}")
            cf_zones_always_use_https+=("${cf_host_zones_always_use_https[j]}")
            cf_zones_ssl+=("${cf_host_zones_ssl[j]}")
            cf_zones_subdomains+=("${cf_host_zones_subdomains[j]}")
            cf_zones_user_email+=("${cf_host_zones_user_email[j]}")
            cf_zones_user_unique_id+=("${cf_host_zones_user_unique_id[j]}")
        done
    done

    if [ "$cf_zones_count" -eq 0 ] 
    then
        Println "$error 请先添加源站\n" && exit 1
    fi

    cf_zones_list=""
    for((i=0;i<cf_zones_count;i++));
    do
        cf_zones_list="$cf_zones_list ${green}$((i+1)).${normal}${indent_6}源站: ${green}${cf_zones_name[i]}${normal} 用户: ${green}${cf_zones_user_email[i]}${normal}\n\n"
    done

    Println "$cf_zones_list"

    echo -e "选择源站, 多个源站用空格分隔, 比如 5 7 9-11"
    while read -p "$i18n_default_cancel" zones_num 
    do
        [ -z "$zones_num" ] && Println "$i18n_canceled...\n" && exit 1
        IFS=" " read -ra zones_num_arr <<< "$zones_num"

        error_no=0
        for zone_num in "${zones_num_arr[@]}"
        do
            case "$zone_num" in
                *"-"*)
                    zone_num_start=${zone_num%-*}
                    zone_num_end=${zone_num#*-}
                    if [[ $zone_num_start == *[!0-9]* ]] || [[ $zone_num_end == *[!0-9]* ]] || \
                    [ "$zone_num_start" -eq 0 ] || [ "$zone_num_end" -eq 0 ] || \
                    [ "$zone_num_end" -gt "$cf_zones_count" ] || \
                    [ "$zone_num_start" -ge "$zone_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$zone_num" -lt 1 ] || [ "$zone_num" -gt "$cf_zones_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                declare -a new_array
                for element in "${zones_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start-1;i<end;i++));
                        do
                            new_array+=("$i")
                        done
                    else
                        new_array+=("$((element-1))")
                    fi
                done
                zones_index_monitor=("${new_array[@]}")
                unset new_array
                break
            ;;
        esac
    done

    Println "$tip 模拟登录官网暂时有问题, 只能选 是"
    yn_options=( '是' )
    inquirer list_input "使用 api 获取 workers 请求数" yn_options yn_option
    if [ "$yn_option" == "$i18n_yes" ] 
    then
        cf_use_api=1
        cf_workers_monitor_seconds_default=1200
    else
        cf_use_api=0
        cf_workers_monitor_seconds_default=1800
    fi

    CloudflareGetUsers
    cf_zones_user_token=()
    cf_zones_user_pass=()
    cf_zones_user_api_key=()

    for((i=0;i<cf_zones_count;i++));
    do
        for((j=0;j<cf_users_count;j++));
        do
            if [ "${cf_users_email[j]}" == "${cf_zones_user_email[i]}" ]
            then
                cf_zones_user_pass+=("${cf_users_pass[j]}")
                if [ -z "${cf_users_token[j]}" ] && [ -z "${cf_users_api_key[j]}" ] && [ "$cf_use_api" -eq 1 ]
                then
                    cf_host_key=${cf_zones_host_key[i]}
                    cf_user_unique_id=${cf_zones_user_unique_id[i]}
                    cf_zone_name=${cf_zones_name[i]}
                    cf_user_email=${cf_zones_user_email[i]}
                    cf_user_pass=${cf_users_pass[j]}
                    cf_zone_resolve_to=${cf_zones_resolve_to[i]}
                    cf_zone_subdomains=${cf_zones_subdomains[i]}
                    CloudflareGetUser
                    CloudflareGetUsers
                    if [ -z "${cf_users_api_key[j]}" ] 
                    then
                        Println "$error 请先添加 ${cf_users_email[j]} Token 或 Key\n"
                        exit 1
                    fi
                fi
                cf_zones_user_token+=("${cf_users_token[j]}")
                cf_zones_user_api_key+=("${cf_users_api_key[j]}")
                continue 2
            fi
        done
        for index in "${zones_index_monitor[@]}"
        do
            if [ "$index" == "$i" ]
            then
                Println "$error 请先添加用户 ${cf_zones_user_email[i]}\n"
                exit 1
            fi
        done
    done

    Println "$info 设置检查时间间隔, 时间太短可能会被 cloudflare 限制查询 (秒)"
    while read -p "(默认: $cf_workers_monitor_seconds_default): " cf_workers_monitor_seconds
    do
        case $cf_workers_monitor_seconds in
            "") 
                cf_workers_monitor_seconds=$cf_workers_monitor_seconds_default
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$cf_workers_monitor_seconds" -ge $((cf_workers_monitor_seconds_default/3)) ] 
                then
                    break
                else
                    Println "$error 检查时间间隔太短\n"
                fi
            ;;
        esac
    done

    Println "$info 设置阀值, 请求数超过此值就会移动源站 CNAME"
    while read -p "(默认: 100000): " cf_workers_monitor_request_counts
    do
        case $cf_workers_monitor_request_counts in
            "") 
                cf_workers_monitor_request_counts=100000
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$cf_workers_monitor_request_counts" -ge 0 ] 
                then
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    Println "$tip 如果今天(UTC时间)已经开启过可以选 否"
    inquirer list_input "是否从第一个账号开始" yn_options start_from_begin

    if [[ $start_from_begin == "$i18n_yes" ]] 
    then
        start_from_begin=1
    else
        start_from_begin=0
    fi

    if [ "$cf_use_api" -eq 0 ] 
    then
        if [[ ! -x $(command -v python3) ]] 
        then
            Println "$info 安装 python3 ..."
            PythonInstall
        fi
        Println "$info 更新 ${CF_WORKERS_FILE##*/} ..."
        if [ "$sh_debug" -eq 0 ] && [ ! -f "$IPTV_ROOT/VIP" ]
        then
            curl -s -Lm 10 "$CF_WORKERS_LINK" -o "$CF_WORKERS_FILE" \
            || curl -s -Lm 20 "$CF_WORKERS_LINK_BACKUP" -o "$CF_WORKERS_FILE"
        fi  
    fi

    [ ! -d "${MONITOR_LOG%/*}" ] && MONITOR_LOG="$HOME/monitor.log"

    if [ "$sh_debug" -eq 1 ] 
    then
        ( CloudflareWorkersMonitor ) 
    else
        ( CloudflareWorkersMonitor ) > /dev/null 2>> "$MONITOR_LOG" &
    fi

    Println "$info workers 监控开启成功\n"
}

CloudflareDisableWorkersMonitor()
{
    # deprecated
    if [ -s "/tmp/cf_workers.pid" ] 
    then
        cf_workers_pid=$(< /tmp/cf_workers.pid)
        if kill -0 "$cf_workers_pid" 2> /dev/null
        then
            kill "$cf_workers_pid" 2> /dev/null
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            [ ! -d "${MONITOR_LOG%/*}" ] && MONITOR_LOG="$HOME/monitor.log"
            printf '%s\n' "$date_now 关闭 workers 监控 PID $cf_workers_pid !" >> "$MONITOR_LOG"
            Println "$info workers 监控 关闭成功\n"
        else
            Println "$error workers 监控 未开启\n"
        fi
    elif [ -s "$CF_WORKERS_ROOT/cf_workers.pid" ]
    then
        PID=$(< "$CF_WORKERS_ROOT/cf_workers.pid")
        if kill -0 "$PID" 2> /dev/null 
        then
            Println "$info 关闭 workers 监控, 稍等..."
            kill "$PID" 2> /dev/null
            if flock -E 1 -w 20 -x "$CF_WORKERS_ROOT/cf_workers.pid" rm -f "$CF_WORKERS_ROOT/cf_workers.pid"
            then
                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                printf '%s\n' "$date_now 关闭 workers 监控 PID $PID !" >> "$MONITOR_LOG"
                Println "$info workers 监控 关闭成功 !\n"
            else
                Println "$error workers 监控 关闭超时, 请重试\n"
                exit 1
            fi
        else
            rm -f "$CF_WORKERS_ROOT/cf_workers.pid"
            Println "$error workers 监控 未开启\n"
        fi
    else
        [ -e "$CF_WORKERS_ROOT/cf_workers.pid" ] && rm -f "$CF_WORKERS_ROOT/cf_workers.pid"
        Println "$error workers 监控 未开启\n"
    fi
}

CloudflareWorkersMenu()
{
    Println "  cloudflare 面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 安装 wrangler
  ${green}2.${normal} 更新 wrangler
  ${green}3.${normal} 查看 worker
  ${green}4.${normal} 添加 worker
  ${green}5.${normal} 更改 worker
  ${green}6.${normal} 部署 worker
  ${green}7.${normal} 设置 路由
  ${green}8.${normal} 开启 监控
  ${green}9.${normal} 关闭 监控
 ${green}10.${normal} 删除 worker

 $tip 当前: ${green}workers${normal} 面板
 $tip 输入: c 切换到 partner 面板\n\n"
    read -p "`gettext \"输入序号\"` [1-10]: " cloudflare_workers_num
    case $cloudflare_workers_num in
        c)
            CloudflarePartnerMenu
        ;;
        1) WranglerInstall
        ;;
        2) WranglerUpdate
        ;;
        3) CloudflareListWorker
        ;;
        4) CloudflareAddWorker
        ;;
        5) CloudflareEditWorker
        ;;
        6) CloudflareDeployWorker
        ;;
        7) CloudflareConfigWorkerRoute
        ;;
        8) CloudflareEnableWorkersMonitor
        ;;
        9) CloudflareDisableWorkersMonitor
        ;;
        10) CloudflareDelWorker
        ;;
        *) Println "$error $i18n_input_correct_number [1-10]\n"
        ;;
    esac
}

IbmInstallCfCli()
{
    if [[ -x $(command -v ibmcloud) ]] 
    then
        Println "$error IBM CF CLI 已存在\n"
        exit 1
    fi
    Println "$info 安装 IBM CF CLI ..."
    curl -sL https://ibm.biz/idt-installer | bash
    ibmcloud cf install
}

IbmUpdateCfCli()
{
    if [[ ! -x $(command -v ibmcloud) ]] 
    then
        Println "$error IBM CF CLI 未安装\n"
        exit 1
    fi
    Println "$info 更新 IBM CF CLI ..."
    ibmcloud update -f
    ibmcloud cf install -f
}

IbmGetUsers()
{
    ibm_users_list=""
    ibm_users_count=0
    ibm_users_email=()
    ibm_users_pass=()
    ibm_users_region=()
    ibm_users_resource_group=()
    ibm_users_org=()
    ibm_users_space=()
    while IFS=" " read -r email pass region resource_group org space
    do
        ibm_users_count=$((ibm_users_count+1))
        email=${email#\"}
        ibm_users_email+=("$email")
        ibm_users_pass+=("$pass")
        ibm_users_region+=("$region")
        ibm_users_resource_group+=("$resource_group")
        ibm_users_org+=("$org")
        space=${space%\"}
        ibm_users_space+=("$space")

        ibm_users_list="$ibm_users_list ${green}$ibm_users_count.${normal}${indent_6}地区: ${green}$region${normal}  资源组: ${green}$resource_group${normal}\n${indent_6}邮箱: ${green}$email${normal}  密码: ${green}$pass${normal}\n${indent_6}组织: ${green}$org${normal}  空间: ${green}$space${normal}\n\n"
    done < <($JQ_FILE '.users[]|[.email,.pass,.region,.resource_group,.org,.space]|join(" ")' "$IBM_CONFIG")
    return 0
}

IbmGetCfApps()
{
    ibm_cf_apps_list=""
    ibm_cf_apps_count=0
    ibm_cf_apps_name=()
    ibm_cf_apps_user_email=()
    ibm_cf_apps_routes_count=()
    ibm_cf_apps_route_hostname=()
    ibm_cf_apps_route_port=()
    ibm_cf_apps_route_domain=()
    ibm_cf_apps_route_path=()
    while IFS="^" read -r name user_email routes_count route_hostname route_port route_domain route_path
    do
        ibm_cf_apps_count=$((ibm_cf_apps_count+1))
        name=${name#\"}
        ibm_cf_apps_name+=("$name")
        ibm_cf_apps_user_email+=("$user_email")
        ibm_cf_apps_routes_count+=("$routes_count")
        ibm_cf_apps_route_hostname+=("$route_hostname")
        ibm_cf_apps_route_port+=("$route_port")
        ibm_cf_apps_route_domain+=("$route_domain")
        route_path=${route_path%\"}
        ibm_cf_apps_route_path+=("$route_path")

        ibm_cf_apps_list="$ibm_cf_apps_list ${green}$ibm_cf_apps_count.${normal}${indent_6}APP: ${green}$name${normal}  用户: ${green}$user_email${normal}  路由数: ${green}$routes_count${normal}\n\n"
    done < <($JQ_FILE '.cf.apps[]|[.name,.user_email,(.routes|length),([.routes[].hostname]|join("|")),([.routes[].port]|join("|")),([.routes[].domain]|join("|")),([.routes[].path]|join("|"))]|join("^")' "$IBM_CONFIG")
    return 0
}

IbmListUsers()
{
    if [ ! -s "$IBM_CONFIG" ] 
    then
        Println "$error 请先添加用户\n" && exit 1
    fi

    IbmGetUsers

    if [ "$ibm_users_count" -gt 0 ] 
    then
        Println "$ibm_users_list"
    else
        Println "$error 没有用户\n"
    fi
}

IbmLoginUser()
{
    IbmListUsers

    if [ "$ibm_users_count" -eq 0 ] 
    then
        Println "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" ibm_users_num
    do
        case "$ibm_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$ibm_users_num" -gt 0 ] && [ "$ibm_users_num" -le "$ibm_users_count" ]
                then
                    ibm_users_index=$((ibm_users_num-1))
                    ibm_user_email=${ibm_users_email[ibm_users_index]}
                    ibm_user_pass=${ibm_users_pass[ibm_users_index]}
                    ibm_user_region=${ibm_users_region[ibm_users_index]}
                    ibm_user_resource_group=${ibm_users_resource_group[ibm_users_index]}
                    ibm_user_org=${ibm_users_org[ibm_users_index]}
                    ibm_user_space=${ibm_users_space[ibm_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"
}

IbmUpdateCfApp()
{
    IbmListCfApps

    echo -e "选择 APP"
    while read -p "$i18n_default_cancel" ibm_cf_apps_num
    do
        case "$ibm_cf_apps_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$ibm_cf_apps_num" -gt 0 ] && [ "$ibm_cf_apps_num" -le "$ibm_cf_apps_count" ]
                then
                    ibm_cf_apps_index=$((ibm_cf_apps_num-1))
                    ibm_cf_app_name=${ibm_cf_apps_name[ibm_cf_apps_index]}
                    ibm_user_email=${ibm_cf_apps_user_email[ibm_cf_apps_index]}
                    ibm_cf_app_routes_count=${ibm_cf_apps_routes_count[ibm_cf_apps_index]}
                    ibm_cf_app_route_hostname=${ibm_cf_apps_route_hostname[ibm_cf_apps_index]}
                    ibm_cf_app_route_port=${ibm_cf_apps_route_port[ibm_cf_apps_index]}
                    ibm_cf_app_route_domain=${ibm_cf_apps_route_domain[ibm_cf_apps_index]}
                    ibm_cf_app_route_path=${ibm_cf_apps_route_path[ibm_cf_apps_index]}
                    IFS="|" read -r -a ibm_cf_app_routes_hostname <<< "$ibm_cf_app_route_hostname"
                    IFS="|" read -r -a ibm_cf_app_routes_port <<< "$ibm_cf_app_route_port"
                    IFS="|" read -r -a ibm_cf_app_routes_domain <<< "$ibm_cf_app_route_domain"
                    IFS="|" read -r -a ibm_cf_app_routes_path <<< "${ibm_cf_app_route_path}|"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    IbmGetUsers

    for((i=0;i<ibm_users_count;i++));
    do
        if [ "${ibm_users_email[i]}" == "$ibm_user_email" ] 
        then
            ibm_user_pass=${ibm_users_pass[i]}
            ibm_user_region=${ibm_users_region[i]}
            ibm_user_resource_group=${ibm_users_resource_group[i]}
            ibm_user_org=${ibm_users_org[i]}
            ibm_user_space=${ibm_users_space[i]}
            break
        fi
    done

    if [ -z "${ibm_user_pass:-}" ] 
    then
        Println "$error 没有找到用户 $ibm_user_email\n"
        exit 1
    fi

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"
}

IbmSetUserEmail()
{
    Println "请输入用户邮箱"
    read -p "$i18n_default_cancel" ibm_user_email
    [ -z "$ibm_user_email" ] && Println "$i18n_canceled...\n" && exit 1
    if [[ -n $($JQ_FILE '.users[]|select(.email=="'"$ibm_user_email"'")' "$IBM_CONFIG") ]] 
    then
        Println "$error 用户已经存在\n"
        exit 1
    fi
    Println "  用户邮箱: ${green} $ibm_user_email ${normal}\n"
}

IbmSetUserPass()
{
    Println "请输入用户密码"
    read -p "$i18n_default_cancel" ibm_user_pass
    [ -z "$ibm_user_pass" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  用户密码: ${green} $ibm_user_pass ${normal}\n"
}

IbmSetUserRegion()
{
    ibmcloud regions
    Println "请输入账号所在区域名称"
    read -p "(默认: us-south): " ibm_user_region
    ibm_user_region=${ibm_user_region:-us-south}
    Println "  区域: ${green} $ibm_user_region ${normal}\n"
}

IbmSetUserResourceGroup()
{
    ibmcloud resource groups
    Println "请输入资源组名称"
    read -p "(默认: Default): " ibm_user_resource_group
    ibm_user_resource_group=${ibm_user_resource_group:-Default}
    Println "  资源组: ${green} $ibm_user_resource_group ${normal}\n"
}

IbmSetUserOrg()
{
    ibmcloud account orgs
    Println "请输入组织名称"
    read -p "(默认: $ibm_user_email): " ibm_user_org
    ibm_user_org=${ibm_user_org:-$ibm_user_email}
    Println "  组织: ${green} $ibm_user_org ${normal}\n"
}

IbmSetUserSpace()
{
    ibmcloud account spaces
    Println "请输入空间名称"
    read -p "(默认: dev): " ibm_user_space
    ibm_user_space=${ibm_user_space:-dev}
    Println "  空间: ${green} $ibm_user_space ${normal}\n"
}

IbmGetApi()
{
    while IFS= read -r line 
    do
        if [[ $line == *"endpoint:"* ]] 
        then
            ibm_api=${line##* }
            break
        fi
    done < <(ibmcloud api)

    if [ -z "${ibm_api:-}" ] 
    then
        Println "$error 无法获取 ibmcloud api ?\n"
        exit 1
    fi
}

IbmAddUser()
{
    if [ ! -s "$IBM_CONFIG" ] 
    then
        printf '{"%s":[],"%s":{"%s":[]}}' "users" "cf" "apps" > "$IBM_CONFIG"
    fi

    IbmSetUserEmail
    IbmSetUserPass

    IbmGetApi

    ibmcloud api "$ibm_api"

    IbmSetUserRegion

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region"

    IbmSetUserResourceGroup

    ibmcloud target -g "$ibm_user_resource_group"

    IbmSetUserOrg

    ibmcloud target -o "$ibm_user_org"

    IbmSetUserSpace

    ibmcloud target -s "$ibm_user_space"

    new_user=$(
    $JQ_FILE -n --arg email "$ibm_user_email" --arg pass "$ibm_user_pass" \
        --arg region "$ibm_user_region" --arg resource_group "$ibm_user_resource_group" \
        --arg org "$ibm_user_org" --arg space "$ibm_user_space" \
        '{
            email: $email,
            pass: $pass,
            region: $region,
            resource_group: $resource_group,
            org: $org,
            space: $space
        }'
    )

    jq_path='["users"]'
    JQ add "$IBM_CONFIG" "$new_user"
    Println "$info 用户添加成功\n"
}

IbmEditUser()
{
    IbmListUsers

    if [ "$ibm_users_count" -eq 0 ] 
    then
        echo -e "$error 请先添加用户\n"
        exit 1
    fi

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" ibm_users_num
    do
        case "$ibm_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$ibm_users_num" -gt 0 ] && [ "$ibm_users_num" -le "$ibm_users_count" ]
                then
                    ibm_users_index=$((ibm_users_num-1))
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    IbmSetUserEmail
    IbmSetUserPass

    IbmGetApi

    ibmcloud api "$ibm_api"

    IbmSetUserRegion

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region"

    IbmSetUserResourceGroup

    ibmcloud target -g "$ibm_user_resource_group"

    IbmSetUserOrg

    ibmcloud target -o "$ibm_user_org"

    IbmSetUserSpace

    ibmcloud target -s "$ibm_user_space"

    new_user=$(
    $JQ_FILE -n --arg email "$ibm_user_email" --arg pass "$ibm_user_pass" \
        --arg region "$ibm_user_region" --arg resource_group "$ibm_user_resource_group" \
        --arg org "$ibm_user_org" --arg space "$ibm_user_space" \
        '{
            email: $email,
            pass: $pass,
            region: $region,
            resource_group: $resource_group,
            org: $org,
            space: $space
        }'
    )

    jq_path='["users",'"$ibm_users_index"']'
    JQ replace "$IBM_CONFIG" "$new_user"
    Println "$info 用户修改成功\n"
}

IbmSetCfAppName()
{
    Println "请输入 APP 名称\n$tip 确保已经在官网建立此 CF APP, 也可以用命令 ibmcloud dev create 新建\n"
    read -p "$i18n_default_cancel" ibm_cf_app_name
    [ -z "$ibm_cf_app_name" ] && Println "$i18n_canceled...\n" && exit 1
    if [[ -n $($JQ_FILE '.cf.apps[]|select(.user_email=="'"$ibm_user_email"'" and .name=="'"$ibm_cf_app_name"'")' "$IBM_CONFIG") ]] 
    then
        Println "$error 此 APP 已存在\n"
        exit 1
    fi
    Println "  APP: ${green} $ibm_cf_app_name ${normal}\n"
}

IbmAddCfApp()
{
    IbmLoginUser

    ibmcloud cf apps

    IbmSetCfAppName

    Println "$info 查询路由 ..."

    app_guid=$(ibmcloud cf app "$ibm_cf_app_name" --guid -q)

    IFS="^" read -r route_guid hostname domain_guid path < <(ibmcloud cf curl "/v2/apps/$app_guid/routes" -q \
        | $JQ_FILE -r '[([.resources[].metadata.guid]|join("|")),([.resources[].entity.host]|join("|")),([.resources[].entity.domain_guid]|join("|")),([.resources[].entity.path]|join("|"))]|join("^")')

    ibm_cf_app_routes_count=0
    if [ -n "$route_guid" ] 
    then
        IFS="|" read -r -a ibm_cf_app_routes_guid <<< "$route_guid"
        IFS="|" read -r -a ibm_cf_app_routes_hostname <<< "$hostname"
        IFS="|" read -r -a ibm_cf_app_routes_domain_guid <<< "$domain_guid"
        IFS="|" read -r -a ibm_cf_app_routes_path <<< "${path}|"
        ibm_cf_app_routes_count=${#ibm_cf_app_routes_guid[@]}

        IFS="^" read -r port route_guid < <(ibmcloud cf curl "/v2/route_mappings?q=app_guid:$app_guid" -q \
            | $JQ_FILE -r '[([.resources[].entity.app_port]|join("|")),([.resources[].entity.route_guid]|join("|"))]|join("^")')

        IFS="|" read -r -a ports <<< "$port"
        IFS="|" read -r -a routes_guid <<< "$route_guid"

        IFS="^" read -r domain domain_guid < <(ibmcloud cf curl "/v2/domains" -q \
            | $JQ_FILE -r '[([.resources[].entity.name]|join("|")),([.resources[].metadata.guid]|join("|"))]|join("^")')

        IFS="|" read -r -a domains <<< "$domain"
        IFS="|" read -r -a domains_guid <<< "$domain_guid"

        ibm_cf_app_routes_port=()
        ibm_cf_app_routes_domain=()

        for((i=0;i<ibm_cf_app_routes_count;i++));
        do
            for((j=0;j<ibm_cf_app_routes_count;j++));
            do
                if [ "${routes_guid[j]}" == "${ibm_cf_app_routes_guid[i]}" ] 
                then
                    ibm_cf_app_routes_port+=("${ports[j]}")
                    break
                fi
            done

            for((k=0;k<${#domains_guid[@]};k++));
            do
                if [ "${domains_guid[k]}" == "${ibm_cf_app_routes_domain_guid[i]}" ] 
                then
                    ibm_cf_app_routes_domain+=("${domains[k]}")
                    break
                fi
            done
        done

        for ibm_cf_app_route_guid in "${ibm_cf_app_routes_guid[@]}"
        do
            for((i=0;i<ibm_cf_app_routes_count;i++));
            do
                if [ "${routes_guid[i]}" == "$ibm_cf_app_route_guid" ] 
                then
                    ibm_cf_app_routes_port+=("${ports[i]}")
                    break
                fi
            done
        done
    fi

    ibm_cf_app_routes=""
    for((i=0;i<ibm_cf_app_routes_count;i++));
    do
        [ -n "$ibm_cf_app_routes" ] && ibm_cf_app_routes="$ibm_cf_app_routes,"
        ibm_cf_app_route=$(
        $JQ_FILE -n --arg hostname "${ibm_cf_app_routes_hostname[i]}" --arg port "${ibm_cf_app_routes_port[i]}" \
            --arg domain "${ibm_cf_app_routes_domain[i]}" --arg path "${ibm_cf_app_routes_path[i]}" \
            '{
                hostname: $hostname,
                port: $port | tonumber,
                domain: $domain,
                path: $path
            }'
        )
        ibm_cf_app_routes="$ibm_cf_app_routes$ibm_cf_app_route"
    done

    ibm_cf_app=$(
    $JQ_FILE -n --arg name "$ibm_cf_app_name" --arg user_email "$ibm_user_email" \
        --argjson routes "[$ibm_cf_app_routes]" \
        '{
            name: $name,
            user_email: $user_email,
            routes: $routes
        }'
    )

    jq_path='["cf","apps"]'
    JQ add "$IBM_CONFIG" "$ibm_cf_app"

    Println "$info APP 添加成功\n"
}

IbmListCfApps()
{
    if [ ! -s "$IBM_CONFIG" ] 
    then
        Println "$error 请先添加 APP\n" && exit 1
    fi

    IbmGetCfApps

    if [ "$ibm_cf_apps_count" -gt 0 ] 
    then
        Println "$ibm_cf_apps_list"
    else
        Println "$error 没有 APP\n"
        exit 1
    fi
}

IbmListCfApp()
{
    IbmListCfApps

    echo -e "选择 APP"
    while read -p "$i18n_default_cancel" ibm_cf_apps_num
    do
        case "$ibm_cf_apps_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$ibm_cf_apps_num" -gt 0 ] && [ "$ibm_cf_apps_num" -le "$ibm_cf_apps_count" ]
                then
                    ibm_cf_apps_index=$((ibm_cf_apps_num-1))
                    ibm_cf_app_name=${ibm_cf_apps_name[ibm_cf_apps_index]}
                    ibm_user_email=${ibm_cf_apps_user_email[ibm_cf_apps_index]}
                    ibm_cf_app_routes_count=${ibm_cf_apps_routes_count[ibm_cf_apps_index]}
                    ibm_cf_app_route_hostname=${ibm_cf_apps_route_hostname[ibm_cf_apps_index]}
                    ibm_cf_app_route_port=${ibm_cf_apps_route_port[ibm_cf_apps_index]}
                    ibm_cf_app_route_domain=${ibm_cf_apps_route_domain[ibm_cf_apps_index]}
                    ibm_cf_app_route_path=${ibm_cf_apps_route_path[ibm_cf_apps_index]}
                    IFS="|" read -r -a ibm_cf_app_routes_hostname <<< "$ibm_cf_app_route_hostname"
                    IFS="|" read -r -a ibm_cf_app_routes_port <<< "$ibm_cf_app_route_port"
                    IFS="|" read -r -a ibm_cf_app_routes_domain <<< "$ibm_cf_app_route_domain"
                    IFS="|" read -r -a ibm_cf_app_routes_path <<< "${ibm_cf_app_route_path}|"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    IbmGetUsers

    for((i=0;i<ibm_users_count;i++));
    do
        if [ "${ibm_users_email[i]}" == "$ibm_user_email" ] 
        then
            ibm_user_pass=${ibm_users_pass[i]}
            ibm_user_region=${ibm_users_region[i]}
            ibm_user_resource_group=${ibm_users_resource_group[i]}
            ibm_user_org=${ibm_users_org[i]}
            ibm_user_space=${ibm_users_space[i]}
            break
        fi
    done

    if [ -z "${ibm_user_pass:-}" ] 
    then
        Println "$error 没有找到用户 $ibm_user_email\n"
        exit 1
    fi

    ibm_cf_app_routes_list=""
    for((i=0;i<ibm_cf_app_routes_count;i++));
    do
        ibm_cf_app_routes_list="$ibm_cf_app_routes_list ${green}$((i+1)).${normal}${indent_6}Host: ${green}${ibm_cf_app_routes_hostname[i]}${normal}  端口: ${green}${ibm_cf_app_routes_port[i]}${normal}\n${indent_6}域名: ${green}${ibm_cf_app_routes_domain[i]}${normal}  路径: ${green}${ibm_cf_app_routes_path[i]:-无}${normal}\n\n"
    done

    Println "APP: ${green}$ibm_cf_app_name${normal}\n\n区域: ${green}$ibm_user_region${normal}\n\n用户: ${green}$ibm_user_email${normal}\n\n资源组: ${green}$ibm_user_resource_group${normal}\n\n组织：${green}$ibm_user_org${normal}\n\n空间：${green}$ibm_user_space${normal}\n\n路由:\n\n${ibm_cf_app_routes_list:-无}\n"
}

IbmSetCfAppRouteDomain()
{
    IFS="|" read -r domain < <(ibmcloud cf curl "/v2/domains" -q \
        | $JQ_FILE -r '[.resources[].entity.name]|join("|")')

    if [ -z "$domain" ] 
    then
        Println "$error 无法获取域名, 请重试"
    fi

    IFS="|" read -r -a domains <<< "$domain"

    domains_list=""
    domains_count=0
    for((i=0;i<${#domains[@]};i++));
    do
        domains_count=$((domains_count+1))
        if [[ ${domains[i]} == *"cf.appdomain.cloud" ]] 
        then
            default_domain_num=$domains_count
        fi
        domains_list="$domains_list ${green}$domains_count.${normal} ${domains[i]}\n\n"
    done

    default_domain_num=${default_domain_num:-1}

    Println "$domains_list"
    echo -e "选择域名"
    while read -p "(默认: $default_domain_num): " domains_num
    do
        case $domains_num in
            "") 
                domains_index=$((default_domain_num-1))
                ibm_cf_app_route_domain=${domains[domains_index]}
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_no\n"
            ;;
            *) 
                if [ "$domains_num" -gt 0 ] && [ "$domains_num" -le "$domains_count" ]
                then
                    domains_index=$((default_domain_num-1))
                    ibm_cf_app_route_domain=${domains[domains_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "  路由域名: ${green} $ibm_cf_app_route_domain ${normal}\n"
}

IbmSetCfAppRouteHostname()
{
    Println "请输入 http 路由 hostname (子域名名称)"
    read -p "$i18n_default_cancel" ibm_cf_app_route_hostname
    [ -z "$ibm_cf_app_route_hostname" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  路由 hostname: ${green} $ibm_cf_app_route_hostname ${normal}\n"
}

IbmSetCfAppRoutePath()
{
    echo
    inquirer text_input "请输入 http 路由 path: " ibm_cf_app_route_path "不设置"
    if [ "$ibm_cf_app_route_path" == "不设置" ] 
    then
        ibm_cf_app_route_path=""
    fi
}

IbmSetCfAppRoutePort()
{
    Println "请输入路由指向的 APP 端口"
    while read -p "$i18n_default_cancel" ibm_cf_app_route_port 
    do
        case $ibm_cf_app_route_port in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*) 
                Println "$error 请输入正确的端口\n"
            ;;
            *) 
                break
            ;;
        esac
    done

    Println "  路由端口: ${green} $ibm_cf_app_route_port ${normal}\n"
}

IbmAddCfAppRoute()
{
    IbmListCfApp

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"

    IbmSetCfAppRouteDomain
    IbmSetCfAppRouteHostname
    IbmSetCfAppRoutePath

    for((i=0;i<ibm_cf_app_routes_count;i++));
    do
        if [ "${ibm_cf_app_routes_domain[i]}" == "$ibm_cf_app_route_domain" ] && [ "${ibm_cf_app_routes_hostname[i]}" == "$ibm_cf_app_route_hostname" ] && [ "${ibm_cf_app_routes_path[i]}" == "$ibm_cf_app_route_path" ]
        then
            Println "$error 此路由已经存在\n"
            exit 1
        fi
    done

    IbmSetCfAppRoutePort

    ibmcloud cf create-route "$ibm_user_space" "$ibm_cf_app_route_domain" --hostname "$ibm_cf_app_route_hostname" --path "$ibm_cf_app_route_path"
    ibm_cf_app_route_guid=$(ibmcloud cf curl "/v2/routes?q=host:$ibm_cf_app_route_hostname" -q | $JQ_FILE -r '.resources[0].metadata.guid')

    ibm_cf_app_routes_port+=("$ibm_cf_app_route_port")
    ibm_cf_app_routes_port_unique=()
    for port in "${ibm_cf_app_routes_port[@]}"
    do
        for port_unique in ${ibm_cf_app_routes_port_unique[@]+"${ibm_cf_app_routes_port_unique[@]}"}
        do
            if [ "$port_unique" == "$port" ] 
            then
                continue 2
            fi
        done
        ibm_cf_app_routes_port_unique+=("$port")
    done

    printf -v ibm_cf_app_route_ports_list ',%s' "${ibm_cf_app_routes_port_unique[@]}"
    ibm_cf_app_route_ports_list=${ibm_cf_app_route_ports_list:1}

    app_guid=$(ibmcloud cf app "$ibm_cf_app_name" --guid -q)
    ibmcloud cf curl "/v2/apps/$app_guid" -X PUT -d '{"ports": ['"$ibm_cf_app_route_ports_list"']}'
    ibmcloud cf curl /v2/route_mappings -X POST -d '{"app_guid": "'"$app_guid"'", "route_guid": "'"$ibm_cf_app_route_guid"'", "app_port": '"$ibm_cf_app_route_port"'}'

    ibm_cf_app_route=$(
    $JQ_FILE -n --arg hostname "$ibm_cf_app_route_hostname" --arg port "$ibm_cf_app_route_port" \
        --arg domain "$ibm_cf_app_route_domain" --arg path "$ibm_cf_app_route_path" \
        '{
            hostname: $hostname,
            port: $port | tonumber,
            domain: $domain,
            path: $path
        }'
    )

    jq_path='["cf","apps",'"$ibm_cf_apps_index"',"routes"]'
    JQ add "$IBM_CONFIG" "$ibm_cf_app_route"

    Println "$info 路由添加成功"
}

IbmDelUser()
{
    IbmListUsers

    echo -e "选择用户"
    while read -p "$i18n_default_cancel" ibm_users_num
    do
        case "$ibm_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$ibm_users_num" -gt 0 ] && [ "$ibm_users_num" -le "$ibm_users_count" ]
                then
                    ibm_users_index=$((ibm_users_num-1))
                    ibm_user_email=${ibm_users_email[ibm_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    jq_path='["users"]'
    JQ delete "$IBM_CONFIG" "$ibm_users_index"

    Println "$info 用户 $ibm_user_email 删除成功"
}

IbmDelApp()
{
    IbmListCfApp

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"

    echo
    inquirer list_input "是否删除 APP 绑定的路由" yn_options delete_app_routes_yn

    if [[ $delete_app_routes_yn == "$i18n_yes" ]] 
    then
        ibmcloud cf delete "$ibm_cf_app_name" -r
    else
        ibmcloud cf delete "$ibm_cf_app_name"
    fi

    jq_path='["cf","apps"]'
    JQ delete "$IBM_CONFIG" "$ibm_cf_apps_index"

    Println "$info APP $ibm_cf_app_name 删除成功"
}

IbmDelAppRoute()
{
    IbmListCfApp

    echo -e "选择需要删除的路由"
    while read -p "$i18n_default_cancel" ibm_cf_app_routes_num
    do
        case $ibm_cf_app_routes_num in
            "") 
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*) 
                Println "$error 请输入正确的端口\n"
            ;;
            *) 
                if [ "$ibm_cf_app_routes_num" -gt 0 ] && [ "$ibm_cf_app_routes_num" -le "$ibm_cf_app_routes_count" ]
                then
                    ibm_cf_app_routes_index=$((ibm_cf_app_routes_num-1))
                    ibm_cf_app_route_domain=${ibm_cf_app_routes_domain[ibm_cf_app_routes_index]}
                    ibm_cf_app_route_hostname=${ibm_cf_app_routes_hostname[ibm_cf_app_routes_index]}
                    ibm_cf_app_route_port=${ibm_cf_app_routes_port[ibm_cf_app_routes_index]}
                    ibm_cf_app_route_path=${ibm_cf_app_routes_path[ibm_cf_app_routes_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"

    ibm_cf_app_routes_port_unique=()
    for((i=0;i<ibm_cf_app_routes_count;i++));
    do
        [[ $i -eq "$ibm_cf_app_routes_index" ]] && continue
        for port_unique in ${ibm_cf_app_routes_port_unique[@]+"${ibm_cf_app_routes_port_unique[@]}"}
        do
            if [ "$port_unique" == "${ibm_cf_app_routes_port[i]}" ] 
            then
                continue 2
            fi
        done
        ibm_cf_app_routes_port_unique+=("${ibm_cf_app_routes_port[i]}")
    done

    printf -v ibm_cf_app_route_ports_list ',%s' "${ibm_cf_app_routes_port_unique[@]}"
    ibm_cf_app_route_ports_list=${ibm_cf_app_route_ports_list:1}

    app_guid=$(ibmcloud cf app "$ibm_cf_app_name" --guid -q)
    ibmcloud cf curl "/v2/apps/$app_guid" -X PUT -d '{"ports": ['"$ibm_cf_app_route_ports_list"']}'

    if ibmcloud cf delete-route "$ibm_cf_app_route_domain" --hostname "$ibm_cf_app_route_hostname" --path "$ibm_cf_app_route_path" -f
    then
        jq_path='["cf","apps",'"$ibm_cf_apps_index"',"routes"]'
        JQ delete "$IBM_CONFIG" "$ibm_cf_app_routes_index"

        Println "$info 路由删除成功"
    fi
}

IbmUpdateV2rayConfig()
{
    if [ ! -d "$IBM_APPS_ROOT/ibm_$v2ray_name" ] 
    then
        Println "$error $v2ray_name 未安装...\n"
        exit 1
    elif [ ! -s "$V2_CONFIG" ] 
    then
        printf '%s' '{
  "log": {
    "access": "none",
    "error": "none",
    "loglevel": "none"
  },
  "inbounds": [],
  "outbounds": [
    {
      "protocol": "freedom",
      "tag": "direct"
    },
    {
      "protocol": "blackhole",
      "tag": "block"
    }
  ]
}' > "$V2_CONFIG"
    fi
}

IbmDownloadV2ray()
{
    if [ -d "$IBM_APPS_ROOT/ibm_$v2ray_name" ] 
    then
        Println "$error ibm $v2ray_name 已存在\n"
    else
        DepsCheck
        JQInstall

        Println "$info 下载 ibm $v2ray_name ..."
        cd ~
        rm -rf $v2ray_package_name-linux-64
        if v2ray_version=$(curl -s -L "$FFMPEG_MIRROR_LINK/$v2ray_name.json" | $JQ_FILE -r '.tag_name') && curl -L "$FFMPEG_MIRROR_LINK/$v2ray_name/$v2ray_version/$v2ray_package_name-linux-64.zip" -o "$v2ray_package_name-linux-64.zip" && unzip "$v2ray_package_name-linux-64.zip" -d "$v2ray_package_name-linux-64" > /dev/null
        then
            mkdir -p "$IBM_APPS_ROOT/ibm_$v2ray_name"
            mv ${v2ray_package_name}-linux-64/$v2ray_name "$IBM_APPS_ROOT/ibm_$v2ray_name/"
            if [ "$v2ray_name" == "xray" ] 
            then
                if ! curl -L "$FFMPEG_MIRROR_LINK/xray/v2ctl" -o "$IBM_APPS_ROOT/ibm_$v2ray_name/v2ctl"
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                fi
            else
                mv $v2ray_package_name-linux-64/v2ctl "$IBM_APPS_ROOT/ibm_$v2ray_name/"
            fi
            chmod 700 "$IBM_APPS_ROOT/ibm_$v2ray_name/$v2ray_name"
            chmod 700 "$IBM_APPS_ROOT/ibm_$v2ray_name/v2ctl"
            Println "$info ibm $v2ray_name 下载完成\n"
        else
            Println "$error 无法连接服务器, 请稍后再试\n"
        fi
    fi
}

IbmUpdateV2ray()
{
    if [ ! -d "$IBM_APPS_ROOT/ibm_$v2ray_name" ] 
    then
        Println "$error ibm $v2ray_name 未安装\n"
    else
        Println "$info 更新 ibm $v2ray_name ..."
        cd ~
        rm -rf $v2ray_package_name-linux-64
        if v2ray_version=$(curl -s -L "$FFMPEG_MIRROR_LINK/$v2ray_name.json" | $JQ_FILE -r '.tag_name') && curl -L "$FFMPEG_MIRROR_LINK/$v2ray_name/$v2ray_version/$v2ray_package_name-linux-64.zip" -o "$v2ray_package_name-linux-64.zip" && unzip $v2ray_package_name-linux-64.zip -d $v2ray_package_name-linux-64 > /dev/null
        then
            mkdir -p "$IBM_APPS_ROOT/ibm_$v2ray_name"
            mv $v2ray_package_name-linux-64/$v2ray_name "$IBM_APPS_ROOT/ibm_$v2ray_name/"
            if [ "$v2ray_name" == "xray" ] 
            then
                if ! curl -L "$FFMPEG_MIRROR_LINK/xray/v2ctl" -o "$IBM_APPS_ROOT/ibm_$v2ray_name/v2ctl"
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                fi
            else
                mv $v2ray_package_name-linux-64/v2ctl "$IBM_APPS_ROOT/ibm_$v2ray_name/"
            fi
            chmod 700 "$IBM_APPS_ROOT/ibm_$v2ray_name/$v2ray_name"
            chmod 700 "$IBM_APPS_ROOT/ibm_$v2ray_name/v2ctl"
            Println "$info ibm $v2ray_name 更新完成\n"
        else
            Println "$error 无法连接服务器, 请稍后再试\n"
        fi
    fi
}

IbmDeployV2ray()
{
    V2rayGetInbounds

    port_found=0
    for port in ${inbounds_port[@]+"${inbounds_port[@]}"}
    do
        if [ "$port" -eq 8080 ] 
        then
            port_found=1
            break
        fi
    done

    if [ "$port_found" -eq 0 ] 
    then
        Println "$error 请先添加 8080 端口\n"
        exit 1
    fi

    if [ ! -e "$IBM_APPS_ROOT/ibm_$v2ray_name/$v2ray_name" ] || [ ! -e "$IBM_APPS_ROOT/ibm_$v2ray_name/v2ctl" ]
    then
        Println "$error 请先更新 IBM $v2ray_name APP\n"
        exit 1
    fi

    IbmListCfApp

    Println "$info 登录账号: $ibm_user_email [ $ibm_user_region ]"
    ibmcloud login -u "$ibm_user_email" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
    ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"

    v2ray_rand_name=$(RandStr)
    cp -r "$IBM_APPS_ROOT/ibm_$v2ray_name" "$IBM_APPS_ROOT/ibm_$v2ray_rand_name"

    cd "$IBM_APPS_ROOT/ibm_$v2ray_rand_name/"

    mv $v2ray_name "$v2ray_rand_name"
    if [ "$v2ray_name" == "xray" ] 
    then
        ./v2ctl convert config.json > "$v2ray_rand_name.pb"
    else
        ./v2ctl config config.json > "$v2ray_rand_name.pb"
    fi
    tar zcf "$v2ray_rand_name.tar.gz" "$v2ray_rand_name" "$v2ray_rand_name.pb"
    rm -f config.json
    rm -f config.json.lock
    rm -f "$v2ray_rand_name"
    rm -f "$v2ray_rand_name.pb"
    rm -f v2ctl

    ibmcloud cf create-app-manifest "$ibm_cf_app_name"

    routes=""
    while read -r line 
    do
        if [[ $line =~ disk_quota: ]] 
        then
            disk_quota=${line##* }
        elif [[ $line =~ instances: ]] 
        then
            instances=${line##* }
        elif [[ $line =~ memory: ]] 
        then
            memory=${line##* }
        elif [[ $line =~ routes: ]] || [[ $line =~ route: ]]
        then
            [ -n "$routes" ] && routes="$routes\n"
            routes="$routes$line"
        elif [[ $line =~ stack: ]] 
        then
            stack=${line##* }
        fi
    done < "${ibm_cf_app_name}_manifest.yml"

    echo -e "---
applications:
- name: $ibm_cf_app_name
  command:
    tar xzf $v2ray_rand_name.tar.gz &&
    { ./$v2ray_rand_name -config ./$v2ray_rand_name.pb -format=pb & } &&
    sleep 5 &&
    rm ./$v2ray_rand_name.pb &&
    rm ./$v2ray_rand_name
  disk_quota: $disk_quota
  instances: ${instances:-1}
  memory: $memory
  stack: $stack
  buildpacks:
    - go_buildpack
  env:
    GOPACKAGENAME: goapp
" > "${ibm_cf_app_name}_manifest.yml"

    printf '%s' 'package main

func main() {

}
' > "main.go"
    ibmcloud cf push -f "${ibm_cf_app_name}_manifest.yml"
    cd ..
    rm -rf "$IBM_APPS_ROOT/ibm_$v2ray_rand_name"
}

IbmV2rayMenu()
{
    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"

    Println " IBM $v2ray_package_name APP 面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 下载 $v2ray_package_name APP
  ${green}2.${normal} 更新 $v2ray_package_name APP
  ${green}3.${normal} 部署 $v2ray_package_name APP
————————————
  ${green}4.${normal} 查看入站
  ${green}5.${normal} 添加入站
  ${green}6.${normal} 添加入站账号
————————————
  ${green}7.${normal} 查看出站
  ${green}8.${normal} 添加出站
  ${green}9.${normal} 添加出站账号
————————————
 ${green}10.${normal} 查看DNS
 ${green}11.${normal} 设置DNS
————————————
 ${green}12.${normal} 查看路由
 ${green}13.${normal} 设置路由
————————————
 ${green}14.${normal} 查看策略
 ${green}15.${normal} 设置策略
————————————
 ${green}16.${normal} 查看流量
 ${green}17.${normal} 重置流量
————————————
 ${green}18.${normal} 查看反向代理
 ${green}19.${normal} 设置反向代理
————————————
 ${green}20.${normal} 删除入站
 ${green}21.${normal} 删除入站账号
 ${green}22.${normal} 删除出站
 ${green}23.${normal} 删除出站账号

    "
    read -p "$i18n_default_cancel" ibm_v2ray_num
    case $ibm_v2ray_num in
        1) 
            IbmDownloadV2ray
        ;;
        2) 
            IbmUpdateV2ray
        ;;
        3) 
            IbmUpdateV2rayConfig
            IbmDeployV2ray
        ;;
        4) 
            IbmUpdateV2rayConfig
            V2rayListInboundAccounts
            V2rayListInboundAccountLink
        ;;
        5) 
            IbmUpdateV2rayConfig
            V2rayAddInbound
        ;;
        6) 
            IbmUpdateV2rayConfig
            V2rayAddInboundAccount
        ;;
        7) 
            IbmUpdateV2rayConfig
            V2rayListOutboundAccounts
        ;;
        8) 
            IbmUpdateV2rayConfig
            V2rayAddOutbound
        ;;
        9) 
            IbmUpdateV2rayConfig
            V2rayAddOutboundAccount
        ;;
        10) 
            IbmUpdateV2rayConfig
            V2rayListDns
        ;;
        11) 
            IbmUpdateV2rayConfig
            V2raySetDns
        ;;
        12) 
            IbmUpdateV2rayConfig
            V2rayListRouting
        ;;
        13) 
            IbmUpdateV2rayConfig
            V2raySetRouting
        ;;
        14) 
            IbmUpdateV2rayConfig
            V2rayListPolicy
        ;;
        15) 
            IbmUpdateV2rayConfig
            V2raySetPolicy
        ;;
        16) 
            IbmUpdateV2rayConfig
            V2rayListStats
        ;;
        17) 
            IbmUpdateV2rayConfig
            V2rayResetStats
        ;;
        18) 
            IbmUpdateV2rayConfig
            V2rayListReverse
        ;;
        19) 
            IbmUpdateV2rayConfig
            V2raySetReverse
        ;;
        20) 
            IbmUpdateV2rayConfig
            V2rayDeleteInbound
        ;;
        21) 
            IbmUpdateV2rayConfig
            V2rayDeleteInboundAccount
        ;;
        22) 
            IbmUpdateV2rayConfig
            V2rayDeleteOutbound
        ;;
        23) 
            IbmUpdateV2rayConfig
            V2rayDeleteOutboundAccount
        ;;
        *) Println "$error $i18n_input_correct_number [1-23]\n"
        ;;
    esac
}

IbmSetCfAppCron()
{
    IbmListCfApps

    echo -e "选择 APP"
    echo -e "$tip 多个 APP 用空格分隔, 比如 5 7 9-11\n"
    apps_name=()
    apps_user_email=()
    while read -p "$i18n_default_cancel" apps_num
    do
        [ -z "$apps_num" ] && Println "$i18n_canceled...\n" && exit 1
        IFS=" " read -ra apps_num_arr <<< "$apps_num"

        error_no=0
        for app_num in "${apps_num_arr[@]}"
        do
            case "$app_num" in
                *"-"*)
                    app_num_start=${app_num%-*}
                    app_num_end=${app_num#*-}
                    if [[ $app_num_start == *[!0-9]* ]] || [[ $app_num_end == *[!0-9]* ]] || \
                    [ "$app_num_start" -eq 0 ] || [ "$app_num_end" -eq 0 ] || \
                    [ "$app_num_end" -gt "$ibm_cf_apps_count" ] || \
                    [ "$app_num_start" -ge "$app_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$app_num" -lt 1 ] || [ "$app_num" -gt "$ibm_cf_apps_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                for element in "${apps_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start;i<=end;i++));
                        do
                            ibm_cf_apps_index=$((i-1))
                            apps_name+=("${ibm_cf_apps_name[ibm_cf_apps_index]}")
                            apps_user_email+=("${ibm_cf_apps_user_email[ibm_cf_apps_index]}")
                        done
                    else
                        ibm_cf_apps_index=$((element-1))
                        apps_name+=("${ibm_cf_apps_name[ibm_cf_apps_index]}")
                        apps_user_email+=("${ibm_cf_apps_user_email[ibm_cf_apps_index]}")
                    fi
                done
                break
            ;;
        esac
    done

    ibm_cf_apps_path=()
    ibm_cf_apps_path_list=""
    ibm_cf_apps_path_count=0

    for path in "$IBM_APPS_ROOT"/*
    do
        [ ! -d "$path" ] && continue
        ibm_cf_apps_path_count=$((ibm_cf_apps_path_count+1))
        app_path=${path##*/}
        ibm_cf_apps_path+=("$app_path")
        ibm_cf_apps_path_list="$ibm_cf_apps_path_list $ibm_cf_apps_path_count.${indent_6}${green}$app_path${normal}\n\n"
    done

    if [ "$ibm_cf_apps_path_count" -eq 0 ] 
    then
        Println "$error 请将 APP 所在目录移动到目录 $IBM_APPS_ROOT 下\n"
        exit 1
    fi

    apps_path=()
    new_jobs=""
    for((i=0;i<${#apps_name[@]};i++));
    do
        Println "$ibm_cf_apps_path_list"
        echo -e "$info 选择 APP: ${green}${apps_name[i]}${normal} 本地目录"
        while read -p "$i18n_default_cancel" apps_path_num 
        do
            case $apps_path_num in
                "") 
                    Println "$i18n_canceled...\n"
                    exit 1
                ;;
                *[!0-9]*) 
                    Println "$error $i18n_input_correct_no\n"
                ;;
                *) 
                    if [ "$apps_path_num" -gt 0 ] && [ "$apps_path_num" -le "$ibm_cf_apps_path_count" ] 
                    then
                        ibm_cf_apps_path_index=$((apps_path_num-1))
                        apps_path+=("${ibm_cf_apps_path[ibm_cf_apps_path_index]}")
                        break
                    else
                        Println "$error $i18n_input_correct_no\n"
                    fi
                ;;
            esac
        done

        new_job=$(
        $JQ_FILE -n --arg app "${apps_name[i]}" --arg user_email "${apps_user_email[i]}" \
            --arg path "${apps_path[i]}" \
            '{
                "app": $app,
                "user_email": $user_email,
                "path": $path
            }'
        )
        [ -n "$new_jobs" ] && new_jobs="$new_jobs,"
        new_jobs="$new_jobs$new_job"
    done

    Println "$info 输入重启间隔天数"
    while read -p "(默认: 5): " cron_days 
    do
        case $cron_days in
            "") 
                cron_days=5
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$cron_days" -gt 0 ] 
                then
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    Println "$info 输入重启小时 [0-23]"
    while read -p "(默认: 0): " cron_hour 
    do
        case $cron_hour in
            "") 
                cron_hour=0
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$cron_hour" -ge 0 ] && [ "$cron_hour" -le 23 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    Println "$info 输入重启分钟 [0-59]"
    while read -p "(默认: 0): " cron_min 
    do
        case $cron_min in
            "") 
                cron_min=0
                break
            ;;
            *[!0-9]*) 
                Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$cron_min" -gt 0 ] && [ "$cron_hour" -le 59 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number\n"
                fi
            ;;
        esac
    done

    cron=$(
    $JQ_FILE -n --arg days "$cron_days" --arg hour "$cron_hour" \
        --arg min "$cron_min" --argjson job "[$new_jobs]" \
        '{
            "days": $days | tonumber,
            "hour": $hour | tonumber,
            "min": $min | tonumber,
            "job": $job
        }'
    )
    jq_path='["cf","cron"]'
    JQ replace "$IBM_CONFIG" "$cron"
    Println "$info 定时重启任务设置成功\n"
}

IbmEnableCfAppCron()
{
    if crontab -l | grep -q "/usr/local/bin/ibm cron" 2> /dev/null
    then
        Println "$error 定时重启任务已开启 !\n"
    else
        IFS=" " read -r cron_days cron_hour cron_min < <($JQ_FILE -r '.cf.cron|[.days,.hour,.min]|join(" ")' "$IBM_CONFIG")
        [ -z "$cron_days" ] && Println "$error 请先设置定时重启任务\n" && exit 1
        crontab -l > "$IBM_APPS_ROOT/cron_tmp" 2> /dev/null || true
        printf '%s\n' "$cron_min $cron_hour */$cron_days * * /usr/local/bin/ibm cron" >> "$IBM_APPS_ROOT/cron_tmp"
        if ! grep -q 'PATH=' < "$IBM_APPS_ROOT/cron_tmp"
        then
            cron=$(< "$IBM_APPS_ROOT/cron_tmp")
            echo -e "PATH=$PATH\n$cron" > "$IBM_APPS_ROOT/cron_tmp"
        fi
        crontab "$IBM_APPS_ROOT/cron_tmp" > /dev/null
        rm -f "$IBM_APPS_ROOT/cron_tmp"
        Println "$info 定时重启任务开启成功\n"
    fi
}

IbmDisableCfAppCron()
{
    if crontab -l | grep -q "/usr/local/bin/ibm cron" 2> /dev/null
    then
        crontab -l > "$IBM_APPS_ROOT/cron_tmp" 2> /dev/null || true
        sed -i "/\/usr\/local\/bin\/ibm cron/d" "$IBM_APPS_ROOT/cron_tmp"
        crontab "$IBM_APPS_ROOT/cron_tmp" > /dev/null
        rm -f "$IBM_APPS_ROOT/cron_tmp"
        Println "$info 定时重启任务关闭成功\n"
    else
        Println "$error 定时重启任务未开启 !\n"
    fi
}

IbmCfAppCronExec()
{
    IFS="^" read -r app_name user_email path < <($JQ_FILE '.cf.cron|[([.job[].app]|join(" ")),([.job[].user_email]|join(" ")),([.job[].path]|join(" "))]|join("^")' "$IBM_CONFIG")
    app_name=${app_name#\"}
    path=${path%\"}

    [ -z "$app_name" ] && Println "$error 请先设置定时重启任务\n" && exit 1

    IbmUpdateCfCli

    IFS=" " read -r -a apps_name <<< "$app_name"
    IFS=" " read -r -a apps_user_email <<< "$user_email"
    IFS=" " read -r -a apps_path <<< "$path"

    IbmGetUsers

    for((i=0;i<${#apps_name[@]};i++));
    do
        for((j=0;j<ibm_users_count;j++));
        do
            if [ "${ibm_users_email[j]}" == "${apps_user_email[i]}" ] 
            then
                ibm_user_pass=${ibm_users_pass[j]}
                ibm_user_region=${ibm_users_region[j]}
                ibm_user_resource_group=${ibm_users_resource_group[j]}
                ibm_user_org=${ibm_users_org[j]}
                ibm_user_space=${ibm_users_space[j]}

                Println "$info 登录账号: ${apps_user_email[i]} [ $ibm_user_region ]"
                ibmcloud login -u "${apps_user_email[i]}" -p "$ibm_user_pass" -r "$ibm_user_region" -g "$ibm_user_resource_group" 
                ibmcloud target -o "$ibm_user_org" -s "$ibm_user_space"

                if [ "${apps_path[i]}" == "ibm_v2ray" ] || [ "${apps_path[i]}" == "ibm_xray" ]
                then
                    v2ray_rand_name=$(RandStr)
                    cp -r "$IBM_APPS_ROOT/${apps_path[i]}" "$IBM_APPS_ROOT/ibm_$v2ray_rand_name"

                    cd "$IBM_APPS_ROOT/ibm_$v2ray_rand_name/"
                    mv "${apps_path[i]#*_}" "$v2ray_rand_name"
                    if [ "${apps_path[i]}" == "ibm_xray" ] 
                    then
                        ./v2ctl convert config.json > "$v2ray_rand_name.pb"
                    else
                        ./v2ctl config config.json > "$v2ray_rand_name.pb"
                    fi
                    tar zcf "$v2ray_rand_name.tar.gz" "$v2ray_rand_name" "$v2ray_rand_name.pb"
                    rm -f config.json
                    rm -f config.json.lock
                    rm -f "$v2ray_rand_name"
                    rm -f "$v2ray_rand_name.pb"
                    rm -f v2ctl

                    ibmcloud cf create-app-manifest "${apps_name[i]}"

                    routes=""
                    while read -r line 
                    do
                        if [[ $line =~ disk_quota: ]] 
                        then
                            disk_quota=${line##* }
                        elif [[ $line =~ instances: ]] 
                        then
                            instances=${line##* }
                        elif [[ $line =~ memory: ]] 
                        then
                            memory=${line##* }
                        elif [[ $line =~ routes: ]] || [[ $line =~ route: ]]
                        then
                            [ -n "$routes" ] && routes="$routes\n"
                            routes="$routes$line"
                        elif [[ $line =~ stack: ]] 
                        then
                            stack=${line##* }
                        fi
                    done < "${apps_name[i]}_manifest.yml"

                    echo -e "---
applications:
- name: ${apps_name[i]}
  command:
    tar xzf $v2ray_rand_name.tar.gz &&
    { ./$v2ray_rand_name -config ./$v2ray_rand_name.pb -format=pb & } &&
    sleep 5 &&
    rm ./$v2ray_rand_name.pb &&
    rm ./$v2ray_rand_name
  disk_quota: $disk_quota
  instances: ${instances:-1}
  memory: $memory
  stack: $stack
  buildpacks:
    - go_buildpack
  env:
    GOPACKAGENAME: goapp
" > "${apps_name[i]}_manifest.yml"

                    printf '%s' 'package main

func main() {

}
' > "main.go"
                    ibmcloud cf push -f "${apps_name[i]}_manifest.yml"
                    cd ..
                    rm -rf "$IBM_APPS_ROOT/ibm_$v2ray_rand_name"
                else
                    cd "$IBM_APPS_ROOT/${apps_path[i]}/"
                    ibmcloud cf create-app-manifest "${apps_name[i]}"
                    ibmcloud cf push -f "${apps_name[i]}_manifest.yml"
                fi
                continue 2
            fi
        done
        Println "$error APP ${apps_name[i]} 没有找到用户 ${apps_user_email[i]}"
    done
}

IbmUninstallCfCli()
{
    if [[ ! -x $(command -v ibmcloud) ]] 
    then
        Println "$error IBM CF CLI 未安装\n"
        exit 1
    fi

    echo
    AskIfContinue n "`gettext \"确定删除 IBM CF CLI\"`"

    EXIT_STATUS=0

    rm -Rf /usr/local/ibmcloud || EXIT_STATUS=$?

    rm -f /usr/local/bin/ibmcloud || EXIT_STATUS=$?
    rm -f /usr/local/bin/bluemix || EXIT_STATUS=$?
    rm -f /usr/local/bin/bx || EXIT_STATUS=$?
    rm -f /usr/local/bin/ibmcloud-analytics || true

    if [ $EXIT_STATUS -eq 0 ]
    then
        Println "$info 删除成功\n"
    else
        Println "$error 发生错误\n"
    fi
}

IbmCfMenu()
{
    Println "  IBM CF 面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 安装 IBM CF CLI
  ${green}2.${normal} 更新 IBM CF CLI
  ${green}3.${normal} 查看 用户
  ${green}4.${normal} 登录 用户
  ${green}5.${normal} 添加 用户
  ${green}6.${normal} 更改 用户
  ${green}7.${normal} 查看 APP
  ${green}8.${normal} 添加 APP
  ${green}9.${normal} 添加 APP 路由
 ${green}10.${normal} 删除 用户
 ${green}11.${normal} 删除 APP
 ${green}12.${normal} 删除 APP 路由
 ${green}13.${normal} 设置 v2ray APP
 ${green}14.${normal} 设置 Xray  APP
 ${green}15.${normal} 设置 APP 定时重启
 ${green}16.${normal} 开启 APP 定时重启
 ${green}17.${normal} 关闭 APP 定时重启
 ${green}18.${normal} 删除 IBM CF CLI
 ${green}19.${normal} 更新脚本

 $tip 输入: ibm 打开面板\n\n"
    read -p "$i18n_default_cancel" ibm_cf_num
    case $ibm_cf_num in
        1) IbmInstallCfCli
        ;;
        2) IbmUpdateCfCli
        ;;
        3) IbmListUsers
        ;;
        4) IbmLoginUser
        ;;
        5) IbmAddUser
        ;;
        6) IbmEditUser
        ;;
        7) IbmListCfApp
        ;;
        8) IbmAddCfApp
        ;;
        9) IbmAddCfAppRoute
        ;;
        10) IbmDelUser
        ;;
        11) IbmDelApp
        ;;
        12) IbmDelAppRoute
        ;;
        13) 
            v2ray_name="v2ray"
            v2ray_package_name="v2ray"
            tls_name="TLS"
            V2CTL_FILE="$IBM_APPS_ROOT/ibm_v2ray/v2ctl"
            V2_CONFIG="$IBM_APPS_ROOT/ibm_v2ray/config.json"
            IbmV2rayMenu
        ;;
        14) 
            v2ray_name="xray"
            v2ray_package_name="Xray"
            tls_name="XTLS"
            V2CTL_FILE="$IBM_APPS_ROOT/ibm_xray/xray"
            V2_CONFIG="$IBM_APPS_ROOT/ibm_xray/config.json"
            IbmV2rayMenu
        ;;
        15) IbmSetCfAppCron
        ;;
        16) IbmEnableCfAppCron
        ;;
        17) IbmDisableCfAppCron
        ;;
        18) IbmUninstallCfCli
        ;;
        19) ShFileUpdate ibm
        ;;
        *) Println "$error $i18n_input_correct_number [1-19]\n"
        ;;
    esac
}

VipSetHostIp()
{
    Println "请输入 VIP 频道所在服务器 IP/域名"
    read -p "$i18n_default_cancel" vip_host_ip
    [ -z "$vip_host_ip" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  VIP 服务器 IP/域名: ${green} $vip_host_ip ${normal}\n"
}

VipSetHostPort()
{
    Println "请输入 VIP 频道所在服务器端口"
    read -p "$i18n_default_cancel" vip_host_port
    [ -z "$vip_host_port" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  VIP 服务器端口: ${green} $vip_host_port ${normal}\n"
}

VipSetHostSeed()
{
    Println "请输入 VIP 频道所在服务器的 seed"
    read -p "$i18n_default_cancel" vip_host_seed
    [ -z "$vip_host_seed" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  VIP 服务器 seed: ${green} $vip_host_seed ${normal}\n"
}

VipSetHostToken()
{
    echo
    inquirer text_input "请输入 VIP 频道所在服务器的 token: " vip_host_token "不设置"
    if [ "$vip_host_token" == "不设置" ] 
    then
        vip_host_token=""
    fi
}

VipSetHostStatus()
{
    echo
    inquirer list_input "是否开启用此 VIP 服务器" yn_options vip_host_status

    if [[ $vip_host_status == "$i18n_yes" ]] 
    then
        vip_host_status_yn="on"
        vip_host_status_text="${green}启用${normal}"
    else
        vip_host_status_yn="off"
        vip_host_status_text="${red}禁用${normal}"
    fi
    Println "  VIP 服务器状态: $vip_host_status_text\n"
}

VipAddHost()
{
    VipSetHostIp
    VipSetHostPort
    VipSetHostSeed
    VipSetHostToken
    VipSetHostStatus

    if [ ! -s "$VIP_FILE" ] 
    then
        printf '{"%s":{},"%s":[],"%s":[]}' "config" "users" "hosts" > "$VIP_FILE"
    fi

    new_host=$(
    $JQ_FILE -n --arg ip "$vip_host_ip" --arg port "$vip_host_port" \
        --arg seed "$vip_host_seed" --arg token "$vip_host_token" \
        --arg status "$vip_host_status_yn" \
        '{
            ip: $ip,
            port: $port | tonumber,
            seed: $seed,
            token: $token,
            status: $status,
            channels: []
        }'
    )

    jq_path='["hosts"]'
    JQ add "$VIP_FILE" "$new_host"
    Println "$info VIP 服务器添加成功\n"
}

VipEditHost()
{
    VipListHosts
    echo -e "选择 VIP 服务器"
    while read -p "$i18n_default_cancel" vip_hosts_num
    do
        case "$vip_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_hosts_num" -gt 0 ] && [ "$vip_hosts_num" -le "$vip_hosts_count" ]
                then
                    vip_hosts_index=$((vip_hosts_num-1))
                    vip_host_ip=${vip_hosts_ip[vip_hosts_index]}
                    vip_host_port=${vip_hosts_port[vip_hosts_index]}
                    vip_host_seed=${vip_hosts_seed[vip_hosts_index]}
                    vip_host_token=${vip_hosts_token[vip_hosts_index]}
                    vip_host_status_yn=${vip_hosts_status_yn[vip_hosts_index]}
                    if [ "$vip_host_status_yn" == "yes" ] 
                    then
                        vip_host_status_text="${green}启用${normal}"
                    else
                        vip_host_status_text="${red}禁用${normal}"
                    fi
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "
选择修改内容

    ${green}1.${normal} 修改 IP/域名
    ${green}2.${normal} 修改 端口
    ${green}3.${normal} 修改 seed
    ${green}4.${normal} 修改 token
    ${green}5.${normal} 修改 状态

"
    read -p "$i18n_default_cancel" edit_vip_host_num

    case $edit_vip_host_num in
        1) 
            Println "原 IP/域名: ${red}$vip_host_ip${normal}"
            VipSetHostIp
            jq_path='["hosts",'"$vip_hosts_index"',"ip"]'
            JQ update "$VIP_FILE" "$vip_host_ip"
            Println "$info IP/域名 修改成功\n"
        ;;
        2) 
            Println "原端口: ${red}$vip_host_port${normal}"
            VipSetHostPort
            jq_path='["hosts",'"$vip_hosts_index"',"port"]'
            JQ update "$VIP_FILE" "$vip_host_port" number
            Println "$info 端口 修改成功\n"
        ;;
        3) 
            Println "原 seed: ${red}$vip_host_seed${normal}"
            VipSetHostSeed
            jq_path='["hosts",'"$vip_hosts_index"',"seed"]'
            JQ update "$VIP_FILE" "$vip_host_seed"
            Println "$info seed 修改成功\n"
        ;;
        4) 
            Println "原 token: ${red}$vip_host_token${normal}"
            VipSetHostToken
            jq_path='["hosts",'"$vip_hosts_index"',"token"]'
            JQ update "$VIP_FILE" "$vip_host_token"
            Println "$info token 修改成功\n"
        ;;
        5) 
            Println "原状态: $vip_host_status_text"
            VipSetHostStatus
            jq_path='["hosts",'"$vip_hosts_index"',"status"]'
            JQ update "$VIP_FILE" "$vip_host_status_yn"
            Println "$info 状态修改成功\n"
        ;;
        *) Println "$i18n_canceled...\n" && exit 1
        ;;
    esac
}

VipGetHosts()
{
    vip_hosts_list=""
    vip_hosts_count=0
    vip_hosts_ip=()
    vip_hosts_port=()
    vip_hosts_seed=()
    vip_hosts_token=()
    vip_hosts_status_yn=()
    vip_hosts_channel_count=()
    vip_hosts_channel_id=()
    vip_hosts_channel_name=()
    vip_hosts_channel_epg_id=()
    while IFS="^" read -r ip port seed token status_yn channels_count channels_id channels_name channels_epg_id
    do
        vip_hosts_count=$((vip_hosts_count+1))
        ip=${ip#\"}
        vip_hosts_ip+=("$ip")
        vip_hosts_port+=("$port")
        vip_hosts_seed+=("$seed")
        vip_hosts_token+=("$token")
        vip_hosts_status_yn+=("$status_yn")
        if [ "$status_yn" == "on" ] 
        then
            status_text="${green} [启用] ${normal}"
        else
            status_text="${red} [禁用] ${normal}"
        fi
        vip_hosts_channel_count+=("$channels_count")
        vip_hosts_channel_id+=("$channels_id")
        vip_hosts_channel_name+=("$channels_name")
        channels_epg_id=${channels_epg_id%\"}
        vip_hosts_channel_epg_id+=("$channels_epg_id")
        vip_hosts_list="$vip_hosts_list ${green}$vip_hosts_count.${normal}${indent_6}服务器: ${green}$ip${normal}  端口: ${green}$port${normal}  频道数: ${green}$channels_count${normal}$status_text\n${indent_6}seed: ${green}$seed${normal}  token: ${green}${token:-无}${normal}\n\n"
    done < <($JQ_FILE '.hosts[]|[.ip,.port,.seed,.token,.status,(.channels|length),([.channels[].id]|join("|")),([.channels[].name]|join("|")),([.channels[].epg_id]|join("|"))]|join("^")' "$VIP_FILE")
    return 0
}

VipListHosts()
{
    if [ ! -s "$VIP_FILE" ] 
    then
        Println "$error 请先添加 VIP 服务器\n" && exit 1
    fi

    VipGetHosts

    if [ "$vip_hosts_count" -gt 0 ] 
    then
        Println "$vip_hosts_list"
    else
        Println "$error 请先添加 VIP 服务器\n" && exit 1
    fi
}

VipDelHost()
{
    VipListHosts
    echo -e "选择 VIP 服务器"
    while read -p "$i18n_default_cancel" vip_hosts_num
    do
        case "$vip_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_hosts_num" -gt 0 ] && [ "$vip_hosts_num" -le "$vip_hosts_count" ]
                then
                    vip_hosts_index=$((vip_hosts_num-1))
                    vip_host_ip=${vip_hosts_ip[vip_hosts_index]}
                    vip_host_port=${vip_hosts_port[vip_hosts_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    jq_path='["hosts"]'
    JQ delete "$VIP_FILE" "$vip_hosts_index"

    Println "服务器 ${green}[ $vip_host_ip ]${normal} 删除成功\n"
}

VipSetUserIp()
{
    Println "请输入用户的 IP"
    read -p "(默认: 本机 IP): " vip_user_ip
    [ -z "$vip_user_ip" ] && vip_user_ip=$(GetServerIp)
    if [[ -n $($JQ_FILE '.users[]|select(.ip=="'"$vip_user_ip"'")' "$VIP_FILE") ]] 
    then
        Println "$error 此 IP 已存在\n" && exit 1
    fi
    Println "  用户 IP: ${green} $vip_user_ip ${normal}\n"
}

VipSetUserLicense()
{
    Println "请输入用户的授权码"
    read -p "(默认: 自动生成): " vip_user_license
    if [ -z "$vip_user_license" ] 
    then
        random_number=$(od -An -N6 -t u8 < /dev/urandom)
        vip_user_license="m${random_number: -12}"
        while [[ -n $($JQ_FILE '.users[]|select(.license=="'"$vip_user_license"'")' "$VIP_FILE") ]] 
        do
            random_number=$(od -An -N6 -t u8 < /dev/urandom)
            vip_user_license="m${random_number: -12}"
        done
    elif [[ -n $($JQ_FILE '.users[]|select(.license=="'"$vip_user_license"'")' "$VIP_FILE") ]] 
    then
        Println "$error 此授权码已存在\n" && exit 1
    fi
    Println "  用户 license: ${green} $vip_user_license ${normal}\n"
}

VipSetUserSum()
{
    Println "选择验证类型

  ${green}1.${normal} ssum (一天)
  ${green}2.${normal} tsum (可控制天数)
  ${green}3.${normal} isum (永久)

"

    while read -p "(默认: 2): " vip_user_sum_num 
    do
        case $vip_user_sum_num in
            1) 
                vip_user_expire_days=1
                vip_user_sum="ssum"
                printf -v now '%(%s)T' -1
                vip_user_expire=$((now+86400))
                break
            ;;
            2|"") 
                vip_user_sum="tsum"
                Println "请输入天数"
                while read -p "(默认: 1): " vip_user_expire_days 
                do
                    case $vip_user_expire_days in
                        ""|1) 
                            vip_user_expire_days=1
                            printf -v now '%(%s)T' -1
                            vip_user_expire=$((now+86400))
                            break 2
                        ;;
                        *[!0-9]*) 
                            Println "$error 输入错误\n"
                        ;;
                        *) 
                            if [[ $vip_user_expire_days -gt 1 ]]
                            then
                                printf -v now '%(%s)T' -1
                                vip_user_expire=$((now+86400*vip_user_expire_days))
                                break 2
                            else
                                Println "$error 输入错误\n"
                            fi
                        ;;
                    esac
                done
            ;;
            3) 
                vip_user_expire_days=""
                vip_user_sum="isum"
                vip_user_expire=0
                break
            ;;
            *) Println "$error 输入错误\n"
            ;;
        esac
    done
    Println "  验证类型: ${green} $vip_user_sum ${normal}\n  到期天数: ${green} ${vip_user_expire_days:-无} ${normal}\n"
}

VipSetUserName()
{
    Println "请输入用户名称(可以是中文)"
    read -p "(默认: 随机): " vip_user_name
    if [ -z "$vip_user_name" ] 
    then
        vip_user_name=$(RandStr)
        while [[ -n $($JQ_FILE '.users[]|select(.name=="'"$vip_user_name"'")' "$VIP_FILE") ]] 
        do
            vip_user_name=$(RandStr)
        done
    elif [[ -n $($JQ_FILE '.users[]|select(.name=="'"$vip_user_name"'")' "$VIP_FILE") ]] 
    then
        Println "$error 此用户名已存在\n" && exit 1
    fi
    Println "  用户名称: ${green} $vip_user_name ${normal}\n"
}

VipAddUser()
{
    if [ ! -s "$VIP_FILE" ] 
    then
        printf '{"%s":{},"%s":[],"%s":[]}' "config" "users" "hosts" > "$VIP_FILE"
    fi

    VipSetUserIp
    VipSetUserLicense
    VipSetUserSum
    VipSetUserName

    new_user=$(
    $JQ_FILE -n --arg ip "$vip_user_ip" --arg license "$vip_user_license" \
        --arg sum "$vip_user_sum" --arg expire "$vip_user_expire" \
        --arg name "$vip_user_name" \
        '{
            ip: $ip,
            license: $license,
            sum: $sum,
            expire: $expire | tonumber,
            name: $name
        }'
    )

    jq_path='["users"]'
    JQ add "$VIP_FILE" "$new_user"

    Println "$info 添加成功\n"
}

VipEditUser()
{
    VipListUsers

    while read -p "请选择用户: " vip_users_num
    do
        case "$vip_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_users_num" -gt 0 ] && [ "$vip_users_num" -le "$vip_users_count" ]
                then
                    vip_users_index=$((vip_users_num-1))
                    vip_user_ip=${vip_users_ip[vip_users_index]}
                    vip_user_license=${vip_users_license[vip_users_index]}
                    vip_user_sum=${vip_users_sum[vip_users_index]}
                    vip_user_expire=${vip_users_expire[vip_users_index]}
                    if [ "$vip_user_expire" -gt 0 ] 
                    then
                        vip_user_expire_text=$(date +%c --date=@"$vip_user_expire")
                    else
                        vip_user_expire_text="无"
                    fi
                    vip_user_name=${vip_users_name[vip_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    Println "
选择修改内容

    ${green}1.${normal} 修改 用户名
    ${green}2.${normal} 修改 IP
    ${green}3.${normal} 修改 授权码
    ${green}4.${normal} 修改 验证类型/到期日

"
    read -p "$i18n_default_cancel" edit_vip_user_num

    case $edit_vip_user_num in
        1) 
            Println "原用户名: ${red}$vip_user_name${normal}"
            VipSetUserName
            jq_path='["users",'"$vip_users_index"',"name"]'
            JQ update "$VIP_FILE" "$vip_user_name"
            Println "$info 用户名修改成功\n"
        ;;
        2) 
            Println "原 IP: ${red}$vip_user_ip${normal}"
            VipSetUserIp
            jq_path='["users",'"$vip_users_index"',"ip"]'
            JQ update "$VIP_FILE" "$vip_user_ip"
            Println "$info IP 修改成功\n"
        ;;
        3) 
            Println "原授权码: ${red}$vip_user_license${normal}"
            VipSetUserLicense
            jq_path='["users",'"$vip_users_index"',"license"]'
            JQ update "$VIP_FILE" "$vip_user_license"
            Println "$info 授权码修改成功\n"
        ;;
        4) 
            Println "原验证类型: ${red}$vip_user_sum${normal}\n原到期日: ${red}$vip_user_expire_text${normal}"
            VipSetUserSum
            jq_path='["users",'"$vip_users_index"',"sum"]'
            JQ update "$VIP_FILE" "$vip_user_sum"
            jq_path='["users",'"$vip_users_index"',"expire"]'
            JQ update "$VIP_FILE" "$vip_user_expire" number
            Println "$info 验证类型/到期日修改成功\n"
        ;;
        *) Println "$i18n_canceled...\n" && exit 1
        ;;
    esac
}

VipGetUsers()
{
    VipGetConfig
    vip_users_list=""
    vip_users_count=0
    vip_users_ip=()
    vip_users_license=()
    vip_users_sum=()
    vip_users_expire=()
    vip_users_name=()
    while IFS=":" read -r ip license sum expire name
    do
        vip_users_count=$((vip_users_count+1))
        ip=${ip#\"}
        vip_users_ip+=("$ip")
        vip_users_license+=("$license")
        vip_users_sum+=("$sum")
        vip_users_expire+=("$expire")
        name=${name%\"}
        vip_users_name+=("$name")
        if [ "$expire" -gt 0 ] 
        then
            expire_text=$(date +%c --date=@"$expire")
        else
            expire_text="无"
        fi
        if [ -n "${vip_public_host:-}" ] 
        then
            m3u_link="$vip_public_host/vip/$license/playlist.m3u"
        else
            m3u_link="${FFMPEG_MIRROR_LINK%/*}/vip/$license/playlist.m3u"
        fi
        vip_users_list="$vip_users_list ${green}$vip_users_count.${normal}${indent_6}用户名: ${green}$name${normal}  ip: ${green}$ip${normal}  到期日: ${green}$expire_text${normal}\n${indent_6}授权码: ${green}$license${normal}  认证方式: ${green}$sum${normal}\n${indent_6}m3u 播放链接: ${green}$m3u_link${normal}\n\n"
    done < <($JQ_FILE '.users[]|[.ip,.license,.sum,.expire,.name]|join(":")' "$VIP_FILE")
    return 0
}

VipListUsers()
{
    if [ ! -s "$VIP_FILE" ] 
    then
        Println "$error 请先添加 VIP 服务器\n" && exit 1
    fi

    VipGetUsers

    if [ "$vip_users_count" -gt 0 ] 
    then
        Println "$vip_users_list"
    else
        Println "$error 请先添加用户\n" && exit 1
    fi
}

VipListUser()
{
    VipListUsers
}

VipDelUser()
{
    VipListUsers

    while read -p "请选择用户: " vip_users_num
    do
        case "$vip_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_users_num" -gt 0 ] && [ "$vip_users_num" -le "$vip_users_count" ]
                then
                    vip_users_index=$((vip_users_num-1))
                    vip_user_ip=${vip_users_ip[vip_users_index]}
                    vip_user_license=${vip_users_license[vip_users_index]}
                    vip_user_sum=${vip_users_sum[vip_users_index]}
                    vip_user_expire=${vip_users_expire[vip_users_index]}
                    vip_user_name=${vip_users_name[vip_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    jq_path='["users"]'
    JQ delete "$VIP_FILE" "$vip_users_index"

    Println "用户 ${green}$vip_user_name [ $vip_user_license ]${normal} 删除成功"
    Println "$tip 同一用户2分钟内不能使用不同的授权码\n"
}

VipSetChannelId()
{
    Println "请输入频道 ID, 同时也是目录名称"
    read -p "$i18n_default_cancel" vip_channel_id

    [ -z "$vip_channel_id" ] && Println "$i18n_canceled...\n" && exit 1

    if [[ -n $($JQ_FILE --arg vip_host_ip "$vip_host_ip" --arg vip_channel_id "$vip_channel_id" '.hosts[] | select(.ip==$vip_host_ip).channels[] | select(.id==$vip_channel_id)' "$VIP_FILE") ]] 
    then
        Println "$error $vip_channel_id 频道已经存在\n" && exit 1
    fi
}

VipSetChannelName()
{
    Println "请输入频道名称(可以是中文)"
    read -p "$i18n_default_cancel" vip_channel_name
    [ -z "$vip_channel_name" ] && Println "$i18n_canceled...\n" && exit 1
    Println "  VIP 频道名称: ${green} $vip_channel_name ${normal}\n"
}

VipSetChannelEpgId()
{
    echo
    inquirer text_input "请输入频道 epg id: " vip_channel_epg_id "不设置"
    if [ "$vip_channel_epg_id" == "不设置" ] 
    then
        vip_channel_epg_id=""
    fi
}

VipSetChannel()
{
    echo
    add_vip_channel_options=( '选择频道' '手动输入频道' )
    inquirer list_input "添加方式" add_vip_channel_options add_vip_channel_option

    if [[ $add_vip_channel_option == "选择频道" ]] 
    then
        if [ ! -f "$IPTV_ROOT/VIP" ] 
        then
            Println "$info 获取频道中..."
            if ! curl -s -L "$VIP_CHANNELS_LINK" -o "${VIP_CHANNELS_FILE}_tmp"
            then
                if [ ! -s "$VIP_CHANNELS_FILE" ] 
                then
                    Println "$error 暂时无法获取频道, 请稍后再试\n"
                    exit 1
                fi
                Println "$error 更新频道失败, 使用原有频道\n"
            else
                mv "${VIP_CHANNELS_FILE}_tmp" "$VIP_CHANNELS_FILE"
            fi
        fi

        vip_channels_name=()
        vip_channels_host_ip=()
        vip_channels_host_port=()
        vip_channels_id=()

        while IFS="^" read -r m_name m_url
        do
            if [ -n "$m_url" ] && [[ $m_url =~ ^http://([^/]+):([^/]+)/([^/]+) ]]
            then
                vip_channels_name+=("$m_name")
                vip_channels_host_ip+=("${BASH_REMATCH[1]}")
                vip_channels_host_port+=("${BASH_REMATCH[2]}")
                vip_channels_id+=("${BASH_REMATCH[3]}")
            fi
        done < <($JQ_FILE -r '.[]|[.name,.url]|join("^")' $VIP_CHANNELS_FILE)

        vip_channels_list=""
        vip_channels_count=${#vip_channels_id[@]}
        vip_channels_epg_id=("${vip_channels_id[@]}")

        flag=0
        for((i=0;i<vip_channels_count;i++));
        do
            if [ "$flag" -eq 0 ] 
            then
                flag=1
                i_last=$i
                vip_channels_list="$vip_channels_list ${green}$((i+1)).${normal}\r\033[7C${vip_channels_name[i]}"
            else
                flag=0
                vip_channels_list="$vip_channels_list\r\033[40C${green}$((i+1)).${normal}\r\033[47C${vip_channels_name[i]}\n\033[7C频道ID: ${vip_channels_id[i_last]}\r\033[47C频道ID: ${vip_channels_id[i]}\n\033[7CEPG ID: ${vip_channels_epg_id[i_last]:-无}\r\033[47CEPG ID: ${vip_channels_epg_id[i]:-无}\n\n"
            fi
        done

        if [ "$flag" -eq 1 ] 
        then
            vip_channels_list="$vip_channels_list\n\033[7C频道ID: ${vip_channels_id[i_last]}\n\033[7CEPG ID: ${vip_channels_epg_id[i_last]:-无}\n\n"
        fi

        Println "$vip_channels_list"

        echo -e "$tip 多个频道用空格分隔, 比如 5 7 9-11"
        while read -p "请选择频道: " vip_channels_num
        do
            [ -z "$vip_channels_num" ] && Println "$i18n_canceled...\n" && exit 1
            IFS=" " read -ra vip_channels_num_arr <<< "$vip_channels_num"

            error_no=0
            for vip_channel_num in "${vip_channels_num_arr[@]}"
            do
                case "$vip_channel_num" in
                    *"-"*)
                        vip_channel_num_start=${vip_channel_num%-*}
                        vip_channel_num_end=${vip_channel_num#*-}
                        if [[ $vip_channel_num_start == *[!0-9]* ]] || [[ $vip_channel_num_end == *[!0-9]* ]] || [ "$vip_channel_num_start" -eq 0 ] || [ "$vip_channel_num_end" -eq 0 ] || [ "$vip_channel_num_end" -gt "$vip_channels_count" ] || [ "$vip_channel_num_start" -ge "$vip_channel_num_end" ]
                        then
                            error_no=3
                        fi
                    ;;
                    *[!0-9]*)
                        error_no=1
                    ;;
                    *)
                        if [ "$vip_channel_num" -lt 1 ] || [ "$vip_channel_num" -gt "$vip_channels_count" ] 
                        then
                            error_no=2
                        fi
                    ;;
                esac
            done

            case "$error_no" in
                1|2|3)
                    Println "$error $i18n_input_correct_number\n"
                ;;
                *)
                    declare -a new_array
                    for element in "${vip_channels_num_arr[@]}"
                    do
                        if [[ $element =~ - ]] 
                        then
                            start=${element%-*}
                            end=${element#*-}
                            for((i=start;i<=end;i++));
                            do
                                new_array+=("$i")
                            done
                        else
                            new_array+=("$element")
                        fi
                    done

                    vip_channels_num_arr=("${new_array[@]}")
                    unset new_array

                    VipGetHosts
                    skip_hosts=""

                    for vip_channels_num in "${vip_channels_num_arr[@]}"
                    do
                        vip_channels_index=$((vip_channels_num-1))
                        vip_channel_id=${vip_channels_id[vip_channels_index]}
                        vip_channel_name=${vip_channels_name[vip_channels_index]}
                        vip_channel_epg_id=${vip_channels_epg_id[vip_channels_index]}
                        vip_channel_host_ip=${vip_channels_host_ip[vip_channels_index]}
                        vip_channel_host_port=${vip_channels_host_port[vip_channels_index]}

                        if [[ $skip_hosts =~ $vip_channel_host_ip:$vip_channel_host_port ]] 
                        then
                            continue
                        fi

                        vip_host_found=0
                        for((i=0;i<vip_hosts_count;i++));
                        do
                            if [ "${vip_hosts_ip[i]}" == "$vip_channel_host_ip" ] && [ "${vip_hosts_port[i]}" == "$vip_channel_host_port" ]
                            then
                                vip_host_found=1
                                break
                            fi
                        done

                        if [ "$vip_host_found" -eq 0 ] 
                        then
                            echo
                            inquirer list_input "是否添加服务器 $vip_channel_host_ip:$vip_channel_host_port" yn_options add_vip_host_yn
                            if [[ $add_vip_host_yn == "$i18n_yes" ]] 
                            then
                                vip_host_ip=$vip_channel_host_ip
                                vip_host_port=$vip_channel_host_port
                                VipSetHostSeed
                                VipSetHostToken
                                vip_host_status_yn="on"

                                if [ ! -s "$VIP_FILE" ] 
                                then
                                    printf '{"%s":{},"%s":[],"%s":[]}' "config" "users" "hosts" > "$VIP_FILE"
                                fi

                                new_host=$(
                                $JQ_FILE -n --arg ip "$vip_host_ip" --arg port "$vip_host_port" \
                                    --arg seed "$vip_host_seed" --arg token "$vip_host_token" \
                                    --arg status "$vip_host_status_yn" \
                                    '{
                                        ip: $ip,
                                        port: $port | tonumber,
                                        seed: $seed,
                                        token: $token,
                                        status: $status,
                                        channels: []
                                    }'
                                )

                                jq_path='["hosts"]'
                                JQ add "$VIP_FILE" "$new_host"
                                Println "$info $vip_channel_host_ip:$vip_channel_host_port 服务器添加成功\n"
                                VipGetHosts
                                i=$((vip_hosts_count-1))
                            else
                                skip_hosts="$skip_hosts$vip_channel_host_ip:$vip_channel_host_port "
                                continue
                            fi
                        fi

                        jq_path='["hosts",'"$i"',"channels"]'
                        JQ delete "$VIP_FILE" id \"$vip_channel_id\"

                        new_channel=$(
                        $JQ_FILE -n --arg id "$vip_channel_id" --arg name "$vip_channel_name" \
                            --arg epg_id "$vip_channel_epg_id" \
                            '{
                                id: $id,
                                name: $name,
                                epg_id: $epg_id
                            }'
                        )

                        jq_path='["hosts",'"$i"',"channels"]'
                        JQ add "$VIP_FILE" "$new_channel"

                        Println "$info $vip_channel_name 添加成功"
                    done
                    break
                ;;
            esac
        done
        exit
    fi

    VipListHosts
    echo -e "选择 VIP 服务器"
    while read -p "$i18n_default_cancel" vip_hosts_num
    do
        case "$vip_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_hosts_num" -gt 0 ] && [ "$vip_hosts_num" -le "$vip_hosts_count" ]
                then
                    vip_hosts_index=$((vip_hosts_num-1))
                    vip_host_ip=${vip_hosts_ip[vip_hosts_index]}
                    vip_host_port=${vip_hosts_port[vip_hosts_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    # awk -v ORS=" " '$1 { print $0; } END { printf("\n"); }'
    echo
    inquirer list_input "是否批量添加" ny_options vip_bulk_add

    if [[ $vip_bulk_add == "$i18n_yes" ]] 
    then
        Println "请输入频道 ID, 同时也是目录名称和频道名称, 用空格分隔"
        read -p "$i18n_default_cancel" vip_channel
        IFS=" " read -r -a vip_channels <<< "$vip_channel"
        new_channels=""
        for vip_channel in "${vip_channels[@]}"
        do
            new_channel=$(
            $JQ_FILE -n --arg id "$vip_channel" --arg name "$vip_channel" \
                '{
                    id: $id,
                    name: $name
                }'
            )
            [ -n "$new_channels" ] && new_channels="$new_channels,"
            new_channels="$new_channels$new_channel"
        done
        jq_path='["hosts",'"$vip_hosts_index"',"channels"]'
        JQ add "$VIP_FILE" "$new_channels"
        Println "$info 批量添加成功\n"
    else
        VipSetChannelId
        VipSetChannelName
        VipSetChannelEpgId
        new_channel=$(
        $JQ_FILE -n --arg id "$vip_channel_id" --arg name "$vip_channel_name" \
            --arg epg_id "$vip_channel_epg_id" \
            '{
                id: $id,
                name: $name,
                epg_id: $epg_id
            }'
        )

        jq_path='["hosts",'"$vip_hosts_index"',"channels"]'
        JQ add "$VIP_FILE" "$new_channel"
        Println "$info 频道 $vip_channel_name 添加成功\n"
    fi
}

VipEditChannel()
{
    VipListChannels
    echo -e "$tip 多个频道用空格分隔, 比如 5 7 9-11"
    while read -p "请选择频道: " vip_channels_num
    do
        [ -z "$vip_channels_num" ] && Println "$i18n_canceled...\n" && exit 1
        IFS=" " read -ra vip_channels_num_arr <<< "$vip_channels_num"

        error_no=0
        for vip_channel_num in "${vip_channels_num_arr[@]}"
        do
            case "$vip_channel_num" in
                *"-"*)
                    vip_channel_num_start=${vip_channel_num%-*}
                    vip_channel_num_end=${vip_channel_num#*-}
                    if [[ $vip_channel_num_start == *[!0-9]* ]] || [[ $vip_channel_num_end == *[!0-9]* ]] || [ "$vip_channel_num_start" -eq 0 ] || [ "$vip_channel_num_end" -eq 0 ] || [ "$vip_channel_num_end" -gt "$vip_channels_count" ] || [ "$vip_channel_num_start" -ge "$vip_channel_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$vip_channel_num" -lt 1 ] || [ "$vip_channel_num" -gt "$vip_channels_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                declare -a new_array
                for element in "${vip_channels_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start;i<=end;i++));
                        do
                            new_array+=("$i")
                        done
                    else
                        new_array+=("$element")
                    fi
                done
                vip_channels_num_arr=("${new_array[@]}")
                unset new_array
                for vip_channels_num in "${vip_channels_num_arr[@]}"
                do
                    vip_channels_index=$((vip_channels_num-1))
                    vip_channel_id=${vip_channels_id[vip_channels_index]}
                    vip_channel_name=${vip_channels_name[vip_channels_index]}
                    vip_channel_epg_id=${vip_channels_epg_id[vip_channels_index]}

                    Println "
选择修改频道 ${green}[ $vip_channel_name ]${normal} 内容

    ${green}1.${normal} 修改频道 ID 
    ${green}2.${normal} 修改频道名称
    ${green}3.${normal} 修改频道 epg

"
                    read -p "$i18n_default_cancel" edit_vip_channel_num

                    case $edit_vip_channel_num in
                        1) 
                            Println "原频道 ID: ${red}$vip_channel_id${normal}"
                            VipSetChannelId
                            jq_path='["hosts",'"$vip_hosts_index"',"channels",'"$vip_channels_index"',"id"]'
                            JQ update "$VIP_FILE" "$vip_channel_id"
                            Println "$info 频道 ID 修改成功\n"
                        ;;
                        2) 
                            Println "原频道名称: ${red}$vip_channel_name${normal}"
                            VipSetChannelName
                            jq_path='["hosts",'"$vip_hosts_index"',"channels",'"$vip_channels_index"',"name"]'
                            JQ update "$VIP_FILE" "$vip_channel_name"
                            Println "$info 频道名称修改成功\n"
                        ;;
                        3) 
                            Println "原频道 epg: ${red}${vip_channel_epg_id:-无}${normal}"
                            VipSetChannelEpgId
                            jq_path='["hosts",'"$vip_hosts_index"',"channels",'"$vip_channels_index"',"epg_id"]'
                            JQ update "$VIP_FILE" "$vip_channel_epg_id"
                            Println "$info 频道 epg 修改成功\n"
                        ;;
                        *) Println "$i18n_canceled...\n" && exit 1
                        ;;
                    esac
                done
                break
            ;;
        esac
    done
}

VipListChannels()
{
    VipListHosts
    while read -p "选择 VIP 服务器: " vip_hosts_num
    do
        case "$vip_hosts_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_hosts_num" -gt 0 ] && [ "$vip_hosts_num" -le "$vip_hosts_count" ]
                then
                    vip_hosts_index=$((vip_hosts_num-1))
                    vip_host_ip=${vip_hosts_ip[vip_hosts_index]}
                    vip_host_port=${vip_hosts_port[vip_hosts_index]}
                    vip_host_seed=${vip_hosts_seed[vip_hosts_index]}
                    vip_host_token=${vip_hosts_token[vip_hosts_index]}
                    vip_channel_id=${vip_hosts_channel_id[vip_hosts_index]}
                    vip_channel_name=${vip_hosts_channel_name[vip_hosts_index]}
                    vip_channel_epg_id=${vip_hosts_channel_epg_id[vip_hosts_index]}
                    IFS="|" read -r -a vip_channels_id <<< "$vip_channel_id"
                    IFS="|" read -r -a vip_channels_name <<< "$vip_channel_name"
                    IFS="|" read -r -a vip_channels_epg_id <<< "${vip_channel_epg_id}|"
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    vip_channels_list=""
    vip_channels_count=${vip_hosts_channel_count[vip_hosts_index]}

    flag=0
    for((i=0;i<vip_channels_count;i++));
    do
        if [ "$flag" -eq 0 ] 
        then
            flag=1
            i_last=$i
            vip_channels_list="$vip_channels_list ${green}$((i+1)).${normal}\r\033[7C${vip_channels_name[i]}"
        else
            flag=0
            vip_channels_list="$vip_channels_list\r\033[40C${green}$((i+1)).${normal}\r\033[47C${vip_channels_name[i]}\n\033[7C频道ID: ${vip_channels_id[i_last]}\r\033[47C频道ID: ${vip_channels_id[i]}\n\033[7CEPG ID: ${vip_channels_epg_id[i_last]:-无}\r\033[47CEPG ID: ${vip_channels_epg_id[i]:-无}\n\n"
        fi
    done

    if [ "$flag" -eq 1 ] 
    then
        vip_channels_list="$vip_channels_list\n\033[7C频道ID: ${vip_channels_id[i_last]}\n\033[7CEPG ID: ${vip_channels_epg_id[i_last]:-无}\n\n"
    fi

    if [ -n "$vip_channels_list" ] 
    then
        Println "$vip_channels_list"
    else
        Println "$error 请先添加频道\n" && exit 1
    fi
}

VipGetStreamLink()
{
    seed=$vip_host_seed
    tid=$vip_user_license
    tid_lower=$(tr '[:upper:]' '[:lower:]' <<< "$tid")
    if [ "$vip_user_expire" -gt 0 ] 
    then
        day=$((vip_user_expire/86400))
        st2=$vip_user_expire
    else
        printf -v now '%(%s)T' -1
        st2=$((now+86400*720))
    fi

    token=$vip_host_token
    ss=$(printf '%s' "$st2$token$vip_user_ip$tid" | md5sum)
    ss=${ss%% *}
    [ -z "${ct2:-}" ] && ct2=$(date +%s%3N)
    vip_channel_id_lower=$(tr '[:upper:]' '[:lower:]' <<< "$vip_channel_id")
    cs=$(printf '%s' "$st2$ss$ct2$vip_channel_id_lower$tid_lower" | md5sum)
    cs=${cs%% *}

    case $vip_user_sum in
        "ssum") 
            ssum="$seed/$vip_channel_id/playlist.m3u8$tid$day"
            ssum=$(printf '%s' "$ssum" | md5sum)
            ssum=${ssum%% *}
            stream_link="http://$vip_host_ip:$vip_host_port/$vip_channel_id/playlist.m3u8?tid=$tid&ssum=$ssum&st2=$st2&ss=$ss&ct2=$ct2&cs=$cs"
        ;;
        "tsum") 
            ct=$day
            tsum="$seed/$vip_channel_id/playlist.m3u8$tid$ct"
            tsum=$(printf '%s' "$tsum" | md5sum)
            tsum=${tsum%% *}
            stream_link="http://$vip_host_ip:$vip_host_port/$vip_channel_id/playlist.m3u8?tid=$tid&ct=$ct&tsum=$tsum&st2=$st2&ss=$ss&ct2=$ct2&cs=$cs"
        ;;
        "isum") 
            isum="$seed$vip_user_ip/$vip_channel_id/playlist.m3u8$tid"
            isum=$(printf '%s' "$isum" | md5sum)
            isum=${isum%% *}
            stream_link="http://$vip_host_ip:$vip_host_port/$vip_channel_id/playlist.m3u8?tid=$tid&isum=$isum&st2=$st2&ss=$ss&ct2=$ct2&cs=$cs"
        ;;
    esac
}

VipListChannel()
{
    VipListChannels

    echo -e "$tip 多个频道用空格分隔, 比如 5 7 9-11"
    while read -p "请选择频道: " vip_channels_num
    do
        [ -z "$vip_channels_num" ] && Println "$i18n_canceled...\n" && exit 1
        IFS=" " read -ra vip_channels_num_arr <<< "$vip_channels_num"

        error_no=0
        for vip_channel_num in "${vip_channels_num_arr[@]}"
        do
            case "$vip_channel_num" in
                *"-"*)
                    vip_channel_num_start=${vip_channel_num%-*}
                    vip_channel_num_end=${vip_channel_num#*-}
                    if [[ $vip_channel_num_start == *[!0-9]* ]] || [[ $vip_channel_num_end == *[!0-9]* ]] || [ "$vip_channel_num_start" -eq 0 ] || [ "$vip_channel_num_end" -eq 0 ] || [ "$vip_channel_num_end" -gt "$vip_channels_count" ] || [ "$vip_channel_num_start" -ge "$vip_channel_num_end" ]
                    then
                        error_no=3
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                ;;
                *)
                    if [ "$vip_channel_num" -lt 1 ] || [ "$vip_channel_num" -gt "$vip_channels_count" ] 
                    then
                        error_no=2
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                declare -a new_array
                for element in "${vip_channels_num_arr[@]}"
                do
                    if [[ $element =~ - ]] 
                    then
                        start=${element%-*}
                        end=${element#*-}
                        for((i=start;i<=end;i++));
                        do
                            new_array+=("$i")
                        done
                    else
                        new_array+=("$element")
                    fi
                done
                vip_channels_num_arr=("${new_array[@]}")
                unset new_array
                break
            ;;
        esac
    done

    VipListUsers

    while read -p "请选择用户: " vip_users_num
    do
        case "$vip_users_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_users_num" -gt 0 ] && [ "$vip_users_num" -le "$vip_users_count" ]
                then
                    vip_users_index=$((vip_users_num-1))
                    vip_user_ip=${vip_users_ip[vip_users_index]}
                    vip_user_license=${vip_users_license[vip_users_index]}
                    vip_user_sum=${vip_users_sum[vip_users_index]}
                    vip_user_expire=${vip_users_expire[vip_users_index]}
                    vip_user_name=${vip_users_name[vip_users_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    if [ -z "${vip_public_host:-}" ] 
    then
        VipConfig
    fi

    for vip_channels_num in "${vip_channels_num_arr[@]}"
    do
        vip_channels_index=$((vip_channels_num-1))
        vip_channel_id=${vip_channels_id[vip_channels_index]}
        vip_channel_name=${vip_channels_name[vip_channels_index]}
        vip_channel_epg_id=${vip_channels_epg_id[vip_channels_index]}

        VipGetStreamLink

        if [ -n "${vip_public_host:-}" ] 
        then
            Println "频道 ${green}[ $vip_channel_name ]${normal}\n\n源链接: $stream_link\n\nm3u8地址: $vip_public_host/vip/$vip_user_license/${vip_host_ip//./}$vip_host_port/$vip_channel_id/playlist.m3u8\n"
        else
            Println "频道 ${green}[ $vip_channel_name ]${normal}\n\n源链接: $stream_link\n\nm3u8地址: $VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}$vip_host_port/$vip_channel_id/playlist.m3u8\n"
        fi
    done
}

VipDelChannel()
{
    VipListChannels

    echo -e " ${green}$((vip_channels_count+1)).${normal}\r\033[7C全部删除\n"

    while read -p "请选择频道: " vip_channels_num
    do
        if [ "$vip_channels_num" == $((vip_channels_count+1)) ] 
        then
            jq_path='["hosts",'"$vip_hosts_index"',"channels"]'
            JQ replace "$VIP_FILE" "[]"

            Println "$info 频道删除成功\n"
            exit 0
        fi
        case "$vip_channels_num" in
            "")
                Println "$i18n_canceled...\n" && exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$vip_channels_num" -gt 0 ] && [ "$vip_channels_num" -le "$vip_channels_count" ]
                then
                    vip_channels_index=$((vip_channels_num-1))
                    vip_channel_id=${vip_channels_id[vip_channels_index]}
                    vip_channel_name=${vip_channels_name[vip_channels_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done

    jq_path='["hosts",'"$vip_hosts_index"',"channels"]'
    JQ delete "$VIP_FILE" "$vip_channels_index"

    Println "频道 ${green}[ $vip_channel_name ]${normal} 删除成功\n"
}

VipGetConfig()
{
    while IFS=" " read -r key value
    do
        if [ -z "$key" ] 
        then
            break
        else
            read -r vip_${key?} <<< "$value"
        fi
    done < <($JQ_FILE -r '.config|to_entries[]|[.key,.value]|join(" ")' "$VIP_FILE")
    return 0
}

VipSetPublicRoot()
{
    Println "请输入公开目录, 比如 /usr/local/nginx/html 或 /usr/local/openresty/nginx/html"
    read -p "(默认: 不公开): " vip_public_root
    if [ -n "$vip_public_root" ] 
    then
        vip_public_root=${vip_public_root%\/}
    fi
    JQ update "$VIP_FILE" '(.config|.public_root)="'"$vip_public_root"'"'
    Println "  VIP 公开目录: ${green} ${vip_public_root:-无} ${normal}\n"
}

VipSetPublicHost()
{
    Println "$tip 比如 http://localhost"
    inquirer text_input "请输入公开目录的 域名 或者 IP 网址: " vip_public_host "不设置"
    if [ "$vip_public_host" == "不设置" ] 
    then
        vip_public_host=""
    fi
    JQ update "$VIP_FILE" '(.config|.public_host)="'"$vip_public_host"'"'
}

VipConfig()
{
    VipSetPublicRoot
    if [ -n "$vip_public_root" ] 
    then
        VipSetPublicHost
    fi
}

VipProcessLists()
{
    [ ! -d "$VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}$vip_host_port/${vip_channels_id[k]}" ] && mkdir -p "$VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}$vip_host_port/${vip_channels_id[k]}"
    printf '#EXTM3U\n#EXT-X-STREAM-INF:PROGRAM-ID=%s,BANDWIDTH=1500002\n%s' \
    "$program_id" "$stream_link" > "$VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}$vip_host_port/${vip_channels_id[k]}/playlist.m3u8"
    if [ "$k" -eq 0 ] 
    then
        m3u_list="$m3u_list#EXTINF:-1,===== $vip_host_ip:$vip_host_port ${vip_channels_name[k]} =====\n$stream_link\n"
    else
        m3u_list="$m3u_list#EXTINF:-1,${vip_channels_name[k]}\n$stream_link\n"
    fi
    epg_id=${vip_channels_epg_id[k]}
    if [ -n "$epg_id" ] && [ -n "${schedules_id:-}" ]
    then
        for((m=0;m<${#schedules_id[@]};m++));
        do
            if [ "${schedules_id[m]}" == "$epg_id" ] && [ -n "${schedules_sys_time[m]}" ]
            then
                IFS="^" read -r -a sys_times <<< "${schedules_sys_time[m]}^"
                IFS="^" read -r -a titles <<< "${schedules_title[m]}^"
                epg_list="$epg_list<channel id=\"$program_id\">\n<display-name lang=\"zh\">${vip_channels_name[k]}</display-name>\n</channel>\n"
                programs_count=${#sys_times[@]}
                for((n=0;n<programs_count;n++));
                do
                    printf -v start '%(%Y%m%d%H%M%S)T' "${sys_times[n]}"
                    if [ "$n" -eq $((programs_count-1)) ] 
                    then
                        stop=$(date -d 'tomorrow 00:00:00' "+%Y%m%d%H%M%S")
                    else
                        printf -v stop '%(%Y%m%d%H%M%S)T' "${sys_times[n+1]}"
                    fi
                    epg_list="$epg_list<programme start=\"$start +0800\" stop=\"$stop +0800\" channel=\"$program_id\">\n<title lang=\"zh\">${titles[n]}</title>\n</programme>\n"
                done
                break
            fi
        done
    fi
}

VipGetSchedules()
{
    GetDefault
    if [ -n "$d_schedule_file" ] && [ -s "$d_schedule_file" ]
    then
        schedules_id=()
        schedules_sys_time=()
        schedules_title=()
        while IFS="%" read -r schedule_id schedule_sys_time schedule_tile
        do
            schedules_id+=("${schedule_id#\"}")
            schedules_sys_time+=("$schedule_sys_time")
            schedules_title+=("${schedule_tile%\"}")
        done < <($JQ_FILE -M 'to_entries[]|[.key,([.value[].sys_time]|join("^")),([.value[].title]|join("^"))]|join("%")' "$d_schedule_file")
    fi
}

VipMonitor()
{
    trap '' HUP INT
    trap 'MonitorError $LINENO' ERR

    delete_on_term="${vip_public_root:-notfound}/vip"
    pid_file="$IPTV_ROOT/vip.pid"
    printf '%s' "$BASHPID" > "$pid_file"
    {
        flock -x 205
        {
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            printf '%s\n' "$date_now 启动 VIP  PID $BASHPID !" >> "$MONITOR_LOG"
            printf -v now '%(%s)T' -1
            never=$((now+86400*720))

            VipGetSchedules
            ct2=$(date +%s%3N)
            clear=$(date --utc -d 'tomorrow 00:00:10' +%s)

            while true 
            do
                if [ "$now" -ge "$clear" ] 
                then
                    ct2=$(date +%s%3N)
                    clear=$(date --utc -d 'tomorrow 00:00:10' +%s)
                fi
                if [ "$vip_hosts_count" -gt 0 ] && [ "$vip_users_count" -gt 0 ]
                then
                    if [ -e "$VIP_USERS_ROOT/epg.update" ] 
                    then
                        VipGetSchedules
                    fi
                    epg_update=1
                    for((i=0;i<vip_users_count;i++));
                    do
                        vip_user_ip=${vip_users_ip[i]}
                        vip_user_license=${vip_users_license[i]}
                        vip_user_sum=${vip_users_sum[i]}
                        vip_user_expire=${vip_users_expire[i]}
                        vip_user_name=${vip_users_name[i]}

                        tid=$vip_user_license
                        #tid_lower=$(tr '[:upper:]' '[:lower:]' <<< "$tid")
                        tid_lower=$tid
                        if [ "$vip_user_expire" -gt 0 ] 
                        then
                            day=$((vip_user_expire/86400))
                            st2=$vip_user_expire
                        else
                            st2=$never
                        fi

                        if [ "$now" -lt "$vip_user_expire" ] || [ "$vip_user_expire" -eq 0 ]
                        then
                            if [ ! -e "$VIP_USERS_ROOT/$vip_user_license/license.json" ] 
                            then
                                license_json=$(
                                $JQ_FILE -n --arg ip "$vip_user_ip" --arg license "$vip_user_license" \
                                    --arg sum "$vip_user_sum" --arg expire "$vip_user_expire" \
                                    --arg name "$vip_user_name" \
                                    '{
                                        ip: $ip,
                                        license: $license,
                                        sum: $sum,
                                        expire: $expire | tonumber,
                                        name: $name
                                    }'
                                )
                                [ ! -d "$VIP_USERS_ROOT/$vip_user_license" ] && mkdir -p "$VIP_USERS_ROOT/$vip_user_license"
                                printf '%s' "$license_json" > "$VIP_USERS_ROOT/$vip_user_license/license.json"
                            fi
                            m3u_list=""
                            epg_list=""
                            program_id=0
                            for((j=0;j<vip_hosts_count;j++));
                            do
                                vip_host_ip=${vip_hosts_ip[j]}
                                vip_host_port=${vip_hosts_port[j]}
                                vip_host_seed=${vip_hosts_seed[j]}
                                vip_host_token=${vip_hosts_token[j]}
                                vip_host_status_yn=${vip_hosts_status_yn[j]}
                                vip_channels_count=${vip_hosts_channel_count[j]}
                                vip_channel_id=${vip_hosts_channel_id[j]}
                                vip_channel_name=${vip_hosts_channel_name[j]}
                                vip_channel_epg_id=${vip_hosts_channel_epg_id[j]}

                                if [ "$vip_host_status_yn" == "on" ] && [ "$vip_channels_count" -gt 0 ] 
                                then
                                    vip_channel_id_lower=$(tr '[:upper:]' '[:lower:]' <<< "$vip_channel_id")
                                    IFS="|" read -r -a vip_channels_id_lower <<< "$vip_channel_id_lower"
                                    IFS="|" read -r -a vip_channels_id <<< "$vip_channel_id"
                                    IFS="|" read -r -a vip_channels_name <<< "$vip_channel_name"
                                    IFS="|" read -r -a vip_channels_epg_id <<< "${vip_channel_epg_id}|"

                                    seed=$vip_host_seed
                                    token=$vip_host_token
                                    ss=$($MD5SUM_FILE "$st2$token$vip_user_ip$tid")

                                    cs=()
                                    for vip_channel_id in "${vip_channels_id_lower[@]}"
                                    do
                                        cs+=("$st2$ss$ct2$vip_channel_id$tid_lower")
                                    done
                                    mapfile -t vip_channels_cs < <($MD5SUM_FILE "${cs[@]}")

                                    case $vip_user_sum in
                                        "ssum") 
                                            ssum=()
                                            for vip_channel_id in "${vip_channels_id[@]}"
                                            do
                                                ssum+=("$seed/$vip_channel_id/playlist.m3u8$tid$day")
                                            done
                                            mapfile -t vip_channels_ssum < <($MD5SUM_FILE "${ssum[@]}")
                                            for((k=0;k<vip_channels_count;k++));
                                            do
                                                program_id=$((program_id+1))
                                                stream_link="http://$vip_host_ip:$vip_host_port/${vip_channels_id[k]}/playlist.m3u8?tid=$tid&ssum=${vip_channels_ssum[k]}&st2=$st2&ss=$ss&ct2=$ct2&cs=${vip_channels_cs[k]}"
                                                VipProcessLists
                                            done
                                        ;;
                                        "tsum") 
                                            ct=$day
                                            tsum=()
                                            for vip_channel_id in "${vip_channels_id[@]}"
                                            do
                                                tsum+=("$seed/$vip_channel_id/playlist.m3u8$tid$ct")
                                            done
                                            mapfile -t vip_channels_tsum < <($MD5SUM_FILE "${tsum[@]}")
                                            for((k=0;k<vip_channels_count;k++));
                                            do
                                                program_id=$((program_id+1))
                                                stream_link="http://$vip_host_ip:$vip_host_port/${vip_channels_id[k]}/playlist.m3u8?tid=$tid&ct=$ct&tsum=${vip_channels_tsum[k]}&st2=$st2&ss=$ss&ct2=$ct2&cs=${vip_channels_cs[k]}"
                                                VipProcessLists
                                            done
                                        ;;
                                        "isum") 
                                            isum=()
                                            for vip_channel_id in "${vip_channels_id[@]}"
                                            do
                                                isum+=("$seed$vip_user_ip/$vip_channel_id/playlist.m3u8$tid")
                                            done
                                            mapfile -t vip_channels_isum < <($MD5SUM_FILE "${isum[@]}")
                                            for((k=0;k<vip_channels_count;k++));
                                            do
                                                program_id=$((program_id+1))
                                                stream_link="http://$vip_host_ip:$vip_host_port/${vip_channels_id[k]}/playlist.m3u8?tid=$tid&isum=${vip_channels_isum[k]}&st2=$st2&ss=$ss&ct2=$ct2&cs=${vip_channels_cs[k]}"
                                                VipProcessLists
                                            done
                                        ;;
                                    esac
                                elif [ -d "$VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}$vip_host_port" ] 
                                then
                                    rm -rf "$VIP_USERS_ROOT/$vip_user_license/${vip_host_ip//./}${vip_host_port:-notfound}"
                                fi
                            done
                            [ -n "$m3u_list" ] && echo -e "#EXTM3U\n$m3u_list" > "$VIP_USERS_ROOT/$vip_user_license/playlist.m3u"
                            if { [ "$epg_update" -eq 1 ] || [ -e "$VIP_USERS_ROOT/epg.update" ]; } && [ -n "$epg_list" ]
                            then
                                epg_update=0
                                echo -e "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<tv>\n$epg_list</tv>" > "$VIP_USERS_ROOT/epg.xml.new"
                                mv "$VIP_USERS_ROOT/epg.xml.new" "$VIP_USERS_ROOT/epg.xml"
                                rm -f "$VIP_USERS_ROOT/epg.update"
                            fi
                        elif [ -d "$VIP_USERS_ROOT/$vip_user_license" ] 
                        then
                            rm -rf "$VIP_USERS_ROOT/${vip_user_license:-notfound}"
                        fi
                    done
                fi

                PrepTerm
                sleep 60 &
                WaitTerm

                vip_users_license_old=("${vip_users_license[@]}")
                vip_hosts_channel_id_old=("${vip_hosts_channel_id[@]}")

                VipGetHosts
                VipGetUsers

                for vip_user_license_old in ${vip_users_license_old[@]+"${vip_users_license_old[@]}"}
                do
                    for vip_user_license in ${vip_users_license[@]+"${vip_users_license[@]}"}
                    do
                        if [ "$vip_user_license" == "$vip_user_license_old" ] 
                        then
                            for vip_host_channel_id_old in ${vip_hosts_channel_id_old[@]+"${vip_hosts_channel_id_old[@]}"}
                            do
                                for vip_host_channel_id in ${vip_hosts_channel_id[@]+"${vip_hosts_channel_id[@]}"}
                                do
                                    if [ "$vip_host_channel_id" == "$vip_host_channel_id_old" ] 
                                    then
                                        break 4
                                    fi
                                done
                                IFS="|" read -r -a vip_channels_id_old <<< "$vip_host_channel_id_old"
                                for vip_channel_id_old in "${vip_channels_id_old[@]}"
                                do
                                    for vip_host_channel_id in ${vip_hosts_channel_id[@]+"${vip_hosts_channel_id[@]}"}
                                    do
                                        IFS="|" read -r -a vip_channels_id <<< "$vip_host_channel_id"
                                        for vip_channel_id in "${vip_channels_id[@]}"
                                        do
                                            if [ "$vip_channel_id" == "$vip_channel_id_old" ] 
                                            then
                                                break 6
                                            fi
                                        done
                                    done
                                    rm -rf "$VIP_USERS_ROOT/$vip_user_license_old/${vip_host_ip//./}$vip_host_port/${vip_channel_id_old:-notfound}"
                                done
                            done
                            break 2
                        fi
                    done
                    rm -rf "$VIP_USERS_ROOT/${vip_user_license_old:-notfound}"
                done
                printf -v now '%(%s)T' -1
            done
        } 205>&-
    } 205<"$pid_file"
}

VipEnable()
{
    # deprecated
    if [ -s "/tmp/vip.pid" ] && kill -0 "$(< /tmp/vip.pid)" 2> /dev/null
    then
        Println "$error VIP 已开启\n" && exit 1
    fi

    if [ -s "$IPTV_ROOT/vip.pid" ] && kill -0 "$(< $IPTV_ROOT/vip.pid)" 2> /dev/null
    then
        Println "$error VIP 已开启\n" && exit 1
    fi

    if [ ! -s "$VIP_FILE" ] 
    then
        Println "$error 请先添加 VIP 服务器\n" && exit 1
    fi

    VipGetHosts

    if [ "$vip_hosts_count" -gt 0 ] 
    then
        VipGetUsers

        if [ "$vip_users_count" -gt 0 ] 
        then
            if [ ! -e "$MD5SUM_FILE" ] 
            then
                Println "$info 安装 md5sum..."
                if [[ ! -x $(command -v gcc) ]] 
                then
                    ReleaseCheck
                    if [ "$release" == "rpm" ] 
                    then
                        yum -y install gcc gcc-c++ >/dev/null 2>&1
                    else
                        apt-get -y install build-essential >/dev/null 2>&1
                    fi
                fi
                mkdir -p "$C_ROOT"
                wget --timeout=10 --tries=1 --no-check-certificate "$MD5SUM_LINK" -qO "$MD5SUM_FILE.c" \
                || wget --timeout=10 --tries=3 --no-check-certificate "$MD5SUM_LINK_BACKUP" -qO "$MD5SUM_FILE.c"
                gcc -Wall -O3 -o "$MD5SUM_FILE" "$MD5SUM_FILE.c"
                Println "$info md5sum 安装成功"
            fi
            if [ -z "${vip_public_root:-}" ] 
            then
                VipConfig
            fi
            [ -n "$vip_public_root" ] && ln -sfT "$VIP_USERS_ROOT" "$vip_public_root/vip"

            ( VipMonitor ) > /dev/null 2>> "$MONITOR_LOG" &

            Println "$info VIP 开启成功\n"
        else
            Println "$error 请先添加用户\n" && exit 1
        fi
    else
        Println "$error 请先添加 VIP 服务器\n" && exit 1
    fi
}

VipDisable()
{
    # deprecated
    if [ -s "/tmp/vip.pid" ] 
    then
        vip_pid=$(< /tmp/vip.pid)
        if kill -0 "$vip_pid" 2> /dev/null
        then
            kill "$vip_pid" 2> /dev/null
            printf -v date_now '%(%m-%d %H:%M:%S)T' -1
            printf '%s\n' "$date_now 关闭 VIP  PID $vip_pid !" >> "$MONITOR_LOG"
            Println "$info VIP 关闭成功\n"
        else
            Println "$error VIP 未开启\n"
        fi
        rm -f "/tmp/vip.pid"
    elif [ -s "$IPTV_ROOT/vip.pid" ] 
    then
        PID=$(< "$IPTV_ROOT/vip.pid")
        if kill -0 "$PID" 2> /dev/null 
        then
            Println "$info 关闭 VIP, 稍等..."
            kill "$PID" 2> /dev/null
            if flock -E 1 -w 20 -x "$IPTV_ROOT/vip.pid" rm -f "$IPTV_ROOT/vip.pid"
            then
                printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                printf '%s\n' "$date_now 关闭 VIP PID $PID !" >> "$MONITOR_LOG"
                Println "$info VIP 关闭成功 !\n"
            else
                Println "$error VIP 关闭超时, 请重试\n"
                exit 1
            fi
        else
            rm -f "$IPTV_ROOT/vip.pid"
            Println "$error VIP 未开启\n"
        fi
    else
        [ -e "$IPTV_ROOT/vip.pid" ] && rm -f "$IPTV_ROOT/vip.pid"
        Println "$error VIP 未开启\n"
    fi
}

VipListUserChannel()
{
    if [ ! -s "$VIP_FILE" ] 
    then
        Println "$error 请先输入授权码, 加微信 woniuzfb 或 tg @ woniuzfb\n"
    else
        VipGetUsers
        printf -v now '%(%s)T' -1
        vip_users_list=""
        for((i=0;i<vip_users_count;i++));
        do
            vip_user_ip=${vip_users_ip[i]}
            vip_user_license=${vip_users_license[i]}
            vip_user_expire=${vip_users_expire[i]}
            vip_user_name=${vip_users_name[i]}

            if [ "$vip_user_expire" -gt 0 ] 
            then
                expire_text=$(date +%c --date=@"$vip_user_expire")
            else
                expire_text="无"
            fi
            if [ "$now" -lt "$vip_user_expire" ] || [ "$vip_user_expire" -eq 0 ]
            then
                vip_users_list="$vip_users_list ${green}$((i+1)).${normal}${indent_6}用户名: ${green}$vip_user_name${normal}  ip: ${green}$vip_user_ip${normal}  到期日: ${green}$expire_text${normal}\n${indent_6}授权码: ${green}$vip_user_license${normal}\n${indent_6}m3u 播放链接: ${green}${FFMPEG_MIRROR_LINK%/*}/vip/$vip_user_license/playlist.m3u${normal}\n\n"
            fi
        done

        if [ -n "$vip_users_list" ] 
        then
            Println "$vip_users_list"
        elif [ "$vip_users_count" -eq 0 ] 
        then
            Println "$error 授权码不存在, 请联系微信 woniuzfb 或 tg @ woniuzfb\n"
        else
            Println "$error 授权码已过期, 请联系微信 woniuzfb 或 tg @ woniuzfb\n"
        fi
    fi
}

VipVerifyLicense()
{
    Println "请输入授权码"
    read -p "$i18n_default_cancel" vip_user_license
    [ -z "$vip_user_license" ] && Println "$i18n_canceled...\n" && exit 1

    if vip_user=$(wget --timeout=10 --tries=3 --no-check-certificate "${FFMPEG_MIRROR_LINK%/*}/vip/$vip_user_license/license.json" -qO- 2> /dev/null)
    then
        if [ ! -s "$VIP_FILE" ] 
        then
            printf '{"%s":{},"%s":[],"%s":[]}' "config" "users" "hosts" > "$VIP_FILE"
        fi

        while IFS= read -r license_ip 
        do
            jq_path='["users"]'
            JQ delete "$VIP_FILE" ip "$license_ip"
        done < <($JQ_FILE -r '.ip' <<< "$vip_user")

        jq_path='["users"]'
        JQ add "$VIP_FILE" "$vip_user"
        Println "$info 授权码验证成功\n"
    else
        Println "$error 授权码验证失败, 请联系微信 woniuzfb 或 tg @ woniuzfb\n"
    fi
}

VipUserMenu()
{
    Println "  `gettext \"VIP 面板\"`

  ${red}1.${normal} `gettext \"查看 VIP 频道\"`
  ${red}2.${normal} `gettext \"输入 VIP 授权码\"`

 `eval_gettext \"\\\$tip 输入: h 切换到 HLS 面板, f 切换到 FLV 面板\"`\n\n"
    read -p "`gettext \"输入序号\"` [1-2]: " vip_menu_num
    case "$vip_menu_num" in
        h)
            kind=""
            color=${green}
            Menu
        ;;
        f)
            kind="flv"
            color=$blue
            Menu
        ;;
        1) VipListUserChannel
        ;;
        2) VipVerifyLicense
        ;;
        *) Println "$error $i18n_input_correct_number [1-2]\n"
        ;;
    esac
}

VipMenu()
{
    [ ! -d "$IPTV_ROOT" ] && Println "`eval_gettext \"\\\$error 请先输入 tv 安装 !\"`\n" && exit 1
    if [ ! -f "$IPTV_ROOT/VIP" ] 
    then
        VipUserMenu
        return 0
    fi
    Println "  `gettext \"VIP 面板\"`

  ${red}1.${normal} `gettext \"查看 VIP 用户\"`
  ${red}2.${normal} `gettext \"添加 VIP 用户\"`
  ${red}3.${normal} `gettext \"设置 VIP 用户\"`
  ${red}4.${normal} `gettext \"查看 VIP 频道\"`
  ${red}5.${normal} `gettext \"添加 VIP 频道\"`
  ${red}6.${normal} `gettext \"设置 VIP 频道\"`
  ${red}7.${normal} `gettext \"查看 VIP 服务器\"`
  ${red}8.${normal} `gettext \"添加 VIP 服务器\"`
  ${red}9.${normal} `gettext \"设置 VIP 服务器\"`
 ${red}10.${normal} `gettext \"删除 VIP 用户\"`
 ${red}11.${normal} `gettext \"删除 VIP 频道\"`
 ${red}12.${normal} `gettext \"删除 VIP 服务器\"`
 ${red}13.${normal} `gettext \"开启 VIP\"`
 ${red}14.${normal} `gettext \"关闭 VIP\"`

 `eval_gettext \"\\\$tip 输入: h 切换到 HLS 面板, f 切换到 FLV 面板\"`\n\n"
    read -p "`gettext \"输入序号\"` [1-14]: " vip_menu_num
    case "$vip_menu_num" in
        h)
            kind=""
            color=${green}
            Menu
        ;;
        f)
            kind="flv"
            color=$blue
            Menu
        ;;
        1) VipListUser
        ;;
        2) VipAddUser
        ;;
        3) VipEditUser
        ;;
        4) VipListChannel
        ;;
        5) VipSetChannel
        ;;
        6) VipEditChannel
        ;;
        7) VipListHosts
        ;;
        8) VipAddHost
        ;;
        9) VipEditHost
        ;;
        10) VipDelUser
        ;;
        11) VipDelChannel
        ;;
        12) VipDelHost
        ;;
        13) VipEnable
        ;;
        14) VipDisable
        ;;
        *) Println "$error $i18n_input_correct_number [1-14]\n"
        ;;
    esac
}

AptSetSources()
{
    echo
    apt_sources_options=( '国内' '国外' )
    inquirer list_input "选择源" apt_sources_options apt_sources
    if [[ $apt_sources == "国内" ]]
    then
        sed -i 's/deb.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list
        sed -i 's/ftp.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list
        sed -i 's|security.debian.org|mirrors.ustc.edu.cn/debian-security|g' /etc/apt/sources.list
        if [ -f "/etc/apt/sources.list.d/armbian.list" ]
        then
            sed -i 's|http[s]*://apt.armbian.com|http://mirrors.nju.edu.cn/armbian|g' /etc/apt/sources.list.d/armbian.list
        fi
    else
        sed -i 's/mirrors.ustc.edu.cn/deb.debian.org/g' /etc/apt/sources.list
        sed -i 's|mirrors.ustc.edu.cn/debian-security|security.debian.org|g' /etc/apt/sources.list
        if [ -f "/etc/apt/sources.list.d/armbian.list" ]
        then
            sed -i 's|http://mirrors.nju.edu.cn/armbian|https://apt.armbian.com|g' /etc/apt/sources.list.d/armbian.list
        fi
    fi
    Println "$info 源更改成功\n"
}

VimConfig()
{
    if [[ ! -x $(command -v vim) ]] 
    then
        Println "$info 安装 vim ..."
        apt-get update
        apt-get -y install vim
    fi

    if [ -e ~/.vimrc ] 
    then
        echo
        AskIfContinue n "`gettext \"将安装 vim-plug 并覆盖 ~/.vimrc , 是否继续\"`"
    fi

    if curl -s -fLo ~/.vim/autoload/plug.vim --create-dirs "$FFMPEG_MIRROR_LINK/vim-plug.vim"
    then
        printf '%s' "
call plug#begin('~/.vim/plugged')
Plug 'preservim/nerdcommenter'
Plug 'ryanpcmcquen/fix-vim-pasting'
call plug#end()

set number
set mouse=a
set tabstop=2
set shiftwidth=2
set expandtab

autocmd BufRead,BufNewFile *.conf setfiletype conf
filetype indent off
" > ~/.vimrc
        Println "$info vimrc 设置完成, 请在 vim 下执行 PlugInstall\n"
    else
        Println "$error 无法连接服务器, 请稍后再试\n"
    fi
}

PveGetVMs()
{
    pve_vm_count=0

    IFS=" " read -r m_id m_name m_status m_mem m_boot_disk m_pid < <(qm list | awk '$1 {a=a $1",";b=b $2",";c=c $3",";d=d $4",";e=e $5",";f=f $6","} END {print a,b,c,d,e,f}')

    if [ -n "${m_id#*,}" ] 
    then
        IFS="," read -r -a pve_vm_ids <<< "${m_id#*,}"
        IFS="," read -r -a pve_vm_name <<< "${m_name#*,}"
        IFS="," read -r -a pve_vm_status <<< "${m_status#*,}"
        IFS="," read -r -a pve_vm_mem <<< "${m_mem#*,}"
        IFS="," read -r -a pve_vm_boot_disk <<< "${m_boot_disk#*,}"
        IFS="," read -r -a pve_vm_pid <<< "${m_pid#*,}"

        pve_vm_count=${#pve_vm_ids[@]}
    fi
}

PveListVMs()
{
    PveGetVMs

    if [ "$pve_vm_count" -eq 0 ] 
    then
        Println "$error 没有虚拟机\n"
        exit 1
    fi

    pve_vm_list=""

    for((i=0;i<pve_vm_count;i++));
    do
        pve_vm_list="$pve_vm_list ${green}$((i+1)).${normal}${indent_6}ID: ${green}${pve_vm_ids[i]}${normal} 名称: ${green}${pve_vm_name[i]}${normal}\n${indent_6}状态: ${green}${pve_vm_status[i]}${normal} 内存: ${green}${pve_vm_mem[i]} MB${normal}\n${indent_6}启动盘: ${green}${pve_vm_boot_disk[i]} GB${normal} pid: ${green}${pve_vm_pid[i]}${normal}\n\n"
    done

    Println "$pve_vm_list"
}

PveSelectVM()
{
    echo "选择 VM"
    while read -p "$i18n_default_cancel" pve_vm_index
    do
        case "$pve_vm_index" in
            "")
                Println "$i18n_canceled...\n"
                exit 1
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_no\n"
            ;;
            *)
                if [ "$pve_vm_index" -gt 0 ] && [ "$pve_vm_index" -le "$pve_vm_count" ]
                then
                    pve_vm_index=$((pve_vm_index-1))
                    vm_id=${pve_vm_ids[pve_vm_index]}
                    vm_name=${pve_vm_name[pve_vm_index]}
                    vm_status=${pve_vm_status[pve_vm_index]}
                    vm_mem=${pve_vm_mem[pve_vm_index]}
                    vm_boot_disk=${pve_vm_boot_disk[pve_vm_index]}
                    vm_pid=${pve_vm_pid[pve_vm_index]}
                    break
                else
                    Println "$error $i18n_input_correct_no\n"
                fi
            ;;
        esac
    done
}

Menu()
{
    color=${color:-${green}}

    if [ -z "${kind:-}" ] 
    then
        title="HLS"
        msg=$(gettext "输入: f 切换到 FLV 面板, v 切换到 VIP 面板")
    elif [ "$kind" == "flv" ] 
    then
        title="FLV"
        msg=$(gettext "输入: h 切换到 HLS 面板, v 切换到 VIP 面板")
    fi

    Println "  ${dim_underlined}MTimer | http://hbo.epub.fun${normal}

  `gettext \"IPTV 一键管理脚本\"` ${red}[v$sh_ver]${normal}

  ${color}1.${normal} `gettext \"安装\"`
  ${color}2.${normal} `gettext \"卸载\"`
  ${color}3.${normal} `gettext \"升级\"`
————————————
  ${color}4.${normal} `gettext \"查看频道\"`
  ${color}5.${normal} `gettext \"添加频道\"`
  ${color}6.${normal} `gettext \"修改频道\"`
  ${color}7.${normal} `gettext \"开关频道\"`
  ${color}8.${normal} `gettext \"重启频道\"`
  ${color}9.${normal} `gettext \"查看日志\"`
 ${color}10.${normal} `gettext \"删除频道\"`
 ${color}11.${normal} `gettext \"修改默认\"`

 `eval_gettext \"\\\$tip 当前: \\\${green}\\\$title\\\${normal} 面板\"`
 $tip $msg\n\n"
    read -p "`gettext \"输入序号\"` [1-11]: " menu_num
    case "$menu_num" in
        h)
            kind=""
            color=${green}
            Menu
        ;;
        f)
            kind="flv"
            color=$blue
            Menu
        ;;
        v)
            VipMenu
        ;;
        1) Install
        ;;
        2) Uninstall
        ;;
        3) Update
        ;;
        4) ViewChannel
        ;;
        5) AddChannel
        ;;
        6) EditChannelMenu
        ;;
        7) ToggleChannel
        ;;
        8) RestartChannel
        ;;
        9) ViewChannelLog
        ;;
        10) DelChannel
        ;;
        11) EditDefaultMenu
        ;;
        *) Println "$error $i18n_input_correct_number [1-11]\n"
        ;;
    esac
}

Usage()
{
    Println " `gettext \"使用方法: tv -i [直播源] [-s 分片时长(秒)] [-o 输出目录名称] [-c m3u8包含的分片数] [-b 比特率] [-p m3u8文件名称] [-C] [-l] [-P http代理]\"`
    `gettext \" -i  直播源(支持 mpegts / hls / flv / youtube ...)\"`
         `gettext \"可以是视频路径\"`
         `gettext \"可以输入不同链接地址(监控按顺序尝试使用), 用空格分隔\"`
    `gettext \" -s  分片时长(秒)(默认: 6)\"`
    `gettext \" -o  输出目录名称(默认: 随机名称)\"`

    `gettext \" -l  非无限时长直播, 无法设置切割的分片数且无法监控(默认: 不设置)\"`
    `gettext \" -P  FFmpeg 的 http 代理, 直播源是 http 链接时可用(默认: 不设置)\"`

    `gettext \" -p  m3u8名称(前缀)(默认: 随机)\"`
    `gettext \" -c  m3u8里包含的分片数目(默认: 5)\"`
    `gettext \" -S  分片所在子目录名称(默认: 不使用子目录)\"`
    `gettext \" -t  分片名称(前缀)(默认: 跟m3u8名称相同)\"`
    `gettext \" -a  音频编码(默认: aac) (不需要转码时输入 copy)\"`
    `gettext \" -v  视频编码(默认: libx264) (不需要转码时输入 copy)\"`
    `gettext \" -f  画面或声音延迟(格式如:  v_3 画面延迟3秒, a_2 声音延迟2秒 画面声音不同步时使用)\"`
    `gettext \" -d  dvb teletext 字幕解码成的格式,可选: text,ass (默认: 不设置)\"`
    `gettext \" -q  crf 值(如果同时设置了输出视频比特率, 则优先使用 crf 值控制视频质量)(数值 0~63 越大质量越差), 多个 crf 用逗号分隔\"`
         `gettext \"(默认: 不设置 crf 值)\"`
    `gettext \" -b  输出视频的比特率(kb/s)(默认: 900-1280x720)\"`
         `gettext \"如果已经设置crf视频质量值, 则比特率用于 -maxrate -bufsize\"`
         `gettext \"如果没有设置crf视频质量值, 则可以继续设置是否固定码率\"`
         `gettext \"多个比特率用逗号分隔(注意-如果设置多个比特率, 就是生成自适应码流)\"`
         `gettext \"同时可以指定输出的分辨率(比如: -b 800-640x360,1000-960x540,1500-1280x720)\"`
         `gettext \"可以输入 omit 省略此选项\"`
    `gettext \" -C  固定码率(只有在没有设置crf视频质量的情况下才有效)(默认: 否)\"`
    `gettext \" -e  加密分片(默认: 不加密)\"`
    `gettext \" -K  Key名称(默认: 随机)\"`
    `gettext \" -z  频道名称(默认: 跟m3u8名称相同)\"`
     `gettext \"也可以不输出 HLS, 比如 flv 推流\"`
    `gettext \" -k  设置推流类型, 比如 -k flv\"`
    `gettext \" -H  推流 h265(默认: 不设置)\"`
    `gettext \" -T  设置推流地址, 比如 rtmp://127.0.0.1/flv/xxx\"`
    `gettext \" -L  输入拉流(播放)地址(可省略), 比如 http://domain.com/flv?app=flv&stream=xxx\"`
    `gettext \" -m  FFmpeg 额外的 输入参数\"`
         (`gettext \"默认:\"` -copy_unknown -reconnect 1 -reconnect_at_eof 1 
         -reconnect_streamed 1 -reconnect_delay_max 2000 
         -rw_timeout 10000000 -y -nostats -nostdin -hide_banner -loglevel error)
         `gettext \"如果输入的直播源是 hls 链接, 需去除 -reconnect_at_eof 1\"`
         `gettext \"如果输入的直播源是 rtmp 或本地链接, 需去除 -reconnect 1 -reconnect_at_eof 1 -reconnect_streamed 1 -reconnect_delay_max 2000\"`
    `gettext \" -n  FFmpeg 额外的 输出参数, 可以输入 omit 省略此选项\"`
         (`gettext \"默认:\"` -g 50 -sc_threshold 0 -sn -preset superfast -pix_fmt yuv420p -profile:v main)

 `gettext \"举例:\"`
     `gettext \"使用crf值控制视频质量:\"` 
         `gettext \"tv -i http://xxx.com/xxx.ts -s 6 -o hbo1 -p hbo1 -q 15 -b 1500-1280x720 -z 'hbo直播1'\"`
     `gettext \"使用比特率控制视频质量[默认]:\"` 
         `gettext \"tv -i http://xxx.com/xxx.ts -s 6 -o hbo2 -p hbo2 -b 900-1280x720 -z 'hbo直播2'\"`
     `gettext \"不需要转码的设置:\"` -a copy -v copy -n omit
     `gettext \"不输出 HLS, 推流 flv:\"`
         tv -i http://xxx/xxx.ts -a aac -v libx264 -b 3000 -k flv -T rtmp://127.0.0.1/flv/xxx

 `gettext \"快捷键:\"`
     `gettext \"tv 打开 HLS 管理面板\"`
         `gettext \"tv l 列出所有开启的频道\"`
         `gettext \"tv d 添加演示频道\"`
         `gettext \"tv e 手动修改 channels.json\"`
       `gettext \"tv f 打开 FLV 管理面板\"`
       `gettext \"tv v 打开 VIP 面板\"`
       `gettext \"tv m 开启监控\"`
         `gettext \"tv m l [行数] 查看监控日志\"`
         `gettext \"tv m s 关闭监控\"`
       `gettext \"tv s 节目表管理面板\"`
       `gettext \"tv 4g 打开 4gtv 频道管理面板\"`
       `gettext \"tv FFmpeg 自建 FFmpeg 镜像\"`
       `gettext \"tv debug 1/0 开启/关闭 调试\"`

     `gettext \"cx 打开 xtream codes 账号/频道管理面板\"`

     `gettext \"v2 打开 v2ray 面板\"`
        `gettext \"v2 e 手动修改 config.json\"`

     `gettext \"x 打开 xray 面板\"`
        `gettext \"x e 手动修改 config.json\"`

     `gettext \"nx 打开 nginx 面板\"`

     `gettext \"or 打开 openresty 面板\"`

     `gettext \"cf 打开 cloudflare partner / workers 面板\"`
        `gettext \"cf w 打开 cloudflare workers 面板\"`

     `gettext \"ibm 打开 IBM Cloud Foundry 面板\"`
        `gettext \"ibm v2 打开 ibm v2ray app 管理面板\"`
        `gettext \"ibm x  打开 ibm xray app 管理面板\"`

     `gettext \"arm 打开 Armbian 管理面板\"`

     `gettext \"pve 打开 Proxmox VE 管理面板\"`

     `gettext \"tv c <en|ru|de|zh_CN|...> 切换/更新 语言\"`
    "
    exit
}

UpdateSelf()
{
    if [ ! -e "$JQ_FILE" ] 
    then
        echo
        AskIfContinue y "`gettext \"检测到安装未完成, 是否卸载重装\"`"

        Uninstall
        Install
        exit 0
    fi
    GetDefault
    if [ "${d_version%.*}" != "${sh_ver%.*}" ] 
    then
        major_ver=${d_version%%.*}
        minor_ver=${d_version#*.}
        minor_ver=${minor_ver%%.*}

        if [ "$major_ver" -eq 1 ] 
        then
            if [ "$minor_ver" -lt 35 ] 
            then
                Println "$info 需要先关闭所有频道, 请稍等...\n"
                StopChannelsForce
                rm -rf "/tmp/flv.lockdir/"
                rm -rf "/tmp/monitor.lockdir"
                rm -rf "$FFMPEG_LOG_ROOT/"*.lock
            fi
        fi

        Println "$info 更新中, 请稍等...\n"
        printf -v update_date '%(%m-%d-%H:%M:%S)T' -1
        cp -f "$CHANNELS_FILE" "${CHANNELS_FILE}_$update_date"

        GetChannels

        while [[ $d_headers =~ \\\\ ]]
        do
            d_headers=${d_headers//\\\\/\\}
        done

        if [[ ! $d_input_flags =~ -copy_unknown ]] 
        then
            d_input_flags="-copy_unknown $d_input_flags"
        fi
        d_input_flags=${d_input_flags//-timeout 2000000000/-rw_timeout 10000000}
        default=$(
        $JQ_FILE -n --arg proxy "$d_proxy" --arg xc_proxy "$d_xc_proxy" \
            --arg user_agent "$d_user_agent" \
            --arg headers "$d_headers" --arg cookies "$d_cookies" \
            --arg playlist_name "$d_playlist_name" --arg seg_dir_name "$d_seg_dir_name" \
            --arg seg_name "$d_seg_name" --arg seg_length "$d_seg_length" \
            --arg seg_count "$d_seg_count" --arg video_codec "$d_video_codec" \
            --arg audio_codec "$d_audio_codec" --arg video_audio_shift "$d_video_audio_shift" \
            --arg txt_format "$d_txt_format" --arg draw_text "$d_draw_text" \
            --arg quality "$d_quality" --arg bitrates "$d_bitrates" \
            --arg const "$d_const_yn" --arg encrypt "$d_encrypt_yn" \
            --arg encrypt_session "$d_encrypt_session_yn" \
            --arg keyinfo_name "$d_keyinfo_name" --arg key_name "$d_key_name" \
            --arg input_flags "$d_input_flags" \
            --arg output_flags "$d_output_flags" --arg sync "$d_sync_yn" \
            --arg sync_file "$d_sync_file" --arg sync_index "$d_sync_index" \
            --arg sync_pairs "$d_sync_pairs" --arg schedule_file "$d_schedule_file" \
            --arg flv_delay_seconds "$d_flv_delay_seconds" --arg flv_restart_nums "$d_flv_restart_nums" \
            --arg hls_delay_seconds "$d_hls_delay_seconds" --arg hls_min_bitrates "$d_hls_min_bitrates" \
            --arg hls_max_seg_size "$d_hls_max_seg_size" --arg hls_restart_nums "$d_hls_restart_nums" \
            --arg hls_key_period "$d_hls_key_period" --arg anti_ddos_port "$d_anti_ddos_port" \
            --arg anti_ddos_syn_flood "$d_anti_ddos_syn_flood_yn" --arg anti_ddos_syn_flood_delay_seconds "$d_anti_ddos_syn_flood_delay_seconds" \
            --arg anti_ddos_syn_flood_seconds "$d_anti_ddos_syn_flood_seconds" --arg anti_ddos "$d_anti_ddos_yn" \
            --arg anti_ddos_seconds "$d_anti_ddos_seconds" --arg anti_ddos_level "$d_anti_ddos_level" \
            --arg anti_leech "$d_anti_leech_yn" --arg anti_leech_restart_nums "$d_anti_leech_restart_nums" \
            --arg anti_leech_restart_flv_changes "$d_anti_leech_restart_flv_changes_yn" --arg anti_leech_restart_hls_changes "$d_anti_leech_restart_hls_changes_yn" \
            --arg recheck_period "$d_recheck_period" --arg version "$sh_ver" \
            '{
                proxy: $proxy,
                xc_proxy: $xc_proxy,
                user_agent: $user_agent,
                headers: $headers,
                cookies: $cookies,
                playlist_name: $playlist_name,
                seg_dir_name: $seg_dir_name,
                seg_name: $seg_name,
                seg_length: $seg_length | tonumber,
                seg_count: $seg_count | tonumber,
                video_codec: $video_codec,
                audio_codec: $audio_codec,
                video_audio_shift: $video_audio_shift,
                txt_format: $txt_format,
                draw_text: $draw_text,
                quality: $quality,
                bitrates: $bitrates,
                const: $const,
                encrypt: $encrypt,
                encrypt_session: $encrypt_session,
                keyinfo_name: $keyinfo_name,
                key_name: $key_name,
                input_flags: $input_flags,
                output_flags: $output_flags,
                sync: $sync,
                sync_file: $sync_file,
                sync_index: $sync_index,
                sync_pairs: $sync_pairs,
                schedule_file: $schedule_file,
                flv_delay_seconds: $flv_delay_seconds | tonumber,
                flv_restart_nums: $flv_restart_nums | tonumber,
                hls_delay_seconds: $hls_delay_seconds | tonumber,
                hls_min_bitrates: $hls_min_bitrates | tonumber,
                hls_max_seg_size: $hls_max_seg_size | tonumber,
                hls_restart_nums: $hls_restart_nums | tonumber,
                hls_key_period: $hls_key_period | tonumber,
                anti_ddos_port: $anti_ddos_port,
                anti_ddos_syn_flood: $anti_ddos_syn_flood,
                anti_ddos_syn_flood_delay_seconds: $anti_ddos_syn_flood_delay_seconds | tonumber,
                anti_ddos_syn_flood_seconds: $anti_ddos_syn_flood_seconds | tonumber,
                anti_ddos: $anti_ddos,
                anti_ddos_seconds: $anti_ddos_seconds | tonumber,
                anti_ddos_level: $anti_ddos_level | tonumber,
                anti_leech: $anti_leech,
                anti_leech_restart_nums: $anti_leech_restart_nums | tonumber,
                anti_leech_restart_flv_changes: $anti_leech_restart_flv_changes,
                anti_leech_restart_hls_changes: $anti_leech_restart_hls_changes,
                recheck_period: $recheck_period | tonumber,
                version: $version
            }'
        )

        JQ replace "$CHANNELS_FILE" default "$default"

        new_channels=""

        for((i=0;i<chnls_count;i++));
        do
            [ -n "$new_channels" ] && new_channels="$new_channels,"

            while [[ ${chnls_headers[i]} =~ \\\\ ]]
            do
                chnls_headers[i]=${chnls_headers[i]//\\\\/\\}
            done

            if [[ ! ${chnls_input_flags[i]} =~ -copy_unknown ]] 
            then
                chnls_input_flags[i]="-copy_unknown ${chnls_input_flags[i]}"
            fi
            new_input_flags=${chnls_input_flags[i]//-timeout 2000000000/-rw_timeout 10000000}
            new_channel=$(
            $JQ_FILE -n --arg pid "${chnls_pid[i]}" --arg status "${chnls_status[i]}" \
                --arg stream_link "${chnls_stream_links[i]}" --arg live "${chnls_live[i]}" \
                --arg proxy "${chnls_proxy[i]}" --arg xc_proxy "${chnls_xc_proxy[i]}" \
                --arg user_agent "${chnls_user_agent[i]}" \
                --arg headers "${chnls_headers[i]}" --arg cookies "${chnls_cookies[i]}" \
                --arg output_dir_name "${chnls_output_dir_name[i]}" --arg playlist_name "${chnls_playlist_name[i]}" \
                --arg seg_dir_name "${chnls_seg_dir_name[i]}" --arg seg_name "${chnls_seg_name[i]}" \
                --arg seg_length "${chnls_seg_length[i]}" --arg seg_count "${chnls_seg_count[i]}" \
                --arg video_codec "${chnls_video_codec[i]}" --arg audio_codec "${chnls_audio_codec[i]}" \
                --arg video_audio_shift "${chnls_video_audio_shift[i]}" --arg txt_format "${chnls_txt_format[i]}"\
                --arg draw_text "${chnls_draw_text[i]}" \
                --arg quality "${chnls_quality[i]}" --arg bitrates "${chnls_bitrates[i]}" \
                --arg const "${chnls_const[i]}" --arg encrypt "${chnls_encrypt[i]}" \
                --arg encrypt_session "${chnls_encrypt_session[i]}" --arg keyinfo_name "${chnls_keyinfo_name[i]}" \
                --arg key_name "${chnls_key_name[i]}" --arg key_time "${chnls_key_time[i]}" \
                --arg input_flags "$new_input_flags" --arg output_flags "${chnls_output_flags[i]}" \
                --arg channel_name "${chnls_channel_name[i]}" --arg channel_time "${chnls_channel_time[i]}" \
                --arg sync "${chnls_sync[i]}" --arg sync_file "${chnls_sync_file[i]}" \
                --arg sync_index "${chnls_sync_index[i]}" --arg sync_pairs "${chnls_sync_pairs[i]}" \
                --arg flv_status "${chnls_flv_status[i]}" --arg flv_h265 "${chnls_flv_h265[i]}" \
                --arg flv_push_link "${chnls_flv_push_link[i]}" --arg flv_pull_link "${chnls_flv_pull_link[i]}" \
                '{
                    pid: $pid | tonumber,
                    status: $status,
                    stream_link: $stream_link,
                    live: $live,
                    proxy: $proxy,
                    xc_proxy: $xc_proxy,
                    user_agent: $user_agent,
                    headers: $headers,
                    cookies: $cookies,
                    output_dir_name: $output_dir_name,
                    playlist_name: $playlist_name,
                    seg_dir_name: $seg_dir_name,
                    seg_name: $seg_name,
                    seg_length: $seg_length | tonumber,
                    seg_count: $seg_count | tonumber,
                    video_codec: $video_codec,
                    audio_codec: $audio_codec,
                    video_audio_shift: $video_audio_shift,
                    txt_format: $txt_format,
                    draw_text: $draw_text,
                    quality: $quality,
                    bitrates: $bitrates,
                    const: $const,
                    encrypt: $encrypt,
                    encrypt_session: $encrypt_session,
                    keyinfo_name: $keyinfo_name,
                    key_name: $key_name,
                    key_time: $key_time | tonumber,
                    input_flags: $input_flags,
                    output_flags: $output_flags,
                    channel_name: $channel_name,
                    channel_time: $channel_time | tonumber,
                    sync: $sync,
                    sync_file: $sync_file,
                    sync_index: $sync_index,
                    sync_pairs: $sync_pairs,
                    flv_status: $flv_status,
                    flv_h265: $flv_h265,
                    flv_push_link: $flv_push_link,
                    flv_pull_link: $flv_pull_link
                }'
            )

            new_channels="$new_channels$new_channel"
        done

        JQ replace "$CHANNELS_FILE" channels "[$new_channels]"
    fi
    printf '%s' "" > ${LOCK_FILE}
}

if [ -e "$IPTV_ROOT" ] && [ ! -e "$LOCK_FILE" ] 
then
    UpdateSelf
fi

self=${0##*/}

if [ "$self" == "ibm" ] || [ "$self" == "ibm.sh" ]
then
    ShFileCheck

    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"

    if [ ! -e "$JQ_FILE" ] 
    then
        DepsCheck
        JQInstall
    fi

    if [ -d "$IPTV_ROOT" ]
    then
        IBM_CONFIG_NEW="$IPTV_ROOT/${IBM_CONFIG##*/}"

        if [ -e "$IBM_CONFIG" ] && [ ! -e "$IBM_CONFIG_NEW" ]
        then
            mv "$IBM_CONFIG" "$IBM_CONFIG_NEW"
        fi

        IBM_CONFIG=$IBM_CONFIG_NEW

        IBM_APPS_ROOT_NEW="$IPTV_ROOT/${IBM_APPS_ROOT##*/}"

        if [ -d "$IBM_APPS_ROOT" ] && [ ! -d "$IBM_APPS_ROOT_NEW" ]
        then
            mv "$IBM_APPS_ROOT" "$IPTV_ROOT/"
        fi

        IBM_APPS_ROOT=$IBM_APPS_ROOT_NEW
    fi

    if [ "${1:-}" == "v2" ] 
    then
        v2ray_name="v2ray"
        v2ray_package_name="v2ray"
        tls_name="TLS"
        V2CTL_FILE="$IBM_APPS_ROOT/ibm_v2ray/v2ctl"
        V2_CONFIG="$IBM_APPS_ROOT/ibm_v2ray/config.json"
        IbmV2rayMenu
    elif [ "${1:-}" == "x" ] 
    then
        v2ray_name="xray"
        v2ray_package_name="Xray"
        tls_name="XTLS"
        V2CTL_FILE="$IBM_APPS_ROOT/ibm_xray/xray"
        V2_CONFIG="$IBM_APPS_ROOT/ibm_xray/config.json"
        IbmV2rayMenu
    elif [ "${1:-}" == "cron" ] 
    then
        IbmCfAppCronExec
    else
        IbmCfMenu
    fi
    exit 0
elif [ "$self" == "cf" ] || [ "$self" == "cf.sh" ]
then
    ShFileCheck

    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"

    if [ ! -e "$JQ_FILE" ] 
    then
        DepsCheck
        JQInstall
    fi

    if [ -d "$IPTV_ROOT" ]
    then
        CF_CONFIG_NEW="$IPTV_ROOT/${CF_CONFIG##*/}"
        if [ -e "$CF_CONFIG" ] && [ ! -e "$CF_CONFIG_NEW" ]
        then
            mv "$CF_CONFIG" "$CF_CONFIG_NEW"
        fi
        CF_CONFIG=$CF_CONFIG_NEW

        CF_WORKERS_ROOT_NEW="$IPTV_ROOT/${CF_WORKERS_ROOT##*/}"
        if [ -d "$CF_WORKERS_ROOT" ] && [ ! -d "$CF_WORKERS_ROOT_NEW" ]
        then
            mv "$CF_WORKERS_ROOT" "$IPTV_ROOT/"
        fi
        CF_WORKERS_ROOT=$CF_WORKERS_ROOT_NEW

        IBM_CONFIG_NEW="$IPTV_ROOT/${IBM_CONFIG##*/}"
        if [ -e "$IBM_CONFIG" ] && [ ! -e "$IBM_CONFIG_NEW" ]
        then
            mv "$IBM_CONFIG" "$IBM_CONFIG_NEW"
        fi
        IBM_CONFIG=$IBM_CONFIG_NEW

        CF_WORKERS_FILE_NEW="$CF_WORKERS_ROOT/${CF_WORKERS_FILE##*/}"
        if [ -e "$CF_WORKERS_FILE" ] && [ ! -e "$CF_WORKERS_FILE_NEW" ]
        then
            mv "$CF_WORKERS_FILE" "$CF_WORKERS_FILE_NEW"
        fi
        CF_WORKERS_FILE=$CF_WORKERS_FILE_NEW
    fi

    cf_use_api=1

    if [ "${1:-}" == "w" ] 
    then
        CloudflareWorkersMenu
    else
        CloudflarePartnerMenu
    fi
    exit 0
elif [ "$self" == "or" ] || [ "$self" == "or.sh" ]
then
    ShFileCheck

    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"

    nginx_prefix="/usr/local/openresty/nginx"
    nginx_name="openresty"
    nginx_ctl="or"
    NGINX_FILE="$nginx_prefix/sbin/nginx"

    if [ ! -s "/etc/systemd/system/$nginx_name.service" ] && [ -d "$nginx_prefix" ]
    then
        echo "[Unit]
Description=$nginx_name
After=syslog.target network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target

[Service]
Type=forking
PIDFile=$nginx_prefix/logs/nginx.pid
ExecStartPre=$nginx_prefix/sbin/nginx -t
ExecStart=$nginx_prefix/sbin/nginx
ExecStartPost=/bin/sleep 0.1
ExecReload=$nginx_prefix/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT \$MAINPID
PrivateTmp=true

[Install]
WantedBy=multi-user.target
" > /etc/systemd/system/$nginx_name.service
        $NGINX_FILE -s stop 2> /dev/null || true
        systemctl daemon-reload
        systemctl enable "$nginx_name"
        systemctl start "$nginx_name"
    fi

    Println "  openresty 管理面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 安装
  ${green}2.${normal} 卸载
  ${green}3.${normal} 升级
————————————
  ${green}4.${normal} 查看域名
  ${green}5.${normal} 添加域名
  ${green}6.${normal} 修改域名
  ${green}7.${normal} 开关域名
  ${green}8.${normal} 查看本地
  ${green}9.${normal} 修改本地
————————————
 ${green}10.${normal} 状态
 ${green}11.${normal} 开关
 ${green}12.${normal} 重启
————————————
 ${green}13.${normal} 删除域名
 ${green}14.${normal} 日志切割
————————————
 ${green}15.${normal} 安装 nodejs
 ${green}16.${normal} 识别 cloudflare/ibm ip

 $tip 输入: or 打开面板

"
    read -p "`gettext \"输入序号\"` [1-16]: " openresty_num
    case "$openresty_num" in
        1) 
            if [ -d "$nginx_prefix" ] 
            then
                Println "$error openresty 已经存在 !\n" && exit 1
            fi

            echo
            AskIfContinue n "`gettext \"因为是编译 openresty, 耗时会很长, 是否继续\"`"

            OpenrestyInstall
            Println "$info openresty 安装完成\n"
        ;;
        2) 
            NginxUninstall
        ;;
        3) 
            NginxUpdate
        ;;
        4) 
            NginxListDomain
        ;;
        5) 
            NginxAddDomain
        ;;
        6) 
            NginxConfigDomain
        ;;
        7) 
            NginxToggleDomain
        ;;
        8) 
            NginxListLocalhost
        ;;
        9) 
            NginxConfigLocalhost
        ;;
        10) 
            NginxViewStatus
        ;;
        11) NginxToggle
        ;;
        12) 
            NginxRestart
        ;;
        13) 
            NginxDeleteDomain
        ;;
        14) 
            NginxLogRotate
        ;;
        15)
            [ ! -d "$IPTV_ROOT" ] && Println "$error 请先输入 tv 安装 !\n" && exit 1
            if [[ ! -x $(command -v node) ]] || [[ ! -x $(command -v npm) ]] 
            then
                NodejsInstall
            fi
            if [ ! -e "$NODE_ROOT/index.js" ] 
            then
                if [[ -x $(command -v node) ]] && [[ -x $(command -v npm) ]] 
                then
                    NodejsConfig
                else
                    Println "$error nodejs 安装发生错误\n" && exit 1
                fi
            else
                Println "$error nodejs 配置已存在\n" && exit 1
            fi
        ;;
        16)
            NginxUpdateCFIBMip
        ;;
        *) Println "$error $i18n_input_correct_number [1-16]\n"
        ;;
    esac
    exit 0
elif [ "$self" == "nx" ] || [ "$self" == "nx.sh" ]
then
    ShFileCheck

    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"

    nginx_prefix="/usr/local/nginx"
    nginx_name="nginx"
    nginx_ctl="nx"
    NGINX_FILE="$nginx_prefix/sbin/nginx"

    if [ ! -s "/etc/systemd/system/$nginx_name.service" ] && [ -d "$nginx_prefix" ]
    then
        echo "[Unit]
Description=$nginx_name
After=syslog.target network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target

[Service]
Type=forking
PIDFile=$nginx_prefix/logs/nginx.pid
ExecStartPre=$nginx_prefix/sbin/nginx -t
ExecStart=$nginx_prefix/sbin/nginx
ExecStartPost=/bin/sleep 0.1
ExecReload=$nginx_prefix/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT \$MAINPID
PrivateTmp=true

[Install]
WantedBy=multi-user.target
" > /etc/systemd/system/$nginx_name.service
        $NGINX_FILE -s stop 2> /dev/null || true
        systemctl daemon-reload
        systemctl enable "$nginx_name"
        systemctl start "$nginx_name"
    fi

    Println "  nginx 管理面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 安装
  ${green}2.${normal} 卸载
  ${green}3.${normal} 升级
————————————
  ${green}4.${normal} 查看域名
  ${green}5.${normal} 添加域名
  ${green}6.${normal} 修改域名
  ${green}7.${normal} 开关域名
  ${green}8.${normal} 查看本地
  ${green}9.${normal} 修改本地
————————————
 ${green}10.${normal} 状态
 ${green}11.${normal} 开关
 ${green}12.${normal} 重启
————————————
 ${green}13.${normal} 删除域名
 ${green}14.${normal} 日志切割
————————————
 ${green}15.${normal} 安装 nodejs
 ${green}16.${normal} 安装 pdf2htmlEX
 ${green}17.${normal} 安装 tesseract
 ${green}18.${normal} 安装 postfix
 ${green}19.${normal} 识别 cloudflare/ibm ip

 $tip 输入: nx 打开面板

"
    read -p "`gettext \"输入序号\"` [1-19]: " nginx_num
    case "$nginx_num" in
        1) 
            if [ -d "$nginx_prefix" ] 
            then
                Println "$error nginx 已经存在 !\n" && exit 1
            fi

            echo
            AskIfContinue n "`gettext \"因为是编译 nginx, 耗时会很长, 是否继续\"`"

            NginxInstall
            Println "$info nginx 安装完成\n"
        ;;
        2) 
            NginxUninstall
        ;;
        3) 
            NginxUpdate
        ;;
        4) 
            NginxListDomain
        ;;
        5) 
            NginxAddDomain
        ;;
        6) 
            NginxConfigDomain
        ;;
        7) 
            NginxToggleDomain
        ;;
        8) 
            NginxListLocalhost
        ;;
        9) 
            NginxConfigLocalhost
        ;;
        10) 
            NginxViewStatus
        ;;
        11) NginxToggle
        ;;
        12) 
            NginxRestart
        ;;
        13) 
            NginxDeleteDomain
        ;;
        14) 
            NginxLogRotate
        ;;
        15)
            [ ! -d "$IPTV_ROOT" ] && Println "$error 请先输入 tv 安装 !\n" && exit 1
            if [[ ! -x $(command -v node) ]] || [[ ! -x $(command -v npm) ]] 
            then
                NodejsInstall
            fi
            if [ ! -e "$NODE_ROOT/index.js" ] 
            then
                if [[ -x $(command -v node) ]] && [[ -x $(command -v npm) ]] 
                then
                    NodejsConfig
                else
                    Println "$error nodejs 安装发生错误\n" && exit 1
                fi
            else
                Println "$error nodejs 配置已存在\n" && exit 1
            fi
        ;;
        16)
            if [[ ! -x $(command -v pdf2htmlEX) ]] 
            then
                echo
                AskIfContinue n "`gettext \"因为是编译 pdf2htmlEX, 耗时会很长, 是否继续\"`"
                Pdf2htmlInstall
                Println "$info pdf2htmlEX 安装完成, 输入 source /etc/profile 可立即使用\n"
            else
                Println "$error pdf2htmlEX 已存在!\n"
            fi
        ;;
        17)
            if [[ ! -x $(command -v tesseract) ]] 
            then
                DepsCheck
                echo
                if [ "$release" == "ubu" ] 
                then
                    add-apt-repository ppa:alex-p/tesseract-ocr -y
                    AptUpdate
                    apt-get -y install tesseract
                elif [ "$release" == "deb" ] 
                then
                    Println "$info 参考 https://notesalexp.org/tesseract-ocr/ ...\n"
                else
                    Println "$info 参考 https://tesseract-ocr.github.io/tessdoc/Home.html ...\n"
                fi
            else
                Println "$error tesseract 已存在!\n"
            fi
        ;;
        18)
            if [[ ! -x $(command -v postfix) ]] 
            then
                ReleaseCheck
                Spinner "安装 postfix" PostfixInstall
            else
                echo
                AskIfContinue y "`gettext \"postfix 已存在, 是否重新设置 smtp\"`"
            fi
            echo
            inquirer text_input "请输入 smtp 地址 (比如 hwsmtp.exmail.qq.com) : " smtp_address "$i18n_cancel"
            ExitOnCancel smtp_address
            echo
            inquirer text_input "请输入 smtp 端口 (比如 465) : " smtp_port "$i18n_cancel"
            ExitOnCancel smtp_port
            echo
            inquirer text_input "请输入 smtp 邮箱 : " smtp_email "$i18n_cancel"
            ExitOnCancel smtp_email
            echo
            inquirer text_input "请输入 smtp 密码 : " smtp_pass "$i18n_cancel"
            ExitOnCancel smtp_pass
            hostname=$(hostname -f)
            sed -i "0,/.*myhostname = .*/s//myhostname = $hostname/" /etc/postfix/main.cf
            sed -i "0,/.*relayhost = .*/s//relayhost = [$smtp_address]:$smtp_port/" /etc/postfix/main.cf
            options=( 
                smtp_tls_security_level=encrypt
                smtp_tls_wrappermode=yes
                smtp_sasl_auth_enable=yes
                smtp_sasl_security_options=noanonymous
                smtp_sasl_password_maps=hash:/etc/postfix/sasl_passwd
                smtp_generic_maps=hash:/etc/postfix/generic
            )
            Println "$info 设置 postfix ..."
            echo "[$smtp_address]:$smtp_port $smtp_email:$smtp_pass" > /etc/postfix/sasl_passwd
            postmap /etc/postfix/sasl_passwd
            echo "$USER@$hostname $smtp_email" > /etc/postfix/generic
            postmap /etc/postfix/generic
            for option in "${options[@]}"
            do
                if grep -q "${option%=*} = " < /etc/postfix/main.cf
                then
                    sed -i "0,/.*${option%=*} = .*/s//${option%=*} = ${option#*=}/" /etc/postfix/main.cf
                elif grep -q "${option%=*}=" < /etc/postfix/main.cf 
                then
                    sed -i "0,/.*${option%=*}=.*/s//${option%=*}=${option#*=}/" /etc/postfix/main.cf
                else
                    echo "${option//=/ = }" >> /etc/postfix/main.cf
                fi
            done
            if ! grep -q "$USER:" < /etc/aliases
            then
                echo "$USER: $smtp_email" >> /etc/aliases
                newaliases
            fi
            if [[ $(ps --no-headers -o comm 1) == "systemd" ]] 
            then
                systemctl restart postfix
            else
                service postfix restart
            fi
            Println "$info smtp 设置成功\n"
        ;;
        19)
            NginxUpdateCFIBMip
        ;;
        *) Println "$error $i18n_input_correct_number [1-19]\n"
        ;;
    esac
    exit 0
elif [ "$self" == "v2" ] || [ "$self" == "v2.sh" ] || [ "$self" == "V2.sh" ] || [ "$self" == "x" ] || [ "$self" == "x.sh" ] || [ "$self" == "xray.sh" ]
then
    ShFileCheck
    [ ! -d "$IPTV_ROOT" ] && JQ_FILE="/usr/local/bin/jq"
    v2ray_sh="v2"
    v2ray_name="v2ray"
    tls_name="TLS"

    if [ "$self" == "x" ] || [ "$self" == "x.sh" ] || [ "$self" == "xray.sh" ]
    then
        v2ray_sh="x"
        v2ray_name="xray"
        tls_name="XTLS"
        V2_FILE="/usr/local/bin/x"
        V2_LINK="https://raw.githubusercontent.com/XTLS/Xray-install/main/install-release.sh"
        V2_LINK_BACKUP="$FFMPEG_MIRROR_LINK/xray_install-release.sh"
        V2CTL_FILE="/usr/local/bin/xray"
        V2_CONFIG="/usr/local/etc/xray/config.json"
    elif [ -d "/etc/v2ray/" ] 
    then
        systemctl disable v2ray.service --now > /dev/null 2> /dev/null || true
        rm -rf /usr/bin/v2ray/
        rm -f /etc/systemd/system/v2ray.service
        rm -f /lib/systemd/system/v2ray.service
        rm -f /etc/init.d/v2ray
        mv /etc/v2ray/ /usr/local/etc/
        if ! grep -q "v2ray:" < "/etc/passwd"
        then
            if grep -q '\--group ' < <(adduser --help)
            then
                adduser v2ray --system --group --no-create-home > /dev/null
            else
                adduser v2ray --system --no-create-home > /dev/null
            fi
            usermod -s /usr/sbin/nologin v2ray
        fi
        mkdir -p /var/log/v2ray/
        [ ! -e "/var/log/v2ray/error.log" ] && printf '%s' "" > /var/log/v2ray/error.log
        chown -R v2ray:v2ray /var/log/v2ray/
        chown -R v2ray:v2ray /usr/local/share/v2ray/
        V2rayUpdate
        systemctl enable v2ray
        systemctl start v2ray
    fi

    case $* in
        "e") 
            [ ! -e "$V2_CONFIG" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            vim "$V2_CONFIG" && exit 0
        ;;
        *) 
        ;;
    esac

    if { [ -d "/usr/local/openresty" ] && [ ! -d "/usr/local/nginx" ]; } || { [ -s "/usr/local/openresty/nginx/logs/nginx.pid" ] && kill -0 "$(< "/usr/local/openresty/nginx/logs/nginx.pid")" 2> /dev/null ; }
    then
        nginx_prefix="/usr/local/openresty/nginx"
        nginx_name="openresty"
        nginx_ctl="or"
    elif { [ -d "/usr/local/nginx" ] && [ ! -d "/usr/local/openresty" ]; } || { [ -s "/usr/local/nginx/logs/nginx.pid" ] && kill -0 "$(< "/usr/local/nginx/logs/nginx.pid")" 2> /dev/null ; }
    then
        nginx_prefix="/usr/local/nginx"
        nginx_name="nginx"
        nginx_ctl="nx"
    else
        nginx_prefix="/usr/local/nginx"
        nginx_name="nginx"
        nginx_ctl="nx"
    fi
    NGINX_FILE="$nginx_prefix/sbin/nginx"

    Println "  $v2ray_name 管理面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 安装
  ${green}2.${normal} 升级
  ${green}3.${normal} 配置域名
  ${green}4.${normal} 查看状态
————————————
  ${green}5.${normal} 查看入站
  ${green}6.${normal} 添加入站
  ${green}7.${normal} 添加入站账号
————————————
  ${green}8.${normal} 查看出站
  ${green}9.${normal} 添加出站
 ${green}10.${normal} 添加出站账号
————————————
 ${green}11.${normal} 查看DNS
 ${green}12.${normal} 设置DNS
————————————
 ${green}13.${normal} 查看路由
 ${green}14.${normal} 设置路由
————————————
 ${green}15.${normal} 查看策略
 ${green}16.${normal} 设置策略
————————————
 ${green}17.${normal} 查看流量
 ${green}18.${normal} 重置流量
————————————
 ${green}19.${normal} 查看反向代理
 ${green}20.${normal} 设置反向代理
————————————
 ${green}21.${normal} 删除入站
 ${green}22.${normal} 删除入站账号
 ${green}23.${normal} 删除出站
 ${green}24.${normal} 删除出站账号
————————————
 ${green}25.${normal} 开关
 ${green}26.${normal} 重启

 $tip 输入: $v2ray_sh 打开面板
"
    read -p "`gettext \"输入序号\"` [1-26]: " v2ray_num
    case $v2ray_num in
        1) 
            V2rayInstall
        ;;
        2) 
            V2rayUpdate
            systemctl restart $v2ray_name
        ;;
        3) 
            V2rayConfigUpdate
            V2rayConfigDomain
        ;;
        4) 
            V2rayStatus
        ;;
        5) 
            V2rayConfigUpdate
            V2rayListInboundAccounts
            V2rayListInboundAccountLink
        ;;
        6)
            V2rayConfigUpdate
            V2rayAddInbound
        ;;
        7)
            V2rayConfigUpdate
            V2rayAddInboundAccount
        ;;
        8)
            V2rayConfigUpdate
            V2rayListOutboundAccounts
        ;;
        9)
            V2rayConfigUpdate
            V2rayAddOutbound
        ;;
        10)
            V2rayConfigUpdate
            V2rayAddOutboundAccount
        ;;
        11)
            V2rayConfigUpdate
            V2rayListDns
        ;;
        12)
            V2rayConfigUpdate
            V2raySetDns
        ;;
        13)
            V2rayConfigUpdate
            V2rayListRouting
        ;;
        14)
            V2rayConfigUpdate
            V2raySetRouting
        ;;
        15)
            V2rayConfigUpdate
            V2rayListPolicy
        ;;
        16)
            V2rayConfigUpdate
            V2raySetPolicy
        ;;
        17)
            V2rayConfigUpdate
            V2rayListStats
        ;;
        18)
            V2rayConfigUpdate
            V2rayResetStats
        ;;
        19)
            V2rayConfigUpdate
            V2rayListReverse
        ;;
        20)
            V2rayConfigUpdate
            V2raySetReverse
        ;;
        21)
            V2rayConfigUpdate
            V2rayDeleteInbound
        ;;
        22)
            V2rayConfigUpdate
            V2rayDeleteInboundAccount
        ;;
        23)
            V2rayConfigUpdate
            V2rayDeleteOutbound
        ;;
        24)
            V2rayConfigUpdate
            V2rayDeleteOutboundAccount
        ;;
        25) 
            if [ ! -e "$V2_CONFIG" ] 
            then
                Println "$error $v2ray_name 未安装...\n" && exit 1
            fi
            echo
            if [[ $(systemctl is-active $v2ray_name) == "active" ]]
            then
                AskIfContinue y "`eval_gettext \"\\\$v2ray_name 正在运行, 是否关闭\"`"

                systemctl stop $v2ray_name > /dev/null 2>&1
                Println "$info $v2ray_name 已关闭\n"
            else
                AskIfContinue y "`eval_gettext \"\\\$v2ray_name 未运行, 是否开启\"`"

                systemctl start $v2ray_name > /dev/null 2>&1
                Println "$info $v2ray_name 已开启\n"
            fi
        ;;
        26) 
            if [ ! -e "$V2_CONFIG" ] 
            then
                Println "$error $v2ray_name 未安装...\n" && exit 1
            fi
            systemctl restart $v2ray_name > /dev/null 2>&1
            Println "$info $v2ray_name 已重启\n"
        ;;
        *) Println "$error $i18n_input_correct_number [1-26]\n"
        ;;
    esac
    exit 0
elif [ "$self" == "cx" ] || [ "$self" == "cx.sh" ]
then
    [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1

    Println "  Xtream Codes 面板 ${normal}

${green}1.${normal} 查看账号
${green}2.${normal} 添加账号
${green}3.${normal} 批量检测
${green}4.${normal} 测试账号
${green}5.${normal} 获取账号
————————————
${green}6.${normal} 查看 mac 地址
${green}7.${normal} 添加 mac 地址
${green}8.${normal} 浏览频道

"
    read -p "`gettext \"输入序号\"` [1-8]: " xtream_codes_num

    case $xtream_codes_num in
        1) 
            XtreamCodesListAcc
        ;;
        2) 
            XtreamCodesAddAccount
            XtreamCodesList
        ;;
        3) 
            [ ! -s "$XTREAM_CODES" ] && Println "$error 没有账号 !\n" && exit 1

            echo
            AskIfContinue n "`gettext \"耗时可能很长, 是否继续\"`"

            Println "$info 检测中..."
            printf -v now '%(%m-%d-%H:%M:%S)T' -1

            cp -f "$XTREAM_CODES" "${XTREAM_CODES}_$now"

            IFS=" " read -r m_ip m_domains m_accounts < <(awk '$1 {a=a $1",";b=b $2",";$1=$2="";c=c substr($0,3)","} END {print a,b,c}' "$XTREAM_CODES")
            IFS="," read -r -a new_domains <<< "$m_domains"
            IFS="," read -r -a new_accounts <<< "$m_accounts"

            result=""

            for((i=0;i<${#new_domains[@]};i++));
            do
                IFS="|" read -r -a domains <<< "${new_domains[i]}"
                IFS=" " read -r -a accounts <<< "${new_accounts[i]}"
                for domain in "${domains[@]}"
                do
                    ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || continue
                    for account in "${accounts[@]}"
                    do
                        [ -n "$result" ] && result="$result\n"
                        result="$result$ip $domain $account"
                    done
                done
            done

            echo -e "$result" > "$XTREAM_CODES_EXAM"

            verify=1

            XtreamCodesList

            Println "$info 账号检测完成\n"
        ;;
        4) 
            XtreamCodesTestAcc
        ;;
        5) 
            Println "$info 稍等...\n"

            if [ -s "$XTREAM_CODES" ] 
            then
                printf -v now '%(%m-%d-%H:%M:%S)T' -1
                cp -f "$XTREAM_CODES" "${XTREAM_CODES}_$now"
            fi

            IFS=" " read -r m_ip m_domains m_accounts < <(curl -s -Lm 20 $XTREAM_CODES_LINK|awk '$1 {a=a $1",";b=b $2",";$1=$2="";c=c substr($0,3)","} END {print a,b,c}')
            IFS="," read -r -a new_domains <<< "$m_domains"
            IFS="," read -r -a new_accounts <<< "$m_accounts"

            result=""

            for((i=0;i<${#new_domains[@]};i++));
            do
                IFS="|" read -r -a domains <<< "${new_domains[i]}"
                IFS=" " read -r -a accounts <<< "${new_accounts[i]}"
                for domain in "${domains[@]}"
                do
                    ip=$(getent ahosts "${domain%%:*}" | awk '{ print $1 ; exit }') || continue
                    for account in "${accounts[@]}"
                    do
                        [ -n "$result" ] && result="$result\n"
                        result="$result$ip $domain $account"
                    done
                done
            done

            [ -z "$result" ] && Println "$error 暂时无法连接, 请稍后再试...\n" && exit 1

            echo -e "$result" >> "$XTREAM_CODES_EXAM"

            XtreamCodesList

            Println "$info 账号添加成功\n"
        ;;
        6) 
            XtreamCodesListMac
        ;;
        7) 
            XtreamCodesAddMac
            if [ "$add_mac_success" -eq 1 ] 
            then
                XtreamCodesList mac
                Println "$info mac 添加成功!\n"
            fi
        ;;
        8) 
            XtreamCodesListChnls
        ;;
        *) Println "$error $i18n_input_correct_number [1-8]\n"
        ;;
    esac
    exit 0
elif [ "$self" == "arm" ] || [ "$self" == "arm.sh" ]
then
    if [[ ! -x $(command -v armbian-config) ]] 
    then
        Println "$error 不是 Armbian 系统\n"
        exit 1
    fi

    ShFileCheck

    JQ_FILE="/usr/local/bin/jq"

    Println "  Armbian 管理面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 更改 apt 源
  ${green}2.${normal} 修复 N1 dtb
————————————
  ${green}3.${normal} 安装 docker
  ${green}4.${normal} 安装/升级 dnscrypt
  ${green}5.${normal} 安装/升降级 openwrt
  ${green}6.${normal} 安装 openwrt-v2ray
————————————
  ${green}7.${normal} 切换 openwrt 语言
  ${green}8.${normal} 切换 v2ray/xray core
  ${green}9.${normal} 切换 配置文件
————————————
 ${green}10.${normal} 设置 docker 镜像加速
 ${green}11.${normal} 设置 vimrc
 ${green}12.${normal} 开关 edns0
 ${green}13.${normal} NAT 类型测试
 ${green}14.${normal} 更新脚本

"
    read -p "`gettext \"输入序号\"` [1-14]: " armbian_num

    case $armbian_num in
        1) 
            AptSetSources
        ;;
        2) 
            echo
            AskIfContinue n "`gettext \"适用于 斐讯 n1, apt upgrade 后需要重新修复, 是否继续\"`"

            if [ ! -d ~/Amlogic_s905-kernel-master ] 
            then
                if curl -L "$FFMPEG_MIRROR_LINK/Amlogic_s905-kernel-master.zip" -o ~/Amlogic_s905-kernel-master.zip 
                then
                    unzip Amlogic_s905-kernel-master.zip
                else
                    Println "$error 下载 Amlogic_s905-kernel-master.zip 发生错误, 请稍后再试\n"
                    exit 1
                fi
            fi

            cd ~/Amlogic_s905-kernel-master
            sed -i 's/interrupts = <29/interrupts = <25/' arch/arm64/boot/dts/amlogic/meson-gxl-s905d-p230.dts
            make defconfig
            make dtbs
            cp -f arch/arm64/boot/dts/amlogic/meson-gxl-s905d-phicomm-n1.dtb /boot/dtb/amlogic/meson-gxl-s905d-phicomm-n1.dtb
            Println "$info 修复成功\n"
        ;;
        3)
            if [[ -x $(command -v docker) ]] 
            then
                Println "$error docker 已经存在\n"
                exit 1
            fi
            if grep -q "docker-ce" < /etc/apt/sources.list
            then
                sed -i '/docker-ce/d' /etc/apt/sources.list
            fi
            if [ ! -f "/etc/apt/sources.list.d/docker.list" ] 
            then
                curl -fsSL http://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | apt-key add -
                echo "deb [arch=arm64] http://mirrors.ustc.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list
            fi
            apt-get update
            apt-get -y install docker-ce docker-ce-cli containerd.io
            Println "$info docker 安装成功\n"
        ;;
        4)
            if ! $JQ_FILE -V > /dev/null 2>&1
            then
                Spinner "编译安装 JQ, 耗时可能会很长" JQInstall
            fi
            if dnscrypt_version=$(curl -s -Lm 10 "$FFMPEG_MIRROR_LINK/dnscrypt.json" | $JQ_FILE -r '.tag_name') 
            then
                DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy)
                dnscrypt_version_old=${DNSCRYPT_ROOT##*-}
                if [[ $dnscrypt_version_old == "*" ]]
                then
                    Println "$tip 请确保已经将本机器用网线连接到主路由器的 LAN 口"
                    AskIfContinue n "`gettext \"是否继续\"`"

                    echo
                    inquirer text_input "请输入主路由器 ip : " eth0_gateway "$i18n_cancel"
                    ExitOnCancel eth0_gateway

                    Println "$tip 必须和主路由器 ip 在同一网段"
                    inquirer text_input "设置本机静态 ip : " eth0_ip "$i18n_cancel"
                    ExitOnCancel eth0_ip

                    Println "$info 下载 dnscrypt proxy ..."
                    if curl -L "$FFMPEG_MIRROR_LINK/dnscrypt/dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz" -o ~/dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz_tmp
                    then
                        Println "$info 设置 dnscrypt proxy ..."
                        cd ~
                        mv dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz_tmp dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz
                        tar zxf dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz
                        mv linux-arm64 dnscrypt-$dnscrypt_version
                        chown -R $USER:$USER dnscrypt-$dnscrypt_version
                        cd dnscrypt-$dnscrypt_version
                        cp -f example-dnscrypt-proxy.toml dnscrypt-proxy.toml

                        if [ ! -f "/etc/NetworkManager/system-connections/armbian.nmconnection" ] 
                        then
                            con=$(nmcli -t c s | grep eth0 | head -1)
                            nmcli connection modify "${con%%:*}" con-name armbian
                        fi

                        cp -f /etc/NetworkManager/system-connections/armbian.nmconnection ~/armbian.nmconnection-old

                        while IFS= read -r line 
                        do
                            if [[ $line =~ uuid= ]] 
                            then
                                etho_uuid=${line#*=}
                            elif [[ $line =~ timestamp= ]] 
                            then
                                eth0_timestamp=${line#*=}
                            elif [[ $line =~ mac-address= ]]
                            then
                                eth0_mac=${line#*=}
                                break
                            fi
                        done < "/etc/NetworkManager/system-connections/armbian.nmconnection"

                        echo "[connection]
id=armbian
uuid=$etho_uuid
type=ethernet
autoconnect=true
interface-name=eth0
permissions=
timestamp=${eth0_timestamp:-$(date +%s)}

[ethernet]
mac-address=${eth0_mac:-$(GetRandomMac)}
mac-address-blacklist=

[ipv4]
address1=$eth0_ip/24,$eth0_gateway
dns=127.0.0.1;
dns-priority=100
dns-search=
ignore-auto-dns=true
method=manual

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=ignore" > /etc/NetworkManager/system-connections/armbian.nmconnection

                        sed -i "0,/.*server_names = \[.*/s//server_names = ['alidns-doh']/" dnscrypt-proxy.toml
                        sed -i "0,/.*listen_addresses = \['127.0.0.1:53']/s//listen_addresses = ['127.0.0.1:53', '$eth0_ip:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" dnscrypt-proxy.toml
                        sed -i "0,/.*fallback_resolvers =.*/s//fallback_resolvers = ['114.114.114.114:53', '8.8.8.8:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*netprobe_address =.*/s//netprobe_address = '114.114.114.114:53'/" dnscrypt-proxy.toml

                        for((i=0;i<3;i++));
                        do
                            if ./dnscrypt-proxy -check > /dev/null 
                            then
                                break
                            elif [[ $i -eq 2 ]] 
                            then
                                cd ~
                                rm -rf dnscrypt-$dnscrypt_version
                                Println "$error 发生错误, 请重试\n"
                                exit 1
                            fi
                        done

                        apt-get -y --purge remove resolvconf > /dev/null

                        systemctl stop systemd-resolved
                        systemctl disable systemd-resolved
                        ./dnscrypt-proxy -service install > /dev/null
                        ./dnscrypt-proxy -service start > /dev/null

                        if ! grep -q "#allow-hotplug eth0" < /etc/network/interfaces
                        then
                            sed -i "0,/allow-hotplug eth0/s//#allow-hotplug eth0/" /etc/network/interfaces
                        fi
                        if ! grep -q "#no-auto-down eth0" < /etc/network/interfaces
                        then
                            sed -i "0,/no-auto-down eth0/s//#no-auto-down eth0/" /etc/network/interfaces
                        fi
                        if ! grep -q "#iface eth0 inet dhcp" < /etc/network/interfaces
                        then
                            sed -i "0,/iface eth0 inet dhcp/s//#iface eth0 inet dhcp/" /etc/network/interfaces
                        fi

                        nmcli connection reload
                        systemctl restart NetworkManager
                        Println "$info dnscrypt proxy 安装配置成功, 请重启 Armbian 后连接 IP: $eth0_ip\n"
                        nmcli con up armbian

                        # echo -e "nameserver 127.0.0.1\noptions edns0" > /etc/resolv.conf
                    else
                        Println "$error dnscrypt proxy 下载失败, 请重试\n"
                        exit 1
                    fi
                elif [[ $dnscrypt_version_old != "$dnscrypt_version" ]] 
                then
                    if [[ -x $(command -v docker) ]] && [[ -n $(docker container ls -a -f name=openwrt$ -q) ]]
                    then
                        Println "$tip 如果已经安装并运行旁路由 openwrt-v2ray, 建议先关闭旁路由 openwrt-v2ray"
                        AskIfContinue n "`gettext \"是否继续\"`"
                    fi

                    if curl -L "$FFMPEG_MIRROR_LINK/dnscrypt/dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz" -o ~/dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz_tmp
                    then
                        cd ~/dnscrypt-$dnscrypt_version_old
                        ./dnscrypt-proxy -service stop > /dev/null
                        ./dnscrypt-proxy -service uninstall > /dev/null
                        cd ~
                        mv dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz_tmp dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz
                        tar zxf dnscrypt-proxy-linux_arm64-$dnscrypt_version.tar.gz
                        mv linux-arm64 dnscrypt-$dnscrypt_version
                        cd dnscrypt-$dnscrypt_version
                        cp -f example-dnscrypt-proxy.toml dnscrypt-proxy.toml
                        eth0_ip=$(ip addr show eth0 | grep "inet\b" | awk '{print $2}' | cut -d/ -f1)
                        sed -i "0,/.*server_names = \[.*/s//server_names = ['alidns-doh']/" dnscrypt-proxy.toml
                        sed -i "0,/.*listen_addresses = \['127.0.0.1:53']/s//listen_addresses = ['127.0.0.1:53', '$eth0_ip:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" dnscrypt-proxy.toml
                        sed -i "0,/.*fallback_resolvers =.*/s//fallback_resolvers = ['114.114.114.114:53', '8.8.8.8:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*netprobe_address =.*/s//netprobe_address = '114.114.114.114:53'/" dnscrypt-proxy.toml
                        ./dnscrypt-proxy -service install > /dev/null
                        ./dnscrypt-proxy -service start > /dev/null
                        Println "$info dnscrypt proxy 升级成功\n"
                    else
                        Println "$error dnscrypt proxy 下载失败, 请重试\n"
                        exit 1
                    fi
                else
                    Println "$error dnscrypt proxy 已经是最新\n"
                fi
                if ! grep -q "options edns0" < /etc/resolv.conf
                then
                    echo "options edns0" >> /etc/resolv.conf
                    systemctl restart dnscrypt-proxy
                    chattr +i /etc/resolv.conf
                fi
            else
                Println "$error 无法连接服务器, 请稍后再试\n"
            fi
        ;;
        5)
            if [[ ! -x $(command -v docker) ]] 
            then
                Println "$error 请先安装 docker\n"
                exit 1
            fi

            DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy)
            dnscrypt_version_old=${DNSCRYPT_ROOT##*-}
            if [[ $dnscrypt_version_old == "*" ]] 
            then
                Println "$error 请先安装 dnscrypt proxy\n"
                exit 1
            fi

            if [[ $(systemctl is-active docker.service) == "inactive" ]] 
            then
                systemctl start docker
            fi

            echo
            openwrt_options=( '19.07.7' '19.07.6' '19.07.5' '19.07.4' '手动输入' )
            inquirer list_input "选择版本: " openwrt_options openwrt_ver

            if [ "$openwrt_ver" == "手动输入" ] 
            then
                echo
                inquirer text_input "输入版本号: " openwrt_ver "$i18n_cancel"
                ExitOnCancel openwrt_ver
            fi

            if grep -q "armvirt-64-$openwrt_ver" < <(docker container ls -a)
            then
                if [ -f /etc/NetworkManager/dispatcher.d/promisc.sh ] 
                then
                    printf '%s' '#!/usr/bin/env bash

interface=$1
event=$2

if [[ $event == "up" ]] && [[ $interface == "eth0" ]] 
then
  ip link set $interface promisc on
  echo "$interface received $event" | systemd-cat -p info -t dispatch_script
fi' > /etc/NetworkManager/dispatcher.d/90-promisc.sh

                    rm -f /etc/NetworkManager/dispatcher.d/promisc.sh
                    chmod +x /etc/NetworkManager/dispatcher.d/90-promisc.sh
                fi
                if grep -q "armvirt-64-$openwrt_ver" < <(docker container ls -f name=openwrt) 
                then
                    Println "$error 此版本 openwrt 已经在运行\n"
                    exit 1
                fi
                Println "$info 切换到版本 openwrt-armvirt-64-$openwrt_ver"
                action="switch"
            else
                Println "$info 安装 openwrt-armvirt-64-$openwrt_ver"
                action="install"
            fi

            if [ ! -f "/etc/NetworkManager/system-connections/armbian.nmconnection" ] 
            then
                con=$(nmcli -t c s | grep eth0 | head -1)
                nmcli connection modify "${con%%:*}" con-name armbian
                nmcli connection reload
            fi

            while IFS= read -r line 
            do
                if [[ $line =~ ^address1=([^/]+)/24,(.+) ]]
                then
                    eth0_ip=${BASH_REMATCH[1]}
                    eth0_gateway=${BASH_REMATCH[2]}
                    break
                fi
            done < "/etc/NetworkManager/system-connections/armbian.nmconnection"

            connected_ip=${SSH_CLIENT% *}
            connected_ip=${connected_ip// /:}
            armbian_ip=$(ss -taH|grep $connected_ip|awk '{print $4}')
            armbian_ip=${armbian_ip%:*}

            if [ "$armbian_ip" != "$eth0_ip" ] 
            then
                docker container start openwrt >/dev/null 2>&1
                Println "$error 请连接 IP: $eth0_ip 到 Armbian\n"
                exit 1
            fi

            Println "$tip openwrt 作为旁路由, 请确保已经将本机器用网线连接到主路由器的 LAN 口, 并且当前连接使用的网关是主路由的地址(可能需要手动设定)"
            Println "$tip 如果是升级, 注意备份原 openwrt 配置(系统 - 备份/还原)"
            AskIfContinue n "`gettext \"是否继续\"`"

            if ! ip addr show hMACvLAN >/dev/null 2>&1
            then
                Println "$tip 必须和主路由器 ip 在同一网段"
                inquirer text_input "设置虚拟接口 hMACvLAN 静态 ip : " hMACvLAN_ip "$i18n_cancel"
                ExitOnCancel hMACvLAN_ip

                Println "$tip 必须和主路由器 ip 在同一网段"
                inquirer text_input "设置 openwrt 静态 ip : " openwrt_ip "$i18n_cancel"
                ExitOnCancel openwrt_ip

                nmcli connection add type macvlan dev eth0 mode bridge ifname hMACvLAN autoconnect yes save yes > /dev/null
                nmcli connection modify macvlan-hMACvLAN con-name hMACvLAN

                while IFS= read -r line 
                do
                    if [[ $line =~ uuid= ]] 
                    then
                        hMACvLAN_uuid=${line#*=}
                        break
                    fi
                done < "/etc/NetworkManager/system-connections/hMACvLAN.nmconnection"

                echo "[connection]
id=hMACvLAN
uuid=$hMACvLAN_uuid
type=macvlan
interface-name=hMACvLAN
permissions=

[macvlan]
mode=2
parent=eth0

[ipv4]
address1=$hMACvLAN_ip/24,$openwrt_ip
dns=127.0.0.1;
dns-search=
ignore-auto-dns=true
method=manual
route-metric=50

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=ignore" > /etc/NetworkManager/system-connections/hMACvLAN.nmconnection
                nmcli connection reload
            else
                while IFS= read -r line 
                do
                    if [[ $line =~ ^address1=([^/]+)/24,(.+) ]] 
                    then
                        openwrt_ip=${BASH_REMATCH[2]}
                        break
                    fi
                done < "/etc/NetworkManager/system-connections/hMACvLAN.nmconnection"

                if [ -z "${openwrt_ip:-}" ] 
                then
                    Println "$tip 必须和主路由器 ip 在同一网段"
                    inquirer text_input "设置虚拟接口 hMACvLAN 静态 ip : " hMACvLAN_ip "$i18n_cancel"
                    ExitOnCancel hMACvLAN_ip

                    Println "$tip 必须和主路由器 ip 在同一网段"
                    inquirer text_input "设置 openwrt 静态 ip : " openwrt_ip "$i18n_cancel"
                    ExitOnCancel openwrt_ip

                    while IFS= read -r line 
                    do
                        if [[ $line =~ uuid= ]] 
                        then
                            hMACvLAN_uuid=${line#*=}
                        elif [[ $line =~ timestamp= ]] 
                        then
                            hMACvLAN_timestamp=${line#*=}
                            break
                        fi
                    done < "/etc/NetworkManager/system-connections/hMACvLAN.nmconnection"

                    echo "[connection]
id=hMACvLAN
uuid=$hMACvLAN_uuid
type=macvlan
interface-name=hMACvLAN
permissions=
timestamp=${hMACvLAN_timestamp:-$(date +%s)}

[macvlan]
mode=2
parent=eth0

[ipv4]
address1=$hMACvLAN_ip/24,$openwrt_ip
dns=127.0.0.1;
dns-search=
ignore-auto-dns=true
method=manual
route-metric=150

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=ignore" > /etc/NetworkManager/system-connections/hMACvLAN.nmconnection
                    nmcli connection reload
                fi
            fi

            if [[ -n $(docker container ls -a -f name=openwrt$ -q) ]] 
            then
                echo
                inquirer list_input "是否重新设置 openwrt 静态 IP" ny_options change_openwrt_ip_yn
                if [[ $change_openwrt_ip_yn == "$i18n_yes" ]] 
                then
                    Println "$tip 必须和主路由器 ip 在同一网段"
                    inquirer text_input "设置 openwrt 静态 ip : " openwrt_ip "$i18n_cancel"
                    if [ "$openwrt_ip" == "$i18n_cancel" ]
                    then
                        if [[ -z $(docker container ls -f name=openwrt$ -q) ]] 
                        then
                            docker container start openwrt >/dev/null 2>&1 || true
                        fi
                        Println "$i18n_canceled...\n"
                        exit 1
                    fi
                    sed -i "0,/address1=\(.*\),.*/s//address1=\1,$openwrt_ip/" /etc/NetworkManager/system-connections/hMACvLAN.nmconnection
                    nmcli connection reload
                fi
                Println "$info 重启 hMACvLAN ..."
                nmcli connection modify hMACvLAN ipv4.route-metric 150 > /dev/null
                nmcli con down hMACvLAN > /dev/null 2>&1 || true
                nmcli con up hMACvLAN > /dev/null
                sleep 3
                openwrt_ver_old=$(docker inspect --format='{{.Config.Image}}' openwrt)
                openwrt_ver_old=${openwrt_ver_old#*:}
                if [[ -n $(docker container ls -f name=openwrt$ -q) ]] 
                then
                    docker rename openwrt openwrt-$openwrt_ver_old
                    docker container stop openwrt-$openwrt_ver_old >/dev/null 2>&1
                    Println "$info 网络马上会中断, 请退出并等待 30秒 后重新连接 armbian 后重复当前步骤 ...\n"
                    exit 1
                else
                    docker rename openwrt openwrt-$openwrt_ver_old
                fi
            fi

            if [ ! -s "/etc/docker/daemon.json" ] 
            then
                printf '%s' "{}" > /etc/docker/daemon.json
            fi

            if ! $JQ_FILE -V > /dev/null 2>&1
            then
                Spinner "编译安装 JQ, 耗时可能会很长" JQInstall
            fi

            jq_path='["dns"]'
            JQ replace /etc/docker/daemon.json '["'"$eth0_ip"'","8.8.8.8"]'

            if ! docker network inspect macnet >/dev/null 2>&1
            then
                docker network create -d macvlan \
                    --subnet=$eth0_ip/24 \
                    --gateway=$eth0_gateway \
                    -o parent=eth0 macnet
            fi

            if [ ! -s /etc/NetworkManager/dispatcher.d/90-promisc.sh ] 
            then
                printf '%s' '#!/usr/bin/env bash

interface=$1
event=$2

if [[ $event == "up" ]] && [[ $interface == "eth0" ]] 
then
  ip link set $interface promisc on
  echo "$interface received $event" | systemd-cat -p info -t dispatch_script
fi' > /etc/NetworkManager/dispatcher.d/90-promisc.sh

                rm -f /etc/NetworkManager/dispatcher.d/promisc.sh
                chmod +x /etc/NetworkManager/dispatcher.d/90-promisc.sh
            fi

            ip link set eth0 promisc on

            if [ "$action" == "switch" ] 
            then
                docker rename openwrt-armvirt-64-$openwrt_ver openwrt
                docker container start openwrt >/dev/null
            else
                Println "$info 下载 armvirt-64-$openwrt_ver ..."
                docker import $FFMPEG_MIRROR_LINK/openwrt/releases/$openwrt_ver/targets/armvirt/64/openwrt-$openwrt_ver-armvirt-64-default-rootfs.tar.gz openwrtorg/rootfs:armvirt-64-$openwrt_ver

                openwrt_network="
config interface 'loopback'
        option ifname 'lo'
        option proto 'static'
        option ipaddr '127.0.0.1'
        option netmask '255.0.0.0'

config interface 'lan'
        option ifname 'eth0'
        option proto 'static'
        option netmask '255.255.255.0'
        option ipaddr '$openwrt_ip'
        option gateway '$eth0_gateway'
        list dns '$eth0_ip'"

                docker run -d \
                    --restart unless-stopped \
                    --network macnet \
                    --privileged \
                    --name openwrt \
                    openwrtorg/rootfs:armvirt-64-$openwrt_ver /sbin/init

                Println "$info openwrt 启动中..."
                until [[ $(docker inspect --format='{{.State.Status}}' openwrt) == "running" ]]
                do
                    sleep 1
                done

                docker exec -it openwrt /bin/ash -c "
                sed -i 's_REJECT_ACCEPT_' /etc/config/firewall
                sed -i '/option syn_flood/d' /etc/config/firewall
                sed -i '/config forwarding/,+2d' /etc/config/firewall
                echo \"${openwrt_network}\" > /etc/config/network
                /etc/init.d/network restart
                sed -i '/option ra_management/a \\\tlist dhcp_option 6,$openwrt_ip' /etc/config/dhcp
                /etc/init.d/dnsmasq restart
                "
            fi

            Println "$info openwrt ${green}旁路由${normal} 安装成功, 地址: $openwrt_ip, 是 ${red}主路由${normal} 负责(拨号)联网\n"
            Println "$tip 如需将 ${green}旁路由${normal} 作为 dhcp 服务器 请将 ${red}主路由${normal} br-lan 接口网关设置为 $openwrt_ip, 否则请关闭 ${green}旁路由${normal} lan 口的 dhcp 功能(此种情况客户端需手动设定网关为 $openwrt_ip)\n"

            nmcli connection modify hMACvLAN ipv4.route-metric 50 > /dev/null
            nmcli con down hMACvLAN > /dev/null 2>&1 || true
            nmcli con up hMACvLAN > /dev/null
        ;;
        6)
            if ! docker inspect openwrt > /dev/null 2>&1
            then
                Println "$error 请先安装或运行 openwrt\n"
                exit 1
            fi

            docker exec -it openwrt /bin/ash -c "
            if ! opkg list-installed | grep -q v2ray
            then
                sed -i 's_downloads.openwrt.org_${FFMPEG_MIRROR_LINK#*\/\/}/openwrt_' /etc/opkg/distfeeds.conf
                if ! grep -q kuoruan < /etc/opkg/customfeeds.conf
                then
                    wget -O kuoruan-public.key $FFMPEG_MIRROR_LINK/openwrt-v2ray/packages/public.key
                    opkg-key add kuoruan-public.key
                    echo \"src/gz kuoruan_packages $FFMPEG_MIRROR_LINK/openwrt-v2ray/packages/releases/\$(. /etc/openwrt_release ; echo \$DISTRIB_ARCH)\" >> /etc/opkg/customfeeds.conf
                    echo \"src/gz kuoruan_universal $FFMPEG_MIRROR_LINK/openwrt-v2ray/packages/releases/all\" >> /etc/opkg/customfeeds.conf
                fi
                opkg update
                opkg install zoneinfo-asia
                opkg install luci luci-base luci-compat
                opkg install kmod-tcp-bbr
                if ! test -e /etc/sysctl.d/12-tcp-bbr.conf || ! grep -q default_qdisc < /etc/sysctl.d/12-tcp-bbr.conf
                then
                    echo \"net.core.default_qdisc=fq\" >> /etc/sysctl.d/12-tcp-bbr.conf
                    sysctl -p
                fi
                opkg remove dnsmasq
                opkg install v2ray-core
                opkg install luci-app-v2ray
                opkg install luci-i18n-v2ray-zh-cn
            fi
            "

            Println "$info 重启 openwrt ..."
            docker container restart openwrt > /dev/null

            Println "$info openwrt-v2ray 安装成功\n"
        ;;
        7)
            if ! docker inspect openwrt > /dev/null 2>&1
            then
                Println "$error 请先安装或运行 openwrt\n"
                exit 1
            fi

            echo
            lang_options=( '简体中文' '繁体中文' '英文' )
            inquirer list_input "选择界面语言" lang_options lang

            if [ "$lang" == "简体中文" ] 
            then
                lang="zh-cn"
            elif [ "$lang" == "繁体中文" ] 
            then
                lang="zh-tw"
            else
                lang="en"
            fi

            docker exec -it openwrt /bin/ash -c "
            if ! opkg list-installed | grep -q luci-i18n-base-$lang
            then
                sed -i 's_downloads.openwrt.org_${FFMPEG_MIRROR_LINK#*\/\/}/openwrt_' /etc/opkg/distfeeds.conf
                opkg update
                opkg install luci-i18n-base-$lang
            fi
            sed -i '/option lang/c \\\toption lang $lang' /etc/config/luci
            "

            Println "$info 界面语言切换成功\n"
        ;;
        8)
            if ! docker inspect openwrt > /dev/null 2>&1
            then
                Println "$error 请先安装或运行 openwrt\n"
                exit 1
            fi

            Println "$tip 请确保已经安装过 openwrt-v2ray"
            core_options=( 'xray-core' 'v2ray-core' )
            inquirer list_input "选择切换目标" core_options core
            if [ "$core" == "xray-core" ] 
            then
                echo
                xray_options=( '最新' '1.4.2' '1.4.0' '1.3.1' '1.3.0' '1.2.4' '1.2.3' )
                inquirer list_input "选择 xray 版本" xray_options xray_ver
                if [ "$xray_ver" == "最新" ] && ! xray_ver=$(curl -s -m 30 "$FFMPEG_MIRROR_LINK/openwrt-xray.json" | $JQ_FILE -r '.tag_name')
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                else
                    xray_ver=${xray_ver#*v}
                    if [[ ! $xray_ver =~ - ]] 
                    then
                        xray_ver="${xray_ver}-1"
                    fi
                fi
                if ! luci_app_xray_ver=$(curl -s -m 30 "$FFMPEG_MIRROR_LINK/luci-app-xray.json" | $JQ_FILE -r '.tag_name')
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                else
                    luci_app_xray_ver=${luci_app_xray_ver#*v}
                fi
                docker exec -it openwrt /bin/ash -c "
                if ! opkg list-installed | grep -q 'xray - $xray_ver-1'
                then
                    wget -O xray_${xray_ver}_aarch64_generic.ipk $FFMPEG_MIRROR_LINK/xray_${xray_ver}_aarch64_generic.ipk
                    opkg install xray_${xray_ver}_aarch64_generic.ipk --force-reinstall || true
                fi
                wget -O luci-app-v2ray_${luci_app_xray_ver}_all.ipk $FFMPEG_MIRROR_LINK/luci-app-v2ray_${luci_app_xray_ver}_all.ipk
                opkg install luci-app-v2ray_${luci_app_xray_ver}_all.ipk --force-reinstall || true
                wget -O luci-i18n-v2ray-zh-cn_${luci_app_xray_ver}_all.ipk $FFMPEG_MIRROR_LINK/luci-i18n-v2ray-zh-cn_${luci_app_xray_ver}_all.ipk
                opkg install luci-i18n-v2ray-zh-cn_${luci_app_xray_ver}_all.ipk --force-reinstall || true
                /etc/init.d/v2ray stop
                sed -i 's_/usr/bin/v2ray_/usr/bin/xray_' /etc/config/v2ray
                sed -i '/option asset_location/d' /etc/config/v2ray
                sed -i '/\/usr\/bin\/xray/a \\\toption asset_location \/usr\/share\/xray' /etc/config/v2ray
                /etc/init.d/v2ray start"
            else
                docker exec -it openwrt /bin/ash -c "
                /etc/init.d/v2ray stop
                sed -i 's_/usr/bin/xray_/usr/bin/v2ray_' /etc/config/v2ray
                sed -i '/option asset_location/d' /etc/config/v2ray
                /etc/init.d/v2ray start"
            fi
            Println "$info 切换成功\n"
        ;;
        9)
            if [[ ! -x $(command -v docker) ]] || [[ -z $(docker container ls -a -f name=openwrt$ -q) ]]
            then
                Println "$error 请先安装并运行 openwrt ...\n"
                exit 1
            fi

            echo
            inquirer text_input "输入当前配置保存名称: " config_name "不设置"
            if [ "$config_name" == "不设置" ] 
            then
                config_name=""
            else
                config_name="-$config_name"
            fi

            mkdir -p "$HOME/openwrt_saved/openwrt-v2ray"

            printf -v timestamp '%(%s)T' -1

            if ! docker cp openwrt:/etc/config/v2ray "$HOME/openwrt_saved/openwrt-v2ray/config-$timestamp$config_name" 2> /dev/null
            then
                Println "$error 请先安装 openwrt-v2ray\n"
                exit 1
            fi

            docker cp openwrt:/etc/v2ray/directlist.txt "$HOME/openwrt_saved/openwrt-v2ray/directlist-$timestamp$config_name"
            docker cp openwrt:/etc/v2ray/proxylist.txt "$HOME/openwrt_saved/openwrt-v2ray/proxylist-$timestamp$config_name"

            docker exec -it openwrt /bin/ash -c "
            cat /var/etc/v2ray/v2ray.main.json 2> /dev/null || true
            " > "$HOME/openwrt_saved/openwrt-v2ray/main-$timestamp$config_name"

            Println "$tip 所有配置文件都是透明代理, 直连国内, 代理国外, 需要自行修改出站连接后使用"
            config_file_options=( 'v2ray-1' 'xray-1' '复原配置' )
            inquirer list_input "选择配置文件: " config_file_options config_file
            if [ "$config_file" == "复原配置" ] 
            then
                if ! ls -A $HOME/openwrt_saved/openwrt-v2ray/config-* > /dev/null 2>&1
                then
                    Println "$error 没有保存的配置\n"
                    exit 1
                fi

                configs_list=""
                configs_count=0
                configs_time=()
                configs_name=()
                for file in "$HOME/openwrt_saved/openwrt-v2ray/config-"*
                do
                    if [[ ${file##*/} =~ ^config-(.+)-(.+)$ ]] 
                    then
                        config_time=${BASH_REMATCH[1]}
                        config_name="-${BASH_REMATCH[2]}"
                        config_name_list=${BASH_REMATCH[2]}
                    elif [[ ${file##*/} =~ ^config-(.+)$ ]] 
                    then
                        config_time=${BASH_REMATCH[1]}
                        config_name=""
                        config_name_list=""
                    fi
                    configs_time+=("$config_time")
                    configs_name+=("$config_name")
                    configs_count=$((configs_count+1))
                    printf -v config_date '%(%Y-%m-%d %H:%M:%S)T' "$config_time"
                    configs_list="$configs_list $configs_count.${indent_6}名称: ${green}${config_name_list:-无}${normal} 日期: ${green}$config_date${normal}\n\n"
                done

                Println "$configs_list"

                echo "选择配置"
                while read -p "$i18n_default_cancel" config_num
                do
                    case "$config_num" in
                        "")
                            Println "$i18n_canceled...\n" && exit 1
                        ;;
                        *[!0-9]*)
                            Println "$error $i18n_input_correct_no\n"
                        ;;
                        *)
                            if [ "$config_num" -gt 0 ] && [ "$config_num" -le $configs_count ]
                            then
                                configs_index=$((config_num-1))
                                config_time=${configs_time[configs_index]}
                                config_name=${configs_name[configs_index]}
                                break
                            else
                                Println "$error $i18n_input_correct_no\n"
                            fi
                        ;;
                    esac
                done

                docker cp "$HOME/openwrt_saved/openwrt-v2ray/config-$config_time$config_name" openwrt:/etc/config/v2ray
                docker cp "$HOME/openwrt_saved/openwrt-v2ray/directlist-$config_time$config_name" openwrt:/etc/v2ray/directlist.txt
                docker cp "$HOME/openwrt_saved/openwrt-v2ray/proxylist-$config_time$config_name" openwrt:/etc/v2ray/proxylist.txt
                Println "$info 配置恢复成功\n"
            else
                docker exec -it -e V2RAY_CONFIG_NAME="$config_file" -e MIRROR="$FFMPEG_MIRROR_LINK" openwrt /bin/ash -c '
                /etc/init.d/v2ray stop 2> /dev/null || true
                wget -O /etc/config/v2ray $MIRROR/v2ray-configs/$V2RAY_CONFIG_NAME
                for ip in $(nslookup dns.alidns.com | grep -v "127.0.0.1" | grep -v "127.0.0.11" | grep -oE "[0-9]{1,3}(\.[0-9]{1,3}){3}(/[0-9]{1,2})?")
                do
                    if ! grep -q "$ip" < /etc/v2ray/directlist.txt
                    then
                        echo "$ip" >> /etc/v2ray/directlist.txt
                    fi
                done
                '
                Println "$info 配置切换成功\n"
            fi
        ;;
        10)
            if [[ ! -x $(command -v docker) ]] 
            then
                Println "$error 请先安装 docker\n"
                exit 1
            fi

            if [ ! -s "/etc/docker/daemon.json" ] 
            then
                printf '%s' "{}" > /etc/docker/daemon.json
            fi

            Println "$tip 可以登录阿里云 (https://cr.console.aliyun.com/cn-shanghai/) 查看镜像加速器地址"
            inquirer text_input "请输入加速器地址 : " registry_mirrors "$i18n_cancel"
            ExitOnCancel registry_mirrors

            if ! $JQ_FILE -V > /dev/null 2>&1
            then
                Spinner "编译安装 JQ, 耗时可能会很长" JQInstall
            fi

            jq_path='["registry-mirrors"]'
            JQ replace /etc/docker/daemon.json '["'"$registry_mirrors"'"]'

            Println "$info docker 镜像加速设置成功\n"
        ;;
        11)
            VimConfig
        ;;
        12)
            DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy)
            dnscrypt_version=${DNSCRYPT_ROOT##*-}
            if [[ $dnscrypt_version == "*" ]] 
            then
                Println "$error 请先安装 dnscrypt proxy\n"
                exit 1
            fi
            echo
            if grep -q "options edns0" < /etc/resolv.conf
            then
                AskIfContinue n "`gettext \"是否关闭 edns0\"`"

                chattr -i /etc/resolv.conf
                sed -i '/options edns0/d' /etc/resolv.conf
                sed -i "0,/.*require_dnssec = .*/s//require_dnssec = false/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info edns0 已关闭\n"
            else
                AskIfContinue n "`gettext \"是否开启 edns0\"`"

                echo "options edns0" >> /etc/resolv.conf
                chattr +i /etc/resolv.conf
                sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info edns0 已开启\n"
            fi
        ;;
        13)
            if [[ ! -x $(command -v pystun) ]] 
            then
                Println "$tip 请确保已经修改了合适的 apt 源"
                AskIfContinue n "`gettext \"是否继续\"`"
                apt-get update
                apt-get -y install python python-pip python-setuptools python-wheel
                pip install pystun
            fi
            Println "$tip 建议关闭远端服务器防火墙, 检测中...\n"
            pystun
        ;;
        14)
            ShFileUpdate Armbian
        ;;
        *) Println "$error $i18n_input_correct_number [1-14]\n"
        ;;
    esac
    exit 0
elif [ "$self" == "pve" ] || [ "$self" == "pve.sh" ]
then
    if [[ ! -x $(command -v pveum) ]] 
    then
        Println "$error 不是 Proxmox 系统\n"
        exit 1
    fi

    ShFileCheck

    JQ_FILE="/usr/local/bin/jq"

    Println "  Proxmox VE 管理面板 ${normal}${red}[v$sh_ver]${normal}

  ${green}1.${normal} 设置 apt 源
  ${green}2.${normal} 设置 vimrc
  ${green}3.${normal} 设置 显示器
————————————
  ${green}4.${normal} 查看 温度 / 风扇
  ${green}5.${normal} 设置 风扇
  ${green}6.${normal} 安装 升级 dnscrypt
  ${green}7.${normal} 安装 qemu-guest-agent
  ${green}8.${normal} 安装 openwrt-v2ray
————————————
  ${green}9.${normal} 切换 openwrt 语言
 ${green}10.${normal} 切换 v2ray/xray core
 ${green}11.${normal} 切换 配置文件
————————————
 ${green}12.${normal} 开关 edns0
 ${green}13.${normal} 更新脚本

"
    read -p "`gettext \"输入序号\"` [1-13]: " pve_num

    case $pve_num in
        1) 
            echo
            apt_options=( '切换 非订阅源/订阅 源' '切换 debian 国内/国外 源' )
            inquirer list_input_index "选择操作" apt_options apt_options_index

            . /etc/os-release

            if [ "$apt_options_index" -eq 0 ] 
            then
                echo
                pve_sources_options=( '非订阅源' '订阅源' )
                inquirer list_input "选择 PVE 源" pve_sources_options pve_sources_option

                if [ "$pve_sources_option" == "非订阅源" ] 
                then
                    if [ -f /etc/apt/sources.list.d/pve-no-subscription.list ] 
                    then
                        sed -i "s_#deb http://download.proxmox.com/debian/pve $VERSION_CODENAME pve-no-subscription_deb http://download.proxmox.com/debian/pve $VERSION_CODENAME pve-no-subscription_" /etc/apt/sources.list.d/pve-no-subscription.list
                    elif grep -q "pve-no-subscription" < /etc/apt/sources.list 
                    then
                        sed -i "s_#deb http://download.proxmox.com/debian/pve $VERSION_CODENAME pve-no-subscription_deb http://download.proxmox.com/debian/pve $VERSION_CODENAME pve-no-subscription_" /etc/apt/sources.list
                    else
                        echo "deb http://download.proxmox.com/debian/pve $VERSION_CODENAME pve-no-subscription" > /etc/apt/sources.list.d/pve-no-subscription.list
                    fi
                else
                    if [ -f /etc/apt/sources.list.d/pve-enterprise.list ] 
                    then
                        sed -i "s_#deb https://enterprise.proxmox.com/debian/pve $VERSION_CODENAME pve-enterprise_deb https://enterprise.proxmox.com/debian/pve $VERSION_CODENAME pve-enterprise_" /etc/apt/sources.list.d/pve-enterprise.list
                    elif grep -q "pve-enterprise" < /etc/apt/sources.list 
                    then
                        sed -i "s_#deb https://enterprise.proxmox.com/debian/pve $VERSION_CODENAME pve-enterprise_deb https://enterprise.proxmox.com/debian/pve $VERSION_CODENAME pve-enterprise_" /etc/apt/sources.list
                    else
                        echo "deb https://enterprise.proxmox.com/debian/pve $VERSION_CODENAME pve-enterprise" > /etc/apt/sources.list.d/pve-enterprise.list
                    fi
                fi

                Println "$info 切换成功\n"
                exit 0
            fi

            AptSetSources
        ;;
        2) 
            VimConfig
        ;;
        3) 
            echo
            monitor_options=( '关闭显示器' '取消关闭显示器' )
            inquirer list_input "选择操作" monitor_options monitor_option

            if [ "$monitor_option" == "关闭显示器" ] 
            then
                echo
                inquirer text_input "输入多少秒后关闭显示器" console_blank_secs 120

                sed -i 's_GRUB_CMDLINE_LINUX=""_GRUB_CMDLINE_LINUX="consoleblank='"$console_blank_secs"'"_' /etc/default/grub
            else
                sed -i '0,/GRUB_CMDLINE_LINUX=.*/s//GRUB_CMDLINE_LINUX=""/' /etc/default/grub
            fi

            update-grub

            Println "$info 设置成功\n"
        ;;
        4) 
            if [[ ! -x $(command -v sensors) ]] 
            then
                Println "$info 安装 lm-sensors..."
                apt-get update
                apt-get -y install lm-sensors
            fi

            sensors

            if [ -d /opt/nbfc/ ] 
            then
                cd /opt/nbfc
                mono nbfc.exe status --all
            fi
        ;;
        5)
            if [[ ! -x $(command -v mono) ]] 
            then
                echo
                AskIfContinue n "`gettext \"需要安装 mono, 耗时会很长, 是否继续\"`"

                . /etc/os-release

                apt-get update
                apt-get -y install apt-transport-https dirmngr gnupg ca-certificates
                apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
                echo "deb https://download.mono-project.com/repo/debian stable-$VERSION_CODENAME main" | tee /etc/apt/sources.list.d/mono-official-stable.list
                apt-get update
                apt-get -y install mono-complete git
            fi

            if [ ! -d /opt/nbfc/ ] 
            then
                Println "$info 安装 nbfc..."

                if [[ ! -x $(command -v git) ]] 
                then
                    Println "$info 安装 git..."
                    apt-get update
                    apt-get -y install git
                fi

                git clone https://github.com/hirschmann/nbfc.git /tmp/nbfc
                cd /tmp/nbfc
                ./build.sh

                mkdir /opt/nbfc
                cp -r /tmp/nbfc/Linux/bin/Release/* /opt/nbfc/
                cp /tmp/nbfc/Linux/{nbfc.service,nbfc-sleep.service} /etc/systemd/system/
                systemctl enable nbfc --now || true
            fi

            echo
            nbfc_options=( '查看状态' '风扇切换为手动控制' '设置风扇转速' '搜索配置' '应用配置' )
            inquirer list_input "选择操作" nbfc_options nbfc_option

            cd /opt/nbfc

            if [ "$nbfc_option" == "查看状态" ] 
            then
                mono nbfc.exe status --all
            elif [ "$nbfc_option" == "风扇切换为手动控制" ]
            then
                echo
                inquirer text_input "输入寄存器地址, 比如 0x93: " register_address "$i18n_cancel"
                ExitOnCancel register_address

                echo
                inquirer text_input "输入值, 比如 0x14: " register_value "$i18n_cancel"
                ExitOnCancel register_value

                mono ec-probe.exe write $register_address $register_value

                if [ -f /opt/nbfc/nbfcservice.sh ] 
                then
                    sed -i '/mono \/opt\/nbfc\/ec-probe.exe write /d' /opt/nbfc/nbfcservice.sh
                    sed -i '/start/a \\t    mono \/opt\/nbfc\/ec-probe.exe write '"$register_address"' '"$register_value"'' /opt/nbfc/nbfcservice.sh
                fi

                Println "$tip 不一定写入成功, 请自行检查\n"
            elif [ "$nbfc_option" == "设置风扇转速" ] 
            then
                Println "$tip 请确保风扇处于手动控制状态"
                echo
                fan_options=( '输入寄存器值' '输入配置百分比' )
                inquirer list_input "选择控制方式" fan_options fan_option

                if [ "$fan_option" == "输入寄存器值" ] 
                then
                    echo
                    inquirer text_input "输入寄存器地址, 比如 0x94: " register_address "$i18n_cancel"
                    ExitOnCancel register_address

                    echo
                    inquirer text_input "输入值, 比如 0x99: " register_value "$i18n_cancel"
                    ExitOnCancel register_value

                    mono ec-probe.exe write $register_address $register_value

                    Println "$tip 不一定写入成功, 请自行检查\n"
                else
                    Println "$tip 请确保已经正确应用配置文件"
                    echo
                    inquirer text_input "输入风扇序号(从 0 开始): " fan_index 0

                    echo
                    inquirer text_input "输入转速百分比: " fan_speed "$i18n_cancel"
                    ExitOnCancel fan_speed

                    mono nbfc.exe set -f $fan_index -s $fan_speed

                    Println "$tip 操作成功\n"
                fi
            elif [ "$nbfc_option" == "搜索配置" ] 
            then
                mono nbfc.exe config -r
            elif [ "$nbfc_option" == "应用配置" ]
            then
                echo
                inquirer text_input "输入配置名称, 比如: Acer Aspire 5745G" config_name "$i18n_cancel"
                ExitOnCancel config_name

                mono nbfc.exe config --apply "$config_name"
                mono nbfc.exe start

                Println "$info 配置已生效\n"
            fi
        ;;
        6) 
            ReleaseCheck
            JQInstall

            if dnscrypt_version=$(curl -s -Lm 10 "$FFMPEG_MIRROR_LINK/dnscrypt.json" | $JQ_FILE -r '.tag_name') 
            then
                DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy)
                dnscrypt_version_old=${DNSCRYPT_ROOT##*-}

                echo
                inquirer text_input "输入本机静态 ip : " proxmox_ip "$i18n_cancel"
                ExitOnCancel proxmox_ip

                if [[ $dnscrypt_version_old == "*" ]]
                then
                    Println "$info 下载 dnscrypt proxy ..."
                    if curl -L "$FFMPEG_MIRROR_LINK/dnscrypt/dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz" -o ~/dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz_tmp
                    then
                        Println "$info 设置 dnscrypt proxy ..."
                        cd ~
                        mv dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz_tmp dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz
                        tar zxf dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz
                        mv linux-x86_64 dnscrypt-$dnscrypt_version
                        chown -R $USER:$USER dnscrypt-$dnscrypt_version
                        cd dnscrypt-$dnscrypt_version
                        cp -f example-dnscrypt-proxy.toml dnscrypt-proxy.toml

                        sed -i "0,/.*server_names = \[.*/s//server_names = ['alidns-doh']/" dnscrypt-proxy.toml
                        sed -i "0,/.*listen_addresses = \['127.0.0.1:53']/s//listen_addresses = ['127.0.0.1:53', '$proxmox_ip:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" dnscrypt-proxy.toml
                        sed -i "0,/.*fallback_resolvers =.*/s//fallback_resolvers = ['114.114.114.114:53', '8.8.8.8:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*netprobe_address =.*/s//netprobe_address = '114.114.114.114:53'/" dnscrypt-proxy.toml

                        for((i=0;i<3;i++));
                        do
                            if ./dnscrypt-proxy -check > /dev/null 
                            then
                                break
                            elif [[ $i -eq 2 ]] 
                            then
                                cd ~
                                rm -rf dnscrypt-$dnscrypt_version
                                Println "$error 发生错误, 请重试\n"
                                exit 1
                            fi
                        done

                        apt-get -y --purge remove resolvconf > /dev/null

                        systemctl stop systemd-resolved
                        systemctl disable systemd-resolved
                        ./dnscrypt-proxy -service install > /dev/null
                        ./dnscrypt-proxy -service start > /dev/null

                        Println "$info dnscrypt proxy 安装配置成功\n"

                        # echo -e "nameserver 127.0.0.1\noptions edns0" > /etc/resolv.conf
                    else
                        Println "$error dnscrypt proxy 下载失败, 请重试\n"
                        exit 1
                    fi
                elif [[ $dnscrypt_version_old != "$dnscrypt_version" ]] 
                then
                    if curl -L "$FFMPEG_MIRROR_LINK/dnscrypt/dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz" -o ~/dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz_tmp
                    then
                        cd ~/dnscrypt-$dnscrypt_version_old
                        ./dnscrypt-proxy -service stop > /dev/null
                        ./dnscrypt-proxy -service uninstall > /dev/null
                        cd ~
                        mv dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz_tmp dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz
                        tar zxf dnscrypt-proxy-linux_x86_64-$dnscrypt_version.tar.gz
                        mv linux-x86_64 dnscrypt-$dnscrypt_version
                        cd dnscrypt-$dnscrypt_version
                        cp -f example-dnscrypt-proxy.toml dnscrypt-proxy.toml
                        sed -i "0,/.*server_names = \[.*/s//server_names = ['alidns-doh']/" dnscrypt-proxy.toml
                        sed -i "0,/.*listen_addresses = \['127.0.0.1:53']/s//listen_addresses = ['127.0.0.1:53', '$proxmox_ip:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" dnscrypt-proxy.toml
                        sed -i "0,/.*fallback_resolvers =.*/s//fallback_resolvers = ['114.114.114.114:53', '8.8.8.8:53']/" dnscrypt-proxy.toml
                        sed -i "0,/.*netprobe_address =.*/s//netprobe_address = '114.114.114.114:53'/" dnscrypt-proxy.toml
                        ./dnscrypt-proxy -service install > /dev/null
                        ./dnscrypt-proxy -service start > /dev/null
                        Println "$info dnscrypt proxy 升级成功\n"
                    else
                        Println "$error dnscrypt proxy 下载失败, 请重试\n"
                        exit 1
                    fi
                else
                    Println "$error dnscrypt proxy 已经是最新\n"
                fi
                if ! grep -q "options edns0" < /etc/resolv.conf
                then
                    echo "options edns0" >> /etc/resolv.conf
                    systemctl restart dnscrypt-proxy
                fi
            else
                Println "$error 无法连接服务器, 请稍后再试\n"
            fi
        ;;
        7)
            PveListVMs

            PveSelectVM

            if [ "$vm_status" != "running" ] 
            then
                Println "$error 请先启动虚拟机 $vm_name\n"
                exit 1
            fi

            qm set $vm_id --agent 1

            Println "$info 请在虚拟机内执行 opkg update; opkg install qemu-ga 后关闭虚拟机几秒后再打开\n"
        ;;
        8)
            ReleaseCheck
            JQInstall

            Println "$tip 请确保已经安装 qemu-guest-agent\n"

            PveListVMs

            PveSelectVM

            if [ "$vm_status" != "running" ] 
            then
                Println "$error 请先启动虚拟机 $vm_name\n"
                exit 1
            fi

            echo
            qm guest exec $vm_id wget "$FFMPEG_MIRROR_LINK/pve/snippets/openwrt-v2ray-install.sh" -- "-O" "/root/openwrt-v2ray-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"'

            Println "$info 安装 openwrt-v2ray, 请稍等 ..."

            echo
            qm guest exec $vm_id --timeout 0 ash "/root/openwrt-v2ray-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"'

            echo
        ;;
        9)
            ReleaseCheck
            JQInstall

            Println "$tip 请确保已经安装 qemu-guest-agent\n"

            PveListVMs

            PveSelectVM

            echo
            lang_options=( '简体中文' '繁体中文' '英文' )
            inquirer list_input "选择界面语言" lang_options lang

            if [ "$lang" == "简体中文" ] 
            then
                lang="zh-cn"
            elif [ "$lang" == "繁体中文" ] 
            then
                lang="zh-tw"
            else
                lang="en"
            fi

            Println "$info 设置 openwrt 语言, 请稍等 ..."

            echo
            qm guest exec $vm_id wget "$FFMPEG_MIRROR_LINK/pve/snippets/openwrt-language-install.sh" -- "-O" "/root/openwrt-language-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"'

            echo
            qm guest exec $vm_id --timeout 0 ash "/root/openwrt-language-install.sh" "$lang" | $JQ_FILE -r '."err-data" // ."out-data"'

            Println "$info 界面语言切换成功\n"
        ;;
        10)
            ReleaseCheck
            JQInstall

            Println "$tip 请确保已经安装 qemu-guest-agent\n"

            PveListVMs

            PveSelectVM

            Println "$tip 请确保已经安装过 openwrt-v2ray"
            core_options=( 'xray-core' 'v2ray-core' )
            inquirer list_input "选择切换目标" core_options core
            if [ "$core" == "xray-core" ] 
            then
                echo
                xray_options=( '最新' '1.4.2' '1.4.0' '1.3.1' '1.3.0' '1.2.4' '1.2.3' )
                inquirer list_input "选择 xray 版本" xray_options xray_ver
                if [ "$xray_ver" == "最新" ] && ! xray_ver=$(curl -s -m 30 "$FFMPEG_MIRROR_LINK/openwrt-xray.json" | $JQ_FILE -r '.tag_name')
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                else
                    xray_ver=${xray_ver#*v}
                    if [[ ! $xray_ver =~ - ]] 
                    then
                        xray_ver="${xray_ver}-1"
                    fi
                fi
                if ! luci_app_xray_ver=$(curl -s -m 30 "$FFMPEG_MIRROR_LINK/luci-app-xray.json" | $JQ_FILE -r '.tag_name')
                then
                    Println "$error 无法连接服务器, 请稍后再试\n"
                    exit 1
                else
                    luci_app_xray_ver=${luci_app_xray_ver#*v}
                fi

                Println "$info 切换 openwrt-xray, 请稍等 ..."

                echo
                qm guest exec $vm_id wget "$FFMPEG_MIRROR_LINK/pve/snippets/openwrt-xray-install.sh" -- "-O" "/root/openwrt-xray-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"'

                echo
                qm guest exec $vm_id --timeout 0 ash "/root/openwrt-xray-install.sh" "$xray_ver" "$luci_app_xray_ver" | $JQ_FILE -r '."err-data" // ."out-data"'
            else
                Println "$info 切换 openwrt-v2ray, 请稍等 ..."

                echo
                qm guest exec $vm_id /etc/init.d/v2ray "stop" | $JQ_FILE -r '."err-data" // ."out-data"'

                echo
                qm guest exec $vm_id sed -- "-i" "s_/usr/bin/xray_/usr/bin/v2ray_" "/etc/config/v2ray" | $JQ_FILE -r '."err-data" // ."out-data"'

                echo
                qm guest exec $vm_id sed -- "-i" "/option asset_location/d" "/etc/config/v2ray" | $JQ_FILE -r '."err-data" // ."out-data"'

                echo
                qm guest exec $vm_id /etc/init.d/v2ray "start" | $JQ_FILE -r '."err-data" // ."out-data"'
            fi

            Println "$info 切换成功\n"
        ;;
        11)
            ReleaseCheck
            JQInstall

            Println "$tip 请确保已经安装 qemu-guest-agent\n"

            PveListVMs

            PveSelectVM

            Println "$tip 请确保已经安装过 openwrt-v2ray"
            inquirer text_input "输入当前配置保存名称: " config_name "不设置"
            if [ "$config_name" == "不设置" ] 
            then
                config_name=""
            else
                config_name="-$config_name"
            fi

            Println "$tip 备份 openwrt-v2ray, 请稍等 ..."
            qm guest exec $vm_id wget "$FFMPEG_MIRROR_LINK/pve/snippets/openwrt-config-install.sh" -- "-O" "/root/openwrt-config-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"'

            if [ $(qm guest exec $vm_id ash "/root/openwrt-config-install.sh" | $JQ_FILE -r '."err-data" // ."out-data"') == "no" ]
            then
                Println "$error 请先安装 openwrt-v2ray\n"
                exit 1
            fi

            printf -v timestamp '%(%s)T' -1

            echo
            qm guest exec $vm_id ash "/root/openwrt-config-install.sh" -- "save" "$timestamp" "$config_name" > /dev/null

            Println "$tip 所有配置文件都是透明代理, 直连国内, 代理国外, 需要自行修改出站连接后使用"
            config_file_options=( 'v2ray-1' 'xray-1' '复原配置' )
            inquirer list_input "选择配置文件: " config_file_options config_file
            if [ "$config_file" == "复原配置" ] 
            then
                echo
                files=($(qm guest exec $vm_id ash "/root/openwrt-config-install.sh" -- "list" | $JQ_FILE -r '."err-data" // ."out-data"'))

                if [ "${files[0]}" == "no" ] 
                then
                    Println "$error 没有保存的配置\n"
                    exit 1
                fi

                configs_list=""
                configs_count=0
                configs_time=()
                configs_name=()
                for file in "${files[@]}"
                do
                    if [[ ${file##*/} =~ ^config-(.+)-(.+)$ ]] 
                    then
                        config_time=${BASH_REMATCH[1]}
                        config_name="-${BASH_REMATCH[2]}"
                        config_name_list=${BASH_REMATCH[2]}
                    elif [[ ${file##*/} =~ ^config-(.+)$ ]] 
                    then
                        config_time=${BASH_REMATCH[1]}
                        config_name=""
                        config_name_list=""
                    fi
                    configs_time+=("$config_time")
                    configs_name+=("$config_name")
                    configs_count=$((configs_count+1))
                    printf -v config_date '%(%Y-%m-%d %H:%M:%S)T' "$config_time"
                    configs_list="$configs_list $configs_count.${indent_6}名称: ${green}${config_name_list:-无}${normal} 日期: ${green}$config_date${normal}\n\n"
                done

                Println "$configs_list"

                echo "选择配置"
                while read -p "$i18n_default_cancel" config_num
                do
                    case "$config_num" in
                        "")
                            Println "$i18n_canceled...\n" && exit 1
                        ;;
                        *[!0-9]*)
                            Println "$error $i18n_input_correct_no\n"
                        ;;
                        *)
                            if [ "$config_num" -gt 0 ] && [ "$config_num" -le $configs_count ]
                            then
                                configs_index=$((config_num-1))
                                config_time=${configs_time[configs_index]}
                                config_name=${configs_name[configs_index]}
                                break
                            else
                                Println "$error $i18n_input_correct_no\n"
                            fi
                        ;;
                    esac
                done

                echo
                qm guest exec $vm_id ash "/root/openwrt-config-install.sh" -- "restore" "$config_time" "$config_name" | $JQ_FILE -r '."err-data" // ."out-data"'
                Println "$info 配置恢复成功\n"
            else
                Println "$info 切换配置中, 请稍等 ..."
                qm guest exec $vm_id ash "/root/openwrt-config-install.sh" -- "switch" "$config_file" | $JQ_FILE -r '."err-data" // ."out-data"'
                Println "$info 配置切换成功\n"
            fi
        ;;
        12)
            DNSCRYPT_ROOT=$(dirname ~/dnscrypt-*/dnscrypt-proxy)
            dnscrypt_version=${DNSCRYPT_ROOT##*-}
            if [[ $dnscrypt_version == "*" ]] 
            then
                Println "$error 请先安装 dnscrypt proxy\n"
                exit 1
            fi
            echo
            if grep -q "options edns0" < /etc/resolv.conf
            then
                AskIfContinue n "`gettext \"是否关闭 edns0\"`"

                sed -i '/options edns0/d' /etc/resolv.conf
                sed -i "0,/.*require_dnssec = .*/s//require_dnssec = false/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info edns0 已关闭\n"
            else
                AskIfContinue n "`gettext \"是否开启 edns0\"`"

                echo "options edns0" >> /etc/resolv.conf
                sed -i "0,/.*require_dnssec = .*/s//require_dnssec = true/" $DNSCRYPT_ROOT/dnscrypt-proxy.toml
                systemctl restart dnscrypt-proxy
                Println "$info edns0 已开启\n"
            fi
        ;;
        13) 
            ShFileUpdate PVE
        ;;
        *) Println "$error $i18n_input_correct_number [1-13]\n"
        ;;
    esac
    exit 0
fi

if [[ -n ${1+x} ]]
then
    case $1 in
        "4g")
            if [ ! -d "$IPTV_ROOT" ] 
            then
                Println "$error 请先安装脚本 !\n" && exit 1
            fi

            user_agent="$USER_AGENT_BROWSER"

            if [ "${2:-}" == "-" ] 
            then
                _4gtvCron
                exit 0
            fi

            if [[ ! -x $(command -v openssl) ]] 
            then
                echo
                AskIfContinue y "`gettext \"是否安装 openssl\"`"
                OpensslInstall
            fi

            Println "  4gtv 面板

  ${green}1.${normal} 注册账号
  ${green}2.${normal} 登录账号
  ${green}3.${normal} 查看账号
  ${green}4.${normal} 修改账号
  ${green}5.${normal} 删除账号
  ${green}6.${normal} 使用免费频道
  ${green}7.${normal} 使用豪华频道
  ${green}8.${normal} 开启计划任务
  ${green}9.${normal} 关闭计划任务

"
            while read -p "(默认: 6): " _4gtv_menu_num 
            do
                _4gtv_menu_num=${_4gtv_menu_num:-6}
                case "$_4gtv_menu_num" in
                    1) 
                        Reg4gtvAcc
                        exit 0
                    ;;
                    2) 
                        Login4gtvAcc
                        exit 0
                    ;;
                    3) 
                        List4gtvAcc
                        exit 0
                    ;;
                    4) 
                        Edit4gtvAcc
                        exit 0
                    ;;
                    5) 
                        Del4gtvAcc
                        exit 0
                    ;;
                    6) 
                        _4gtv_set_id=4
                        fsVALUE=""
                        Use4gtvProxy
                        break
                    ;;
                    7) 
                        Get4gtvAccToken
                        _4gtv_set_id=1
                        Use4gtvProxy
                        break
                    ;;
                    8) 
                        Enable4gtvCron
                        exit 0
                    ;;
                    9) 
                        Disable4gtvCron
                        exit 0
                    ;;
                    *) Println "$error $i18n_input_correct_number [1-9]\n"
                    ;;
                esac
            done

            hinet_4gtv=(
                "litv-longturn14:寰宇新聞台"
                "4gtv-4gtv052:華視新聞資訊台"
                "4gtv-4gtv012:空中英語教室"
                "litv-ftv07:民視旅遊台"
                "litv-ftv15:i-Fun動漫台"
                "4gtv-live206:幸福空間居家台"
                "4gtv-4gtv070:愛爾達娛樂台"
                "litv-longturn17:亞洲旅遊台"
                "4gtv-4gtv025:MTV Live HD"
                "litv-longturn15:寰宇新聞台灣台"
                "4gtv-4gtv001:民視台灣台"
                "4gtv-4gtv074:中視新聞台"
                "4gtv-4gtv011:影迷數位電影台"
                "4gtv-4gtv047:靖天日本台"
                "litv-longturn11:龍華日韓台"
                "litv-longturn12:龍華偶像台"
                "4gtv-4gtv042:公視戲劇"
                "litv-ftv12:i-Fun動漫台3"
                "4gtv-4gtv002:民視無線台"
                "4gtv-4gtv027:CI 罪案偵查頻道"
                "4gtv-4gtv013:CNEX DOC CHANNEL"
                "litv-longturn03:龍華電影台"
                "4gtv-4gtv004:民視綜藝台"
                "litv-longturn20:ELTV英語學習台"
                "litv-longturn01:龍華卡通台"
                "4gtv-4gtv040:中視無線台"
                "litv-longturn02:Baby First"
                "4gtv-4gtv003:民視第一台"
                "4gtv-4gtv007:大愛電視台"
                "4gtv-4gtv076:SMART 知識頻道"
                "4gtv-4gtv030:CNBC"
                "litv-ftv10:半島電視台"
            )

            GetChannels

            hinet_4gtv_count=${#hinet_4gtv[@]}
            hinet_4gtv_list=""
            for((i=0;i<hinet_4gtv_count;i++));
            do
                hinet_4gtv_chnl_added=""
                for chnl in ${chnls_stream_link[@]+"${chnls_stream_link[@]}"}
                do
                    if [[ $chnl =~ embed.4gtv.tv/HiNet ]] && [[ $chnl =~ asset_id=${hinet_4gtv[i]%:*}\& ]] 
                    then
                        hinet_4gtv_chnl_added=" ${green}[已添加]${normal}"
                        break
                    fi
                done
                hinet_4gtv_list="$hinet_4gtv_list ${green}$((i+1)).${normal}${indent_6}${hinet_4gtv[i]#*:}$hinet_4gtv_chnl_added\n\n"
            done

            cookies=""

            Println "$info 获取频道 ..."
            IFS="^" read -r _4gtv_chnl_id _4gtv_chnl_name _4gtv_chnl_aid < <(curl -s -Lm 10 \
                -H "User-Agent: $user_agent" \
                -H "Referer: https://www.4gtv.tv/channel.html?channelSet_id=$_4gtv_set_id" https://api2.4gtv.tv/Channel/GetChannelBySetId/$_4gtv_set_id/pc/L \
                | $JQ_FILE -r '[([.Data[].fnID]|join("|")),([.Data[].fsNAME]|join("|")),([.Data[].fs4GTV_ID]|join("|"))]|join("^")'
            ) || true

            IFS="|" read -r -a _4gtv_chnls_id <<< "$_4gtv_chnl_id"
            IFS="|" read -r -a _4gtv_chnls_name <<< "$_4gtv_chnl_name"
            IFS="|" read -r -a _4gtv_chnls_aid <<< "$_4gtv_chnl_aid"

            if [ -n "${_4gtv_chnls_id:-}" ] 
            then
                _4gtv_list=""
                _4gtv_chnls_count=${#_4gtv_chnls_id[@]}
                for((i=0;i<_4gtv_chnls_count;i++));
                do
                    _4gtv_chnl_added=""
                    for chnl in ${chnls_stream_link[@]+"${chnls_stream_link[@]}"}
                    do
                        if [[ $chnl =~ 4gtv.tv/channel_sub.html ]] && [[ $chnl =~ asset_id=${_4gtv_chnls_aid[i]}\& ]] 
                        then
                            _4gtv_chnl_added=" ${green}[已添加]${normal}"
                            break
                        fi
                    done
                    _4gtv_list="$_4gtv_list ${green}$((i+hinet_4gtv_count+1)).${normal}${indent_6}${_4gtv_chnls_name[i]}$_4gtv_chnl_added\n\n"
                done
                chnls_list="HiNet 4gtv 频道:\n\n${hinet_4gtv_list}4gtv 官网频道:\n\n$_4gtv_list"
            else
                _4gtv_chnls_count=0
                chnls_list="HiNet 4gtv 频道:\n\n$hinet_4gtv_list"
            fi

            chnls_count=$((hinet_4gtv_count+_4gtv_chnls_count))
            Println "$chnls_list"
            echo "选择需要添加的频道序号, 多个频道用空格分隔, 比如 5 7 9-11"
            while read -p "$i18n_default_cancel" chnls_num 
            do
                [ -z "$chnls_num" ] && Println "$i18n_canceled...\n" && exit 1
                IFS=" " read -ra chnls_num_arr <<< "$chnls_num"

                error_no=0
                for chnl_num in "${chnls_num_arr[@]}"
                do
                    case "$chnl_num" in
                        *"-"*)
                            chnl_num_start=${chnl_num%-*}
                            chnl_num_end=${chnl_num#*-}
                            if [[ $chnl_num_start == *[!0-9]* ]] || [[ $chnl_num_end == *[!0-9]* ]] || \
                            [ "$chnl_num_start" -eq 0 ] || [ "$chnl_num_end" -eq 0 ] || \
                            [ "$chnl_num_end" -gt "$chnls_count" ] || \
                            [ "$chnl_num_start" -ge "$chnl_num_end" ]
                            then
                                error_no=3
                            fi
                        ;;
                        *[!0-9]*)
                            error_no=1
                        ;;
                        *)
                            if [ "$chnl_num" -lt 1 ] || [ "$chnl_num" -gt "$chnls_count" ] 
                            then
                                error_no=2
                            fi
                        ;;
                    esac
                done

                case "$error_no" in
                    1|2|3)
                        Println "$error $i18n_input_correct_number\n"
                    ;;
                    *)
                        declare -a new_array
                        for element in "${chnls_num_arr[@]}"
                        do
                            if [[ $element =~ - ]] 
                            then
                                start=${element%-*}
                                end=${element#*-}
                                for((i=start;i<=end;i++));
                                do
                                    new_array+=("$i")
                                done
                            else
                                new_array+=("$element")
                            fi
                        done
                        chnls_num_arr=("${new_array[@]}")
                        unset new_array
                        break
                    ;;
                esac
            done

            for chnl_num in "${chnls_num_arr[@]}"
            do
                xc=1
                if [ "$chnl_num" -le "$hinet_4gtv_count" ] 
                then
                    hinet_4gtv_chnl_index=$((chnl_num-1))
                    hinet_4gtv_chnl_id=${hinet_4gtv[hinet_4gtv_chnl_index]%%:*}
                    hinet_4gtv_chnl_name=${hinet_4gtv[hinet_4gtv_chnl_index]#*:}
                    hinet_4gtv_chnl_name_enc=$(Urlencode "$hinet_4gtv_chnl_name")
                    Println "$info 添加频道 [ $hinet_4gtv_chnl_name ]\n\n"
                    inquirer list_input "是否推流 flv" ny_options add_channel_flv_yn
                    if [[ $add_channel_flv_yn == "$i18n_yes" ]] 
                    then
                        kind="flv"
                    else
                        kind=""
                    fi
                    Println "$info 解析 [ $hinet_4gtv_chnl_name ] 链接 ..."
                    stream_links="https://embed.4gtv.tv/HiNet/$hinet_4gtv_chnl_name_enc.html"
                    headers="Referer: $stream_links?ar=0&as=1&volume=0\r\n"
                    stream_link_data=$(curl -s -Lm 10 \
                        ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} \
                        -H "User-Agent: $user_agent" \
                        -H "${headers:0:-4}" "https://app.4gtv.tv/Data/HiNet/GetURL.ashx?ChannelNamecallback=channelname&Type=LIVE&Content=$hinet_4gtv_chnl_id&HostURL=https%3A%2F%2Fwww.hinet.net%2Ftv%2F&_=$(date +%s%3N)") || true
                    if [ -n "$stream_link_data" ] 
                    then
                        stream_link_data=$($JQ_FILE -r '.VideoURL' <<< "${stream_link_data:12:-1}")
                        hexkey=$(echo -n "VxzAfiseH0AbLShkQOPwdsssw5KyLeuv" | hexdump -v -e '/1 "%02x"')
                        hexiv=$(echo -n "${stream_link_data:0:16}" | hexdump -v -e '/1 "%02x"')
                        stream_link=$stream_links
                        stream_link_url=$(echo "${stream_link_data:16}" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a)
                        stream_link_url_path=${stream_link_url%/*}
                        Add4gtvLink
                    else
                        Println "$error 无法连接 4gtv !\n" && exit 1
                    fi
                    AddChannel
                else
                    _4gtv_chnl_index=$((chnl_num-hinet_4gtv_count-1))
                    _4gtv_chnl_id=${_4gtv_chnls_id[_4gtv_chnl_index]}
                    _4gtv_chnl_name=${_4gtv_chnls_name[_4gtv_chnl_index]}
                    _4gtv_chnl_aid=${_4gtv_chnls_aid[_4gtv_chnl_index]}
                    Println "$info 添加频道 [ $_4gtv_chnl_name ]\n\n"
                    inquirer list_input "是否推流 flv" ny_options add_channel_flv_yn
                    if [[ $add_channel_flv_yn == "$i18n_yes" ]] 
                    then
                        kind="flv"
                    else
                        kind=""
                    fi
                    Println "$info 解析 [ $_4gtv_chnl_name ] 链接 ..."
                    stream_links="https://www.4gtv.tv/channel_sub.html?channelSet_id=$_4gtv_set_id&asset_id=$_4gtv_chnl_aid&channel_id=$_4gtv_chnl_id"
                    headers="Referer: $stream_links\r\n"
                    key="ilyB29ZdruuQjC45JhBBR7o2Z8WJ26Vg"
                    iv="JUMxvVMmszqUTeKn"
                    hexkey=$(echo -n $key | hexdump -v -e '/1 "%02x"')
                    hexiv=$(echo -n $iv | hexdump -v -e '/1 "%02x"')
                    post_data='{"fnCHANNEL_ID":'"$_4gtv_chnl_id"',"fsASSET_ID":"'"$_4gtv_chnl_aid"'","fsDEVICE_TYPE":"pc","clsIDENTITY_VALIDATE_ARUS":{"fsVALUE":"'"$fsVALUE"'"}}'
                    post_data=$(echo -n "$post_data" | openssl enc -aes-256-cbc -iv "$hexiv" -K "$hexkey" -a)
                    if [ -n "$fsVALUE" ] 
                    then
                        value="$(UrlencodeUpper ${post_data//[[:space:]]/})"
                    else
                        value="$(Urlencode ${post_data//[[:space:]]/})"
                    fi

                    for((try_i=0;try_i<10;try_i++));
                    do
                        stream_link_data=$(curl -s -Lm 10 -X POST \
                            ${_4gtv_proxy_command[@]+"${_4gtv_proxy_command[@]}"} \
                            -H "User-Agent: $user_agent" \
                            -H "${headers:0:-4}" \
                            --data "value=$value" "https://api2.4gtv.tv/Channel/GetChannelUrl3") || true
                        if [ -n "$stream_link_data" ] 
                        then
                            break
                        fi
                    done

                    if [ -z "$stream_link_data" ] 
                    then
                        Println "$error 无法连接 4gtv !\n" && exit 1
                    fi

                    stream_link_data=$($JQ_FILE -r '.Data' <<< "$stream_link_data")
                    if [ "$stream_link_data" == null ] 
                    then
                        Println "$error 此服务器 ip 不支持或频道不可用!\n"
                    else
                        stream_link=$stream_links
                        stream_link_url=$(echo "$stream_link_data" | openssl enc -aes-256-cbc -d -iv "$hexiv" -K "$hexkey" -a \
                            | $JQ_FILE -r '.flstURLs[0]')
                        stream_link_url_path=${stream_link_url%/*}
                        Add4gtvLink
                        AddChannel
                    fi
                fi
            done
            exit 0
        ;;
        "s") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请先安装 !" && exit 1
            Schedule "$@"
            exit 0
        ;;
        "singtel") 
            Println "$info 检测 singteltv ..."
            while IFS= read -r line 
            do
                if [[ $line =~ epgEndPoint ]] 
                then
                    line=${line#*epgEndPoint&#34;:&#34;}
                    epg_end_point=${line%%&#34*}
                    line=${line#*tvChannelLists&#34;:}
                    tv_channel_lists=${line%%,&#34;errorMessage*}
                    tv_channel_lists=${tv_channel_lists//&#34;/\"}
                    $JQ_FILE -r '.[]|[
                        (.title // "空"),
                        (.channelId // "空"),
                        (.language // []|join(","))
                    ]|@tsv' <<< "$tv_channel_lists"
                    break
                fi
            done < <(curl -s -L "https://www.singtel.com/personal/products-services/tv/tv-programme-guide" 2> /dev/null)
            exit 0
        ;;
        "astro")
            Println "$info 检测 astro ..."

            delimiters=( $'\001' )
            IFS=$'\002\t' read -r m_id m_title m_description m_is_hd m_language < <(
            JQs flat "$(curl -s -Lm 20 -H 'User-Agent: '"$USER_AGENT_BROWSER"'' https://contenthub-api.eco.astro.com.my/channel/all.json)" '.[0].response' '
            . as $response | reduce ({id,title,description,isHd,language}|keys_unsorted[]) as $key ([];
                $response[$key] as $val | if $val then
                    . + [$val + "\u0001\u0002"]
                else
                    . + ["\u0002"]
                end
            )|@tsv' "${delimiters[@]}")

            IFS=$'\001' read -ra chnls_id <<< "$m_id"
            IFS=$'\001' read -ra chnls_title <<< "$m_title"
            IFS=$'\001' read -ra chnls_description <<< "$m_description"
            IFS=$'\001' read -ra chnls_is_hd <<< "$m_is_hd"
            IFS=$'\001' read -ra chnls_language <<< "$m_language"

            chnls_list=""
            for((i=0;i<${#chnls_id[@]};i++));
            do
                if [ "${chnls_is_hd[i]}" == "true" ] 
                then
                    is_hd="${green}是${normal}"
                else
                    is_hd="${red}否${normal}"
                fi
                chnls_list="$chnls_list ${green}$((i+1)).${normal}${indent_6}频道ID: ${green}${chnls_id[i]}${normal} 频道名称: ${green}${chnls_title[i]}${normal}\n${indent_6}高清: ${green}$is_hd${normal} 语言: ${green}${chnls_language[i]}${normal}\n${indent_6}${chnls_description[i]}\n\n"
            done

            Println "$chnls_list"
            exit 0
        ;;
        "m") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请先安装 !" && exit 1
            [ ! -d "${MONITOR_LOG%/*}" ] && MONITOR_LOG="$HOME/monitor.log"

            cmd=${2:-}

            case $cmd in
                "s"|"stop") 
                    MonitorStop
                ;;
                "l"|"log")
                    if [ -s "$MONITOR_LOG" ] 
                    then
                        Println "$info 监控日志: "
                        count=0
                        log=""
                        last_line=""
                        printf -v this_hour '%(%H)T' -1
                        while IFS= read -r line 
                        do
                            if [ "$count" -lt "${3:-10}" ] 
                            then
                                message=${line#* }
                                message=${message#* }
                                if [ -z "$last_line" ] 
                                then
                                    count=$((count+1))
                                    log=$line
                                    last_line=$message
                                elif [ "$message" != "$last_line" ] 
                                then
                                    count=$((count+1))
                                    log="$line\n$log"
                                    last_line="$message"
                                fi
                            fi

                            if [ "${line:2:1}" == "-" ] 
                            then
                                hour=${line:6:2}
                            elif [ "${line:2:1}" == ":" ] 
                            then
                                hour=${line:0:2}
                            fi

                            if [ -n "${hour:-}" ] && [ "$hour" != "$this_hour" ] && [ "$count" -eq "${3:-10}" ] 
                            then
                                break
                            elif [ -n "${hour:-}" ] && [ "$hour" == "$this_hour" ] && [[ $line == *"计划重启时间"* ]]
                            then
                                [ -z "${found_line:-}" ] && found_line=$line
                            fi
                        done < <(awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }' "$MONITOR_LOG")
                        Println "$log"
                        [ -n "${found_line:-}" ] && Println "${green}${found_line#* }${normal}"
                    fi
                    if [ -s "$IP_LOG" ] 
                    then
                        Println "$info AntiDDoS 日志: "
                        tail -n 10 "$IP_LOG"
                    fi
                    if [ ! -s "$MONITOR_LOG" ] && [ ! -s "$IP_LOG" ]
                    then
                        Println "$error 无日志\n"
                    fi
                ;;
                *) 
                    if [ -s "$IPTV_ROOT/monitor.pid" ] || [ -s "$IPTV_ROOT/antiddos.pid" ]
                    then
                        Println "$error 监控已经在运行 !\n" && exit 1
                    else
                        if { [ -d "/usr/local/openresty" ] && [ ! -d "/usr/local/nginx" ]; } || { [ -s "/usr/local/openresty/nginx/logs/nginx.pid" ] && kill -0 "$(< "/usr/local/openresty/nginx/logs/nginx.pid")" 2> /dev/null ; }
                        then
                            nginx_prefix="/usr/local/openresty/nginx"
                            nginx_name="openresty"
                            nginx_ctl="or"
                        elif { [ -d "/usr/local/nginx" ] && [ ! -d "/usr/local/openresty" ]; } || { [ -s "/usr/local/nginx/logs/nginx.pid" ] && kill -0 "$(< "/usr/local/nginx/logs/nginx.pid")" 2> /dev/null ; }
                        then
                            nginx_prefix="/usr/local/nginx"
                            nginx_name="nginx"
                            nginx_ctl="nx"
                        else
                            echo
                            inquirer list_input "没有检测到运行的 nginx, 是否使用 openresty" ny_options use_openresty_yn

                            if [[ $use_openresty_yn == "$i18n_yes" ]] 
                            then
                                nginx_prefix="/usr/local/openresty/nginx"
                                nginx_name="openresty"
                                nginx_ctl="or"
                            else
                                nginx_prefix="/usr/local/nginx"
                                nginx_name="nginx"
                                nginx_ctl="nx"
                            fi
                        fi

                        NGINX_FILE="$nginx_prefix/sbin/nginx"
                        printf -v date_now '%(%m-%d %H:%M:%S)T' -1
                        MonitorSet

                        i18nGetMsg get_channel

                        if [ "$sh_debug" -eq 1 ] 
                        then
                            ( Monitor ) 
                        else
                            ( Monitor ) > /dev/null 2>> "$MONITOR_LOG" < /dev/null &
                        fi

                        Println "$info 监控启动成功 !\n"
                        AntiDDoSSet

                        if [ "$sh_debug" -eq 1 ] 
                        then
                            ( AntiDDoS ) 
                        else
                            ( AntiDDoS ) > /dev/null 2>> "$MONITOR_LOG" < /dev/null &
                        fi

                        Println "$info AntiDDoS 启动成功 !\n"
                        rm -f "$IPTV_ROOT/ip.pid"
                    fi
                ;;
            esac
            exit 0
        ;;
        "e") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            vim "$CHANNELS_FILE" && exit 0
        ;;
        "ee") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            GetDefault
            [ -z "$d_sync_file" ] && Println "$error sync_file 未设置, 请检查 !\n" && exit 1
            vim "${d_sync_file%% *}" && exit 0
        ;;
        "d")
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            channels=""
            while IFS= read -r line 
            do
                if [[ $line == *\"pid\":* ]] 
                then
                    pid=${line#*:}
                    pid=${pid%,*}
                    rand_pid=$pid
                    while [[ -n $($JQ_FILE '.channels[]|select(.pid=='"$rand_pid"')' "$CHANNELS_FILE") ]] 
                    do
                        true &
                        rand_pid=$!
                    done
                    line=${line//$pid/$rand_pid}
                fi
                channels="$channels$line"
            done < <(curl -s -Lm 20 "$DEFAULT_DEMOS")
            [ -z "$channels" ] && Println "$error 暂时无法连接服务器, 请稍后再试 !\n" && exit 1
            delimiters=( $'\001' )
            IFS=$'\001' read -r -a channels_name < <(JQs flat "$channels" '' '.channel_name' "${delimiters[@]}")
            echo
            channels_name+=("全部")
            inquirer list_input "选择添加的频道" channels_name channel_name
            if [ "$channel_name" != "全部" ] 
            then
                channels=$($JQ_FILE '[.[]|select(.channel_name=="'"$channel_name"'")]' <<< "$channels")
            fi
            JQ add "$CHANNELS_FILE" channels "$channels"
            Println "$info 频道添加成功 !\n"
            exit 0
        ;;
        "ffmpeg") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1

            if [[ ! -x $(command -v curl) ]] || [ ! -e "$JQ_FILE" ]
            then
                DepsCheck
            fi

            if [ ! -e "$JQ_FILE" ] 
            then
                JQInstall
            fi

            mkdir -p "$FFMPEG_MIRROR_ROOT/builds"
            mkdir -p "$FFMPEG_MIRROR_ROOT/releases"

            git_download=0
            release_download=0
            git_version_old=""
            release_version_old=""

            if [ -e "$FFMPEG_MIRROR_ROOT/index.html" ] 
            then
                while IFS= read -r line
                do
                    if [[ $line == *"<th>"* ]] 
                    then
                        if [[ $line == *"git"* ]] 
                        then
                            git_version_old=$line
                        else
                            release_version_old=$line
                        fi
                    fi
                done < "$FFMPEG_MIRROR_ROOT/index.html"
            fi

            if curl -s -L "https://www.johnvansickle.com/ffmpeg/index.html" -o "$FFMPEG_MIRROR_ROOT/index.html_tmp" 
            then
                mv "$FFMPEG_MIRROR_ROOT/index.html_tmp" "$FFMPEG_MIRROR_ROOT/index.html"
                curl -s -L "https://www.johnvansickle.com/ffmpeg/style.css" -o "$FFMPEG_MIRROR_ROOT/style.css"
            else
                Println "$error ffmpeg 查询新版本出错, 无法连接 johnvansickle.com ?"
            fi

            if [ -e "$FFMPEG_MIRROR_ROOT/index.html" ] 
            then
                while IFS= read -r line
                do
                    if [[ $line == *"<th>"* ]] 
                    then
                        if [[ $line == *"git"* ]] 
                        then
                            git_version_new=$line
                            if [ "$git_version_new" != "$git_version_old" ] || [ ! -e "$FFMPEG_MIRROR_ROOT/builds/ffmpeg-git-amd64-static.tar.xz" ]
                            then
                                git_download=1
                            fi
                        else
                            release_version_new=$line
                            [ "$release_version_new" != "$release_version_old" ] && release_download=1
                        fi
                    fi

                    if [[ $line == *"tar.xz"* ]]  
                    then
                        if [[ $line == *"git"* ]] && [ "$git_download" -eq 1 ]
                        then
                            line=${line#*<td><a href=\"}
                            git_link=${line%%\" style*}
                            build_file_name=${git_link##*/}
                            if [ "$git_version_new" != "$git_version_old" ] || [ ! -e "$FFMPEG_MIRROR_ROOT/builds/${build_file_name}" ]
                            then
                                Println "$info 下载 $build_file_name ..."
                                if curl -s -L "$git_link" -o "$FFMPEG_MIRROR_ROOT/builds/${build_file_name}_tmp"
                                then
                                    mv "$FFMPEG_MIRROR_ROOT/builds/${build_file_name}_tmp" "$FFMPEG_MIRROR_ROOT/builds/${build_file_name}"
                                else
                                    Println "$error ffmpeg git build 下载出错, 无法连接 github ?"
                                fi
                            fi
                        else 
                            if [ "$release_download" -eq 1 ] 
                            then
                                line=${line#*<td><a href=\"}
                                release_link=${line%%\" style*}
                                release_file_name=${release_link##*/}
                                if [ "$release_version_new" != "$release_version_old" ] || [ ! -e "$FFMPEG_MIRROR_ROOT/releases/${release_file_name}" ]
                                then
                                    Println "$info 下载 $release_file_name ..."
                                    if curl -s -L "$release_link" -o "$FFMPEG_MIRROR_ROOT/releases/${release_file_name}_tmp"
                                    then
                                        mv "$FFMPEG_MIRROR_ROOT/releases/${release_file_name}_tmp" "$FFMPEG_MIRROR_ROOT/releases/${release_file_name}"
                                    else
                                        Println "$error ffmpeg release build 下载出错, 无法连接 github ?"
                                    fi
                                fi
                            fi
                        fi
                    fi
                done < "$FFMPEG_MIRROR_ROOT/index.html"

                #Println "输入镜像网站链接(比如: $FFMPEG_MIRROR_LINK)"
                #read -p "$i18n_default_cancel" FFMPEG_LINK
                #[ -z "$FFMPEG_LINK" ] && echo "$i18n_canceled...\n" && exit 1
                #sed -i "s+https://johnvansickle.com/ffmpeg/\(builds\|releases\)/\(.*\).tar.xz\"+$FFMPEG_LINK/\1/\2.tar.xz\"+g" "$FFMPEG_MIRROR_ROOT/index.html"

                sed -i "s+https://johnvansickle.com/ffmpeg/\(builds\|releases\)/\(.*\).tar.xz\"+\1/\2.tar.xz\"+g" "$FFMPEG_MIRROR_ROOT/index.html"
            fi

            while IFS= read -r line
            do
                if [[ $line == *"latest stable release is"* ]] 
                then
                    line=${line#*<a href=\"}
                    poppler_name=${line%%.tar.xz*}
                    poppler_name="poppler-0.81.0"
                    if [ ! -e "$FFMPEG_MIRROR_ROOT/$poppler_name.tar.xz" ] 
                    then
                        Println "$info 下载 poppler ..."
                        rm -f "$FFMPEG_MIRROR_ROOT/poppler-"*.tar.xz
                        if curl -s -L "https://poppler.freedesktop.org/$poppler_name.tar.xz" -o "$FFMPEG_MIRROR_ROOT/$poppler_name.tar.xz_tmp" 
                        then
                            mv "$FFMPEG_MIRROR_ROOT/$poppler_name.tar.xz_tmp" "$FFMPEG_MIRROR_ROOT/$poppler_name.tar.xz"
                        else
                            Println "$error poppler 下载出错"
                        fi
                    fi
                elif [[ $line == *"poppler encoding data"* ]] 
                then
                    line=${line#*<a href=\"}
                    poppler_data_name=${line%%.tar.gz*}
                    if [ ! -e "$FFMPEG_MIRROR_ROOT/$poppler_data_name.tar.gz" ] 
                    then
                        Println "$info 下载 poppler-data ..."
                        rm -f "$FFMPEG_MIRROR_ROOT/poppler-data-"*.tar.gz
                        if curl -s -L "https://poppler.freedesktop.org/$poppler_data_name.tar.gz" -o "$FFMPEG_MIRROR_ROOT/$poppler_data_name.tar.gz_tmp"
                        then
                            mv "$FFMPEG_MIRROR_ROOT/$poppler_data_name.tar.gz_tmp" "$FFMPEG_MIRROR_ROOT/$poppler_data_name.tar.gz"
                        else
                            Println "$error poppler-data 下载出错"
                        fi
                    fi
                    break
                fi
            done < <(curl -s -Lm 20 "https://poppler.freedesktop.org/" 2> /dev/null)

            if jq_ver=$(curl -s -Lm 20 "https://api.github.com/repos/stedolan/jq/releases/latest" | $JQ_FILE -r '.tag_name')
            then
                if [ ! -e "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux64" ] || [ ! -e "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux32" ] 
                then
                    Println "$info 下载 jq ..."
                    rm -f "$FFMPEG_MIRROR_ROOT/jq-"*
                    mkdir -p "$FFMPEG_MIRROR_ROOT/$jq_ver/"
                    if curl -s -L "https://github.com/stedolan/jq/releases/download/$jq_ver/jq-linux64" -o "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux64_tmp" && curl -s -L "https://github.com/stedolan/jq/releases/download/$jq_ver/jq-linux32" -o "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux32_tmp"
                    then
                        mv "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux64_tmp" "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux64"
                        mv "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux32_tmp" "$FFMPEG_MIRROR_ROOT/$jq_ver/jq-linux32"
                    else
                        Println "$error jq 下载出错, 无法连接 github ?"
                    fi
                fi
            else
                Println "$error jq 下载出错, 无法连接 github ?"
            fi

            if v2ray_ver=$(curl -s -m 30 "https://api.github.com/repos/v2fly/v2ray-core/releases/latest" | $JQ_FILE -r '.tag_name') 
            then
                if [ ! -e "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-64.zip" ] || [ ! -e "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-32.zip" ] 
                then
                    Println "$info 下载 v2ray $v2ray_ver ..."
                    mkdir -p "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/"
                    if curl -s -L "https://github.com/v2fly/v2ray-core/releases/download/$v2ray_ver/v2ray-linux-64.zip" -o "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-64.zip_tmp" \
                    && curl -s -L "https://github.com/v2fly/v2ray-core/releases/download/$v2ray_ver/v2ray-linux-32.zip" -o "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-32.zip_tmp" \
                    && curl -s -L "https://github.com/v2fly/v2ray-core/releases/download/$v2ray_ver/v2ray-linux-64.zip.dgst" -o "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-64.zip.dgst_tmp" \
                    && curl -s -L "https://github.com/v2fly/v2ray-core/releases/download/$v2ray_ver/v2ray-linux-32.zip.dgst" -o "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-32.zip.dgst_tmp"
                    then
                        mv "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-64.zip_tmp" "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-64.zip"
                        mv "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-32.zip_tmp" "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-32.zip"
                        mv "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-64.zip.dgst_tmp" "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-64.zip.dgst"
                        mv "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-32.zip.dgst_tmp" "$FFMPEG_MIRROR_ROOT/v2ray/$v2ray_ver/v2ray-linux-32.zip.dgst"
                    else
                        Println "$error v2ray $v2ray_ver 下载出错, 无法连接 github ?"
                    fi
                fi
            else
                Println "$error v2ray $v2ray_ver 下载出错, 无法连接 github ?"
            fi

            if xray_ver=$(curl -s -m 30 "https://api.github.com/repos/XTLS/Xray-core/releases/latest" | $JQ_FILE -r '.tag_name') 
            then
                if [ ! -e "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-64.zip" ] || [ ! -e "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-32.zip" ] 
                then
                    Println "$info 下载 xray $xray_ver ..."
                    mkdir -p "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/"
                    if curl -s -L "https://github.com/XTLS/Xray-core/releases/download/$xray_ver/Xray-linux-64.zip" -o "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-64.zip_tmp" \
                    && curl -s -L "https://github.com/XTLS/Xray-core/releases/download/$xray_ver/Xray-linux-32.zip" -o "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-32.zip_tmp" \
                    && curl -s -L "https://github.com/XTLS/Xray-core/releases/download/$xray_ver/Xray-linux-64.zip.dgst" -o "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-64.zip.dgst_tmp" \
                    && curl -s -L "https://github.com/XTLS/Xray-core/releases/download/$xray_ver/Xray-linux-32.zip.dgst" -o "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-32.zip.dgst_tmp"
                    then
                        mv "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-64.zip_tmp" "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-64.zip"
                        mv "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-32.zip_tmp" "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-32.zip"
                        mv "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-64.zip.dgst_tmp" "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-64.zip.dgst"
                        mv "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-32.zip.dgst_tmp" "$FFMPEG_MIRROR_ROOT/xray/$xray_ver/Xray-linux-32.zip.dgst"
                    else
                        Println "$error xray $xray_ver 下载出错, 无法连接 github ?"
                    fi
                fi
            else
                Println "$error xray $xray_ver 下载出错, 无法连接 github ?"
            fi

            if xray_ver=$(curl -s -m 30 "https://api.github.com/repos/woniuzfb/openwrt-xray/releases/latest" | $JQ_FILE -r '.tag_name') 
            then
                xray_ver=${xray_ver#*v}
                if [[ ! $xray_ver =~ - ]] 
                then
                    xray_package_ver="${xray_ver}-1"
                else
                    xray_package_ver="$xray_ver"
                fi
                xray_archs=( 'x86_64' 'aarch64_generic' )
                for arch in "${xray_archs[@]}"
                do
                    if [ ! -e "$FFMPEG_MIRROR_ROOT/xray_${xray_package_ver}_$arch.ipk" ] 
                    then
                        Println "$info 下载 xray_${xray_package_ver}_$arch.ipk ..."
                        if curl -s -L "https://github.com/woniuzfb/openwrt-xray/releases/download/v$xray_ver/xray_${xray_package_ver}_$arch.ipk" -o "$FFMPEG_MIRROR_ROOT/xray_${xray_package_ver}_$arch.ipk_tmp"
                        then
                            mv "$FFMPEG_MIRROR_ROOT/xray_${xray_package_ver}_$arch.ipk_tmp" "$FFMPEG_MIRROR_ROOT/xray_${xray_package_ver}_$arch.ipk"
                        else
                            Println "$error xray_${xray_package_ver}_$arch.ipk 下载出错, 无法连接 github ?"
                        fi
                    fi
                done
            else
                Println "$error openwrt-xray 下载出错, 无法连接 github ?"
            fi

            IFS=" " read -r luci_app_xray_ver xray_i18n_name < <(curl -s -m 30 "https://api.github.com/repos/woniuzfb/luci-app-xray/releases/latest" | $JQ_FILE -r '[.tag_name,.assets[1].name]|join(" ")')
            if [ -n "${luci_app_xray_ver:-}" ]
            then
                luci_app_xray_ver=${luci_app_xray_ver#*v}
                Println "$info 下载 luci-app-v2ray_${luci_app_xray_ver}_all.ipk ..."
                if curl -s -L "https://github.com/woniuzfb/luci-app-xray/releases/download/v$luci_app_xray_ver/luci-app-v2ray_${luci_app_xray_ver}_all.ipk" -o "$FFMPEG_MIRROR_ROOT/luci-app-v2ray_${luci_app_xray_ver}_all.ipk_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/luci-app-v2ray_${luci_app_xray_ver}_all.ipk_tmp" "$FFMPEG_MIRROR_ROOT/luci-app-v2ray_${luci_app_xray_ver}_all.ipk"
                else
                    Println "$error luci-app-v2ray_${luci_app_xray_ver}_all.ipk 下载出错, 无法连接 github ?"
                fi
                Println "$info 下载 $xray_i18n_name ..."
                if curl -s -L "https://github.com/woniuzfb/luci-app-xray/releases/download/v$luci_app_xray_ver/$xray_i18n_name" -o "$FFMPEG_MIRROR_ROOT/${xray_i18n_name}_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/${xray_i18n_name}_tmp" "$FFMPEG_MIRROR_ROOT/luci-i18n-v2ray-zh-cn_${luci_app_xray_ver}_all.ipk"
                else
                    Println "$error $xray_i18n_name 下载出错, 无法连接 github ?"
                fi
            else
                Println "$error luci-app-xray 下载出错, 无法连接 github ?"
            fi

            if dnscrypt_ver=$(curl -s -m 30 "https://api.github.com/repos/DNSCrypt/dnscrypt-proxy/releases/latest" | $JQ_FILE -r '.tag_name') 
            then
                if [ ! -e "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_arm64-$dnscrypt_ver.tar.gz" ]
                then
                    Println "$info 下载 dnscrypt proxy arm64 ..."
                    mkdir -p "$FFMPEG_MIRROR_ROOT/dnscrypt/"
                    if curl -s -L "https://github.com/DNSCrypt/dnscrypt-proxy/releases/download/$dnscrypt_ver/dnscrypt-proxy-linux_arm64-$dnscrypt_ver.tar.gz" -o "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_arm64-$dnscrypt_ver.tar.gz_tmp"
                    then
                        mv "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_arm64-$dnscrypt_ver.tar.gz_tmp" "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_arm64-$dnscrypt_ver.tar.gz"
                    else
                        Println "$error dnscrypt arm64 下载出错, 无法连接 github ?"
                    fi
                fi
                if [ ! -e "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_x86_64-$dnscrypt_ver.tar.gz" ]
                then
                    Println "$info 下载 dnscrypt proxy x86_64 ..."
                    mkdir -p "$FFMPEG_MIRROR_ROOT/dnscrypt/"
                    if curl -s -L "https://github.com/DNSCrypt/dnscrypt-proxy/releases/download/$dnscrypt_ver/dnscrypt-proxy-linux_x86_64-$dnscrypt_ver.tar.gz" -o "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_x86_64-$dnscrypt_ver.tar.gz_tmp"
                    then
                        mv "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_x86_64-$dnscrypt_ver.tar.gz_tmp" "$FFMPEG_MIRROR_ROOT/dnscrypt/dnscrypt-proxy-linux_x86_64-$dnscrypt_ver.tar.gz"
                    else
                        Println "$error dnscrypt x86_64 下载出错, 无法连接 github ?"
                    fi
                fi
            else
                Println "$error dnscrypt 下载出错, 无法连接 github ?"
            fi

            Println "$info 下载 nginx-http-flv-module ..."
            if curl -s -L "https://github.com/winshining/nginx-http-flv-module/archive/master.zip" -o "$FFMPEG_MIRROR_ROOT/nginx-http-flv-module.zip_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/nginx-http-flv-module.zip_tmp" "$FFMPEG_MIRROR_ROOT/nginx-http-flv-module.zip"
            else
                Println "$error nginx-http-flv-module 下载出错, 无法连接 github ?"
            fi

            Println "$info 下载 imgcat ..."
            if curl -s -L "https://github.com/eddieantonio/imgcat/archive/master.zip" -o "$FFMPEG_MIRROR_ROOT/imgcat.zip_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/imgcat.zip_tmp" "$FFMPEG_MIRROR_ROOT/imgcat.zip"
            else
                Println "$error imgcat 下载出错, 无法连接 github ?"
            fi

            Println "$info 下载 CImg ..."
            if curl -s -L "https://github.com/dtschump/CImg/archive/master.zip" -o "$FFMPEG_MIRROR_ROOT/CImg.zip_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/CImg.zip_tmp" "$FFMPEG_MIRROR_ROOT/CImg.zip"
            else
                Println "$error CImg 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/stedolan/jq/releases/latest" -o "$FFMPEG_MIRROR_ROOT/jq.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/jq.json_tmp" "$FFMPEG_MIRROR_ROOT/jq.json"
            else
                Println "$error jq.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/v2fly/v2ray-core/releases/latest" -o "$FFMPEG_MIRROR_ROOT/v2ray.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/v2ray.json_tmp" "$FFMPEG_MIRROR_ROOT/v2ray.json"
            else
                Println "$error v2ray.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/XTLS/Xray-core/releases/latest" -o "$FFMPEG_MIRROR_ROOT/xray.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/xray.json_tmp" "$FFMPEG_MIRROR_ROOT/xray.json"
            else
                Println "$error xray.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/woniuzfb/openwrt-xray/releases/latest" -o "$FFMPEG_MIRROR_ROOT/openwrt-xray.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/openwrt-xray.json_tmp" "$FFMPEG_MIRROR_ROOT/openwrt-xray.json"
            else
                Println "$error openwrt-xray.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/woniuzfb/luci-app-xray/releases/latest" -o "$FFMPEG_MIRROR_ROOT/luci-app-xray.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/luci-app-xray.json_tmp" "$FFMPEG_MIRROR_ROOT/luci-app-xray.json"
            else
                Println "$error luci-app-xray.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://api.github.com/repos/DNSCrypt/dnscrypt-proxy/releases/latest" -o "$FFMPEG_MIRROR_ROOT/dnscrypt.json_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/dnscrypt.json_tmp" "$FFMPEG_MIRROR_ROOT/dnscrypt.json"
            else
                Println "$error dnscrypt.json 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim" -o "$FFMPEG_MIRROR_ROOT/vim-plug.vim_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/vim-plug.vim_tmp" "$FFMPEG_MIRROR_ROOT/vim-plug.vim"
            else
                Println "$error vim-plug.vim 下载出错, 无法连接 github ?"
            fi

            if [ ! -e "$FFMPEG_MIRROR_ROOT/openssl-1.1.1f-sess_set_get_cb_yield.patch" ]
            then
                if curl -s -L "https://raw.githubusercontent.com/openresty/openresty/master/patches/openssl-1.1.1f-sess_set_get_cb_yield.patch" -o "$FFMPEG_MIRROR_ROOT/openssl-1.1.1f-sess_set_get_cb_yield.patch_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/openssl-1.1.1f-sess_set_get_cb_yield.patch_tmp" "$FFMPEG_MIRROR_ROOT/openssl-1.1.1f-sess_set_get_cb_yield.patch"
                else
                    Println "$error openssl patch 下载出错, 无法连接 github ?"
                fi
            fi

            if [ ! -e "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch" ] 
            then
                if curl -s -L "https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch" -o "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch_tmp" "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch"
                else
                    Println "$error Add-SVT-HEVC-support-for-RTMP-and-HLS-on-Nginx-HTTP-FLV.patch 下载出错, 无法连接 github ?"
                fi
            fi

            if curl -s -L "https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch" -o "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch_tmp" "$FFMPEG_MIRROR_ROOT/Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch"
            else
                Println "$error Add-SVT-HEVC-FLV-support-on-FFmpeg-git.patch 下载出错, 无法连接 github ?"
            fi

            if curl -s -L "https://raw.githubusercontent.com/woniuzfb/iptv/master/scripts/fix_ngx_lua_resp_get_headers_key_whitespace.patch" -o "$FFMPEG_MIRROR_ROOT/fix_ngx_lua_resp_get_headers_key_whitespace.patch_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/fix_ngx_lua_resp_get_headers_key_whitespace.patch_tmp" "$FFMPEG_MIRROR_ROOT/fix_ngx_lua_resp_get_headers_key_whitespace.patch"
            else
                Println "$error fix_ngx_lua_resp_get_headers_key_whitespace.patch 下载出错, 无法连接 github ?"
            fi

            if [ ! -e "$FFMPEG_MIRROR_ROOT/fontforge-20190413.tar.gz" ] 
            then
                if curl -s -L "https://github.com/fontforge/fontforge/releases/download/20190413/fontforge-20190413.tar.gz" -o "$FFMPEG_MIRROR_ROOT/fontforge-20190413.tar.gz_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/fontforge-20190413.tar.gz_tmp" "$FFMPEG_MIRROR_ROOT/fontforge-20190413.tar.gz"
                else
                    Println "$error fontforge 下载出错, 无法连接 github ?"
                fi
            fi

            Println "$info 下载 pdf2htmlEX ..."
            if [ ! -e "$FFMPEG_MIRROR_ROOT/pdf2htmlEX-0.18.7-poppler-0.81.0.zip" ] 
            then
                if curl -s -L "https://github.com/pdf2htmlEX/pdf2htmlEX/archive/v0.18.7-poppler-0.81.0.zip" -o "$FFMPEG_MIRROR_ROOT/pdf2htmlEX-0.18.7-poppler-0.81.0.zip_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/pdf2htmlEX-0.18.7-poppler-0.81.0.zip_tmp" "$FFMPEG_MIRROR_ROOT/pdf2htmlEX-0.18.7-poppler-0.81.0.zip"
                else
                    Println "$error pdf2htmlEX 下载出错, 无法连接 github ?"
                fi
            fi

            Println "$info 下载 v2ray install-release.sh ..."
            if curl -s -L "$V2_LINK" -o "$FFMPEG_MIRROR_ROOT/v2ray_install-release.sh_tmp"
            then
                mv "$FFMPEG_MIRROR_ROOT/v2ray_install-release.sh_tmp" "$FFMPEG_MIRROR_ROOT/v2ray_install-release.sh"
            else
                Println "$error v2ray install-release.sh 下载出错, 无法连接 github ?"
            fi

            locale_options=( en )
            mkdir -p "$FFMPEG_MIRROR_ROOT/locale/po/"

            for locale in "${locale_options[@]}"
            do
                Println "$info 下载 $locale 语言文件 ..."
                if curl -s -L "https://raw.githubusercontent.com/woniuzfb/iptv/master/i18n/po/iptv.sh-$locale.mo" -o "$FFMPEG_MIRROR_ROOT/locale/po/iptv.sh-$locale.mo_tmp"
                then
                    mv "$FFMPEG_MIRROR_ROOT/locale/po/iptv.sh-$locale.mo_tmp" "$FFMPEG_MIRROR_ROOT/locale/po/iptv.sh-$locale.mo"
                else
                    Println "$error iptv.sh-$locale.mo 下载出错, 无法连接 github ?"
                fi
            done

            exit 0
        ;;
        "ts") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            TsMenu
            exit 0
        ;;
        "f"|"flv") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            kind="flv"
            color="$blue"
            shift
        ;;
        "v"|"vip") 
            [ ! -d "$IPTV_ROOT" ] && Println "$error 尚未安装, 请检查 !\n" && exit 1
            vip=1
            shift
        ;;
        "l"|"ll") 
            flv_count=0
            chnls_channel_name=()
            chnls_stream_link=()
            chnls_flv_pull_link=()
            while IFS= read -r flv_channel
            do
                flv_count=$((flv_count+1))
                map_channel_name=${flv_channel#*channel_name: }
                map_channel_name=${map_channel_name%, stream_link:*}
                map_stream_link=${flv_channel#*, stream_link: }
                map_stream_link=${map_stream_link%, flv_pull_link:*}
                map_flv_pull_link=${flv_channel#*, flv_pull_link: }
                map_flv_pull_link=${map_flv_pull_link%\"}

                chnls_channel_name+=("$map_channel_name")
                chnls_stream_link+=("${map_stream_link// /, }")
                chnls_flv_pull_link+=("${map_flv_pull_link}")
            done < <($JQ_FILE '.channels | to_entries | map(select(.value.flv_status=="on")) | map("channel_name: \(.value.channel_name), stream_link: \(.value.stream_link), flv_pull_link: \(.value.flv_pull_link)") | .[]' "$CHANNELS_FILE")

            if [ "$flv_count" -gt 0 ] 
            then

                Println "FLV 频道"
                result=""
                for((i=0;i<flv_count;i++));
                do
                    chnl_flv_pull_link=${chnls_flv_pull_link[i]}
                    result=$result"  ${green}$((i+1)).${normal}${indent_6}${green}${chnls_channel_name[i]}${normal}\n${indent_6}源: ${chnls_stream_link[i]}\n${indent_6}pull: ${chnl_flv_pull_link:-无}\n\n"
                done
                Println "$result"
            fi


            hls_count=0
            chnls_channel_name=()
            chnls_stream_link=()
            chnls_output_dir_name=()
            while IFS= read -r hls_channel
            do
                hls_count=$((hls_count+1))
                map_channel_name=${hls_channel#*channel_name: }
                map_channel_name=${map_channel_name%, stream_link:*}
                map_stream_link=${hls_channel#*stream_link: }
                map_stream_link=${map_stream_link%, output_dir_name:*}
                map_output_dir_name=${hls_channel#*output_dir_name: }
                map_output_dir_name=${map_output_dir_name%\"}

                chnls_channel_name+=("$map_channel_name")
                chnls_stream_link+=("${map_stream_link// /, }")
                chnls_output_dir_name+=("$map_output_dir_name")
            done < <($JQ_FILE '.channels | to_entries | map(select(.value.status=="on")) | map("channel_name: \(.value.channel_name), stream_link: \(.value.stream_link), output_dir_name: \(.value.output_dir_name)") | .[]' "$CHANNELS_FILE")

            if [ "$hls_count" -gt 0 ] 
            then
                Println "HLS 频道"
                result=""
                for((i=0;i<hls_count;i++));
                do
                    result=$result"  ${green}$((i+1)).${normal}${indent_6}${green}${chnls_channel_name[i]}${normal}\n${indent_6}源: ${chnls_stream_link[i]}\n\n"
                done
                Println "$result"
            fi

            echo 

            for((i=0;i<hls_count;i++));
            do
                echo -e "  ${green}$((i+1)).${normal}${indent_6}${chnls_channel_name[i]} ${chnls_stream_link[i]}"
                if [ -e "$LIVE_ROOT/${chnls_output_dir_name[i]}" ] 
                then
                    if ls -A "$LIVE_ROOT/${chnls_output_dir_name[i]}"/* > /dev/null 2>&1 
                    then
                        ls "$LIVE_ROOT/${chnls_output_dir_name[i]}"/* -lght && echo
                    else
                        Println "$error 无\n"
                    fi
                else
                    Println "$error 目录不存在\n"
                fi
            done

            if ls -A $LIVE_ROOT/* > /dev/null 2>&1 
            then
                for output_dir_root in "$LIVE_ROOT"/*
                do
                    output_dir_name=${output_dir_root#*$LIVE_ROOT/}
                    for((i=0;i<hls_count;i++));
                    do
                        if [ "$output_dir_name" == "${chnls_output_dir_name[i]}" ] 
                        then
                            continue 2
                        fi
                    done
                    Println "$error 未知目录 $output_dir_name\n"
                    if ls -A "$output_dir_root"/* > /dev/null 2>&1 
                    then
                        ls "$output_dir_root"/* -lght
                    fi
                done
            fi

            if [ "$flv_count" -eq 0 ] && [ "$hls_count" -eq 0 ]
            then
                Println "$error 没有开启的频道 !\n" && exit 1
            fi

            exit 0
        ;;
        "debug")
            sed -i "0,/sh_debug=.*/s//sh_debug=${2:-1}/" "$SH_FILE"
            exit 0
        ;;
        "c")
            to_locale=${2:-}
            new_locale=""

            if [ -n "$to_locale" ] 
            then
                new_locale=${to_locale%.*}

                if [[ $new_locale =~ ^(.+)[-|_](.+)$ ]] 
                then
                    new_locale=$(tr '[:upper:]' '[:lower:]' <<< "${BASH_REMATCH[1]}")_$(tr '[:lower:]' '[:upper:]' <<< "${BASH_REMATCH[2]}")
                else
                    new_locale=$(tr '[:upper:]' '[:lower:]' <<< "$new_locale")
                fi

                if [[ $to_locale =~ \. ]] 
                then
                    new_locale="$new_locale.${to_locale#*.}"
                fi
            fi

            i18nInstall "$new_locale"
            exit 0
        ;;
        *)
        ;;
    esac
fi

if [ -z "$*" ]
then
    ShFileCheck
    if [ "${vip:-0}" -eq 1 ] 
    then
        VipMenu
    else
        Menu
    fi
else
    while getopts "i:l:P:o:p:S:t:s:c:v:a:f:d:q:b:k:K:m:n:z:H:T:L:Ce" flag
    do
        case "$flag" in
            i) stream_link="$OPTARG";;
            l) live_yn="no";;
            P) proxy="$OPTARG";;
            o) output_dir_name="$OPTARG";;
            p) playlist_name="$OPTARG";;
            S) seg_dir_name="$OPTARG";;
            t) seg_name="$OPTARG";;
            s) seg_length="$OPTARG";;
            c) seg_count="$OPTARG";;
            v) video_codec="$OPTARG";;
            a) audio_codec="$OPTARG";;
            f) video_audio_shift="$OPTARG";;
            d) txt_format="$OPTARG";;
            q) quality="$OPTARG";;
            b) bitrates="$OPTARG";;
            C) const="-C";;
            e) encrypt="-e";;
            k) kind="$OPTARG";;
            K) key_name="$OPTARG";;
            m) input_flags="$OPTARG";;
            n) output_flags="$OPTARG";;
            z) channel_name="$OPTARG";;
            H) flv_h265_yn="yes";;
            T) flv_push_link="$OPTARG";;
            L) flv_pull_link="$OPTARG";;
            *) Usage;
        esac
    done
    if [ -z "${stream_link:-}" ]
    then
        Usage
    else
        if [ ! -d "$IPTV_ROOT" ]
        then
            echo
            AskIfContinue n "`gettext \"尚未安装, 是否现在安装\"`"
            Install
        else
            FFMPEG_ROOT=$(dirname "$IPTV_ROOT"/ffmpeg-git-*/ffmpeg)
            FFMPEG="$FFMPEG_ROOT/ffmpeg"
            GetDefault
            export FFMPEG

            stream_links=$stream_link
            stream_link=${stream_link%% *}

            if [ -z "${proxy:-}" ] 
            then
                if [[ $stream_link =~ ^https?:// ]] && [ -n "$d_proxy" ] 
                then
                    echo
                    inquirer list_input "`eval_gettext \"是否使用代理 \\\$d_proxy: \"`" yn_options use_proxy_yn
                    if [[ $use_proxy_yn == "$i18n_yes" ]]
                    then
                        proxy=$d_proxy
                    else
                        proxy=""
                    fi
                else
                    proxy=""
                fi
            fi

            if [ -z "${xc_proxy:-}" ] 
            then
                if [ -n "$d_xc_proxy" ] 
                then
                    if [[ $stream_link =~ ^http://([^/]+) ]] 
                    then
                        XtreamCodesGetDomains

                        xc_proxy=""
                        for xc_domain in "${xtream_codes_domains[@]}"
                        do
                            if [ "$xc_domain" == "${BASH_REMATCH[1]}" ] 
                            then
                                echo
                                inquirer list_input "`eval_gettext \"是否使用 xtream codes 代理 \\\$d_xc_proxy: \"`" yn_options use_proxy_yn
                                if [[ $use_proxy_yn == "$i18n_yes" ]]
                                then
                                    xc_proxy=$d_xc_proxy
                                else
                                    xc_proxy=""
                                fi
                                break
                            fi
                        done
                    else
                        xc_proxy=""
                    fi
                else
                    xc_proxy=""
                fi
            fi

            user_agent=$d_user_agent
            headers=$d_headers
            while [[ $headers =~ \\\\ ]]
            do
                headers=${headers//\\\\/\\}
            done
            if [ -n "$headers" ] && [[ ! $headers =~ \\r\\n$ ]]
            then
                headers="$headers\r\n"
            fi
            cookies=$d_cookies
            output_dir_name=${output_dir_name:-$(RandOutputDirName)}
            output_dir_root="$LIVE_ROOT/$output_dir_name"
            playlist_name=${playlist_name:-$(RandPlaylistName)}
            seg_dir_name=${seg_dir_name:-$d_seg_dir_name}
            seg_name=${seg_name:-$playlist_name}
            seg_length=${seg_length:-$d_seg_length}
            seg_count=${seg_count:-$d_seg_count}
            audio_codec=${audio_codec:-$d_audio_codec}
            video_codec=${video_codec:-$d_video_codec}
            origin_hls_url=0
            hboasia_host="hbogoasia.com:8443"

            if [ -n "${const:-}" ] 
            then
                const_yn="yes"
            else
                const_yn=$d_const_yn
                const=""
            fi

            live_yn=${live_yn:-yes}
            if [ "$live_yn" == "yes" ] 
            then
                live="-l"
            else
                live=""
            fi

            video_audio_shift=${video_audio_shift:-}
            v_or_a=${video_audio_shift%_*}
            if [ "$v_or_a" == "v" ] 
            then
                video_shift=${video_audio_shift#*_}
            elif [ "$v_or_a" == "a" ] 
            then
                audio_shift=${video_audio_shift#*_}
            fi

            txt_format=${txt_format:-$d_txt_format}
            draw_text=${draw_text:-$d_draw_text}
            quality=${quality:-$d_quality}
            bitrates=${bitrates:-$d_bitrates}

            subtitle_append=""
            if [ -n "$txt_format" ]
            then
                subtitle_append=',SUBTITLES="subs"'
            fi

            master=0
            if [[ $bitrates =~ , ]] || [[ $quality =~ , ]] || [ -n "$subtitle_append" ]
            then
                master=1
            fi

            if [ -z "${encrypt:-}" ]  
            then
                if [ "$d_encrypt_yn" == "yes" ] 
                then
                    encrypt="-e"
                    encrypt_yn="yes"
                else
                    encrypt=""
                    encrypt_yn="no"
                fi
            else
                encrypt_yn="yes"
            fi

            encrypt_session_yn="no"
            keyinfo_name=${keyinfo_name:-$d_keyinfo_name}
            keyinfo_name=${keyinfo_name:-$(RandStr)}
            key_name=${key_name:-$d_key_name}
            key_name=${key_name:-$(RandStr)}

            if [ "${stream_link:0:4}" == "rtmp" ] || [ "${stream_link:0:1}" == "/" ]
            then
                d_input_flags=${d_input_flags//-timeout 2000000000/}
                d_input_flags=${d_input_flags//-reconnect 1/}
                d_input_flags=${d_input_flags//-reconnect_at_eof 1/}
                d_input_flags=${d_input_flags//-reconnect_streamed 1/}
                d_input_flags=${d_input_flags//-reconnect_delay_max 2000/}
                lead=${d_input_flags%%[^[:blank:]]*}
                d_input_flags=${d_input_flags#${lead}}
            elif [[ $stream_link == *".m3u8"* ]]
            then
                d_input_flags=${d_input_flags//-reconnect_at_eof 1/}
            fi

            input_flags=${input_flags:-$d_input_flags}
            if [[ ${input_flags:0:1} == "'" ]] 
            then
                input_flags=${input_flags%\'}
                input_flags=${input_flags#\'}
            fi

            if [ "${output_flags:-}" == "omit" ] 
            then
                output_flags=""
            else
                output_flags=${output_flags:-$d_output_flags}
            fi

            if [[ ${output_flags:0:1} == "'" ]] 
            then
                output_flags=${output_flags%\'}
                output_flags=${output_flags#\'}
            fi

            channel_name=${channel_name:-$playlist_name}
            sync_yn=$d_sync_yn
            sync_file=${sync_file:-}
            sync_index=${sync_index:-}
            sync_pairs=${sync_pairs:-}

            [ ! -e $FFMPEG_LOG_ROOT ] && mkdir $FFMPEG_LOG_ROOT
            from="AddChannel"

            flv_h265_yn=${flv_h265_yn:-no}
            flv_push_link=${flv_push_link:-}
            flv_pull_link=${flv_pull_link:-}

            extra_filters=""
            if [ "$video_codec" != "copy" ] && [ -n "$draw_text" ] 
            then
                filters=( vf filter:v )
                for filter in "${filters[@]}"
                do
                    if [[ $output_flags =~ (.*)"-$filter "([^ ]+)(.*) ]] 
                    then
                        extra_filters="${BASH_REMATCH[2]},"
                        output_flags="${BASH_REMATCH[1]} ${BASH_REMATCH[3]}"
                    fi
                done
            fi

            FilterString stream_link user_agent headers cookies output_dir_name \
                playlist_name seg_dir_name seg_name keyinfo_name key_name input_flags \
                output_flags channel_name sync_file sync_index sync_pairs flv_push_link \
                flv_pull_link

            if [ -n "${kind:-}" ] 
            then
                if [ "$kind" == "flv" ] 
                then
                    if [ -z "${flv_push_link:-}" ] 
                    then
                        Println "`eval_gettext \"\\\$error 未设置推流地址...\"`\n" && exit 1
                    else
                        if [ "$sh_debug" -eq 1 ] 
                        then
                            ( FlvStreamCreator ) 
                        else
                            ( FlvStreamCreator ) > /dev/null 2> /dev/null < /dev/null &
                        fi
                    fi
                else
                    Println "`eval_gettext \"\\\$error 暂不支持输出 \$kind ...\"`\n" && exit 1
                fi
            else
                if [ "$sh_debug" -eq 1 ] 
                then
                    ( HlsStreamCreatorPlus ) 
                else
                    ( HlsStreamCreatorPlus ) > /dev/null 2> /dev/null < /dev/null &
                fi
            fi

            Println "`eval_gettext \"\\\$info 添加频道成功\"`\n"
        fi
    fi
fi